                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/vector.anchor:                          
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Vector {                                                                                  
      array T = int[isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E]                                                                  
                                                                                                    
       [Vector.T{this}] elems isLocal(this, tid)                                                    
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int count isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      volatile Seq<int> spec isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      invariant  this.count == SeqLen<int>(this.spec);                                              
      invariant  forall int i ::0 <= i && i < this.count ==> this.elems[i] == SeqNth<int>(this.spec,i);
                                                                                                    
      requires this.elems == [Vector.T{this}].null;                                                 
      {                                                                                             
        ensures this.spec == SeqEmpty<int>();                                                       
      }                                                                                             
      public void init() {                                                                          
        assume this.elems == [Vector.T{this}].null;                                                 
        assume this.count == 0;                                                                     
        assume this.spec == SeqEmpty;                                                               
        {                                                                                           
          Seq<int> tmp1;                                                                            
          tmp1 = SeqEmpty<int>();                                                                   
          this.spec := tmp1;                                                                        
          int tmp2;                                                                                 
          tmp2 = 0;                                                                                 
          this.count := tmp2;                                                                       
          [Vector.T{this}] tmp3;                                                                    
          tmp3 = new [Vector.T{this}](100);                                                         
          this.elems := tmp3;                                                                       
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        modifies this.elems;                                                                        
        modifies this.elems;                                                                        
        ensures this.spec == SeqConcat<int>(old(this.spec),SeqUnit<int>(x));                        
      }                                                                                             
      public void add(int x) {                                                                      
        synchronized (this) {                                                                       
          boolean tmp4;                                                                             
          int tmp5;                                                                                 
          tmp5 := this.count;                                                                       
          int tmp6;                                                                                 
          int tmp7;                                                                                 
          [Vector.T{this}] tmp8;                                                                    
          tmp8 := this.elems;                                                                       
          tmp7 = tmp8.length;                                                                       
          tmp6 = tmp7 - 1;                                                                          
          tmp4 = tmp5 == tmp6;                                                                      
          if (tmp4 /* == this.count == this.elems.length - 1 */) {                                  
            [Vector.T{this}] newElems;                                                              
            int tmp9;                                                                               
            int tmp10;                                                                              
            [Vector.T{this}] tmp11;                                                                 
            tmp11 := this.elems;                                                                    
            tmp10 = tmp11.length;                                                                   
            tmp9 = tmp10 + 10;                                                                      
            newElems = new [Vector.T{this}](tmp9);                                                  
            {                                                                                       
              int j;                                                                                
              j = 0;                                                                                
              while (true)                                                                          
                invariant forall int i ::0 <= i && i < j ==> newElems[i] == SeqNth<int>(this.spec,i);
                {                                                                                   
                boolean tmp12;                                                                      
                int tmp13;                                                                          
                tmp13 := this.count;                                                                
                tmp12 = j < tmp13;                                                                  
                if (!tmp12) break; else {                                                           
                                                                                                    
                }                                                                                   
                {                                                                                   
                  [Vector.T{this}] tmp15;                                                           
                  tmp15 := this.elems;                                                              
                  int tmp14;                                                                        
                  tmp14 := tmp15[j];                                                                
                  newElems[j] := tmp14;                                                             
                  j = j + 1;                                                                        
                }                                                                                   
              }                                                                                     
            }                                                                                       
            this.elems := newElems;                                                                 
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          [Vector.T{this}] tmp16;                                                                   
          tmp16 := this.elems;                                                                      
          int tmp17;                                                                                
          tmp17 := this.count;                                                                      
          tmp16[tmp17] := x;                                                                        
          int tmp18;                                                                                
          int tmp19;                                                                                
          tmp19 := this.count;                                                                      
          tmp18 = tmp19 + 1;                                                                        
          this.count := tmp18;                                                                      
          Seq<int> tmp20;                                                                           
          Seq<int> tmp21;                                                                           
          tmp21 := this.spec;                                                                       
          Seq<int> tmp22;                                                                           
          tmp22 = SeqUnit<int>(x);                                                                  
          tmp20 = SeqConcat<int>(tmp21,tmp22);                                                      
          this.spec := tmp20;                                                                       
        }                                                                                           
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        ensures $result == (exists int i ::0 <= i && i < SeqLen<int>(this.spec) && SeqNth<int>(this.spec,i) == x);
      }                                                                                             
      public boolean contains(int x) {                                                              
        synchronized (this) {                                                                       
          {                                                                                         
            int j;                                                                                  
            j = 0;                                                                                  
            while (true)                                                                            
              invariant forall int i ::0 <= i && i < j ==> SeqNth<int>(this.spec,i) != x;           
              {                                                                                     
              boolean tmp23;                                                                        
              int tmp24;                                                                            
              tmp24 := this.count;                                                                  
              tmp23 = j < tmp24;                                                                    
              if (!tmp23) break; else {                                                             
                                                                                                    
              }                                                                                     
              {                                                                                     
                boolean tmp25;                                                                      
                [Vector.T{this}] tmp27;                                                             
                tmp27 := this.elems;                                                                
                int tmp26;                                                                          
                tmp26 := tmp27[j];                                                                  
                tmp25 = tmp26 == x;                                                                 
                if (tmp25 /* == this.elems[j] == x */) {                                            
                   return true;                                                                     
                } else {                                                                            
                                                                                                    
                }                                                                                   
                j = j + 1;                                                                          
              }                                                                                     
            }                                                                                       
          }                                                                                         
           return false;                                                                            
        }                                                                                           
        // return false;                                                                            
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Vector {                                                                                  
      array T = int[isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E]                                                                  
                                                                                                    
       [Vector.T{this}] elems isLocal(this, tid)                                                    
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int count isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      volatile Seq<int> spec isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.count == SeqLen<int>(this.spec);                                              
      invariant  forall int i ::0 <= i && i < this.count ==> this.elems[i] == SeqNth<int>(this.spec,i);
                                                                                                    
      requires this.elems == [Vector.T{this}].null;                                                 
      {                                                                                             
        ensures this.spec == SeqEmpty<int>();                                                       
      }                                                                                             
      public void init() {                                                                          
        assume this.elems == [Vector.T{this}].null;                                                 
        assume this.count == 0;                                                                     
        assume this.spec == SeqEmpty;                                                               
        {                                                                                           
          Seq<int> tmp1;                                                                            
          tmp1 = SeqEmpty<int>();                                                                   
          this.spec := tmp1;                                                                        
          int tmp2;                                                                                 
          tmp2 = 0;                                                                                 
          this.count := tmp2;                                                                       
          [Vector.T{this}] tmp3;                                                                    
          tmp3 = new [Vector.T{this}](100);                                                         
          this.elems := tmp3;                                                                       
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        modifies this.elems;                                                                        
        modifies this.elems;                                                                        
        ensures this.spec == SeqConcat<int>(old(this.spec),SeqUnit<int>(x));                        
      }                                                                                             
      public void add(int x) {                                                                      
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            boolean tmp4;                                                                           
            int tmp5;                                                                               
            tmp5 := this.count;                                                                     
            int tmp6;                                                                               
            int tmp7;                                                                               
            [Vector.T{this}] tmp8;                                                                  
            tmp8 := this.elems;                                                                     
            tmp7 = tmp8.length;                                                                     
            tmp6 = tmp7 - 1;                                                                        
            tmp4 = tmp5 == tmp6;                                                                    
            if (tmp4 /* == this.count == this.elems.length - 1 */) {                                
              [Vector.T{this}] newElems;                                                            
              int tmp9;                                                                             
              int tmp10;                                                                            
              [Vector.T{this}] tmp11;                                                               
              tmp11 := this.elems;                                                                  
              tmp10 = tmp11.length;                                                                 
              tmp9 = tmp10 + 10;                                                                    
              newElems = new [Vector.T{this}](tmp9);                                                
              {                                                                                     
                int j;                                                                              
                j = 0;                                                                              
                while (true)                                                                        
                  invariant forall int i ::0 <= i && i < j ==> newElems[i] == SeqNth<int>(this.spec,i);
                  invariant holds(this, tid);                                                       
                  {                                                                                 
                  boolean tmp12;                                                                    
                  int tmp13;                                                                        
                  tmp13 := this.count;                                                              
                  tmp12 = j < tmp13;                                                                
                  if (!tmp12) {                                                                     
                    break;                                                                          
                  } else {                                                                          
                                                                                                    
                  }                                                                                 
                  {                                                                                 
                    [Vector.T{this}] tmp15;                                                         
                    tmp15 := this.elems;                                                            
                    int tmp14;                                                                      
                    tmp14 := tmp15[j];                                                              
                    newElems[j] := tmp14;                                                           
                    j = j + 1;                                                                      
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              this.elems := newElems;                                                               
            } else {                                                                                
                                                                                                    
            }                                                                                       
            [Vector.T{this}] tmp16;                                                                 
            tmp16 := this.elems;                                                                    
            int tmp17;                                                                              
            tmp17 := this.count;                                                                    
            tmp16[tmp17] := x;                                                                      
            int tmp18;                                                                              
            int tmp19;                                                                              
            tmp19 := this.count;                                                                    
            tmp18 = tmp19 + 1;                                                                      
            this.count := tmp18;                                                                    
            Seq<int> tmp20;                                                                         
            Seq<int> tmp21;                                                                         
            tmp21 := this.spec;                                                                     
            Seq<int> tmp22;                                                                         
            tmp22 = SeqUnit<int>(x);                                                                
            tmp20 = SeqConcat<int>(tmp21,tmp22);                                                    
            this.spec := tmp20;                                                                     
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        ensures $result == (exists int i ::0 <= i && i < SeqLen<int>(this.spec) && SeqNth<int>(this.spec,i) == x);
      }                                                                                             
      public boolean contains(int x) {                                                              
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            {                                                                                       
              int j;                                                                                
              j = 0;                                                                                
              while (true)                                                                          
                invariant forall int i ::0 <= i && i < j ==> SeqNth<int>(this.spec,i) != x;         
                invariant holds(this, tid);                                                         
                {                                                                                   
                boolean tmp23;                                                                      
                int tmp24;                                                                          
                tmp24 := this.count;                                                                
                tmp23 = j < tmp24;                                                                  
                if (!tmp23) {                                                                       
                  break;                                                                            
                } else {                                                                            
                                                                                                    
                }                                                                                   
                {                                                                                   
                  boolean tmp25;                                                                    
                  [Vector.T{this}] tmp27;                                                           
                  tmp27 := this.elems;                                                              
                  int tmp26;                                                                        
                  tmp26 := tmp27[j];                                                                
                  tmp25 = tmp26 == x;                                                               
                  if (tmp25 /* == this.elems[j] == x */) {                                          
                    {                                                                               
                      release(this);                                                                
                       return true;                                                                 
                    }                                                                               
                  } else {                                                                          
                                                                                                    
                  }                                                                                 
                  j = j + 1;                                                                        
                }                                                                                   
              }                                                                                     
            }                                                                                       
            {                                                                                       
              release(this);                                                                        
               return false;                                                                        
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Vector {                                                                                  
      array T = int[isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E]                                                                  
                                                                                                    
       [Vector.T{this}] elems isLocal(this, tid)                                                    
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int count isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      volatile Seq<int> spec isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.count == SeqLen<int>(this.spec);                                              
      invariant  forall int i ::0 <= i && i < this.count ==> this.elems[i] == SeqNth<int>(this.spec,i);
                                                                                                    
      requires this.elems == [Vector.T{this}].null;                                                 
      {                                                                                             
        ensures this.spec == SeqEmpty<int>();                                                       
      }                                                                                             
      public void init() {                                                                          
        assume this.elems == [Vector.T{this}].null;                                                 
        assume this.count == 0;                                                                     
        assume this.spec == SeqEmpty;                                                               
        {                                                                                           
          Seq<int> tmp1;                                                                            
          tmp1 = SeqEmpty<int>();                                                                   
          this.spec := tmp1;                                                                        
          int tmp2;                                                                                 
          tmp2 = 0;                                                                                 
          this.count := tmp2;                                                                       
          [Vector.T{this}] tmp3;                                                                    
          tmp3 = new [Vector.T{this}](100);                                                         
          this.elems := tmp3;                                                                       
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        modifies this.elems;                                                                        
        modifies this.elems;                                                                        
        ensures this.spec == SeqConcat<int>(old(this.spec),SeqUnit<int>(x));                        
      }                                                                                             
      public void add(int x) {                                                                      
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            boolean tmp4;                                                                           
            int tmp5;                                                                               
            tmp5 := this.count;                                                                     
            int tmp6;                                                                               
            int tmp7;                                                                               
            [Vector.T{this}] tmp8;                                                                  
            tmp8 := this.elems;                                                                     
            tmp7 = tmp8.length;                                                                     
            tmp6 = tmp7 - 1;                                                                        
            tmp4 = tmp5 == tmp6;                                                                    
            if (tmp4 /* == this.count == this.elems.length - 1 */) {                                
              [Vector.T{this}] newElems;                                                            
              int tmp9;                                                                             
              int tmp10;                                                                            
              [Vector.T{this}] tmp11;                                                               
              tmp11 := this.elems;                                                                  
              tmp10 = tmp11.length;                                                                 
              tmp9 = tmp10 + 10;                                                                    
              newElems = new [Vector.T{this}](tmp9);                                                
              {                                                                                     
                int j;                                                                              
                j = 0;                                                                              
                while (true)                                                                        
                  invariant forall int i ::0 <= i && i < j ==> newElems[i] == SeqNth<int>(this.spec,i);
                  invariant holds(this, tid);                                                       
                  {                                                                                 
                  boolean tmp12;                                                                    
                  int tmp13;                                                                        
                  tmp13 := this.count;                                                              
                  tmp12 = j < tmp13;                                                                
                  if (!tmp12) {                                                                     
                    break;                                                                          
                  } else {                                                                          
                                                                                                    
                  }                                                                                 
                  {                                                                                 
                    [Vector.T{this}] tmp15;                                                         
                    tmp15 := this.elems;                                                            
                    int tmp14;                                                                      
                    tmp14 := tmp15[j];                                                              
                    newElems[j] := tmp14;                                                           
                    j = j + 1;                                                                      
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              this.elems := newElems;                                                               
            } else {                                                                                
                                                                                                    
            }                                                                                       
            [Vector.T{this}] tmp16;                                                                 
            tmp16 := this.elems;                                                                    
            int tmp17;                                                                              
            tmp17 := this.count;                                                                    
            tmp16[tmp17] := x;                                                                      
            int tmp18;                                                                              
            int tmp19;                                                                              
            tmp19 := this.count;                                                                    
            tmp18 = tmp19 + 1;                                                                      
            this.count := tmp18;                                                                    
            Seq<int> tmp20;                                                                         
            Seq<int> tmp21;                                                                         
            tmp21 := this.spec;                                                                     
            Seq<int> tmp22;                                                                         
            tmp22 = SeqUnit<int>(x);                                                                
            tmp20 = SeqConcat<int>(tmp21,tmp22);                                                    
            this.spec := tmp20;                                                                     
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        ensures $result == (exists int i ::0 <= i && i < SeqLen<int>(this.spec) && SeqNth<int>(this.spec,i) == x);
      }                                                                                             
      public boolean contains(int x) {                                                              
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            {                                                                                       
              int j;                                                                                
              j = 0;                                                                                
              while (true)                                                                          
                invariant forall int i ::0 <= i && i < j ==> SeqNth<int>(this.spec,i) != x;         
                invariant holds(this, tid);                                                         
                {                                                                                   
                boolean tmp23;                                                                      
                int tmp24;                                                                          
                tmp24 := this.count;                                                                
                tmp23 = j < tmp24;                                                                  
                if (!tmp23) {                                                                       
                  break;                                                                            
                } else {                                                                            
                                                                                                    
                }                                                                                   
                {                                                                                   
                  boolean tmp25;                                                                    
                  [Vector.T{this}] tmp27;                                                           
                  tmp27 := this.elems;                                                              
                  int tmp26;                                                                        
                  tmp26 := tmp27[j];                                                                
                  tmp25 = tmp26 == x;                                                               
                  if (tmp25 /* == this.elems[j] == x */) {                                          
                    {                                                                               
                      release(this);                                                                
                       return true;                                                                 
                    }                                                                               
                  } else {                                                                          
                                                                                                    
                  }                                                                                 
                  j = j + 1;                                                                        
                }                                                                                   
              }                                                                                     
            }                                                                                       
            {                                                                                       
              release(this);                                                                        
               return false;                                                                        
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Vector {                                                                                  
      array T = int[isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E]                                                                  
                                                                                                    
       [Vector.T{this}] elems isLocal(this, tid)                                                    
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       int count isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      volatile Seq<int> spec isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.count == SeqLen<int>(this.spec);                                              
      invariant  forall int i ::0 <= i && i < this.count ==> this.elems[i] == SeqNth<int>(this.spec,i);
                                                                                                    
      requires this.elems == [Vector.T{this}].null;                                                 
      {                                                                                             
        ensures this.spec == SeqEmpty<int>();                                                       
      }                                                                                             
      public void init() {                                                                          
        assume this.elems == [Vector.T{this}].null;                                                 
        assume this.count == 0;                                                                     
        assume this.spec == SeqEmpty;                                                               
        {                                                                                           
          Seq<int> tmp1;                                                                            
          tmp1 = SeqEmpty<int>();                                                                   
          this.spec := tmp1;                                                                        
          int tmp2;                                                                                 
          tmp2 = 0;                                                                                 
          this.count := tmp2;                                                                       
          [Vector.T{this}] tmp3;                                                                    
          tmp3 = new [Vector.T{this}](100);                                                         
          this.elems := tmp3;                                                                       
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        modifies this;                                                                              
        modifies this.elems;                                                                        
        modifies this.elems;                                                                        
        ensures this.spec == SeqConcat<int>(old(this.spec),SeqUnit<int>(x));                        
      }                                                                                             
      public void add(int x) {                                                                      
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            boolean tmp4;                                                                           
            int tmp5;                                                                               
            tmp5 := this.count;                                                                     
            int tmp6;                                                                               
            int tmp7;                                                                               
            [Vector.T{this}] tmp8;                                                                  
            tmp8 := this.elems;                                                                     
            tmp7 = tmp8.length;                                                                     
            tmp6 = tmp7 - 1;                                                                        
            tmp4 = tmp5 == tmp6;                                                                    
            if (tmp4 /* == this.count == this.elems.length - 1 */) {                                
              [Vector.T{this}] newElems;                                                            
              int tmp9;                                                                             
              int tmp10;                                                                            
              [Vector.T{this}] tmp11;                                                               
              tmp11 := this.elems;                                                                  
              tmp10 = tmp11.length;                                                                 
              tmp9 = tmp10 + 10;                                                                    
              newElems = new [Vector.T{this}](tmp9);                                                
              {                                                                                     
                int j;                                                                              
                j = 0;                                                                              
                while (true)                                                                        
                  invariant forall int i ::0 <= i && i < j ==> newElems[i] == SeqNth<int>(this.spec,i);
                  invariant holds(this, tid);                                                       
                  {                                                                                 
                  boolean tmp12;                                                                    
                  int tmp13;                                                                        
                  tmp13 := this.count;                                                              
                  tmp12 = j < tmp13;                                                                
                  if (!tmp12) {                                                                     
                    break;                                                                          
                  } else {                                                                          
                                                                                                    
                  }                                                                                 
                  {                                                                                 
                    [Vector.T{this}] tmp15;                                                         
                    tmp15 := this.elems;                                                            
                    int tmp14;                                                                      
                    tmp14 := tmp15[j];                                                              
                    newElems[j] := tmp14;                                                           
                    j = j + 1;                                                                      
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              this.elems := newElems;                                                               
            } else {                                                                                
                                                                                                    
            }                                                                                       
            [Vector.T{this}] tmp16;                                                                 
            tmp16 := this.elems;                                                                    
            int tmp17;                                                                              
            tmp17 := this.count;                                                                    
            tmp16[tmp17] := x;                                                                      
            int tmp18;                                                                              
            int tmp19;                                                                              
            tmp19 := this.count;                                                                    
            tmp18 = tmp19 + 1;                                                                      
            this.count := tmp18;                                                                    
            Seq<int> tmp20;                                                                         
            Seq<int> tmp21;                                                                         
            tmp21 := this.spec;                                                                     
            Seq<int> tmp22;                                                                         
            tmp22 = SeqUnit<int>(x);                                                                
            tmp20 = SeqConcat<int>(tmp21,tmp22);                                                    
            this.spec := tmp20;                                                                     
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      {                                                                                             
        ensures $result == (exists int i ::0 <= i && i < SeqLen<int>(this.spec) && SeqNth<int>(this.spec,i) == x);
      }                                                                                             
      public boolean contains(int x) {                                                              
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            {                                                                                       
              int j;                                                                                
              j = 0;                                                                                
              while (true)                                                                          
                invariant forall int i ::0 <= i && i < j ==> SeqNth<int>(this.spec,i) != x;         
                invariant holds(this, tid);                                                         
                {                                                                                   
                boolean tmp23;                                                                      
                int tmp24;                                                                          
                tmp24 := this.count;                                                                
                tmp23 = j < tmp24;                                                                  
                if (!tmp23) {                                                                       
                  break;                                                                            
                } else {                                                                            
                                                                                                    
                }                                                                                   
                {                                                                                   
                  boolean tmp25;                                                                    
                  [Vector.T{this}] tmp27;                                                           
                  tmp27 := this.elems;                                                              
                  int tmp26;                                                                        
                  tmp26 := tmp27[j];                                                                
                  tmp25 = tmp26 == x;                                                               
                  if (tmp25 /* == this.elems[j] == x */) {                                          
                    {                                                                               
                      release(this);                                                                
                       return true;                                                                 
                    }                                                                               
                  } else {                                                                          
                                                                                                    
                  }                                                                                 
                  j = j + 1;                                                                        
                }                                                                                   
              }                                                                                     
            }                                                                                       
            {                                                                                       
              release(this);                                                                        
               return false;                                                                        
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Vector ***/                                                                         
                                                                                                    
type Vector;                                                                                        
const unique Vector.null: Vector;                                                                   
var Vector._state: [Vector]State;                                                                   
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Vector.elems: [Vector]Array.Vector.T;                                                           
                                                                                                    
function {:inline} ReadEval.Vector.elems(tid: Tid,this : Vector,Vector._state: [Vector]State,Vector.elems: [Vector]Array.Vector.T,Vector.count: [Vector]int,Vector.spec: [Vector]Seq.int,Vector._lock: [Vector]Tid,Array.Vector.T._state: [Array.Vector.T]State,Array.Vector.T._elems: [Array.Vector.T]([int]int),Array.Vector.T._length: [Array.Vector.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Array.Vector.T.null;                                                              
 if (isLocal(Vector._state[this], tid)) then                                                        
  if (isLocal(Vector._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Vector._state[this], tid) && Vector._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Vector.elems(tid: Tid,this : Vector,newValue: Array.Vector.T,Vector._state: [Vector]State,Vector.elems: [Vector]Array.Vector.T,Vector.count: [Vector]int,Vector.spec: [Vector]Seq.int,Vector._lock: [Vector]Tid,Array.Vector.T._state: [Array.Vector.T]State,Array.Vector.T._elems: [Array.Vector.T]([int]int),Array.Vector.T._length: [Array.Vector.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Vector._state[this], tid)) then                                                        
  if (isLocal(Vector._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Vector._state[this], tid) && Vector._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Vector.count: [Vector]int;                                                                      
                                                                                                    
function {:inline} ReadEval.Vector.count(tid: Tid,this : Vector,Vector._state: [Vector]State,Vector.elems: [Vector]Array.Vector.T,Vector.count: [Vector]int,Vector.spec: [Vector]Seq.int,Vector._lock: [Vector]Tid,Array.Vector.T._state: [Array.Vector.T]State,Array.Vector.T._elems: [Array.Vector.T]([int]int),Array.Vector.T._length: [Array.Vector.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Vector._state[this], tid)) then                                                        
  if (isLocal(Vector._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Vector._state[this], tid) && Vector._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Vector.count(tid: Tid,this : Vector,newValue: int,Vector._state: [Vector]State,Vector.elems: [Vector]Array.Vector.T,Vector.count: [Vector]int,Vector.spec: [Vector]Seq.int,Vector._lock: [Vector]Tid,Array.Vector.T._state: [Array.Vector.T]State,Array.Vector.T._elems: [Array.Vector.T]([int]int),Array.Vector.T._length: [Array.Vector.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Vector._state[this], tid)) then                                                        
  if (isLocal(Vector._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Vector._state[this], tid) && Vector._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Vector.spec: [Vector]Seq.int;                                                                   
                                                                                                    
function {:inline} ReadEval.Vector.spec(tid: Tid,this : Vector,Vector._state: [Vector]State,Vector.elems: [Vector]Array.Vector.T,Vector.count: [Vector]int,Vector.spec: [Vector]Seq.int,Vector._lock: [Vector]Tid,Array.Vector.T._state: [Array.Vector.T]State,Array.Vector.T._elems: [Array.Vector.T]([int]int),Array.Vector.T._length: [Array.Vector.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := SeqEmpty.int() : Seq.int;                                                         
 if (isLocal(Vector._state[this], tid)) then                                                        
  if (isLocal(Vector._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Vector._state[this], tid) && Vector._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Vector.spec(tid: Tid,this : Vector,newValue: Seq.int,Vector._state: [Vector]State,Vector.elems: [Vector]Array.Vector.T,Vector.count: [Vector]int,Vector.spec: [Vector]Seq.int,Vector._lock: [Vector]Tid,Array.Vector.T._state: [Array.Vector.T]State,Array.Vector.T._elems: [Array.Vector.T]([int]int),Array.Vector.T._length: [Array.Vector.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Vector._state[this], tid)) then                                                        
  if (isLocal(Vector._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Vector._state[this], tid) && Vector._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Vector._lock: [Vector]Tid;                                                                      
                                                                                                    
function {:inline} ReadEval.Vector._lock(tid: Tid,this : Vector,Vector._state: [Vector]State,Vector.elems: [Vector]Array.Vector.T,Vector.count: [Vector]int,Vector.spec: [Vector]Seq.int,Vector._lock: [Vector]Tid,Array.Vector.T._state: [Array.Vector.T]State,Array.Vector.T._elems: [Array.Vector.T]([int]int),Array.Vector.T._length: [Array.Vector.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Vector._state[this], tid)) then                                                        
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Vector._lock[this]==tid)) then                                                              
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Vector._lock[this]==Tid.null)&&(newValue==tid))) then                                      
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Vector._lock[this]==tid)&&(newValue==Tid.null))) then                                     
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Vector._lock(tid: Tid,this : Vector,newValue: Tid,Vector._state: [Vector]State,Vector.elems: [Vector]Array.Vector.T,Vector.count: [Vector]int,Vector.spec: [Vector]Seq.int,Vector._lock: [Vector]Tid,Array.Vector.T._state: [Array.Vector.T]State,Array.Vector.T._elems: [Array.Vector.T]([int]int),Array.Vector.T._length: [Array.Vector.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Vector._state[this], tid)) then                                                        
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Vector._lock[this]==tid)) then                                                              
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Vector._lock[this]==Tid.null)&&(newValue==tid))) then                                      
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Vector._lock[this]==tid)&&(newValue==Tid.null))) then                                     
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.Vector.4663331(tid: Tid,this : Vector,Vector._state: [Vector]State,Vector.elems: [Vector]Array.Vector.T,Vector.count: [Vector]int,Vector.spec: [Vector]Seq.int,Vector._lock: [Vector]Tid,Array.Vector.T._state: [Array.Vector.T]State,Array.Vector.T._elems: [Array.Vector.T]([int]int),Array.Vector.T._length: [Array.Vector.T]int) returns (bool) {
 (Vector.count[this]==SeqLen.int(Vector.spec[this]))                                                
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Vector.4663360(tid: Tid,this : Vector,Vector._state: [Vector]State,Vector.elems: [Vector]Array.Vector.T,Vector.count: [Vector]int,Vector.spec: [Vector]Seq.int,Vector._lock: [Vector]Tid,Array.Vector.T._state: [Array.Vector.T]State,Array.Vector.T._elems: [Array.Vector.T]([int]int),Array.Vector.T._length: [Array.Vector.T]int) returns (bool) {
 (forall i: int ::  ((((0<=i)&&(i<Vector.count[this]))==>(Array.Vector.T._elems[Vector.elems[this]][i]==SeqNth.int(Vector.spec[this],i)))))
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Vector.init(tid:Tid, this : Vector)                                                      
modifies Vector._state;                                                                             
modifies Vector.elems;                                                                              
modifies Vector.count;                                                                              
modifies Vector.spec;                                                                               
modifies Vector._lock;                                                                              
modifies Array.Vector.T._state;                                                                     
modifies Array.Vector.T._elems;                                                                     
                                                                                                    
requires ValidTid(tid);                                                                                    // (20.5): Bad tid
requires isLocal(Vector._state[this], tid);                                                         
requires (forall _x : Vector :: this != _x ==> !isLocal(Vector._state[_x], tid));                   
                                                                                                    
requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
requires (Vector.elems[this]==Array.Vector.T.null);                                                 
                                                                                                    
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && _this != this ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (20.5): Object invariant may not hold.
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && _this != this ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (20.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
ensures  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (20.5): Object invariant may not hold.
ensures  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (20.5): Object invariant may not hold.
{                                                                                                   
 var $pc4673860: Phase;                                                                             
 var Array.Vector.T._length4673883: [Array.Vector.T]int;                                            
 var Vector._state4673884: [Vector]State;                                                           
 var tmp24673883: int;                                                                              
 var $pc4673883: Phase;                                                                             
 var Array.Vector.T._length4673884: [Array.Vector.T]int;                                            
 var Vector._lock4673884: [Vector]Tid;                                                              
 var this4673884: Vector;                                                                           
 var path4673860: int;                                                                              
 var Vector._lock4673870: [Vector]Tid;                                                              
 var Array.Vector.T._length4673860: [Array.Vector.T]int;                                            
 var tmp14673860: Seq.int;                                                                          
 var tid4673884: Tid;                                                                               
 var Vector.elems4673883: [Vector]Array.Vector.T;                                                   
 var Array.Vector.T._elems4673884: [Array.Vector.T]([int]int);                                      
 var Array.Vector.T._elems4673883: [Array.Vector.T]([int]int);                                      
 var Vector.count4673884: [Vector]int;                                                              
 var tmp14673884: Seq.int;                                                                          
 var tmp3: Array.Vector.T;                                                                          
 var $recorded.state4673870: int;                                                                   
 var Vector._state4673860: [Vector]State;                                                           
 var moverPath4673870: MoverPath;                                                                   
 var Vector.count4673860: [Vector]int;                                                              
 var mover4673860: Mover;                                                                           
 var Array.Vector.T._state4673883: [Array.Vector.T]State;                                           
 var Array.Vector.T._elems4673860: [Array.Vector.T]([int]int);                                      
 var $pc4673870: Phase;                                                                             
 var tid4673883: Tid;                                                                               
 var moverPath4673883: MoverPath;                                                                   
 var Array.Vector.T._elems4673870: [Array.Vector.T]([int]int);                                      
 var tmp24673884: int;                                                                              
 var mover4673883: Mover;                                                                           
 var tid4673860: Tid;                                                                               
 var $recorded.state4673883: int;                                                                   
 var mover4673870: Mover;                                                                           
 var path4673883: int;                                                                              
 var Vector.spec4673884: [Vector]Seq.int;                                                           
 var Array.Vector.T._length4673870: [Array.Vector.T]int;                                            
 var path4673870: int;                                                                              
 var Vector.count4673870: [Vector]int;                                                              
 var Array.Vector.T._state4673870: [Array.Vector.T]State;                                           
 var this4673860: Vector;                                                                           
 var this4673883: Vector;                                                                           
 var $recorded.state4673860: int;                                                                   
 var this4673870: Vector;                                                                           
 var moverPath4673860: MoverPath;                                                                   
 var Vector._state4673883: [Vector]State;                                                           
 var tmp14673883: Seq.int;                                                                          
 var Vector.count4673883: [Vector]int;                                                              
 var tmp24673870: int;                                                                              
 var Vector._lock4673860: [Vector]Tid;                                                              
 var Vector.spec4673860: [Vector]Seq.int;                                                           
 var tmp14673870: Seq.int;                                                                          
 var Vector.elems4673870: [Vector]Array.Vector.T;                                                   
 var tmp34673883: Array.Vector.T;                                                                   
 var $pc4673884: Phase;                                                                             
 var Vector._state4673870: [Vector]State;                                                           
 var tmp34673884: Array.Vector.T;                                                                   
 var Vector.elems4673884: [Vector]Array.Vector.T;                                                   
 var Vector.spec4673883: [Vector]Seq.int;                                                           
 var Vector.elems4673860: [Vector]Array.Vector.T;                                                   
 var tmp1: Seq.int;                                                                                 
 var $recorded.state4673884: int;                                                                   
 var Array.Vector.T._state4673884: [Array.Vector.T]State;                                           
 var Vector._lock4673883: [Vector]Tid;                                                              
 var tmp2: int;                                                                                     
 var Array.Vector.T._state4673860: [Array.Vector.T]State;                                           
 var Vector.spec4673870: [Vector]Seq.int;                                                           
 var tid4673870: Tid;                                                                               
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true && leq(m#moverPath(ReadEval.Vector.elems(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length)),_R);       // (20.5): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 20.5: assume this.elems == [Vector.T{this}].null;                                               
                                                                                                    
 assume (Vector.elems[this]==Array.Vector.T.null);                                                  
                                                                                                    
 // 20.5: assume this.count == 0;                                                                   
                                                                                                    
 assume (Vector.count[this]==0);                                                                    
                                                                                                    
 // 20.5: assume this.spec == SeqEmpty;                                                             
                                                                                                    
 assume (Vector.spec[this]==SeqEmpty.int() : Seq.int);                                              
                                                                                                    
 // 22.9: Seq<int> tmp1;                                                                            
                                                                                                    
                                                                                                    
 // 22.9: tmp1 = SeqEmpty<int>();                                                                   
                                                                                                    
 tmp1 := SeqEmpty.int();                                                                            
                                                                                                    
                                                                                                    
 // 22.9: this.spec := tmp1;                                                                        
                                                                                                    
                                                                                                    
 moverPath4673860 := WriteEval.Vector.spec(tid: Tid,this: Vector,tmp1: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 mover4673860 := m#moverPath(moverPath4673860);                                                     
 path4673860 := p#moverPath(moverPath4673860);                                                      
 assume Vector._state4673860 == Vector._state && Vector.elems4673860 == Vector.elems && Vector.count4673860 == Vector.count && Vector.spec4673860 == Vector.spec && Vector._lock4673860 == Vector._lock && Array.Vector.T._state4673860 == Array.Vector.T._state && Array.Vector.T._elems4673860 == Array.Vector.T._elems && Array.Vector.T._length4673860 == Array.Vector.T._length && tmp14673860 == tmp1 && this4673860 == this && tid4673860 == tid && $pc4673860 == $pc;
 assume $recorded.state4673860 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (22.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover4673860);                                                              
 assert $pc != PhaseError;                                                                                 // (22.9): Reduction failure
 Vector.spec[this] := tmp1;                                                                         
                                                                                                    
 // 23.9: int tmp2;                                                                                 
                                                                                                    
                                                                                                    
 // 23.9: tmp2 = 0;                                                                                 
                                                                                                    
 tmp2 := 0;                                                                                         
                                                                                                    
                                                                                                    
 // 23.9: this.count := tmp2;                                                                       
                                                                                                    
                                                                                                    
 moverPath4673870 := WriteEval.Vector.count(tid: Tid,this: Vector,tmp2: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 mover4673870 := m#moverPath(moverPath4673870);                                                     
 path4673870 := p#moverPath(moverPath4673870);                                                      
 assume Vector._state4673870 == Vector._state && Vector.elems4673870 == Vector.elems && Vector.count4673870 == Vector.count && Vector.spec4673870 == Vector.spec && Vector._lock4673870 == Vector._lock && Array.Vector.T._state4673870 == Array.Vector.T._state && Array.Vector.T._elems4673870 == Array.Vector.T._elems && Array.Vector.T._length4673870 == Array.Vector.T._length && tmp24673870 == tmp2 && tmp14673870 == tmp1 && this4673870 == this && tid4673870 == tid && $pc4673870 == $pc;
 assume $recorded.state4673870 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (23.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover4673870);                                                              
 assert $pc != PhaseError;                                                                                 // (23.9): Reduction failure
 Vector.count[this] := tmp2;                                                                        
                                                                                                    
 // 24.9: [Vector.T{this}] tmp3;                                                                    
                                                                                                    
                                                                                                    
 // 24.9: tmp3 = new [Vector.T{this}](100);                                                         
                                                                                                    
 havoc tmp3;                                                                                        
 assume isFresh(Array.Vector.T._state[tmp3]);                                                       
 assume Array.Vector.T._length[tmp3] == 100;                                                        
 assume Array.Vector.T._this[tmp3] == this;                                                         
 Array.Vector.T._state[tmp3] := LOCAL(tid);                                                         
 assume (forall _i : int :: 0 <= _i ==> Array.Vector.T._elems[tmp3][_i] == 0);                      
                                                                                                    
                                                                                                    
 // 24.9: this.elems := tmp3;                                                                       
                                                                                                    
                                                                                                    
 moverPath4673883 := WriteEval.Vector.elems(tid: Tid,this: Vector,tmp3: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 mover4673883 := m#moverPath(moverPath4673883);                                                     
 path4673883 := p#moverPath(moverPath4673883);                                                      
 assume Vector._state4673883 == Vector._state && Vector.elems4673883 == Vector.elems && Vector.count4673883 == Vector.count && Vector.spec4673883 == Vector.spec && Vector._lock4673883 == Vector._lock && Array.Vector.T._state4673883 == Array.Vector.T._state && Array.Vector.T._elems4673883 == Array.Vector.T._elems && Array.Vector.T._length4673883 == Array.Vector.T._length && tmp34673883 == tmp3 && tmp24673883 == tmp2 && tmp14673883 == tmp1 && this4673883 == this && tid4673883 == tid && $pc4673883 == $pc;
 assume $recorded.state4673883 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (24.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover4673883);                                                              
 assert $pc != PhaseError;                                                                                 // (24.9): Reduction failure
 Vector.elems[this] := tmp3;                                                                        
 if (isLocal(Array.Vector.T._state[tmp3], tid)) {                                                   
  Array.Vector.T._state[tmp3] := SHARED();                                                          
  if (isLocal(Vector._state[Array.Vector.T._this[tmp3]], tid)) {                                    
   Vector._state[Array.Vector.T._this[tmp3]] := SHARED();                                           
   assert isSharedAssignable(Array.Vector.T._state[Vector.elems[Array.Vector.T._this[tmp3]]]);             // (24.9): tmp3 became shared, but Array.Vector.T._this[tmp3].elems may not be shared.
  }                                                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 21.21: // return;                                                                               
                                                                                                    
 assume Vector._state4673884 == Vector._state && Vector.elems4673884 == Vector.elems && Vector.count4673884 == Vector.count && Vector.spec4673884 == Vector.spec && Vector._lock4673884 == Vector._lock && Array.Vector.T._state4673884 == Array.Vector.T._state && Array.Vector.T._elems4673884 == Array.Vector.T._elems && Array.Vector.T._length4673884 == Array.Vector.T._length && tmp34673884 == tmp3 && tmp24673884 == tmp2 && tmp14673884 == tmp1 && this4673884 == this && tid4673884 == tid;
 assume $recorded.state4673884 == 1;                                                                
 assert  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (21.21): Object invariant may not hold.
 assert  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (21.21): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  Vector.add(tid:Tid, this : Vector, x : int)                                              
modifies Vector._state;                                                                             
modifies Vector.elems;                                                                              
modifies Vector.count;                                                                              
modifies Vector.spec;                                                                               
modifies Vector._lock;                                                                              
modifies Array.Vector.T._state;                                                                     
modifies Array.Vector.T._elems;                                                                     
                                                                                                    
requires ValidTid(tid);                                                                                    // (27.5): Bad tid
requires isShared(Vector._state[this]);                                                                    // (27.5): this is not global
                                                                                                    
requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (27.5): Object invariant may not hold.
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (27.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
ensures  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (27.5): Object invariant may not hold.
ensures  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (27.5): Object invariant may not hold.
{                                                                                                   
 var tmp64674049: int;                                                                              
 var newElems4674020: Array.Vector.T;                                                               
 var Array.Vector.T._state4674070: [Array.Vector.T]State;                                           
 var this4674040: Vector;                                                                           
 var Vector.count4674016_bottom: [Vector]int;                                                       
 var tmp64674059: int;                                                                              
 var tmp114674016_bottom: Array.Vector.T;                                                           
 var $pc4674059: Phase;                                                                             
 var tmp17: int;                                                                                    
 var Vector._state4674020: [Vector]State;                                                           
 var tmp64674070: int;                                                                              
 var tmp64674016_bottom: int;                                                                       
 var tmp22: Seq.int;                                                                                
 var tmp84674040: Array.Vector.T;                                                                   
 var Vector._state4673978: [Vector]State;                                                           
 var Vector.elems4674016_bottom: [Vector]Array.Vector.T;                                            
 var tmp204674088: Seq.int;                                                                         
 var Vector.count4674040: [Vector]int;                                                              
 var Array.Vector.T._elems4674016_bottom: [Array.Vector.T]([int]int);                               
 var $recorded.state4674020: int;                                                                   
 var path4674006: int;                                                                              
 var tmp74673946: int;                                                                              
 var tmp64674002: int;                                                                              
 var Array.Vector.T._state4674030: [Array.Vector.T]State;                                           
 var path4674036: int;                                                                              
 var Vector.elems4673978: [Vector]Array.Vector.T;                                                   
 var tmp84674088: Array.Vector.T;                                                                   
 var tmp164674070: Array.Vector.T;                                                                  
 var Vector.elems4674036: [Vector]Array.Vector.T;                                                   
 var tmp54674040: int;                                                                              
 var tmp74674036: int;                                                                              
 var tmp64674040: int;                                                                              
 var Array.Vector.T._elems4674070: [Array.Vector.T]([int]int);                                      
 var x4674059: int;                                                                                 
 var moverPath4674030: MoverPath;                                                                   
 var newElems4674016_bottom: Array.Vector.T;                                                        
 var tmp74674002: int;                                                                              
 var tid4673899: Tid;                                                                               
 var $recorded.state4674088: int;                                                                   
 var $recorded.state4674036: int;                                                                   
 var Vector._lock4674002: [Vector]Tid;                                                              
 var Vector._lock4674040: [Vector]Tid;                                                              
 var tmp54673978: int;                                                                              
 var Array.Vector.T._length4674059: [Array.Vector.T]int;                                            
 var this4673946: Vector;                                                                           
 var tmp44674059: bool;                                                                             
 var tmp5: int;                                                                                     
 var path4674059: int;                                                                              
 var newElems: Array.Vector.T;                                                                      
 var tmp54673899: int;                                                                              
 var Vector.spec4674030: [Vector]Seq.int;                                                           
 var moverPath4674049: MoverPath;                                                                   
 var $pc4674049: Phase;                                                                             
 var Vector.spec4674006: [Vector]Seq.int;                                                           
 var tmp54674036: int;                                                                              
 var tmp64673912: int;                                                                              
 var tid4673946: Tid;                                                                               
 var Vector.elems4674088: [Vector]Array.Vector.T;                                                   
 var tmp84673995: Array.Vector.T;                                                                   
 var tmp44674088: bool;                                                                             
 var tmp184674059: int;                                                                             
 var tmp124673995: bool;                                                                            
 var tmp94673946: int;                                                                              
 var Vector.elems4674016: [Vector]Array.Vector.T;                                                   
 var tmp104674016: int;                                                                             
 var Array.Vector.T._elems4674006: [Array.Vector.T]([int]int);                                      
 var Array.Vector.T._elems4673899: [Array.Vector.T]([int]int);                                      
 var tmp44673899: bool;                                                                             
 var Vector.elems4674002: [Vector]Array.Vector.T;                                                   
 var tid4674036: Tid;                                                                               
 var tmp64674020: int;                                                                              
 var tmp94674006: int;                                                                              
 var tmp74674040: int;                                                                              
 var Array.Vector.T._state4674093: [Array.Vector.T]State;                                           
 var $pc4674093: Phase;                                                                             
 var tmp224674088: Seq.int;                                                                         
 var Array.Vector.T._length4673995: [Array.Vector.T]int;                                            
 var tmp164674059: Array.Vector.T;                                                                  
 var j4673995: int;                                                                                 
 var Vector.elems4673899: [Vector]Array.Vector.T;                                                   
 var tmp54673995: int;                                                                              
 var $pc4673899: Phase;                                                                             
 var Vector._lock4674020: [Vector]Tid;                                                              
 var tmp54674020: int;                                                                              
 var Vector.elems4674020: [Vector]Array.Vector.T;                                                   
 var Array.Vector.T._elems4674002: [Array.Vector.T]([int]int);                                      
 var tmp84673912: Array.Vector.T;                                                                   
 var tmp194674088: int;                                                                             
 var $recorded.state4674049: int;                                                                   
 var this4674093: Vector;                                                                           
 var $pc4674002: Phase;                                                                             
 var tmp84674070: Array.Vector.T;                                                                   
 var Array.Vector.T._state4674020: [Array.Vector.T]State;                                           
 var path4673978: int;                                                                              
 var tmp74674049: int;                                                                              
 var Vector.elems4674070: [Vector]Array.Vector.T;                                                   
 var tmp84674036: Array.Vector.T;                                                                   
 var tmp64674030: int;                                                                              
 var $pc4674040: Phase;                                                                             
 var newElems4673995: Array.Vector.T;                                                               
 var $pc4673946: Phase;                                                                             
 var tmp174674040: int;                                                                             
 var $pc4673912: Phase;                                                                             
 var Vector._state4674040: [Vector]State;                                                           
 var tmp154673995: Array.Vector.T;                                                                  
 var this4674049: Vector;                                                                           
 var tmp44674040: bool;                                                                             
 var Vector._state4674036: [Vector]State;                                                           
 var Array.Vector.T._state4674002: [Array.Vector.T]State;                                           
 var tmp16: Array.Vector.T;                                                                         
 var tmp44673946: bool;                                                                             
 var $recorded.state4673912: int;                                                                   
 var tmp84674059: Array.Vector.T;                                                                   
 var tmp124673978: bool;                                                                            
 var x4674036: int;                                                                                 
 var tmp44674016: bool;                                                                             
 var $recorded.state4674030: int;                                                                   
 var Vector._lock4674016: [Vector]Tid;                                                              
 var tmp114674016: Array.Vector.T;                                                                  
 var this4674020: Vector;                                                                           
 var Vector._state4674006: [Vector]State;                                                           
 var Array.Vector.T._elems4674049: [Array.Vector.T]([int]int);                                      
 var moverPath4674088: MoverPath;                                                                   
 var tmp44673995: bool;                                                                             
 var Vector._lock4674006: [Vector]Tid;                                                              
 var tmp124674006: bool;                                                                            
 var Vector.spec4674016_bottom: [Vector]Seq.int;                                                    
 var tmp84673978: Array.Vector.T;                                                                   
 var tmp84674016: Array.Vector.T;                                                                   
 var tmp104673946: int;                                                                             
 var moverPath4673912: MoverPath;                                                                   
 var tmp94674002: int;                                                                              
 var tmp9: int;                                                                                     
 var Vector.elems4674030: [Vector]Array.Vector.T;                                                   
 var tmp104674016_bottom: int;                                                                      
 var tmp74674020: int;                                                                              
 var mover4673899: Mover;                                                                           
 var $pc4674006: Phase;                                                                             
 var tmp14: int;                                                                                    
 var Array.Vector.T._state4674016: [Array.Vector.T]State;                                           
 var Vector.spec4674002: [Vector]Seq.int;                                                           
 var $recorded.state4674040: int;                                                                   
 var x4673899: int;                                                                                 
 var moverPath4674070: MoverPath;                                                                   
 var Vector.count4674002: [Vector]int;                                                              
 var Array.Vector.T._elems4673978: [Array.Vector.T]([int]int);                                      
 var Vector._state4673946: [Vector]State;                                                           
 var Array.Vector.T._elems4674030: [Array.Vector.T]([int]int);                                      
 var path4674030: int;                                                                              
 var path4674002: int;                                                                              
 var tmp54673946: int;                                                                              
 var Array.Vector.T._state4673912: [Array.Vector.T]State;                                           
 var Vector._state4674030: [Vector]State;                                                           
 var newElems4673946: Array.Vector.T;                                                               
 var tmp44674006: bool;                                                                             
 var moverPath4674059: MoverPath;                                                                   
 var tmp64674016: int;                                                                              
 var Array.Vector.T._state4673899: [Array.Vector.T]State;                                           
 var Vector.count4674059: [Vector]int;                                                              
 var Array.Vector.T._length4674040: [Array.Vector.T]int;                                            
 var moverPath4674006: MoverPath;                                                                   
 var Vector.count4674093: [Vector]int;                                                              
 var x4674040: int;                                                                                 
 var $pc4674088: Phase;                                                                             
 var Vector.count4673899: [Vector]int;                                                              
 var moverPath4674002: MoverPath;                                                                   
 var tmp44674016_bottom: bool;                                                                      
 var $recorded.state4674059: int;                                                                   
 var $recorded.state4674016_bottom: int;                                                            
 var tmp44674030: bool;                                                                             
 var Vector.count4673946: [Vector]int;                                                              
 var Vector.count4673995: [Vector]int;                                                              
 var Array.Vector.T._elems4674036: [Array.Vector.T]([int]int);                                      
 var tmp15: Array.Vector.T;                                                                         
 var Vector.spec4674020: [Vector]Seq.int;                                                           
 var Array.Vector.T._state4674040: [Array.Vector.T]State;                                           
 var tid4673978: Tid;                                                                               
 var tmp94674016_bottom: int;                                                                       
 var tid4674016_bottom: Tid;                                                                        
 var Vector.count4674016: [Vector]int;                                                              
 var Vector.spec4674093: [Vector]Seq.int;                                                           
 var j4674002: int;                                                                                 
 var tmp94674020: int;                                                                              
 var this4674030: Vector;                                                                           
 var Array.Vector.T._elems4673995: [Array.Vector.T]([int]int);                                      
 var mover4674040: Mover;                                                                           
 var Vector.elems4674049: [Vector]Array.Vector.T;                                                   
 var this4674006: Vector;                                                                           
 var tmp104674002: int;                                                                             
 var $pc4673995: Phase;                                                                             
 var Vector._lock4673899: [Vector]Tid;                                                              
 var Vector._lock4673978: [Vector]Tid;                                                              
 var this4673978: Vector;                                                                           
 var Array.Vector.T._elems4674040: [Array.Vector.T]([int]int);                                      
 var mover4674006: Mover;                                                                           
 var tid4673912: Tid;                                                                               
 var tmp54674002: int;                                                                              
 var Vector._lock4673946: [Vector]Tid;                                                              
 var Vector._state4674093: [Vector]State;                                                           
 var Vector.spec4674049: [Vector]Seq.int;                                                           
 var tmp44674049: bool;                                                                             
 var tmp74673912: int;                                                                              
 var tmp74674030: int;                                                                              
 var Vector.count4674070: [Vector]int;                                                              
 var Array.Vector.T._elems4674088: [Array.Vector.T]([int]int);                                      
 var tmp64674006: int;                                                                              
 var Vector.count4674049: [Vector]int;                                                              
 var moverPath4673995: MoverPath;                                                                   
 var tmp74674070: int;                                                                              
 var tmp54674059: int;                                                                              
 var tid4674088: Tid;                                                                               
 var mover4674070: Mover;                                                                           
 var tmp114673995: Array.Vector.T;                                                                  
 var $recorded.state4674070: int;                                                                   
 var x4673946: int;                                                                                 
 var tmp74674016: int;                                                                              
 var Vector.elems4674059: [Vector]Array.Vector.T;                                                   
 var moverPath4674040: MoverPath;                                                                   
 var Vector.spec4674088: [Vector]Seq.int;                                                           
 var Array.Vector.T._state4674006: [Array.Vector.T]State;                                           
 var tmp164674088: Array.Vector.T;                                                                  
 var tid4674006: Tid;                                                                               
 var phase4674016: Phase;                                                                           
 var Array.Vector.T._state4674016_bottom: [Array.Vector.T]State;                                    
 var tmp8: Array.Vector.T;                                                                          
 var tmp134673995: int;                                                                             
 var Vector.elems4673912: [Vector]Array.Vector.T;                                                   
 var tmp174674088: int;                                                                             
 var tmp184674088: int;                                                                             
 var tmp164674036: Array.Vector.T;                                                                  
 var tmp44674002: bool;                                                                             
 var this4673995: Vector;                                                                           
 var Vector.spec4674040: [Vector]Seq.int;                                                           
 var Array.Vector.T._length4674088: [Array.Vector.T]int;                                            
 var tmp84673946: Array.Vector.T;                                                                   
 var tmp54674030: int;                                                                              
 var Array.Vector.T._length4674070: [Array.Vector.T]int;                                            
 var Vector._state4674088: [Vector]State;                                                           
 var $pc4674070: Phase;                                                                             
 var Vector.spec4673995: [Vector]Seq.int;                                                           
 var tmp54673912: int;                                                                              
 var Array.Vector.T._elems4674059: [Array.Vector.T]([int]int);                                      
 var Vector.spec4674036: [Vector]Seq.int;                                                           
 var tmp94673978: int;                                                                              
 var tmp18: int;                                                                                    
 var tmp44674020: bool;                                                                             
 var tmp174674059: int;                                                                             
 var newElems4673978: Array.Vector.T;                                                               
 var tmp74674006: int;                                                                              
 var tmp54674006: int;                                                                              
 var tmp184674049: int;                                                                             
 var tmp44673978: bool;                                                                             
 var moverPath4673899: MoverPath;                                                                   
 var path4674049: int;                                                                              
 var Vector.count4673912: [Vector]int;                                                              
 var Vector._state4674070: [Vector]State;                                                           
 var x4674006: int;                                                                                 
 var tmp64674036: int;                                                                              
 var tid4674002: Tid;                                                                               
 var Array.Vector.T._state4673978: [Array.Vector.T]State;                                           
 var Vector.spec4674070: [Vector]Seq.int;                                                           
 var tmp54674088: int;                                                                              
 var Vector.elems4673995: [Vector]Array.Vector.T;                                                   
 var tmp114674020: Array.Vector.T;                                                                  
 var x4673912: int;                                                                                 
 var Vector.elems4674006: [Vector]Array.Vector.T;                                                   
 var x4673995: int;                                                                                 
 var tmp12: bool;                                                                                   
 var Vector._state4674059: [Vector]State;                                                           
 var Vector._lock4674016_bottom: [Vector]Tid;                                                       
 var $recorded.state4673946: int;                                                                   
 var this4674036: Vector;                                                                           
 var Vector._state4673899: [Vector]State;                                                           
 var tmp74673995: int;                                                                              
 var x4674016_bottom: int;                                                                          
 var Array.Vector.T._length4674006: [Array.Vector.T]int;                                            
 var Array.Vector.T._state4674036: [Array.Vector.T]State;                                           
 var Vector.elems4674093: [Vector]Array.Vector.T;                                                   
 var tmp10: int;                                                                                    
 var tmp214674088: Seq.int;                                                                         
 var Array.Vector.T._elems4673946: [Array.Vector.T]([int]int);                                      
 var Vector._lock4674070: [Vector]Tid;                                                              
 var tmp104674006: int;                                                                             
 var Vector.count4673978: [Vector]int;                                                              
 var Vector._state4673912: [Vector]State;                                                           
 var tmp13: int;                                                                                    
 var path4673946: int;                                                                              
 var tmp94674016: int;                                                                              
 var tid4674020: Tid;                                                                               
 var newElems4674016: Array.Vector.T;                                                               
 var mover4673946: Mover;                                                                           
 var Array.Vector.T._state4674059: [Array.Vector.T]State;                                           
 var this4674016_bottom: Vector;                                                                    
 var mover4674002: Mover;                                                                           
 var this4674088: Vector;                                                                           
 var Array.Vector.T._length4674093: [Array.Vector.T]int;                                            
 var Vector.count4674088: [Vector]int;                                                              
 var tmp114674002: Array.Vector.T;                                                                  
 var $recorded.state4673899: int;                                                                   
 var $pc4674016_bottom: Phase;                                                                      
 var tmp19: int;                                                                                    
 var tid4674016: Tid;                                                                               
 var Vector._lock4674036: [Vector]Tid;                                                              
 var tmp194674049: int;                                                                             
 var tmp114673978: Array.Vector.T;                                                                  
 var Vector.spec4674059: [Vector]Seq.int;                                                           
 var Vector.elems4674040: [Vector]Array.Vector.T;                                                   
 var $recorded.state4674093: int;                                                                   
 var x4674030: int;                                                                                 
 var Vector._state4674049: [Vector]State;                                                           
 var tid4674093: Tid;                                                                               
 var x4674016: int;                                                                                 
 var x4674049: int;                                                                                 
 var $recorded.state4674006: int;                                                                   
 var tmp94673995: int;                                                                              
 var tmp20: Seq.int;                                                                                
 var mover4674036: Mover;                                                                           
 var tmp164674030: Array.Vector.T;                                                                  
 var Array.Vector.T._elems4674020: [Array.Vector.T]([int]int);                                      
 var tmp74674059: int;                                                                              
 var tmp54674070: int;                                                                              
 var Vector._state4673995: [Vector]State;                                                           
 var tmp174674036: int;                                                                             
 var x4674093: int;                                                                                 
 var tid4673995: Tid;                                                                               
 var this4674059: Vector;                                                                           
 var mover4673978: Mover;                                                                           
 var path4674040: int;                                                                              
 var tid4674040: Tid;                                                                               
 var mover4674059: Mover;                                                                           
 var x4674088: int;                                                                                 
 var Vector._lock4674088: [Vector]Tid;                                                              
 var tid4674059: Tid;                                                                               
 var tmp84674049: Array.Vector.T;                                                                   
 var tmp184674070: int;                                                                             
 var tmp54674049: int;                                                                              
 var tmp74674088: int;                                                                              
 var mover4673995: Mover;                                                                           
 var Array.Vector.T._length4674002: [Array.Vector.T]int;                                            
 var tmp64673978: int;                                                                              
 var x4673978: int;                                                                                 
 var tmp134673978: int;                                                                             
 var Array.Vector.T._elems4674093: [Array.Vector.T]([int]int);                                      
 var Array.Vector.T._state4673946: [Array.Vector.T]State;                                           
 var tmp74674016_bottom: int;                                                                       
 var Vector.spec4673912: [Vector]Seq.int;                                                           
 var j4673978: int;                                                                                 
 var Array.Vector.T._length4673912: [Array.Vector.T]int;                                            
 var $recorded.state4673978: int;                                                                   
 var Array.Vector.T._length4673946: [Array.Vector.T]int;                                            
 var tmp7: int;                                                                                     
 var Vector.count4674036: [Vector]int;                                                              
 var Vector.count4674030: [Vector]int;                                                              
 var this4674070: Vector;                                                                           
 var moverPath4673978: MoverPath;                                                                   
 var x4674070: int;                                                                                 
 var $pc4674030: Phase;                                                                             
 var tmp54674016_bottom: int;                                                                       
 var tmp4: bool;                                                                                    
 var tmp154674002: Array.Vector.T;                                                                  
 var tid4674049: Tid;                                                                               
 var tmp154674006: Array.Vector.T;                                                                  
 var tmp44673912: bool;                                                                             
 var mover4673912: Mover;                                                                           
 var mover4674020: Mover;                                                                           
 var tmp21: Seq.int;                                                                                
 var tmp44674036: bool;                                                                             
 var newElems4674002: Array.Vector.T;                                                               
 var tmp84674020: Array.Vector.T;                                                                   
 var mover4674049: Mover;                                                                           
 var tid4674030: Tid;                                                                               
 var tmp214674070: Seq.int;                                                                         
 var $recorded.state4674002: int;                                                                   
 var x4674002: int;                                                                                 
 var Vector._state4674016: [Vector]State;                                                           
 var Vector.spec4673899: [Vector]Seq.int;                                                           
 var Array.Vector.T._length4674049: [Array.Vector.T]int;                                            
 var tmp134674002: int;                                                                             
 var Array.Vector.T._state4674088: [Array.Vector.T]State;                                           
 var $recorded.state4674016: int;                                                                   
 var Vector._lock4674093: [Vector]Tid;                                                              
 var tmp124674002: bool;                                                                            
 var Array.Vector.T._length4673978: [Array.Vector.T]int;                                            
 var path4673995: int;                                                                              
 var Array.Vector.T._length4673899: [Array.Vector.T]int;                                            
 var path4673899: int;                                                                              
 var $pc4673978: Phase;                                                                             
 var tmp74673978: int;                                                                              
 var tmp84674002: Array.Vector.T;                                                                   
 var Array.Vector.T._elems4674016: [Array.Vector.T]([int]int);                                      
 var this4674002: Vector;                                                                           
 var tmp104673995: int;                                                                             
 var j4674016_bottom: int;                                                                          
 var Vector._lock4673912: [Vector]Tid;                                                              
 var tmp64674088: int;                                                                              
 var tid4674070: Tid;                                                                               
 var tmp204674070: Seq.int;                                                                         
 var tmp114673946: Array.Vector.T;                                                                  
 var this4673899: Vector;                                                                           
 var tmp144674006: int;                                                                             
 var tmp11: Array.Vector.T;                                                                         
 var Vector._state4674002: [Vector]State;                                                           
 var this4673912: Vector;                                                                           
 var path4674020: int;                                                                              
 var newElems4674006: Array.Vector.T;                                                               
 var tmp194674059: int;                                                                             
 var tmp174674049: int;                                                                             
 var Vector._lock4674059: [Vector]Tid;                                                              
 var tmp144674002: int;                                                                             
 var Array.Vector.T._length4674016: [Array.Vector.T]int;                                            
 var Array.Vector.T._state4673995: [Array.Vector.T]State;                                           
 var path4674070: int;                                                                              
 var Vector.spec4673978: [Vector]Seq.int;                                                           
 var Vector._lock4674049: [Vector]Tid;                                                              
 var tmp104673978: int;                                                                             
 var this4674016: Vector;                                                                           
 var tmp44674070: bool;                                                                             
 var Array.Vector.T._length4674020: [Array.Vector.T]int;                                            
 var moverPath4674036: MoverPath;                                                                   
 var tmp64673995: int;                                                                              
 var Array.Vector.T._length4674016_bottom: [Array.Vector.T]int;                                     
 var tmp104674020: int;                                                                             
 var tmp174674070: int;                                                                             
 var mover4674088: Mover;                                                                           
 var tmp164674040: Array.Vector.T;                                                                  
 var tmp194674070: int;                                                                             
 var Vector.count4674006: [Vector]int;                                                              
 var moverPath4674020: MoverPath;                                                                   
 var tmp134674006: int;                                                                             
 var tmp164674049: Array.Vector.T;                                                                  
 var Array.Vector.T._length4674030: [Array.Vector.T]int;                                            
 var Vector.elems4673946: [Vector]Array.Vector.T;                                                   
 var Array.Vector.T._state4674049: [Array.Vector.T]State;                                           
 var x4674020: int;                                                                                 
 var tmp84674006: Array.Vector.T;                                                                   
 var Vector._lock4673995: [Vector]Tid;                                                              
 var j4674016: int;                                                                                 
 var Vector._lock4674030: [Vector]Tid;                                                              
 var tmp54674016: int;                                                                              
 var tmp114674006: Array.Vector.T;                                                                  
 var j4674006: int;                                                                                 
 var mover4674030: Mover;                                                                           
 var tmp64673946: int;                                                                              
 var tmp84674030: Array.Vector.T;                                                                   
 var Array.Vector.T._length4674036: [Array.Vector.T]int;                                            
 var $recorded.state4673995: int;                                                                   
 var tmp6: int;                                                                                     
 var Array.Vector.T._elems4673912: [Array.Vector.T]([int]int);                                      
 var moverPath4673946: MoverPath;                                                                   
 var j: int;                                                                                        
 var $pc4674016: Phase;                                                                             
 var $pc4674036: Phase;                                                                             
 var path4674088: int;                                                                              
 var path4673912: int;                                                                              
 var Vector.count4674020: [Vector]int;                                                              
 var Vector.spec4674016: [Vector]Seq.int;                                                           
 var tmp84674016_bottom: Array.Vector.T;                                                            
 var Vector._state4674016_bottom: [Vector]State;                                                    
 var $pc4674020: Phase;                                                                             
 var Vector.spec4673946: [Vector]Seq.int;                                                           
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (30.23): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume Vector._lock[this] == Tid.null;                                                             
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (30.23): Reduction failure
 Vector._lock[this] := tid;                                                                         
                                                                                                    
 // 31.13: boolean tmp4;                                                                            
                                                                                                    
                                                                                                    
 // 31.13: int tmp5;                                                                                
                                                                                                    
                                                                                                    
 // 31.13: tmp5 := this.count;                                                                      
                                                                                                    
                                                                                                    
 moverPath4673899 := ReadEval.Vector.count(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 mover4673899 := m#moverPath(moverPath4673899);                                                     
 path4673899 := p#moverPath(moverPath4673899);                                                      
 assume Vector._state4673899 == Vector._state && Vector.elems4673899 == Vector.elems && Vector.count4673899 == Vector.count && Vector.spec4673899 == Vector.spec && Vector._lock4673899 == Vector._lock && Array.Vector.T._state4673899 == Array.Vector.T._state && Array.Vector.T._elems4673899 == Array.Vector.T._elems && Array.Vector.T._length4673899 == Array.Vector.T._length && tmp54673899 == tmp5 && tmp44673899 == tmp4 && x4673899 == x && this4673899 == this && tid4673899 == tid && $pc4673899 == $pc;
 assume $recorded.state4673899 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (31.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4673899);                                                              
 assert $pc != PhaseError;                                                                                 // (31.13): Reduction failure
 tmp5 := Vector.count[this];                                                                        
                                                                                                    
 // 31.13: int tmp6;                                                                                
                                                                                                    
                                                                                                    
 // 31.13: int tmp7;                                                                                
                                                                                                    
                                                                                                    
 // 31.13: [Vector.T{this}] tmp8;                                                                   
                                                                                                    
                                                                                                    
 // 31.13: tmp8 := this.elems;                                                                      
                                                                                                    
                                                                                                    
 moverPath4673912 := ReadEval.Vector.elems(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 mover4673912 := m#moverPath(moverPath4673912);                                                     
 path4673912 := p#moverPath(moverPath4673912);                                                      
 assume Vector._state4673912 == Vector._state && Vector.elems4673912 == Vector.elems && Vector.count4673912 == Vector.count && Vector.spec4673912 == Vector.spec && Vector._lock4673912 == Vector._lock && Array.Vector.T._state4673912 == Array.Vector.T._state && Array.Vector.T._elems4673912 == Array.Vector.T._elems && Array.Vector.T._length4673912 == Array.Vector.T._length && tmp84673912 == tmp8 && tmp74673912 == tmp7 && tmp64673912 == tmp6 && tmp54673912 == tmp5 && tmp44673912 == tmp4 && x4673912 == x && this4673912 == this && tid4673912 == tid && $pc4673912 == $pc;
 assume $recorded.state4673912 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (31.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4673912);                                                              
 assert $pc != PhaseError;                                                                                 // (31.13): Reduction failure
 tmp8 := Vector.elems[this];                                                                        
                                                                                                    
 // 31.13: tmp7 = tmp8.length;                                                                      
                                                                                                    
 tmp7 := Array.Vector.T._length[tmp8];                                                              
                                                                                                    
 // 31.13: tmp6 = tmp7 - 1;                                                                         
                                                                                                    
 tmp6 := (tmp7-1);                                                                                  
                                                                                                    
 // 31.13: tmp4 = tmp5 == tmp6;                                                                     
                                                                                                    
 tmp4 := (tmp5==tmp6);                                                                              
 if (tmp4 /* lowered (Vector.count[this]==(Array.Vector.T._length[Vector.elems[this]]-1)) */) {     
                                                                                                    
  // 32.17: [Vector.T{this}] newElems;                                                              
                                                                                                    
                                                                                                    
  // 32.17: int tmp9;                                                                               
                                                                                                    
                                                                                                    
  // 32.17: int tmp10;                                                                              
                                                                                                    
                                                                                                    
  // 32.17: [Vector.T{this}] tmp11;                                                                 
                                                                                                    
                                                                                                    
  // 32.17: tmp11 := this.elems;                                                                    
                                                                                                    
                                                                                                    
  moverPath4673946 := ReadEval.Vector.elems(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
  mover4673946 := m#moverPath(moverPath4673946);                                                    
  path4673946 := p#moverPath(moverPath4673946);                                                     
  assume Vector._state4673946 == Vector._state && Vector.elems4673946 == Vector.elems && Vector.count4673946 == Vector.count && Vector.spec4673946 == Vector.spec && Vector._lock4673946 == Vector._lock && Array.Vector.T._state4673946 == Array.Vector.T._state && Array.Vector.T._elems4673946 == Array.Vector.T._elems && Array.Vector.T._length4673946 == Array.Vector.T._length && tmp114673946 == tmp11 && tmp104673946 == tmp10 && tmp94673946 == tmp9 && newElems4673946 == newElems && tmp84673946 == tmp8 && tmp74673946 == tmp7 && tmp64673946 == tmp6 && tmp54673946 == tmp5 && tmp44673946 == tmp4 && x4673946 == x && this4673946 == this && tid4673946 == tid && $pc4673946 == $pc;
  assume $recorded.state4673946 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Vector.null;                                                                      
  } else {                                                                                          
   assert this != Vector.null;                                                                             // (32.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4673946);                                                             
  assert $pc != PhaseError;                                                                                // (32.17): Reduction failure
  tmp11 := Vector.elems[this];                                                                      
                                                                                                    
  // 32.17: tmp10 = tmp11.length;                                                                   
                                                                                                    
  tmp10 := Array.Vector.T._length[tmp11];                                                           
                                                                                                    
  // 32.17: tmp9 = tmp10 + 10;                                                                      
                                                                                                    
  tmp9 := (tmp10+10);                                                                               
                                                                                                    
  // 32.17: newElems = new [Vector.T{this}](tmp9);                                                  
                                                                                                    
  havoc newElems;                                                                                   
  assume isFresh(Array.Vector.T._state[newElems]);                                                  
  assume Array.Vector.T._length[newElems] == tmp9;                                                  
  assume Array.Vector.T._this[newElems] == this;                                                    
  Array.Vector.T._state[newElems] := LOCAL(tid);                                                    
  assume (forall _i : int :: 0 <= _i ==> Array.Vector.T._elems[newElems][_i] == 0);                 
                                                                                                    
  // 33.22: int j;                                                                                  
                                                                                                    
                                                                                                    
  // 33.22: j = 0;                                                                                  
                                                                                                    
  j := 0;                                                                                           
  assume Vector._state4674016 == Vector._state && Vector.elems4674016 == Vector.elems && Vector.count4674016 == Vector.count && Vector.spec4674016 == Vector.spec && Vector._lock4674016 == Vector._lock && Array.Vector.T._state4674016 == Array.Vector.T._state && Array.Vector.T._elems4674016 == Array.Vector.T._elems && Array.Vector.T._length4674016 == Array.Vector.T._length && j4674016 == j && tmp114674016 == tmp11 && tmp104674016 == tmp10 && tmp94674016 == tmp9 && newElems4674016 == newElems && tmp84674016 == tmp8 && tmp74674016 == tmp7 && tmp64674016 == tmp6 && tmp54674016 == tmp5 && tmp44674016 == tmp4 && x4674016 == x && this4674016 == this && tid4674016 == tid;
  assume $recorded.state4674016 == 1;                                                               
                                                                                                    
  // 33.35: while (true)                                                                            
                                                                                                    
  phase4674016 := $pc;                                                                              
  while (true)                                                                                      
                                                                                                    
   invariant ValidTid(tid);                                                                                // (27.5): Bad tid
   invariant isShared(Vector._state[this]);                                                                // (27.5): this is not global
                                                                                                    
   invariant StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
   invariant  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (33.35): Object invariant may not hold.
   invariant  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (33.35): Object invariant may not hold.
   invariant (forall i: int ::  ((((0<=i)&&(i<j))==>(Array.Vector.T._elems[newElems][i]==SeqNth.int(Vector.spec[this],i)))));
   invariant (isAccessible(Vector._state[this], tid) && Vector._lock[this] == tid);                 
   invariant (forall _this : Vector :: Invariant.Y_Vector.elems(tid : Tid, _this, Vector.elems[_this] ,Vector._state4674016,Vector.elems4674016,Vector.count4674016,Vector.spec4674016,Vector._lock4674016,Array.Vector.T._state4674016,Array.Vector.T._elems4674016,Array.Vector.T._length4674016));       // (33.35): Loop does not preserve yields_as annotation for field elems
   invariant (forall _this : Vector :: Invariant.Y_Vector.count(tid : Tid, _this, Vector.count[_this] ,Vector._state4674016,Vector.elems4674016,Vector.count4674016,Vector.spec4674016,Vector._lock4674016,Array.Vector.T._state4674016,Array.Vector.T._elems4674016,Array.Vector.T._length4674016));       // (33.35): Loop does not preserve yields_as annotation for field count
   invariant (forall _this : Vector :: Invariant.Y_Vector.spec(tid : Tid, _this, Vector.spec[_this] ,Vector._state4674016,Vector.elems4674016,Vector.count4674016,Vector.spec4674016,Vector._lock4674016,Array.Vector.T._state4674016,Array.Vector.T._elems4674016,Array.Vector.T._length4674016));       // (33.35): Loop does not preserve yields_as annotation for field spec
   invariant (forall _athis : Array.Vector.T, _index : int :: Invariant.Y_Array.Vector.T(tid : Tid, _athis, _index, Array.Vector.T._elems[_athis][_index] ,Vector._state4674016,Vector.elems4674016,Vector.count4674016,Vector.spec4674016,Vector._lock4674016,Array.Vector.T._state4674016,Array.Vector.T._elems4674016,Array.Vector.T._length4674016));       // (33.35): Loop does not preserve yields_as annotation for field ArrayDecl(T,IntType(),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(Holds(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
   invariant phase4674016 == $pc;                                                                          // (33.35): Phase must be invariant at loop head
   invariant $pc == PreCommit;                                                                             // (33.35): Potentially infinite loop cannot be in post-commit phase.
  {                                                                                                 
                                                                                                    
   // 33.35: boolean tmp12;                                                                         
                                                                                                    
                                                                                                    
   // 33.37: int tmp13;                                                                             
                                                                                                    
                                                                                                    
   // 33.37: tmp13 := this.count;                                                                   
                                                                                                    
                                                                                                    
   moverPath4673978 := ReadEval.Vector.count(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
   mover4673978 := m#moverPath(moverPath4673978);                                                   
   path4673978 := p#moverPath(moverPath4673978);                                                    
   assume Vector._state4673978 == Vector._state && Vector.elems4673978 == Vector.elems && Vector.count4673978 == Vector.count && Vector.spec4673978 == Vector.spec && Vector._lock4673978 == Vector._lock && Array.Vector.T._state4673978 == Array.Vector.T._state && Array.Vector.T._elems4673978 == Array.Vector.T._elems && Array.Vector.T._length4673978 == Array.Vector.T._length && tmp134673978 == tmp13 && tmp124673978 == tmp12 && j4673978 == j && tmp114673978 == tmp11 && tmp104673978 == tmp10 && tmp94673978 == tmp9 && newElems4673978 == newElems && tmp84673978 == tmp8 && tmp74673978 == tmp7 && tmp64673978 == tmp6 && tmp54673978 == tmp5 && tmp44673978 == tmp4 && x4673978 == x && this4673978 == this && tid4673978 == tid && $pc4673978 == $pc;
   assume $recorded.state4673978 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Vector.null;                                                                     
   } else {                                                                                         
    assert this != Vector.null;                                                                            // (33.37): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4673978);                                                            
   assert $pc != PhaseError;                                                                               // (33.37): Reduction failure
   tmp13 := Vector.count[this];                                                                     
                                                                                                    
   // 33.35: tmp12 = j < tmp13;                                                                     
                                                                                                    
   tmp12 := (j<tmp13);                                                                              
   if (!(tmp12)) {                                                                                  
                                                                                                    
    // 33.35: break;                                                                                
                                                                                                    
    break;                                                                                          
   } else {                                                                                         
   }                                                                                                
                                                                                                    
   // 36.21: [Vector.T{this}] tmp15;                                                                
                                                                                                    
                                                                                                    
   // 36.21: tmp15 := this.elems;                                                                   
                                                                                                    
                                                                                                    
   moverPath4673995 := ReadEval.Vector.elems(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
   mover4673995 := m#moverPath(moverPath4673995);                                                   
   path4673995 := p#moverPath(moverPath4673995);                                                    
   assume Vector._state4673995 == Vector._state && Vector.elems4673995 == Vector.elems && Vector.count4673995 == Vector.count && Vector.spec4673995 == Vector.spec && Vector._lock4673995 == Vector._lock && Array.Vector.T._state4673995 == Array.Vector.T._state && Array.Vector.T._elems4673995 == Array.Vector.T._elems && Array.Vector.T._length4673995 == Array.Vector.T._length && tmp154673995 == tmp15 && tmp134673995 == tmp13 && tmp124673995 == tmp12 && j4673995 == j && tmp114673995 == tmp11 && tmp104673995 == tmp10 && tmp94673995 == tmp9 && newElems4673995 == newElems && tmp84673995 == tmp8 && tmp74673995 == tmp7 && tmp64673995 == tmp6 && tmp54673995 == tmp5 && tmp44673995 == tmp4 && x4673995 == x && this4673995 == this && tid4673995 == tid && $pc4673995 == $pc;
   assume $recorded.state4673995 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Vector.null;                                                                     
   } else {                                                                                         
    assert this != Vector.null;                                                                            // (36.21): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4673995);                                                            
   assert $pc != PhaseError;                                                                               // (36.21): Reduction failure
   tmp15 := Vector.elems[this];                                                                     
                                                                                                    
   // 36.21: int tmp14;                                                                             
                                                                                                    
                                                                                                    
   // 36.21: tmp14 := tmp15[j];                                                                     
                                                                                                    
                                                                                                    
   moverPath4674002 := ReadEval.Array.Vector.T(tid: Tid,this: Vector,tmp15: Array.Vector.T,j: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
   mover4674002 := m#moverPath(moverPath4674002);                                                   
   path4674002 := p#moverPath(moverPath4674002);                                                    
   assume Vector._state4674002 == Vector._state && Vector.elems4674002 == Vector.elems && Vector.count4674002 == Vector.count && Vector.spec4674002 == Vector.spec && Vector._lock4674002 == Vector._lock && Array.Vector.T._state4674002 == Array.Vector.T._state && Array.Vector.T._elems4674002 == Array.Vector.T._elems && Array.Vector.T._length4674002 == Array.Vector.T._length && tmp144674002 == tmp14 && tmp154674002 == tmp15 && tmp134674002 == tmp13 && tmp124674002 == tmp12 && j4674002 == j && tmp114674002 == tmp11 && tmp104674002 == tmp10 && tmp94674002 == tmp9 && newElems4674002 == newElems && tmp84674002 == tmp8 && tmp74674002 == tmp7 && tmp64674002 == tmp6 && tmp54674002 == tmp5 && tmp44674002 == tmp4 && x4674002 == x && this4674002 == this && tid4674002 == tid && $pc4674002 == $pc;
   assume $recorded.state4674002 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume tmp15 != Array.Vector.T.null;                                                            
   } else {                                                                                         
    assert tmp15 != Array.Vector.T.null;                                                                   // (36.21): Cannot have potential null deference in left-mover part.
   }                                                                                                
   if ($pc == PreCommit) {                                                                          
    assume 0 <= j;                                                                                  
   } else {                                                                                         
    assert 0 <= j;                                                                                         // (36.21): index < 0.
   }                                                                                                
   if ($pc == PreCommit) {                                                                          
    assume j < Array.Vector.T._length[tmp15];                                                       
   } else {                                                                                         
    assert j < Array.Vector.T._length[tmp15];                                                              // (36.21): index is >= length.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4674002);                                                            
   assert $pc != PhaseError;                                                                               // (36.21): Reduction failure
   tmp14 := Array.Vector.T._elems[tmp15][j];                                                        
                                                                                                    
   // 36.21: newElems[j] := tmp14;                                                                  
                                                                                                    
                                                                                                    
   moverPath4674006 := WriteEval.Array.Vector.T(tid: Tid,this: Vector,newElems: Array.Vector.T,j: int,tmp14: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
   mover4674006 := m#moverPath(moverPath4674006);                                                   
   path4674006 := p#moverPath(moverPath4674006);                                                    
   assume Vector._state4674006 == Vector._state && Vector.elems4674006 == Vector.elems && Vector.count4674006 == Vector.count && Vector.spec4674006 == Vector.spec && Vector._lock4674006 == Vector._lock && Array.Vector.T._state4674006 == Array.Vector.T._state && Array.Vector.T._elems4674006 == Array.Vector.T._elems && Array.Vector.T._length4674006 == Array.Vector.T._length && tmp144674006 == tmp14 && tmp154674006 == tmp15 && tmp134674006 == tmp13 && tmp124674006 == tmp12 && j4674006 == j && tmp114674006 == tmp11 && tmp104674006 == tmp10 && tmp94674006 == tmp9 && newElems4674006 == newElems && tmp84674006 == tmp8 && tmp74674006 == tmp7 && tmp64674006 == tmp6 && tmp54674006 == tmp5 && tmp44674006 == tmp4 && x4674006 == x && this4674006 == this && tid4674006 == tid && $pc4674006 == $pc;
   assume $recorded.state4674006 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume newElems != Array.Vector.T.null;                                                         
   } else {                                                                                         
    assert newElems != Array.Vector.T.null;                                                                // (36.21): Cannot have potential null deference in left-mover part.
   }                                                                                                
   if ($pc == PreCommit) {                                                                          
    assume 0 <= j;                                                                                  
   } else {                                                                                         
    assert 0 <= j;                                                                                         // (36.21): index < 0.
   }                                                                                                
   if ($pc == PreCommit) {                                                                          
    assume j < Array.Vector.T._length[newElems];                                                    
   } else {                                                                                         
    assert j < Array.Vector.T._length[newElems];                                                           // (36.21): index is >= length.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4674006);                                                            
   assert $pc != PhaseError;                                                                               // (36.21): Reduction failure
   Array.Vector.T._elems[newElems][j] := tmp14;                                                     
                                                                                                    
   // 33.49: j = j + 1;                                                                             
                                                                                                    
   j := (j+1);                                                                                      
   assume Vector._state4674016_bottom == Vector._state && Vector.elems4674016_bottom == Vector.elems && Vector.count4674016_bottom == Vector.count && Vector.spec4674016_bottom == Vector.spec && Vector._lock4674016_bottom == Vector._lock && Array.Vector.T._state4674016_bottom == Array.Vector.T._state && Array.Vector.T._elems4674016_bottom == Array.Vector.T._elems && Array.Vector.T._length4674016_bottom == Array.Vector.T._length && j4674016_bottom == j && tmp114674016_bottom == tmp11 && tmp104674016_bottom == tmp10 && tmp94674016_bottom == tmp9 && newElems4674016_bottom == newElems && tmp84674016_bottom == tmp8 && tmp74674016_bottom == tmp7 && tmp64674016_bottom == tmp6 && tmp54674016_bottom == tmp5 && tmp44674016_bottom == tmp4 && x4674016_bottom == x && this4674016_bottom == this && tid4674016_bottom == tid;
   assume $recorded.state4674016_bottom == 1;                                                       
   assert phase4674016 == $pc;                                                                             // (33.35): Phase must be invariant at loop head
  }                                                                                                 
                                                                                                    
                                                                                                    
  // 38.17: this.elems := newElems;                                                                 
                                                                                                    
                                                                                                    
  moverPath4674020 := WriteEval.Vector.elems(tid: Tid,this: Vector,newElems: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
  mover4674020 := m#moverPath(moverPath4674020);                                                    
  path4674020 := p#moverPath(moverPath4674020);                                                     
  assume Vector._state4674020 == Vector._state && Vector.elems4674020 == Vector.elems && Vector.count4674020 == Vector.count && Vector.spec4674020 == Vector.spec && Vector._lock4674020 == Vector._lock && Array.Vector.T._state4674020 == Array.Vector.T._state && Array.Vector.T._elems4674020 == Array.Vector.T._elems && Array.Vector.T._length4674020 == Array.Vector.T._length && tmp114674020 == tmp11 && tmp104674020 == tmp10 && tmp94674020 == tmp9 && newElems4674020 == newElems && tmp84674020 == tmp8 && tmp74674020 == tmp7 && tmp64674020 == tmp6 && tmp54674020 == tmp5 && tmp44674020 == tmp4 && x4674020 == x && this4674020 == this && tid4674020 == tid && $pc4674020 == $pc;
  assume $recorded.state4674020 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Vector.null;                                                                      
  } else {                                                                                          
   assert this != Vector.null;                                                                             // (38.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover4674020);                                                             
  assert $pc != PhaseError;                                                                                // (38.17): Reduction failure
  Vector.elems[this] := newElems;                                                                   
  if (isLocal(Array.Vector.T._state[newElems], tid)) {                                              
   Array.Vector.T._state[newElems] := SHARED();                                                     
   if (isLocal(Vector._state[Array.Vector.T._this[newElems]], tid)) {                               
    Vector._state[Array.Vector.T._this[newElems]] := SHARED();                                      
    assert isSharedAssignable(Array.Vector.T._state[Vector.elems[Array.Vector.T._this[newElems]]]);        // (38.17): newElems became shared, but Array.Vector.T._this[newElems].elems may not be shared.
   }                                                                                                
  }                                                                                                 
                                                                                                    
 } else {                                                                                           
 }                                                                                                  
                                                                                                    
 // 41.13: [Vector.T{this}] tmp16;                                                                  
                                                                                                    
                                                                                                    
 // 41.13: tmp16 := this.elems;                                                                     
                                                                                                    
                                                                                                    
 moverPath4674030 := ReadEval.Vector.elems(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 mover4674030 := m#moverPath(moverPath4674030);                                                     
 path4674030 := p#moverPath(moverPath4674030);                                                      
 assume Vector._state4674030 == Vector._state && Vector.elems4674030 == Vector.elems && Vector.count4674030 == Vector.count && Vector.spec4674030 == Vector.spec && Vector._lock4674030 == Vector._lock && Array.Vector.T._state4674030 == Array.Vector.T._state && Array.Vector.T._elems4674030 == Array.Vector.T._elems && Array.Vector.T._length4674030 == Array.Vector.T._length && tmp164674030 == tmp16 && tmp84674030 == tmp8 && tmp74674030 == tmp7 && tmp64674030 == tmp6 && tmp54674030 == tmp5 && tmp44674030 == tmp4 && x4674030 == x && this4674030 == this && tid4674030 == tid && $pc4674030 == $pc;
 assume $recorded.state4674030 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (41.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4674030);                                                              
 assert $pc != PhaseError;                                                                                 // (41.13): Reduction failure
 tmp16 := Vector.elems[this];                                                                       
                                                                                                    
 // 41.13: int tmp17;                                                                               
                                                                                                    
                                                                                                    
 // 41.13: tmp17 := this.count;                                                                     
                                                                                                    
                                                                                                    
 moverPath4674036 := ReadEval.Vector.count(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 mover4674036 := m#moverPath(moverPath4674036);                                                     
 path4674036 := p#moverPath(moverPath4674036);                                                      
 assume Vector._state4674036 == Vector._state && Vector.elems4674036 == Vector.elems && Vector.count4674036 == Vector.count && Vector.spec4674036 == Vector.spec && Vector._lock4674036 == Vector._lock && Array.Vector.T._state4674036 == Array.Vector.T._state && Array.Vector.T._elems4674036 == Array.Vector.T._elems && Array.Vector.T._length4674036 == Array.Vector.T._length && tmp174674036 == tmp17 && tmp164674036 == tmp16 && tmp84674036 == tmp8 && tmp74674036 == tmp7 && tmp64674036 == tmp6 && tmp54674036 == tmp5 && tmp44674036 == tmp4 && x4674036 == x && this4674036 == this && tid4674036 == tid && $pc4674036 == $pc;
 assume $recorded.state4674036 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (41.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4674036);                                                              
 assert $pc != PhaseError;                                                                                 // (41.13): Reduction failure
 tmp17 := Vector.count[this];                                                                       
                                                                                                    
 // 41.13: tmp16[tmp17] := x;                                                                       
                                                                                                    
                                                                                                    
 moverPath4674040 := WriteEval.Array.Vector.T(tid: Tid,this: Vector,tmp16: Array.Vector.T,tmp17: int,x: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 mover4674040 := m#moverPath(moverPath4674040);                                                     
 path4674040 := p#moverPath(moverPath4674040);                                                      
 assume Vector._state4674040 == Vector._state && Vector.elems4674040 == Vector.elems && Vector.count4674040 == Vector.count && Vector.spec4674040 == Vector.spec && Vector._lock4674040 == Vector._lock && Array.Vector.T._state4674040 == Array.Vector.T._state && Array.Vector.T._elems4674040 == Array.Vector.T._elems && Array.Vector.T._length4674040 == Array.Vector.T._length && tmp174674040 == tmp17 && tmp164674040 == tmp16 && tmp84674040 == tmp8 && tmp74674040 == tmp7 && tmp64674040 == tmp6 && tmp54674040 == tmp5 && tmp44674040 == tmp4 && x4674040 == x && this4674040 == this && tid4674040 == tid && $pc4674040 == $pc;
 assume $recorded.state4674040 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume tmp16 != Array.Vector.T.null;                                                              
 } else {                                                                                           
  assert tmp16 != Array.Vector.T.null;                                                                     // (41.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 if ($pc == PreCommit) {                                                                            
  assume 0 <= tmp17;                                                                                
 } else {                                                                                           
  assert 0 <= tmp17;                                                                                       // (41.13): index < 0.
 }                                                                                                  
 if ($pc == PreCommit) {                                                                            
  assume tmp17 < Array.Vector.T._length[tmp16];                                                     
 } else {                                                                                           
  assert tmp17 < Array.Vector.T._length[tmp16];                                                            // (41.13): index is >= length.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4674040);                                                              
 assert $pc != PhaseError;                                                                                 // (41.13): Reduction failure
 Array.Vector.T._elems[tmp16][tmp17] := x;                                                          
                                                                                                    
 // 42.13: int tmp18;                                                                               
                                                                                                    
                                                                                                    
 // 42.13: int tmp19;                                                                               
                                                                                                    
                                                                                                    
 // 42.13: tmp19 := this.count;                                                                     
                                                                                                    
                                                                                                    
 moverPath4674049 := ReadEval.Vector.count(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 mover4674049 := m#moverPath(moverPath4674049);                                                     
 path4674049 := p#moverPath(moverPath4674049);                                                      
 assume Vector._state4674049 == Vector._state && Vector.elems4674049 == Vector.elems && Vector.count4674049 == Vector.count && Vector.spec4674049 == Vector.spec && Vector._lock4674049 == Vector._lock && Array.Vector.T._state4674049 == Array.Vector.T._state && Array.Vector.T._elems4674049 == Array.Vector.T._elems && Array.Vector.T._length4674049 == Array.Vector.T._length && tmp194674049 == tmp19 && tmp184674049 == tmp18 && tmp174674049 == tmp17 && tmp164674049 == tmp16 && tmp84674049 == tmp8 && tmp74674049 == tmp7 && tmp64674049 == tmp6 && tmp54674049 == tmp5 && tmp44674049 == tmp4 && x4674049 == x && this4674049 == this && tid4674049 == tid && $pc4674049 == $pc;
 assume $recorded.state4674049 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (42.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4674049);                                                              
 assert $pc != PhaseError;                                                                                 // (42.13): Reduction failure
 tmp19 := Vector.count[this];                                                                       
                                                                                                    
 // 42.13: tmp18 = tmp19 + 1;                                                                       
                                                                                                    
 tmp18 := (tmp19+1);                                                                                
                                                                                                    
                                                                                                    
 // 42.13: this.count := tmp18;                                                                     
                                                                                                    
                                                                                                    
 moverPath4674059 := WriteEval.Vector.count(tid: Tid,this: Vector,tmp18: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 mover4674059 := m#moverPath(moverPath4674059);                                                     
 path4674059 := p#moverPath(moverPath4674059);                                                      
 assume Vector._state4674059 == Vector._state && Vector.elems4674059 == Vector.elems && Vector.count4674059 == Vector.count && Vector.spec4674059 == Vector.spec && Vector._lock4674059 == Vector._lock && Array.Vector.T._state4674059 == Array.Vector.T._state && Array.Vector.T._elems4674059 == Array.Vector.T._elems && Array.Vector.T._length4674059 == Array.Vector.T._length && tmp194674059 == tmp19 && tmp184674059 == tmp18 && tmp174674059 == tmp17 && tmp164674059 == tmp16 && tmp84674059 == tmp8 && tmp74674059 == tmp7 && tmp64674059 == tmp6 && tmp54674059 == tmp5 && tmp44674059 == tmp4 && x4674059 == x && this4674059 == this && tid4674059 == tid && $pc4674059 == $pc;
 assume $recorded.state4674059 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (42.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover4674059);                                                              
 assert $pc != PhaseError;                                                                                 // (42.13): Reduction failure
 Vector.count[this] := tmp18;                                                                       
                                                                                                    
 // 43.13: Seq<int> tmp20;                                                                          
                                                                                                    
                                                                                                    
 // 43.13: Seq<int> tmp21;                                                                          
                                                                                                    
                                                                                                    
 // 43.13: tmp21 := this.spec;                                                                      
                                                                                                    
                                                                                                    
 moverPath4674070 := ReadEval.Vector.spec(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 mover4674070 := m#moverPath(moverPath4674070);                                                     
 path4674070 := p#moverPath(moverPath4674070);                                                      
 assume Vector._state4674070 == Vector._state && Vector.elems4674070 == Vector.elems && Vector.count4674070 == Vector.count && Vector.spec4674070 == Vector.spec && Vector._lock4674070 == Vector._lock && Array.Vector.T._state4674070 == Array.Vector.T._state && Array.Vector.T._elems4674070 == Array.Vector.T._elems && Array.Vector.T._length4674070 == Array.Vector.T._length && tmp214674070 == tmp21 && tmp204674070 == tmp20 && tmp194674070 == tmp19 && tmp184674070 == tmp18 && tmp174674070 == tmp17 && tmp164674070 == tmp16 && tmp84674070 == tmp8 && tmp74674070 == tmp7 && tmp64674070 == tmp6 && tmp54674070 == tmp5 && tmp44674070 == tmp4 && x4674070 == x && this4674070 == this && tid4674070 == tid && $pc4674070 == $pc;
 assume $recorded.state4674070 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (43.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover4674070);                                                              
 assert $pc != PhaseError;                                                                                 // (43.13): Reduction failure
 tmp21 := Vector.spec[this];                                                                        
                                                                                                    
 // 43.13: Seq<int> tmp22;                                                                          
                                                                                                    
                                                                                                    
 // 43.13: tmp22 = SeqUnit<int>(x);                                                                 
                                                                                                    
 tmp22 := SeqUnit.int(x);                                                                           
                                                                                                    
 // 43.13: tmp20 = SeqConcat<int>(tmp21,tmp22);                                                     
                                                                                                    
 tmp20 := SeqConcat.int(tmp21,tmp22);                                                               
                                                                                                    
                                                                                                    
 // 43.13: this.spec := tmp20;                                                                      
                                                                                                    
                                                                                                    
 moverPath4674088 := WriteEval.Vector.spec(tid: Tid,this: Vector,tmp20: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 mover4674088 := m#moverPath(moverPath4674088);                                                     
 path4674088 := p#moverPath(moverPath4674088);                                                      
 assume Vector._state4674088 == Vector._state && Vector.elems4674088 == Vector.elems && Vector.count4674088 == Vector.count && Vector.spec4674088 == Vector.spec && Vector._lock4674088 == Vector._lock && Array.Vector.T._state4674088 == Array.Vector.T._state && Array.Vector.T._elems4674088 == Array.Vector.T._elems && Array.Vector.T._length4674088 == Array.Vector.T._length && tmp224674088 == tmp22 && tmp214674088 == tmp21 && tmp204674088 == tmp20 && tmp194674088 == tmp19 && tmp184674088 == tmp18 && tmp174674088 == tmp17 && tmp164674088 == tmp16 && tmp84674088 == tmp8 && tmp74674088 == tmp7 && tmp64674088 == tmp6 && tmp54674088 == tmp5 && tmp44674088 == tmp4 && x4674088 == x && this4674088 == this && tid4674088 == tid && $pc4674088 == $pc;
 assume $recorded.state4674088 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (43.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover4674088);                                                              
 assert $pc != PhaseError;                                                                                 // (43.13): Reduction failure
 Vector.spec[this] := tmp20;                                                                        
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (44.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Vector._lock[this] == tid;                                                                         // (44.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (44.9): Reduction failure
 Vector._lock[this] := Tid.null;                                                                    
                                                                                                    
 // 29.28: // return;                                                                               
                                                                                                    
 assume Vector._state4674093 == Vector._state && Vector.elems4674093 == Vector.elems && Vector.count4674093 == Vector.count && Vector.spec4674093 == Vector.spec && Vector._lock4674093 == Vector._lock && Array.Vector.T._state4674093 == Array.Vector.T._state && Array.Vector.T._elems4674093 == Array.Vector.T._elems && Array.Vector.T._length4674093 == Array.Vector.T._length && x4674093 == x && this4674093 == this && tid4674093 == tid;
 assume $recorded.state4674093 == 1;                                                                
 assert  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (29.28): Object invariant may not hold.
 assert  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (29.28): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  Vector.contains(tid:Tid, this : Vector, x : int)                                         
returns ($result : bool)                                                                            
modifies Vector._state;                                                                             
modifies Vector.elems;                                                                              
modifies Vector.count;                                                                              
modifies Vector.spec;                                                                               
modifies Vector._lock;                                                                              
modifies Array.Vector.T._state;                                                                     
modifies Array.Vector.T._elems;                                                                     
                                                                                                    
requires ValidTid(tid);                                                                                    // (47.5): Bad tid
requires isShared(Vector._state[this]);                                                                    // (47.5): this is not global
                                                                                                    
requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (47.5): Object invariant may not hold.
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (47.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
ensures  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (47.5): Object invariant may not hold.
ensures  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (47.5): Object invariant may not hold.
{                                                                                                   
 var tmp254674134: bool;                                                                            
 var tid4674114: Tid;                                                                               
 var this4674114: Vector;                                                                           
 var Array.Vector.T._elems4674166: [Array.Vector.T]([int]int);                                      
 var $pc4674114: Phase;                                                                             
 var x4674141: int;                                                                                 
 var Vector.spec4674114: [Vector]Seq.int;                                                           
 var Array.Vector.T._state4674166_bottom: [Array.Vector.T]State;                                    
 var Vector.elems4674134: [Vector]Array.Vector.T;                                                   
 var tmp264674152: int;                                                                             
 var Array.Vector.T._length4674172: [Array.Vector.T]int;                                            
 var this4674172: Vector;                                                                           
 var Vector.count4674172: [Vector]int;                                                              
 var tmp244674114: int;                                                                             
 var tmp244674152: int;                                                                             
 var Vector._lock4674172: [Vector]Tid;                                                              
 var $pc4674166_bottom: Phase;                                                                      
 var tmp244674141: int;                                                                             
 var $recorded.state4674152: int;                                                                   
 var Array.Vector.T._state4674172: [Array.Vector.T]State;                                           
 var tid4674180: Tid;                                                                               
 var tmp234674114: bool;                                                                            
 var Vector._state4674141: [Vector]State;                                                           
 var Vector.spec4674166_bottom: [Vector]Seq.int;                                                    
 var Vector._state4674152: [Vector]State;                                                           
 var Array.Vector.T._length4674152: [Array.Vector.T]int;                                            
 var $result4674180: bool;                                                                          
 var j4674166_bottom: int;                                                                          
 var this4674180: Vector;                                                                           
 var $result4674141: bool;                                                                          
 var x4674166: int;                                                                                 
 var j4674114: int;                                                                                 
 var Vector.elems4674152: [Vector]Array.Vector.T;                                                   
 var tmp264674141: int;                                                                             
 var Vector.spec4674141: [Vector]Seq.int;                                                           
 var path4674114: int;                                                                              
 var Vector.elems4674166: [Vector]Array.Vector.T;                                                   
 var $recorded.state4674166_bottom: int;                                                            
 var Array.Vector.T._elems4674172: [Array.Vector.T]([int]int);                                      
 var tmp23: bool;                                                                                   
 var Vector.count4674152: [Vector]int;                                                              
 var x4674134: int;                                                                                 
 var this4674166: Vector;                                                                           
 var Vector.count4674134: [Vector]int;                                                              
 var Vector._lock4674180: [Vector]Tid;                                                              
 var tid4674141: Tid;                                                                               
 var $result4674152: bool;                                                                          
 var tid4674152: Tid;                                                                               
 var Array.Vector.T._state4674152: [Array.Vector.T]State;                                           
 var mover4674114: Mover;                                                                           
 var Array.Vector.T._state4674141: [Array.Vector.T]State;                                           
 var Vector.count4674180: [Vector]int;                                                              
 var Array.Vector.T._state4674134: [Array.Vector.T]State;                                           
 var Vector._state4674114: [Vector]State;                                                           
 var x4674166_bottom: int;                                                                          
 var Vector._state4674166_bottom: [Vector]State;                                                    
 var $recorded.state4674172: int;                                                                   
 var Vector.spec4674180: [Vector]Seq.int;                                                           
 var Array.Vector.T._length4674134: [Array.Vector.T]int;                                            
 var tmp254674141: bool;                                                                            
 var j4674134: int;                                                                                 
 var Vector.count4674114: [Vector]int;                                                              
 var Array.Vector.T._length4674141: [Array.Vector.T]int;                                            
 var tmp25: bool;                                                                                   
 var $pc4674180: Phase;                                                                             
 var tmp234674134: bool;                                                                            
 var $recorded.state4674141: int;                                                                   
 var $recorded.state4674114: int;                                                                   
 var Vector.elems4674114: [Vector]Array.Vector.T;                                                   
 var $pc4674141: Phase;                                                                             
 var Vector.elems4674180: [Vector]Array.Vector.T;                                                   
 var $pc4674172: Phase;                                                                             
 var $result4674114: bool;                                                                          
 var Vector.elems4674172: [Vector]Array.Vector.T;                                                   
 var Array.Vector.T._length4674166: [Array.Vector.T]int;                                            
 var moverPath4674141: MoverPath;                                                                   
 var Array.Vector.T._elems4674180: [Array.Vector.T]([int]int);                                      
 var this4674152: Vector;                                                                           
 var tmp274674141: Array.Vector.T;                                                                  
 var Vector.count4674166: [Vector]int;                                                              
 var Vector._state4674172: [Vector]State;                                                           
 var Vector._lock4674114: [Vector]Tid;                                                              
 var this4674141: Vector;                                                                           
 var $recorded.state4674166: int;                                                                   
 var Vector._lock4674166: [Vector]Tid;                                                              
 var $result4674172: bool;                                                                          
 var tmp274674134: Array.Vector.T;                                                                  
 var tmp26: int;                                                                                    
 var tmp274674152: Array.Vector.T;                                                                  
 var Vector.spec4674152: [Vector]Seq.int;                                                           
 var moverPath4674134: MoverPath;                                                                   
 var this4674166_bottom: Vector;                                                                    
 var x4674114: int;                                                                                 
 var x4674180: int;                                                                                 
 var Array.Vector.T._length4674166_bottom: [Array.Vector.T]int;                                     
 var tmp244674134: int;                                                                             
 var tid4674172: Tid;                                                                               
 var path4674141: int;                                                                              
 var Array.Vector.T._elems4674166_bottom: [Array.Vector.T]([int]int);                               
 var Array.Vector.T._length4674180: [Array.Vector.T]int;                                            
 var Array.Vector.T._elems4674141: [Array.Vector.T]([int]int);                                      
 var tmp27: Array.Vector.T;                                                                         
 var Vector.elems4674141: [Vector]Array.Vector.T;                                                   
 var $pc4674166: Phase;                                                                             
 var x4674152: int;                                                                                 
 var phase4674166: Phase;                                                                           
 var Array.Vector.T._elems4674152: [Array.Vector.T]([int]int);                                      
 var Array.Vector.T._elems4674134: [Array.Vector.T]([int]int);                                      
 var tid4674134: Tid;                                                                               
 var Vector.count4674141: [Vector]int;                                                              
 var path4674134: int;                                                                              
 var $result4674166: bool;                                                                          
 var Vector.spec4674172: [Vector]Seq.int;                                                           
 var Array.Vector.T._elems4674114: [Array.Vector.T]([int]int);                                      
 var Vector.elems4674166_bottom: [Vector]Array.Vector.T;                                            
 var tid4674166: Tid;                                                                               
 var mover4674134: Mover;                                                                           
 var Vector._state4674166: [Vector]State;                                                           
 var $result4674134: bool;                                                                          
 var x4674172: int;                                                                                 
 var $recorded.state4674134: int;                                                                   
 var j4674141: int;                                                                                 
 var tmp24: int;                                                                                    
 var j4674152: int;                                                                                 
 var tmp234674141: bool;                                                                            
 var tmp234674152: bool;                                                                            
 var Array.Vector.T._length4674114: [Array.Vector.T]int;                                            
 var $result4674166_bottom: bool;                                                                   
 var this4674134: Vector;                                                                           
 var $recorded.state4674180: int;                                                                   
 var moverPath4674114: MoverPath;                                                                   
 var Vector.spec4674166: [Vector]Seq.int;                                                           
 var Vector._lock4674141: [Vector]Tid;                                                              
 var tid4674166_bottom: Tid;                                                                        
 var Array.Vector.T._state4674180: [Array.Vector.T]State;                                           
 var Vector._lock4674166_bottom: [Vector]Tid;                                                       
 var Vector.spec4674134: [Vector]Seq.int;                                                           
 var $pc4674152: Phase;                                                                             
 var Vector.count4674166_bottom: [Vector]int;                                                       
 var $pc4674134: Phase;                                                                             
 var Vector._lock4674134: [Vector]Tid;                                                              
 var j4674166: int;                                                                                 
 var Vector._lock4674152: [Vector]Tid;                                                              
 var j: int;                                                                                        
 var Vector._state4674180: [Vector]State;                                                           
 var Array.Vector.T._state4674166: [Array.Vector.T]State;                                           
 var Vector._state4674134: [Vector]State;                                                           
 var mover4674141: Mover;                                                                           
 var Array.Vector.T._state4674114: [Array.Vector.T]State;                                           
 var tmp254674152: bool;                                                                            
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (49.22): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume Vector._lock[this] == Tid.null;                                                             
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (49.22): Reduction failure
 Vector._lock[this] := tid;                                                                         
                                                                                                    
 // 50.18: int j;                                                                                   
                                                                                                    
                                                                                                    
 // 50.18: j = 0;                                                                                   
                                                                                                    
 j := 0;                                                                                            
 assume Vector._state4674166 == Vector._state && Vector.elems4674166 == Vector.elems && Vector.count4674166 == Vector.count && Vector.spec4674166 == Vector.spec && Vector._lock4674166 == Vector._lock && Array.Vector.T._state4674166 == Array.Vector.T._state && Array.Vector.T._elems4674166 == Array.Vector.T._elems && Array.Vector.T._length4674166 == Array.Vector.T._length && j4674166 == j && $result4674166 == $result && x4674166 == x && this4674166 == this && tid4674166 == tid;
 assume $recorded.state4674166 == 1;                                                                
                                                                                                    
 // 50.31: while (true)                                                                             
                                                                                                    
 phase4674166 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (47.5): Bad tid
  invariant isShared(Vector._state[this]);                                                                 // (47.5): this is not global
                                                                                                    
  invariant StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
  invariant  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (50.31): Object invariant may not hold.
  invariant  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (50.31): Object invariant may not hold.
  invariant (forall i: int ::  ((((0<=i)&&(i<j))==>(SeqNth.int(Vector.spec[this],i)!=x))));         
  invariant (isAccessible(Vector._state[this], tid) && Vector._lock[this] == tid);                  
  invariant (forall _this : Vector :: Invariant.Y_Vector.elems(tid : Tid, _this, Vector.elems[_this] ,Vector._state4674166,Vector.elems4674166,Vector.count4674166,Vector.spec4674166,Vector._lock4674166,Array.Vector.T._state4674166,Array.Vector.T._elems4674166,Array.Vector.T._length4674166));       // (50.31): Loop does not preserve yields_as annotation for field elems
  invariant (forall _this : Vector :: Invariant.Y_Vector.count(tid : Tid, _this, Vector.count[_this] ,Vector._state4674166,Vector.elems4674166,Vector.count4674166,Vector.spec4674166,Vector._lock4674166,Array.Vector.T._state4674166,Array.Vector.T._elems4674166,Array.Vector.T._length4674166));       // (50.31): Loop does not preserve yields_as annotation for field count
  invariant (forall _this : Vector :: Invariant.Y_Vector.spec(tid : Tid, _this, Vector.spec[_this] ,Vector._state4674166,Vector.elems4674166,Vector.count4674166,Vector.spec4674166,Vector._lock4674166,Array.Vector.T._state4674166,Array.Vector.T._elems4674166,Array.Vector.T._length4674166));       // (50.31): Loop does not preserve yields_as annotation for field spec
  invariant (forall _athis : Array.Vector.T, _index : int :: Invariant.Y_Array.Vector.T(tid : Tid, _athis, _index, Array.Vector.T._elems[_athis][_index] ,Vector._state4674166,Vector.elems4674166,Vector.count4674166,Vector.spec4674166,Vector._lock4674166,Array.Vector.T._state4674166,Array.Vector.T._elems4674166,Array.Vector.T._length4674166));       // (50.31): Loop does not preserve yields_as annotation for field ArrayDecl(T,IntType(),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(Holds(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
  invariant phase4674166 == $pc;                                                                           // (50.31): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (50.31): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 50.31: boolean tmp23;                                                                          
                                                                                                    
                                                                                                    
  // 50.33: int tmp24;                                                                              
                                                                                                    
                                                                                                    
  // 50.33: tmp24 := this.count;                                                                    
                                                                                                    
                                                                                                    
  moverPath4674114 := ReadEval.Vector.count(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
  mover4674114 := m#moverPath(moverPath4674114);                                                    
  path4674114 := p#moverPath(moverPath4674114);                                                     
  assume Vector._state4674114 == Vector._state && Vector.elems4674114 == Vector.elems && Vector.count4674114 == Vector.count && Vector.spec4674114 == Vector.spec && Vector._lock4674114 == Vector._lock && Array.Vector.T._state4674114 == Array.Vector.T._state && Array.Vector.T._elems4674114 == Array.Vector.T._elems && Array.Vector.T._length4674114 == Array.Vector.T._length && tmp244674114 == tmp24 && tmp234674114 == tmp23 && j4674114 == j && $result4674114 == $result && x4674114 == x && this4674114 == this && tid4674114 == tid && $pc4674114 == $pc;
  assume $recorded.state4674114 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Vector.null;                                                                      
  } else {                                                                                          
   assert this != Vector.null;                                                                             // (50.33): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4674114);                                                             
  assert $pc != PhaseError;                                                                                // (50.33): Reduction failure
  tmp24 := Vector.count[this];                                                                      
                                                                                                    
  // 50.31: tmp23 = j < tmp24;                                                                      
                                                                                                    
  tmp23 := (j<tmp24);                                                                               
  if (!(tmp23)) {                                                                                   
                                                                                                    
   // 50.31: break;                                                                                 
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 53.17: boolean tmp25;                                                                          
                                                                                                    
                                                                                                    
  // 53.17: [Vector.T{this}] tmp27;                                                                 
                                                                                                    
                                                                                                    
  // 53.17: tmp27 := this.elems;                                                                    
                                                                                                    
                                                                                                    
  moverPath4674134 := ReadEval.Vector.elems(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
  mover4674134 := m#moverPath(moverPath4674134);                                                    
  path4674134 := p#moverPath(moverPath4674134);                                                     
  assume Vector._state4674134 == Vector._state && Vector.elems4674134 == Vector.elems && Vector.count4674134 == Vector.count && Vector.spec4674134 == Vector.spec && Vector._lock4674134 == Vector._lock && Array.Vector.T._state4674134 == Array.Vector.T._state && Array.Vector.T._elems4674134 == Array.Vector.T._elems && Array.Vector.T._length4674134 == Array.Vector.T._length && tmp274674134 == tmp27 && tmp254674134 == tmp25 && tmp244674134 == tmp24 && tmp234674134 == tmp23 && j4674134 == j && $result4674134 == $result && x4674134 == x && this4674134 == this && tid4674134 == tid && $pc4674134 == $pc;
  assume $recorded.state4674134 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Vector.null;                                                                      
  } else {                                                                                          
   assert this != Vector.null;                                                                             // (53.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4674134);                                                             
  assert $pc != PhaseError;                                                                                // (53.17): Reduction failure
  tmp27 := Vector.elems[this];                                                                      
                                                                                                    
  // 53.17: int tmp26;                                                                              
                                                                                                    
                                                                                                    
  // 53.17: tmp26 := tmp27[j];                                                                      
                                                                                                    
                                                                                                    
  moverPath4674141 := ReadEval.Array.Vector.T(tid: Tid,this: Vector,tmp27: Array.Vector.T,j: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
  mover4674141 := m#moverPath(moverPath4674141);                                                    
  path4674141 := p#moverPath(moverPath4674141);                                                     
  assume Vector._state4674141 == Vector._state && Vector.elems4674141 == Vector.elems && Vector.count4674141 == Vector.count && Vector.spec4674141 == Vector.spec && Vector._lock4674141 == Vector._lock && Array.Vector.T._state4674141 == Array.Vector.T._state && Array.Vector.T._elems4674141 == Array.Vector.T._elems && Array.Vector.T._length4674141 == Array.Vector.T._length && tmp264674141 == tmp26 && tmp274674141 == tmp27 && tmp254674141 == tmp25 && tmp244674141 == tmp24 && tmp234674141 == tmp23 && j4674141 == j && $result4674141 == $result && x4674141 == x && this4674141 == this && tid4674141 == tid && $pc4674141 == $pc;
  assume $recorded.state4674141 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume tmp27 != Array.Vector.T.null;                                                             
  } else {                                                                                          
   assert tmp27 != Array.Vector.T.null;                                                                    // (53.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  if ($pc == PreCommit) {                                                                           
   assume 0 <= j;                                                                                   
  } else {                                                                                          
   assert 0 <= j;                                                                                          // (53.17): index < 0.
  }                                                                                                 
  if ($pc == PreCommit) {                                                                           
   assume j < Array.Vector.T._length[tmp27];                                                        
  } else {                                                                                          
   assert j < Array.Vector.T._length[tmp27];                                                               // (53.17): index is >= length.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4674141);                                                             
  assert $pc != PhaseError;                                                                                // (53.17): Reduction failure
  tmp26 := Array.Vector.T._elems[tmp27][j];                                                         
                                                                                                    
  // 53.17: tmp25 = tmp26 == x;                                                                     
                                                                                                    
  tmp25 := (tmp26==x);                                                                              
  if (tmp25 /* lowered (Array.Vector.T._elems[Vector.elems[this]][j]==x) */) {                      
   if ($pc == PreCommit) {                                                                          
    assume this != Vector.null;                                                                     
   } else {                                                                                         
    assert this != Vector.null;                                                                            // (58.9): Cannot have potential null deference in left-mover part.
   }                                                                                                
   assert Vector._lock[this] == tid;                                                                       // (58.9): lock not held
   $pc := transition($pc, _L);                                                                      
   assert $pc != PhaseError;                                                                               // (58.9): Reduction failure
   Vector._lock[this] := Tid.null;                                                                  
                                                                                                    
   // 54.21:  return true;                                                                          
                                                                                                    
   assume Vector._state4674152 == Vector._state && Vector.elems4674152 == Vector.elems && Vector.count4674152 == Vector.count && Vector.spec4674152 == Vector.spec && Vector._lock4674152 == Vector._lock && Array.Vector.T._state4674152 == Array.Vector.T._state && Array.Vector.T._elems4674152 == Array.Vector.T._elems && Array.Vector.T._length4674152 == Array.Vector.T._length && tmp264674152 == tmp26 && tmp274674152 == tmp27 && tmp254674152 == tmp25 && tmp244674152 == tmp24 && tmp234674152 == tmp23 && j4674152 == j && $result4674152 == $result && x4674152 == x && this4674152 == this && tid4674152 == tid;
   assume $recorded.state4674152 == 1;                                                              
   $result := true;                                                                                 
   assert  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (54.21): Object invariant may not hold.
   assert  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (54.21): Object invariant may not hold.
   return;                                                                                          
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 50.45: j = j + 1;                                                                              
                                                                                                    
  j := (j+1);                                                                                       
  assume Vector._state4674166_bottom == Vector._state && Vector.elems4674166_bottom == Vector.elems && Vector.count4674166_bottom == Vector.count && Vector.spec4674166_bottom == Vector.spec && Vector._lock4674166_bottom == Vector._lock && Array.Vector.T._state4674166_bottom == Array.Vector.T._state && Array.Vector.T._elems4674166_bottom == Array.Vector.T._elems && Array.Vector.T._length4674166_bottom == Array.Vector.T._length && j4674166_bottom == j && $result4674166_bottom == $result && x4674166_bottom == x && this4674166_bottom == this && tid4674166_bottom == tid;
  assume $recorded.state4674166_bottom == 1;                                                        
  assert phase4674166 == $pc;                                                                              // (50.31): Phase must be invariant at loop head
 }                                                                                                  
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (58.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Vector._lock[this] == tid;                                                                         // (58.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (58.9): Reduction failure
 Vector._lock[this] := Tid.null;                                                                    
                                                                                                    
 // 57.13:  return false;                                                                           
                                                                                                    
 assume Vector._state4674172 == Vector._state && Vector.elems4674172 == Vector.elems && Vector.count4674172 == Vector.count && Vector.spec4674172 == Vector.spec && Vector._lock4674172 == Vector._lock && Array.Vector.T._state4674172 == Array.Vector.T._state && Array.Vector.T._elems4674172 == Array.Vector.T._elems && Array.Vector.T._length4674172 == Array.Vector.T._length && $result4674172 == $result && x4674172 == x && this4674172 == this && tid4674172 == tid;
 assume $recorded.state4674172 == 1;                                                                
 $result := false;                                                                                  
 assert  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (57.13): Object invariant may not hold.
 assert  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (57.13): Object invariant may not hold.
 return;                                                                                            
 if ($pc == PreCommit) {                                                                            
  assume this != Vector.null;                                                                       
 } else {                                                                                           
  assert this != Vector.null;                                                                              // (58.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Vector._lock[this] == tid;                                                                         // (58.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (58.9): Reduction failure
 Vector._lock[this] := Tid.null;                                                                    
                                                                                                    
 // 48.36: // return false;                                                                         
                                                                                                    
 assume Vector._state4674180 == Vector._state && Vector.elems4674180 == Vector.elems && Vector.count4674180 == Vector.count && Vector.spec4674180 == Vector.spec && Vector._lock4674180 == Vector._lock && Array.Vector.T._state4674180 == Array.Vector.T._state && Array.Vector.T._elems4674180 == Array.Vector.T._elems && Array.Vector.T._length4674180 == Array.Vector.T._length && $result4674180 == $result && x4674180 == x && this4674180 == this && tid4674180 == tid;
 assume $recorded.state4674180 == 1;                                                                
 $result := false;                                                                                  
 assert  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (48.36): Object invariant may not hold.
 assert  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (48.36): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
/*** Array Array.Vector.T ***/                                                                      
                                                                                                    
type Array.Vector.T;                                                                                
const unique Array.Vector.T.null: Array.Vector.T;                                                   
var Array.Vector.T._state: [Array.Vector.T]State;                                                   
                                                                                                    
const Array.Vector.T._this : [Array.Vector.T]Vector;                                                
const Array.Vector.T._length : [Array.Vector.T]int;                                                 
var Array.Vector.T._elems  : [Array.Vector.T]([int]int);                                            
                                                                                                    
axiom (forall $this : Array.Vector.T :: Array.Vector.T._length[$this] >= 0);                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
// Array.Vector.T: Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(Holds(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List())
                                                                                                    
function {:inline} ReadEval.Array.Vector.T(tid: Tid,this : Vector,athis : Array.Vector.T,index : int,Vector._state: [Vector]State,Vector.elems: [Vector]Array.Vector.T,Vector.count: [Vector]int,Vector.spec: [Vector]Seq.int,Vector._lock: [Vector]Tid,Array.Vector.T._state: [Array.Vector.T]State,Array.Vector.T._elems: [Array.Vector.T]([int]int),Array.Vector.T._length: [Array.Vector.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 if (isLocal(Vector._state[this], tid)) then                                                        
  if (isLocal(Vector._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Vector._state[this], tid) && Vector._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
// Array.Vector.T: Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(Holds(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List())
                                                                                                    
function {:inline} WriteEval.Array.Vector.T(tid: Tid,this : Vector,athis : Array.Vector.T,index : int,newValue: int,Vector._state: [Vector]State,Vector.elems: [Vector]Array.Vector.T,Vector.count: [Vector]int,Vector.spec: [Vector]Seq.int,Vector._lock: [Vector]Tid,Array.Vector.T._state: [Array.Vector.T]State,Array.Vector.T._elems: [Array.Vector.T]([int]int),Array.Vector.T._length: [Array.Vector.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Vector._state[this], tid)) then                                                        
  if (isLocal(Vector._state[this], tid)) then                                                       
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Vector._state[this], tid) && Vector._lock[this] == tid)) then                   
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Vector._state: [Vector]State,Vector.elems: [Vector]Array.Vector.T,Vector.count: [Vector]int,Vector.spec: [Vector]Seq.int,Vector._lock: [Vector]Tid,Array.Vector.T._state: [Array.Vector.T]State,Array.Vector.T._elems: [Array.Vector.T]([int]int),Array.Vector.T._length: [Array.Vector.T]int) returns (bool) {
  true &&                                                                                           
  (forall _i: Vector  :: _i == Vector.null <==> isNull(Vector._state[_i])) &&                       
  (forall _i: Array.Vector.T  :: _i == Array.Vector.T.null <==> isNull(Array.Vector.T._state[_i])) &&
  (forall _t: Tid, _i: Array.Vector.T  :: ValidTid(_t) && isAccessible(Array.Vector.T._state[_i], _t) ==> isAccessible(Vector._state[Array.Vector.T._this[_i]], _t)) &&
  (forall _i: Vector ::  (isShared(Vector._state[_i]) ==> isSharedAssignable(Array.Vector.T._state[Vector.elems[_i]]))) &&
  (forall _i: Vector ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Vector._state[_i],_t) ==> isLocalAssignable(Array.Vector.T._state[Vector.elems[_i]], _t)))) &&
  (forall _i: Vector :: { Vector.elems[_i] } Array.Vector.T._this[Vector.elems[_i]] == _i) &&       
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Vector.elems(t: Tid, u: Tid, v: Array.Vector.T, w: Array.Vector.T, x: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Vector.elems[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Vector.elems(u: Tid,x: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (9.5): Vector.elems failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Vector.elems(t: Tid, u: Tid, v: Array.Vector.T, w: Array.Vector.T, x: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Vector.elems[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Vector.elems(u: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (9.5): Vector.elems failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Vector.elems(t: Tid, u: Tid, v: Array.Vector.T, w: Array.Vector.T, x: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Array.Vector.T;                                                                   
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Vector.elems[x];                                                                       
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Vector.elems[x] := havocValue;                                                                     
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Vector.elems(u: Tid,x: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (9.5): Vector.elems failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Vector.elems(t: Tid, u: Tid, v: Array.Vector.T, w: Array.Vector.T, x: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Array.Vector.T;                                                                   
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Vector.elems[x];                                                                       
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Vector.elems(u: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (9.5): Vector.elems failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Vector.elems(t: Tid, u: Tid, v: Array.Vector.T, w: Array.Vector.T, x: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Vector.elems(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Vector.elems(u: Tid,x: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (9.5): Vector.elems failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Vector.elems(t: Tid, u: Tid, v: Array.Vector.T, w: Array.Vector.T, x: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Array.Vector.T;                                                                   
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Vector.elems[x];                                                                       
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Vector.elems(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Vector.elems[x] := havocValue;                                                                     
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Vector.elems(u: Tid,x: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (9.5): Vector.elems failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Vector.count(t: Tid, u: Tid, v: int, w: int, x: Vector)      
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Vector.count[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Vector.count(u: Tid,x: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (10.5): Vector.count failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Vector.count(t: Tid, u: Tid, v: int, w: int, x: Vector)       
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Vector.count[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Vector.count(u: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (10.5): Vector.count failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Vector.count(t: Tid, u: Tid, v: int, w: int, x: Vector)       
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Vector.count[x];                                                                       
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Vector.count[x] := havocValue;                                                                     
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Vector.count(u: Tid,x: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (10.5): Vector.count failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Vector.count(t: Tid, u: Tid, v: int, w: int, x: Vector)        
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Vector.count[x];                                                                       
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Vector.count(u: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (10.5): Vector.count failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Vector.count(t: Tid, u: Tid, v: int, w: int, x: Vector)            
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Vector.count(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Vector.count(u: Tid,x: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (10.5): Vector.count failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Vector.count(t: Tid, u: Tid, v: int, w: int, x: Vector)             
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Vector.count[x];                                                                       
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Vector.count(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Vector.count[x] := havocValue;                                                                     
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Vector.count(u: Tid,x: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (10.5): Vector.count failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Vector.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: Seq.int;                                                                               
 var w_post: Seq.int;                                                                               
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Vector.spec[x] := v;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Vector.spec(u: Tid,x: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (13.5): Vector.spec failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Vector.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: Seq.int;                                                                               
 var w_post: Seq.int;                                                                               
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Vector.spec[x] := v;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Vector.spec(u: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (13.5): Vector.spec failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Vector.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Seq.int;                                                                          
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: Seq.int;                                                                               
 var w_post: Seq.int;                                                                               
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Vector.spec[x];                                                                        
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Vector.spec[x] := havocValue;                                                                      
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Vector.spec(u: Tid,x: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (13.5): Vector.spec failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Vector.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Vector) 
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Seq.int;                                                                          
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: Seq.int;                                                                               
 var w_post: Seq.int;                                                                               
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Vector.spec[x];                                                                        
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Vector.spec(u: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (13.5): Vector.spec failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Vector.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Vector)     
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: Seq.int;                                                                               
 var w_post: Seq.int;                                                                               
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Vector.spec(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Vector.spec(u: Tid,x: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (13.5): Vector.spec failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Vector.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Vector)      
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[x], u);                                                        
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Seq.int;                                                                          
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: Seq.int;                                                                               
 var w_post: Seq.int;                                                                               
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Vector.spec[x];                                                                        
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Vector.spec(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Vector.spec[x] := havocValue;                                                                      
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Vector.spec(u: Tid,x: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (13.5): Vector.spec failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Vector, x: Array.Vector.T, i: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Vector.T._state[x], u);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Array.Vector.T(u: Tid,x_owner: Vector,x: Array.Vector.T,i: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.5): Array Array.Vector.T failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Vector, x: Array.Vector.T, i: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Vector.T._state[x], u);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Array.Vector.T(u: Tid,x_owner: Vector,x: Array.Vector.T,i: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (7.5): Array Array.Vector.T failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Vector, x: Array.Vector.T, i: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Vector.T._state[x], u);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Array.Vector.T._elems[x][i];                                                           
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Array.Vector.T._elems[x][i] := havocValue;                                                         
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Array.Vector.T(u: Tid,x_owner: Vector,x: Array.Vector.T,i: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.5): Array Array.Vector.T failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Vector, x: Array.Vector.T, i: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Vector.T._state[x], u);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Array.Vector.T._elems[x][i];                                                           
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Array.Vector.T(u: Tid,x_owner: Vector,x: Array.Vector.T,i: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (7.5): Array Array.Vector.T failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Vector, x: Array.Vector.T, i: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Vector.T._state[x], u);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Array.Vector.T(u: Tid,x_owner: Vector,x: Array.Vector.T,i: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.5): Array Array.Vector.T failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Vector, x: Array.Vector.T, i: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Vector.T._state[x], u);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Array.Vector.T._elems[x][i];                                                           
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Array.Vector.T._elems[x][i] := havocValue;                                                         
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && x_owner_post == x_owner && x_post == x && i_post == i;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Array.Vector.T(u: Tid,x_owner: Vector,x: Array.Vector.T,i: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.5): Array Array.Vector.T failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Vector.elems.Vector.elems(t: Tid, u: Tid, v: Array.Vector.T, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.elems[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.elems (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Vector.elems.Vector.elems(t: Tid, u: Tid, v: Array.Vector.T, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Vector.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var v_mid: Array.Vector.T;                                                                         
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Array.Vector.T;                                                                         
 var y_mid: Vector;                                                                                 
 var w0_mid: Array.Vector.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Vector.elems[x];                                                                           
 Vector.elems[x] := v;                                                                              
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Vector.elems[x] := tmpV;                                                                           
 Vector.elems[y] := w;                                                                              
 _writeByTPost := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Vector.elems.Vector.elems(t: Tid, u: Tid, v: Array.Vector.T, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Vector.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var v_mid: Array.Vector.T;                                                                         
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Array.Vector.T;                                                                         
 var y_mid: Vector;                                                                                 
 var w0_mid: Array.Vector.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Vector.elems[x];                                                                           
 Vector.elems[x] := v;                                                                              
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Vector.elems[x] := tmpV;                                                                           
 Vector.elems[y] := w;                                                                              
 _writeByTPost := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Vector.elems.Vector.elems(t: Tid, u: Tid, v: Array.Vector.T, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Vector.elems(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.elems[y] := w;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Vector.elems(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Vector.elems is not Read-Write Stable with respect to Vector.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Vector.elems is not Read-Write Stable with respect to Vector.elems (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Vector.elems is not Read-Write Stable with respect to Vector.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Vector.elems.Vector.elems(t: Tid, u: Tid, v: Array.Vector.T, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Vector.elems(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.elems[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Vector.elems(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Vector.elems is not Write-Read Stable with respect to Vector.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Vector.elems is not Write-Read Stable with respect to Vector.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Vector.elems is not Write-Read Stable with respect to Vector.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Vector.elems.Vector.count(t: Tid, u: Tid, v: Array.Vector.T, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.elems[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.elems (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Vector.elems.Vector.count(t: Tid, u: Tid, v: Array.Vector.T, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Vector.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var v_mid: Array.Vector.T;                                                                         
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var y_mid: Vector;                                                                                 
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Vector.elems[x];                                                                           
 Vector.elems[x] := v;                                                                              
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Vector.elems[x] := tmpV;                                                                           
 Vector.count[y] := w;                                                                              
 _writeByTPost := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.count (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Vector.elems.Vector.count(t: Tid, u: Tid, v: Array.Vector.T, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Vector.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var v_mid: Array.Vector.T;                                                                         
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var y_mid: Vector;                                                                                 
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Vector.elems[x];                                                                           
 Vector.elems[x] := v;                                                                              
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Vector.elems[x] := tmpV;                                                                           
 Vector.count[y] := w;                                                                              
 _writeByTPost := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.count (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.count (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Vector.elems.Vector.count(t: Tid, u: Tid, v: Array.Vector.T, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Vector.elems(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.count[y] := w;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Vector.elems(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Vector.elems is not Read-Write Stable with respect to Vector.count (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Vector.elems is not Read-Write Stable with respect to Vector.count (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Vector.elems is not Read-Write Stable with respect to Vector.count (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Vector.elems.Vector.count(t: Tid, u: Tid, v: Array.Vector.T, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Vector.count(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.elems[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Vector.count(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Vector.count is not Write-Read Stable with respect to Vector.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Vector.count is not Write-Read Stable with respect to Vector.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Vector.count is not Write-Read Stable with respect to Vector.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Vector.elems.Vector.spec(t: Tid, u: Tid, v: Array.Vector.T, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.elems[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.elems (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Vector.elems.Vector.spec(t: Tid, u: Tid, v: Array.Vector.T, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Vector.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w0_mid: Seq.int;                                                                               
 var v_mid: Array.Vector.T;                                                                         
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Seq.int;                                                                                
 var y_mid: Vector;                                                                                 
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Vector.elems[x];                                                                           
 Vector.elems[x] := v;                                                                              
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Vector.elems[x] := tmpV;                                                                           
 Vector.spec[y] := w;                                                                               
 _writeByTPost := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Vector.elems.Vector.spec(t: Tid, u: Tid, v: Array.Vector.T, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Vector.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w0_mid: Seq.int;                                                                               
 var v_mid: Array.Vector.T;                                                                         
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Seq.int;                                                                                
 var y_mid: Vector;                                                                                 
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Vector.elems[x];                                                                           
 Vector.elems[x] := v;                                                                              
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Vector.elems[x] := tmpV;                                                                           
 Vector.spec[y] := w;                                                                               
 _writeByTPost := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Vector.elems.Vector.spec(t: Tid, u: Tid, v: Array.Vector.T, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Vector.elems(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.spec[y] := w;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Vector.elems(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Vector.elems is not Read-Write Stable with respect to Vector.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Vector.elems is not Read-Write Stable with respect to Vector.spec (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Vector.elems is not Read-Write Stable with respect to Vector.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Vector.elems.Vector.spec(t: Tid, u: Tid, v: Array.Vector.T, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.elems;                                                                             
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Vector.spec(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.elems[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Vector.spec(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): Vector.spec is not Write-Read Stable with respect to Vector.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): Vector.spec is not Write-Read Stable with respect to Vector.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (13.5): Vector.spec is not Write-Read Stable with respect to Vector.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Vector.elems.Array.Vector.T._elems(t: Tid, u: Tid, v: Array.Vector.T, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.elems;                                                                             
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Vector.elems[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.elems (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Vector.elems.Array.Vector.T._elems(t: Tid, u: Tid, v: Array.Vector.T, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.elems;                                                                             
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Vector.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var y_owner_mid: Vector;                                                                           
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var v_mid: Array.Vector.T;                                                                         
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var y_mid: Array.Vector.T;                                                                         
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Vector.elems[x];                                                                           
 Vector.elems[x] := v;                                                                              
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Vector.elems[x] := tmpV;                                                                           
 Array.Vector.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Array Array.Vector.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Vector.elems.Array.Vector.T._elems(t: Tid, u: Tid, v: Array.Vector.T, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.elems;                                                                             
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Vector.T;                                                                         
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var y_owner_mid: Vector;                                                                           
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var v_mid: Array.Vector.T;                                                                         
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var y_mid: Array.Vector.T;                                                                         
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Vector.elems[x];                                                                           
 Vector.elems[x] := v;                                                                              
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Vector.elems[x] := tmpV;                                                                           
 Array.Vector.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Array Array.Vector.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Array Array.Vector.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Vector.elems.Array.Vector.T._elems(t: Tid, u: Tid, v: Array.Vector.T, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.elems;                                                                             
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Vector.elems(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Vector.T._elems[y][j] := w;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Vector.elems(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Vector.elems is not Read-Write Stable with respect to Array Array.Vector.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Vector.elems is not Read-Write Stable with respect to Array Array.Vector.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Vector.elems is not Read-Write Stable with respect to Array Array.Vector.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Vector.elems.Array.Vector.T._elems(t: Tid, u: Tid, v: Array.Vector.T, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.elems;                                                                             
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var v_pre: Array.Vector.T;                                                                         
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var v_post: Array.Vector.T;                                                                        
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Vector.elems(t: Tid,x: Vector,v: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Vector.elems[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Vector.count.Vector.elems(t: Tid, u: Tid, v: int, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.count[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.count (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.count (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.count (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Vector.count.Vector.elems(t: Tid, u: Tid, v: int, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Array.Vector.T;                                                                         
 var v_mid: int;                                                                                    
 var y_mid: Vector;                                                                                 
 var w0_mid: Array.Vector.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Vector.count[x];                                                                           
 Vector.count[x] := v;                                                                              
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Vector.count[x] := tmpV;                                                                           
 Vector.elems[y] := w;                                                                              
 _writeByTPost := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Vector.count.Vector.elems(t: Tid, u: Tid, v: int, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Array.Vector.T;                                                                         
 var v_mid: int;                                                                                    
 var y_mid: Vector;                                                                                 
 var w0_mid: Array.Vector.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Vector.count[x];                                                                           
 Vector.count[x] := v;                                                                              
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Vector.count[x] := tmpV;                                                                           
 Vector.elems[y] := w;                                                                              
 _writeByTPost := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Vector.count.Vector.elems(t: Tid, u: Tid, v: int, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Vector.count(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.elems[y] := w;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Vector.count(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Vector.count is not Read-Write Stable with respect to Vector.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Vector.count is not Read-Write Stable with respect to Vector.elems (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Vector.count is not Read-Write Stable with respect to Vector.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Vector.count.Vector.elems(t: Tid, u: Tid, v: int, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Vector.elems(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.count[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Vector.elems(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Vector.elems is not Write-Read Stable with respect to Vector.count (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Vector.elems is not Write-Read Stable with respect to Vector.count (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Vector.elems is not Write-Read Stable with respect to Vector.count (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Vector.count.Vector.count(t: Tid, u: Tid, v: int, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.count[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.count (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.count (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.count (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Vector.count.Vector.count(t: Tid, u: Tid, v: int, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var v_mid: int;                                                                                    
 var y_mid: Vector;                                                                                 
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Vector.count[x];                                                                           
 Vector.count[x] := v;                                                                              
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Vector.count[x] := tmpV;                                                                           
 Vector.count[y] := w;                                                                              
 _writeByTPost := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.count (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Vector.count.Vector.count(t: Tid, u: Tid, v: int, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var v_mid: int;                                                                                    
 var y_mid: Vector;                                                                                 
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Vector.count[x];                                                                           
 Vector.count[x] := v;                                                                              
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Vector.count[x] := tmpV;                                                                           
 Vector.count[y] := w;                                                                              
 _writeByTPost := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.count (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.count (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Vector.count.Vector.count(t: Tid, u: Tid, v: int, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Vector.count(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.count[y] := w;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Vector.count(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Vector.count is not Read-Write Stable with respect to Vector.count (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Vector.count is not Read-Write Stable with respect to Vector.count (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Vector.count is not Read-Write Stable with respect to Vector.count (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Vector.count.Vector.count(t: Tid, u: Tid, v: int, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Vector.count(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.count[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Vector.count(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Vector.count is not Write-Read Stable with respect to Vector.count (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Vector.count is not Write-Read Stable with respect to Vector.count (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Vector.count is not Write-Read Stable with respect to Vector.count (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Vector.count.Vector.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.count[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.count (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.count (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.count (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Vector.count.Vector.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w0_mid: Seq.int;                                                                               
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Seq.int;                                                                                
 var v_mid: int;                                                                                    
 var y_mid: Vector;                                                                                 
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Vector.count[x];                                                                           
 Vector.count[x] := v;                                                                              
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Vector.count[x] := tmpV;                                                                           
 Vector.spec[y] := w;                                                                               
 _writeByTPost := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Vector.count.Vector.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w0_mid: Seq.int;                                                                               
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Seq.int;                                                                                
 var v_mid: int;                                                                                    
 var y_mid: Vector;                                                                                 
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Vector.count[x];                                                                           
 Vector.count[x] := v;                                                                              
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Vector.count[x] := tmpV;                                                                           
 Vector.spec[y] := w;                                                                               
 _writeByTPost := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Vector.count.Vector.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Vector.count(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.spec[y] := w;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Vector.count(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Vector.count is not Read-Write Stable with respect to Vector.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Vector.count is not Read-Write Stable with respect to Vector.spec (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Vector.count is not Read-Write Stable with respect to Vector.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Vector.count.Vector.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.count;                                                                             
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Vector.spec(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.count[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Vector.spec(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): Vector.spec is not Write-Read Stable with respect to Vector.count (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): Vector.spec is not Write-Read Stable with respect to Vector.count (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (13.5): Vector.spec is not Write-Read Stable with respect to Vector.count (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Vector.count.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.count;                                                                             
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Vector.count[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.count (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.count (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.count (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Vector.count.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.count;                                                                             
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var y_owner_mid: Vector;                                                                           
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var v_mid: int;                                                                                    
 var y_mid: Array.Vector.T;                                                                         
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Vector.count[x];                                                                           
 Vector.count[x] := v;                                                                              
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Vector.count[x] := tmpV;                                                                           
 Array.Vector.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Array Array.Vector.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Vector.count.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.count;                                                                             
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var y_owner_mid: Vector;                                                                           
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var v_mid: int;                                                                                    
 var y_mid: Array.Vector.T;                                                                         
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Vector.count[x];                                                                           
 Vector.count[x] := v;                                                                              
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Vector.count[x] := tmpV;                                                                           
 Array.Vector.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Array Array.Vector.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Array Array.Vector.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Vector.count.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.count;                                                                             
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Vector.count(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Vector.T._elems[y][j] := w;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Vector.count(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Vector.count is not Read-Write Stable with respect to Array Array.Vector.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Vector.count is not Read-Write Stable with respect to Array Array.Vector.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Vector.count is not Read-Write Stable with respect to Array Array.Vector.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Vector.count.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.count;                                                                             
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Vector.count(t: Tid,x: Vector,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Vector.count[x] := v;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.count (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.count (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.count (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Vector.spec.Vector.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var v_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.spec[x] := v;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.spec (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Vector.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Vector.spec.Vector.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var v_mid: Seq.int;                                                                                
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Array.Vector.T;                                                                         
 var y_mid: Vector;                                                                                 
 var w0_mid: Array.Vector.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var v_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Vector.spec[x];                                                                            
 Vector.spec[x] := v;                                                                               
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Vector.spec[x] := tmpV;                                                                            
 Vector.elems[y] := w;                                                                              
 _writeByTPost := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Vector.spec.Vector.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var v_mid: Seq.int;                                                                                
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Array.Vector.T;                                                                         
 var y_mid: Vector;                                                                                 
 var w0_mid: Array.Vector.T;                                                                        
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var v_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Vector.spec[x];                                                                            
 Vector.spec[x] := v;                                                                               
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Vector.spec[x] := tmpV;                                                                            
 Vector.elems[y] := w;                                                                              
 _writeByTPost := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Vector.spec.Vector.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var v_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Vector.spec(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.elems[y] := w;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Vector.spec(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): Vector.spec is not Read-Write Stable with respect to Vector.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): Vector.spec is not Read-Write Stable with respect to Vector.elems (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): Vector.spec is not Read-Write Stable with respect to Vector.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Vector.spec.Vector.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Vector.T, w0: Array.Vector.T, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var v_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Vector.elems(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.spec[x] := v;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Vector.elems(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Vector.elems is not Write-Read Stable with respect to Vector.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Vector.elems is not Write-Read Stable with respect to Vector.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Vector.elems is not Write-Read Stable with respect to Vector.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Vector.spec.Vector.count(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.spec[x] := v;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.spec (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Vector.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Vector.spec.Vector.count(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var v_mid: Seq.int;                                                                                
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var y_mid: Vector;                                                                                 
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Vector.spec[x];                                                                            
 Vector.spec[x] := v;                                                                               
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Vector.spec[x] := tmpV;                                                                            
 Vector.count[y] := w;                                                                              
 _writeByTPost := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.count (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Vector.spec.Vector.count(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var v_mid: Seq.int;                                                                                
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var y_mid: Vector;                                                                                 
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Vector.spec[x];                                                                            
 Vector.spec[x] := v;                                                                               
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Vector.spec[x] := tmpV;                                                                            
 Vector.count[y] := w;                                                                              
 _writeByTPost := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.count (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.count (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Vector.spec.Vector.count(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Vector.spec(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.count[y] := w;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Vector.spec(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): Vector.spec is not Read-Write Stable with respect to Vector.count (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): Vector.spec is not Read-Write Stable with respect to Vector.count (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): Vector.spec is not Read-Write Stable with respect to Vector.count (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Vector.spec.Vector.count(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Vector.count(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.spec[x] := v;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Vector.count(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Vector.count is not Write-Read Stable with respect to Vector.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Vector.count is not Write-Read Stable with respect to Vector.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Vector.count is not Write-Read Stable with respect to Vector.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Vector.spec.Vector.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: Seq.int;                                                                               
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.spec[x] := v;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.spec (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Vector.spec.Vector.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w0_mid: Seq.int;                                                                               
 var v_mid: Seq.int;                                                                                
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Seq.int;                                                                                
 var y_mid: Vector;                                                                                 
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: Seq.int;                                                                               
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Vector.spec[x];                                                                            
 Vector.spec[x] := v;                                                                               
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Vector.spec[x] := tmpV;                                                                            
 Vector.spec[y] := w;                                                                               
 _writeByTPost := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Vector.spec.Vector.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w0_mid: Seq.int;                                                                               
 var v_mid: Seq.int;                                                                                
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Seq.int;                                                                                
 var y_mid: Vector;                                                                                 
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: Seq.int;                                                                               
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Vector.spec[x];                                                                            
 Vector.spec[x] := v;                                                                               
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Vector.spec[x] := tmpV;                                                                            
 Vector.spec[y] := w;                                                                               
 _writeByTPost := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Vector.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Vector.spec.Vector.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: Seq.int;                                                                               
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Vector.spec(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.spec[y] := w;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Vector.spec(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): Vector.spec is not Read-Write Stable with respect to Vector.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): Vector.spec is not Read-Write Stable with respect to Vector.spec (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): Vector.spec is not Read-Write Stable with respect to Vector.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Vector.spec.Vector.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Vector, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Vector.spec;                                                                              
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: Seq.int;                                                                               
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Vector.spec(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.spec[x] := v;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Vector.spec(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): Vector.spec is not Write-Read Stable with respect to Vector.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): Vector.spec is not Write-Read Stable with respect to Vector.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (13.5): Vector.spec is not Write-Read Stable with respect to Vector.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Vector.spec.Array.Vector.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.spec;                                                                              
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: Seq.int;                                                                               
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Vector.spec[x] := v;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.spec (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Vector.spec.Array.Vector.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.spec;                                                                              
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var y_owner_mid: Vector;                                                                           
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var v_mid: Seq.int;                                                                                
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var y_mid: Array.Vector.T;                                                                         
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: Seq.int;                                                                               
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Vector.spec[x];                                                                            
 Vector.spec[x] := v;                                                                               
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Vector.spec[x] := tmpV;                                                                            
 Array.Vector.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Array Array.Vector.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Vector.spec.Array.Vector.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.spec;                                                                              
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var y_owner_mid: Vector;                                                                           
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var x_mid: Vector;                                                                                 
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var v_mid: Seq.int;                                                                                
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var y_mid: Array.Vector.T;                                                                         
 var j_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: Seq.int;                                                                               
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Vector.spec[x];                                                                            
 Vector.spec[x] := v;                                                                               
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Vector.spec[x] := tmpV;                                                                            
 Array.Vector.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Array Array.Vector.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Array Array.Vector.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Vector.spec.Array.Vector.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.spec;                                                                              
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: Seq.int;                                                                               
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Vector.spec(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Vector.T._elems[y][j] := w;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Vector.spec(t: Tid,x: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): Vector.spec is not Read-Write Stable with respect to Array Array.Vector.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): Vector.spec is not Read-Write Stable with respect to Array Array.Vector.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): Vector.spec is not Read-Write Stable with respect to Array Array.Vector.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Vector.spec.Array.Vector.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Vector, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Vector._state[x], t);                                                        
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Vector.spec;                                                                              
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var x_pre: Vector;                                                                                 
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Vector;                                                                                
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: Seq.int;                                                                               
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Vector.spec(t: Tid,x: Vector,v: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Vector.spec[x] := v;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Vector.T._elems.Vector.elems(t: Tid, u: Tid, v: int, w: Array.Vector.T, w0: Array.Vector.T, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Array Array.Vector.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Vector.elems is not Write-Write Stable with respect to Array Array.Vector.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Vector.elems is not Write-Write Stable with respect to Array Array.Vector.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Vector.T._elems.Vector.elems(t: Tid, u: Tid, v: int, w: Array.Vector.T, w0: Array.Vector.T, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Array.Vector.T;                                                                         
 var v_mid: int;                                                                                    
 var x_mid: Array.Vector.T;                                                                         
 var y_mid: Vector;                                                                                 
 var w0_mid: Array.Vector.T;                                                                        
 var x_owner_mid: Vector;                                                                           
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Vector.T._elems[x][i];                                                               
 Array.Vector.T._elems[x][i] := v;                                                                  
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Vector.T._elems[x][i] := tmpV;                                                               
 Vector.elems[y] := w;                                                                              
 _writeByTPost := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Vector.T._elems.Vector.elems(t: Tid, u: Tid, v: int, w: Array.Vector.T, w0: Array.Vector.T, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Array.Vector.T;                                                                         
 var v_mid: int;                                                                                    
 var x_mid: Array.Vector.T;                                                                         
 var y_mid: Vector;                                                                                 
 var w0_mid: Array.Vector.T;                                                                        
 var x_owner_mid: Vector;                                                                           
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Vector.T._elems[x][i];                                                               
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Vector.T._elems[x][i] := tmpV;                                                               
 Vector.elems[y] := w;                                                                              
 _writeByTPost := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Vector.T._elems.Vector.elems(t: Tid, u: Tid, v: int, w: Array.Vector.T, w0: Array.Vector.T, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Vector.elems(u: Tid,y: Vector,w: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.elems[y] := w;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.elems (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Vector.T._elems.Vector.elems(t: Tid, u: Tid, v: int, w: Array.Vector.T, w0: Array.Vector.T, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.elems;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var w_pre: Array.Vector.T;                                                                         
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var w0_pre: Array.Vector.T;                                                                        
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w0_post: Array.Vector.T;                                                                       
 var w_post: Array.Vector.T;                                                                        
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Vector.elems(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Vector.elems(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Vector.elems is not Write-Read Stable with respect to Array Array.Vector.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Vector.elems is not Write-Read Stable with respect to Array Array.Vector.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Vector.elems is not Write-Read Stable with respect to Array Array.Vector.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Vector.T._elems.Vector.count(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Array Array.Vector.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Vector.count is not Write-Write Stable with respect to Array Array.Vector.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Vector.count is not Write-Write Stable with respect to Array Array.Vector.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Vector.T._elems.Vector.count(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var v_mid: int;                                                                                    
 var x_mid: Array.Vector.T;                                                                         
 var y_mid: Vector;                                                                                 
 var x_owner_mid: Vector;                                                                           
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Vector.T._elems[x][i];                                                               
 Array.Vector.T._elems[x][i] := v;                                                                  
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Vector.T._elems[x][i] := tmpV;                                                               
 Vector.count[y] := w;                                                                              
 _writeByTPost := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.count (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Vector.T._elems.Vector.count(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var v_mid: int;                                                                                    
 var x_mid: Array.Vector.T;                                                                         
 var y_mid: Vector;                                                                                 
 var x_owner_mid: Vector;                                                                           
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Vector.T._elems[x][i];                                                               
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Vector.T._elems[x][i] := tmpV;                                                               
 Vector.count[y] := w;                                                                              
 _writeByTPost := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.count (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.count (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Vector.T._elems.Vector.count(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Vector.count(u: Tid,y: Vector,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.count[y] := w;                                                                              
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.count (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.count (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.count (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Vector.T._elems.Vector.count(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.count;                                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Vector.count(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Vector.count(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Vector.count is not Write-Read Stable with respect to Array Array.Vector.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Vector.count is not Write-Read Stable with respect to Array Array.Vector.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Vector.count is not Write-Read Stable with respect to Array Array.Vector.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Vector.T._elems.Vector.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Array Array.Vector.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (13.5): Vector.spec is not Write-Write Stable with respect to Array Array.Vector.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (13.5): Vector.spec is not Write-Write Stable with respect to Array Array.Vector.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Vector.T._elems.Vector.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w0_mid: Seq.int;                                                                               
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Seq.int;                                                                                
 var v_mid: int;                                                                                    
 var x_mid: Array.Vector.T;                                                                         
 var y_mid: Vector;                                                                                 
 var x_owner_mid: Vector;                                                                           
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Vector.T._elems[x][i];                                                               
 Array.Vector.T._elems[x][i] := v;                                                                  
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Vector.T._elems[x][i] := tmpV;                                                               
 Vector.spec[y] := w;                                                                               
 _writeByTPost := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Vector.T._elems.Vector.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w0_mid: Seq.int;                                                                               
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var w_mid: Seq.int;                                                                                
 var v_mid: int;                                                                                    
 var x_mid: Array.Vector.T;                                                                         
 var y_mid: Vector;                                                                                 
 var x_owner_mid: Vector;                                                                           
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Vector.T._elems[x][i];                                                               
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Vector.T._elems[x][i] := tmpV;                                                               
 Vector.spec[y] := w;                                                                               
 _writeByTPost := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Vector.T._elems.Vector.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Vector.spec(u: Tid,y: Vector,w: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Vector.spec[y] := w;                                                                               
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.spec (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Vector.T._elems.Vector.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Vector, x: Array.Vector.T, i: int, y: Vector)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Vector._state[y], u);                                                        
 modifies Array.Vector.T._elems;                                                                    
 modifies Vector.spec;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var y_pre: Vector;                                                                                 
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var t_pre: Tid;                                                                                    
 var w_pre: Seq.int;                                                                                
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var w0_post: Seq.int;                                                                              
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var v_post: int;                                                                                   
 var w_post: Seq.int;                                                                               
 var y_post: Vector;                                                                                
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Vector.spec(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Vector.spec(u: Tid,y: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): Vector.spec is not Write-Read Stable with respect to Array Array.Vector.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): Vector.spec is not Write-Read Stable with respect to Array Array.Vector.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (13.5): Vector.spec is not Write-Read Stable with respect to Array Array.Vector.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Vector.T._elems.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Vector, x: Array.Vector.T, i: int, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Array.Vector.T._elems;                                                                    
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Array Array.Vector.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Array Array.Vector.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Array Array.Vector.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Vector.T._elems.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Vector, x: Array.Vector.T, i: int, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Array.Vector.T._elems;                                                                    
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var y_owner_mid: Vector;                                                                           
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var v_mid: int;                                                                                    
 var y_mid: Array.Vector.T;                                                                         
 var x_mid: Array.Vector.T;                                                                         
 var j_mid: int;                                                                                    
 var x_owner_mid: Vector;                                                                           
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Vector.T._elems[x][i];                                                               
 Array.Vector.T._elems[x][i] := v;                                                                  
                                                                                                    
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Vector.T._elems[x][i] := tmpV;                                                               
 Array.Vector.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Array Array.Vector.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Vector.T._elems.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Vector, x: Array.Vector.T, i: int, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Array.Vector.T._elems;                                                                    
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var Array.Vector.T._elems_mid: [Array.Vector.T]([int]int);                                         
 var t_mid: Tid;                                                                                    
 var Vector._state_mid: [Vector]State;                                                              
 var y_owner_mid: Vector;                                                                           
 var Vector.elems_mid: [Vector]Array.Vector.T;                                                      
 var Vector.spec_mid: [Vector]Seq.int;                                                              
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Vector.count_mid: [Vector]int;                                                                 
 var Vector._lock_mid: [Vector]Tid;                                                                 
 var Array.Vector.T._state_mid: [Array.Vector.T]State;                                              
 var w_mid: int;                                                                                    
 var Array.Vector.T._length_mid: [Array.Vector.T]int;                                               
 var v_mid: int;                                                                                    
 var y_mid: Array.Vector.T;                                                                         
 var x_mid: Array.Vector.T;                                                                         
 var j_mid: int;                                                                                    
 var x_owner_mid: Vector;                                                                           
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Vector.T._elems[x][i];                                                               
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_mid == Vector._state && Vector.elems_mid == Vector.elems && Vector.count_mid == Vector.count && Vector.spec_mid == Vector.spec && Vector._lock_mid == Vector._lock && Array.Vector.T._state_mid == Array.Vector.T._state && Array.Vector.T._elems_mid == Array.Vector.T._elems && Array.Vector.T._length_mid == Array.Vector.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Vector.T._elems[x][i] := tmpV;                                                               
 Array.Vector.T._elems[y][j] := w;                                                                  
 _writeByTPost := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Array Array.Vector.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Array Array.Vector.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Vector.T._elems.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Vector, x: Array.Vector.T, i: int, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Array.Vector.T._elems;                                                                    
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,w: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Vector.T._elems[y][j] := w;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Array Array.Vector.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Array Array.Vector.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Array Array.Vector.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Vector.T._elems.Array.Vector.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Vector, x: Array.Vector.T, i: int, y_owner: Vector, y: Array.Vector.T, j: int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Vector.T._state[x], t);                                                
 requires Array.Vector.T._this[x] == x_owner;                                                       
 requires isAccessible(Array.Vector.T._state[y], u);                                                
 requires Array.Vector.T._this[y] == y_owner;                                                       
 modifies Array.Vector.T._elems;                                                                    
 modifies Array.Vector.T._elems;                                                                    
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Vector.count_pre: [Vector]int;                                                                 
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                         
 var x_owner_pre: Vector;                                                                           
 var Vector.elems_pre: [Vector]Array.Vector.T;                                                      
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var x_pre: Array.Vector.T;                                                                         
 var w0_pre: int;                                                                                   
 var Vector.spec_pre: [Vector]Seq.int;                                                              
 var Array.Vector.T._length_pre: [Array.Vector.T]int;                                               
 var Vector._state_pre: [Vector]State;                                                              
 var Vector._lock_pre: [Vector]Tid;                                                                 
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var y_pre: Array.Vector.T;                                                                         
 var y_owner_pre: Vector;                                                                           
 var t_pre: Tid;                                                                                    
 var Array.Vector.T._state_pre: [Array.Vector.T]State;                                              
                                                                                                    
 var x_owner_post: Vector;                                                                          
 var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Vector.elems_post: [Vector]Array.Vector.T;                                                     
 var t_post: Tid;                                                                                   
 var i_post: int;                                                                                   
 var Array.Vector.T._length_post: [Array.Vector.T]int;                                              
 var Vector._lock_post: [Vector]Tid;                                                                
 var y_owner_post: Vector;                                                                          
 var $pc_post: Phase;                                                                               
 var x_post: Array.Vector.T;                                                                        
 var j_post: int;                                                                                   
 var Vector.count_post: [Vector]int;                                                                
 var Vector._state_post: [Vector]State;                                                             
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Array.Vector.T;                                                                        
 var Vector.spec_post: [Vector]Seq.int;                                                             
 var Array.Vector.T._state_post: [Array.Vector.T]State;                                             
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Vector.T(t: Tid,x_owner: Vector,x: Array.Vector.T,i: int,v: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Vector.T._elems[x][i] := v;                                                                  
 assume Vector._state_post == Vector._state && Vector.elems_post == Vector.elems && Vector.count_post == Vector.count && Vector.spec_post == Vector.spec && Vector._lock_post == Vector._lock && Array.Vector.T._state_post == Array.Vector.T._state && Array.Vector.T._elems_post == Array.Vector.T._elems && Array.Vector.T._length_post == Array.Vector.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Vector.T(u: Tid,y_owner: Vector,y: Array.Vector.T,j: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Array Array.Vector.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Array Array.Vector.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Array Array.Vector.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
requires ValidTid(tid);                                                                             
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (<undefined position>): Object invariant may not hold.
modifies Vector._state;                                                                             
modifies Vector.elems;                                                                              
modifies Vector.count;                                                                              
modifies Vector.spec;                                                                               
modifies Vector._lock;                                                                              
modifies Array.Vector.T._state;                                                                     
modifies Array.Vector.T._elems;                                                                     
ensures StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
ensures Y(tid , old(Vector._state), old(Vector.elems), old(Vector.count), old(Vector.spec), old(Vector._lock), old(Array.Vector.T._state), old(Array.Vector.T._elems), old(Array.Vector.T._length) , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
ensures  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// Vector.elems:                                                                                    
                                                                                                    
function {:inline} Y_Vector.elems(tid : Tid, this: Vector, newValue: Array.Vector.T , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int): bool
{                                                                                                   
 ((isAccessible(Vector._state[this], tid) && leq(m#moverPath(ReadEval.Vector.elems(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length)), _R)) ==> (Vector.elems[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Vector.elems(tid : Tid, this: Vector, newValue: Array.Vector.T , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Vector.elems.Subsumes.W(tid : Tid, u : Tid, this: Vector, newValue: Array.Vector.T , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var Vector.spec_yield: [Vector]Seq.int;                                                             
var Array.Vector.T._length_yield: [Array.Vector.T]int;                                              
var newValue_yield: Array.Vector.T;                                                                 
var Array.Vector.T._state_yield: [Array.Vector.T]State;                                             
var Vector._lock_yield: [Vector]Tid;                                                                
var u_yield: Tid;                                                                                   
var this_yield: Vector;                                                                             
var Vector._state_yield: [Vector]State;                                                             
var Array.Vector.T._elems_yield: [Array.Vector.T]([int]int);                                        
var Vector.elems_yield: [Vector]Array.Vector.T;                                                     
var $recorded.state_yield: int;                                                                     
var Vector.count_yield: [Vector]int;                                                                
                                                                                                    
 assume isAccessible(Vector._state[this], tid);                                                     
 assume isAccessible(Vector._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Vector.elems(u: Tid,this: Vector,newValue: Array.Vector.T,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length)));
                                                                                                    
assume Vector._state_yield == Vector._state && Vector.elems_yield == Vector.elems && Vector.count_yield == Vector.count && Vector.spec_yield == Vector.spec && Vector._lock_yield == Vector._lock && Array.Vector.T._state_yield == Array.Vector.T._state && Array.Vector.T._elems_yield == Array.Vector.T._elems && Array.Vector.T._length_yield == Array.Vector.T._length && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Vector.elems(tid, this, newValue , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Vector.elems.Reflexive(tid : Tid, this: Vector , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var Vector.spec_yield: [Vector]Seq.int;                                                             
var Array.Vector.T._length_yield: [Array.Vector.T]int;                                              
var Array.Vector.T._state_yield: [Array.Vector.T]State;                                             
var Vector._lock_yield: [Vector]Tid;                                                                
var this_yield: Vector;                                                                             
var Vector._state_yield: [Vector]State;                                                             
var Array.Vector.T._elems_yield: [Array.Vector.T]([int]int);                                        
var Vector.elems_yield: [Vector]Array.Vector.T;                                                     
var $recorded.state_yield: int;                                                                     
var Vector.count_yield: [Vector]int;                                                                
                                                                                                    
 assume isAccessible(Vector._state[this], tid);                                                     
assume Vector._state_yield == Vector._state && Vector.elems_yield == Vector.elems && Vector.count_yield == Vector.count && Vector.spec_yield == Vector.spec && Vector._lock_yield == Vector._lock && Array.Vector.T._state_yield == Array.Vector.T._state && Array.Vector.T._elems_yield == Array.Vector.T._elems && Array.Vector.T._length_yield == Array.Vector.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Vector.elems(tid, this, Vector.elems[this] , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Vector.elems.Transitive(tid : Tid, this: Vector, newValue : Array.Vector.T , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int , Vector._state_p: [Vector]State, Vector.elems_p: [Vector]Array.Vector.T, Vector.count_p: [Vector]int, Vector.spec_p: [Vector]Seq.int, Vector._lock_p: [Vector]Tid, Array.Vector.T._state_p: [Array.Vector.T]State, Array.Vector.T._elems_p: [Array.Vector.T]([int]int), Array.Vector.T._length_p: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires StateInvariant(Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (9.24): Object invariant may not hold.
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (9.24): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Vector.count_pre: [Vector]int;                                                                  
var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                          
var Vector.elems_pre: [Vector]Array.Vector.T;                                                       
var $recorded.state_pre: int;                                                                       
var Vector.spec_pre: [Vector]Seq.int;                                                               
var Array.Vector.T._length_pre: [Array.Vector.T]int;                                                
var Vector._state_pre: [Vector]State;                                                               
var Vector._lock_pre: [Vector]Tid;                                                                  
var this_pre: Vector;                                                                               
var tid_pre: Tid;                                                                                   
var $pc_pre: Phase;                                                                                 
var newValue_pre: Array.Vector.T;                                                                   
var Array.Vector.T._state_pre: [Array.Vector.T]State;                                               
                                                                                                    
var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                         
var $recorded.state_post: int;                                                                      
var newValue_post: Array.Vector.T;                                                                  
var Vector.elems_post: [Vector]Array.Vector.T;                                                      
var Array.Vector.T._length_post: [Array.Vector.T]int;                                               
var Vector._lock_post: [Vector]Tid;                                                                 
var $pc_post: Phase;                                                                                
var this_post: Vector;                                                                              
var tid_post: Tid;                                                                                  
var Vector.count_post: [Vector]int;                                                                 
var Vector._state_post: [Vector]State;                                                              
var Vector.spec_post: [Vector]Seq.int;                                                              
var Array.Vector.T._state_post: [Array.Vector.T]State;                                              
                                                                                                    
assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Vector._state[this], tid);                                                     
 assume Y(tid , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length , Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
 assume Y_Vector.elems(tid, this, newValue , Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
assume Vector._state_post == Vector._state_p && Vector.elems_post == Vector.elems_p && Vector.count_post == Vector.count_p && Vector.spec_post == Vector.spec_p && Vector._lock_post == Vector._lock_p && Array.Vector.T._state_post == Array.Vector.T._state_p && Array.Vector.T._elems_post == Array.Vector.T._elems_p && Array.Vector.T._length_post == Array.Vector.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Vector.elems(tid, this, newValue , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
// Vector.count:                                                                                    
                                                                                                    
function {:inline} Y_Vector.count(tid : Tid, this: Vector, newValue: int , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int): bool
{                                                                                                   
 ((isAccessible(Vector._state[this], tid) && leq(m#moverPath(ReadEval.Vector.count(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length)), _R)) ==> (Vector.count[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Vector.count(tid : Tid, this: Vector, newValue: int , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Vector.count.Subsumes.W(tid : Tid, u : Tid, this: Vector, newValue: int , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var Vector.spec_yield: [Vector]Seq.int;                                                             
var Array.Vector.T._length_yield: [Array.Vector.T]int;                                              
var newValue_yield: int;                                                                            
var Array.Vector.T._state_yield: [Array.Vector.T]State;                                             
var Vector._lock_yield: [Vector]Tid;                                                                
var u_yield: Tid;                                                                                   
var this_yield: Vector;                                                                             
var Vector._state_yield: [Vector]State;                                                             
var Array.Vector.T._elems_yield: [Array.Vector.T]([int]int);                                        
var Vector.elems_yield: [Vector]Array.Vector.T;                                                     
var $recorded.state_yield: int;                                                                     
var Vector.count_yield: [Vector]int;                                                                
                                                                                                    
 assume isAccessible(Vector._state[this], tid);                                                     
 assume isAccessible(Vector._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Vector.count(u: Tid,this: Vector,newValue: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length)));
                                                                                                    
assume Vector._state_yield == Vector._state && Vector.elems_yield == Vector.elems && Vector.count_yield == Vector.count && Vector.spec_yield == Vector.spec && Vector._lock_yield == Vector._lock && Array.Vector.T._state_yield == Array.Vector.T._state && Array.Vector.T._elems_yield == Array.Vector.T._elems && Array.Vector.T._length_yield == Array.Vector.T._length && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Vector.count(tid, this, newValue , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Vector.count.Reflexive(tid : Tid, this: Vector , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var Vector.spec_yield: [Vector]Seq.int;                                                             
var Array.Vector.T._length_yield: [Array.Vector.T]int;                                              
var Array.Vector.T._state_yield: [Array.Vector.T]State;                                             
var Vector._lock_yield: [Vector]Tid;                                                                
var this_yield: Vector;                                                                             
var Vector._state_yield: [Vector]State;                                                             
var Array.Vector.T._elems_yield: [Array.Vector.T]([int]int);                                        
var Vector.elems_yield: [Vector]Array.Vector.T;                                                     
var $recorded.state_yield: int;                                                                     
var Vector.count_yield: [Vector]int;                                                                
                                                                                                    
 assume isAccessible(Vector._state[this], tid);                                                     
assume Vector._state_yield == Vector._state && Vector.elems_yield == Vector.elems && Vector.count_yield == Vector.count && Vector.spec_yield == Vector.spec && Vector._lock_yield == Vector._lock && Array.Vector.T._state_yield == Array.Vector.T._state && Array.Vector.T._elems_yield == Array.Vector.T._elems && Array.Vector.T._length_yield == Array.Vector.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Vector.count(tid, this, Vector.count[this] , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Vector.count.Transitive(tid : Tid, this: Vector, newValue : int , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int , Vector._state_p: [Vector]State, Vector.elems_p: [Vector]Array.Vector.T, Vector.count_p: [Vector]int, Vector.spec_p: [Vector]Seq.int, Vector._lock_p: [Vector]Tid, Array.Vector.T._state_p: [Array.Vector.T]State, Array.Vector.T._elems_p: [Array.Vector.T]([int]int), Array.Vector.T._length_p: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires StateInvariant(Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (10.24): Object invariant may not hold.
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (10.24): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Vector.count_pre: [Vector]int;                                                                  
var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                          
var Vector.elems_pre: [Vector]Array.Vector.T;                                                       
var $recorded.state_pre: int;                                                                       
var Vector.spec_pre: [Vector]Seq.int;                                                               
var newValue_pre: int;                                                                              
var Array.Vector.T._length_pre: [Array.Vector.T]int;                                                
var Vector._state_pre: [Vector]State;                                                               
var Vector._lock_pre: [Vector]Tid;                                                                  
var this_pre: Vector;                                                                               
var tid_pre: Tid;                                                                                   
var $pc_pre: Phase;                                                                                 
var Array.Vector.T._state_pre: [Array.Vector.T]State;                                               
                                                                                                    
var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                         
var $recorded.state_post: int;                                                                      
var Vector.elems_post: [Vector]Array.Vector.T;                                                      
var Array.Vector.T._length_post: [Array.Vector.T]int;                                               
var Vector._lock_post: [Vector]Tid;                                                                 
var newValue_post: int;                                                                             
var $pc_post: Phase;                                                                                
var this_post: Vector;                                                                              
var tid_post: Tid;                                                                                  
var Vector.count_post: [Vector]int;                                                                 
var Vector._state_post: [Vector]State;                                                              
var Vector.spec_post: [Vector]Seq.int;                                                              
var Array.Vector.T._state_post: [Array.Vector.T]State;                                              
                                                                                                    
assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Vector._state[this], tid);                                                     
 assume Y(tid , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length , Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
 assume Y_Vector.count(tid, this, newValue , Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
assume Vector._state_post == Vector._state_p && Vector.elems_post == Vector.elems_p && Vector.count_post == Vector.count_p && Vector.spec_post == Vector.spec_p && Vector._lock_post == Vector._lock_p && Array.Vector.T._state_post == Array.Vector.T._state_p && Array.Vector.T._elems_post == Array.Vector.T._elems_p && Array.Vector.T._length_post == Array.Vector.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Vector.count(tid, this, newValue , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
// Vector.spec:                                                                                     
                                                                                                    
function {:inline} Y_Vector.spec(tid : Tid, this: Vector, newValue: Seq.int , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int): bool
{                                                                                                   
 ((isAccessible(Vector._state[this], tid) && leq(m#moverPath(ReadEval.Vector.spec(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length)), _R)) ==> (Vector.spec[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Vector.spec(tid : Tid, this: Vector, newValue: Seq.int , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Vector.spec.Subsumes.W(tid : Tid, u : Tid, this: Vector, newValue: Seq.int , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var Vector.spec_yield: [Vector]Seq.int;                                                             
var Array.Vector.T._length_yield: [Array.Vector.T]int;                                              
var newValue_yield: Seq.int;                                                                        
var Array.Vector.T._state_yield: [Array.Vector.T]State;                                             
var Vector._lock_yield: [Vector]Tid;                                                                
var u_yield: Tid;                                                                                   
var this_yield: Vector;                                                                             
var Vector._state_yield: [Vector]State;                                                             
var Array.Vector.T._elems_yield: [Array.Vector.T]([int]int);                                        
var Vector.elems_yield: [Vector]Array.Vector.T;                                                     
var $recorded.state_yield: int;                                                                     
var Vector.count_yield: [Vector]int;                                                                
                                                                                                    
 assume isAccessible(Vector._state[this], tid);                                                     
 assume isAccessible(Vector._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Vector.spec(u: Tid,this: Vector,newValue: Seq.int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length)));
                                                                                                    
assume Vector._state_yield == Vector._state && Vector.elems_yield == Vector.elems && Vector.count_yield == Vector.count && Vector.spec_yield == Vector.spec && Vector._lock_yield == Vector._lock && Array.Vector.T._state_yield == Array.Vector.T._state && Array.Vector.T._elems_yield == Array.Vector.T._elems && Array.Vector.T._length_yield == Array.Vector.T._length && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Vector.spec(tid, this, newValue , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Vector.spec.Reflexive(tid : Tid, this: Vector , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var Vector.spec_yield: [Vector]Seq.int;                                                             
var Array.Vector.T._length_yield: [Array.Vector.T]int;                                              
var Array.Vector.T._state_yield: [Array.Vector.T]State;                                             
var Vector._lock_yield: [Vector]Tid;                                                                
var this_yield: Vector;                                                                             
var Vector._state_yield: [Vector]State;                                                             
var Array.Vector.T._elems_yield: [Array.Vector.T]([int]int);                                        
var Vector.elems_yield: [Vector]Array.Vector.T;                                                     
var $recorded.state_yield: int;                                                                     
var Vector.count_yield: [Vector]int;                                                                
                                                                                                    
 assume isAccessible(Vector._state[this], tid);                                                     
assume Vector._state_yield == Vector._state && Vector.elems_yield == Vector.elems && Vector.count_yield == Vector.count && Vector.spec_yield == Vector.spec && Vector._lock_yield == Vector._lock && Array.Vector.T._state_yield == Array.Vector.T._state && Array.Vector.T._elems_yield == Array.Vector.T._elems && Array.Vector.T._length_yield == Array.Vector.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Vector.spec(tid, this, Vector.spec[this] , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Vector.spec.Transitive(tid : Tid, this: Vector, newValue : Seq.int , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int , Vector._state_p: [Vector]State, Vector.elems_p: [Vector]Array.Vector.T, Vector.count_p: [Vector]int, Vector.spec_p: [Vector]Seq.int, Vector._lock_p: [Vector]Tid, Array.Vector.T._state_p: [Array.Vector.T]State, Array.Vector.T._elems_p: [Array.Vector.T]([int]int), Array.Vector.T._length_p: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires StateInvariant(Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (13.37): Object invariant may not hold.
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (13.37): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Vector.count_pre: [Vector]int;                                                                  
var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                          
var Vector.elems_pre: [Vector]Array.Vector.T;                                                       
var $recorded.state_pre: int;                                                                       
var Vector.spec_pre: [Vector]Seq.int;                                                               
var Array.Vector.T._length_pre: [Array.Vector.T]int;                                                
var Vector._state_pre: [Vector]State;                                                               
var Vector._lock_pre: [Vector]Tid;                                                                  
var this_pre: Vector;                                                                               
var newValue_pre: Seq.int;                                                                          
var tid_pre: Tid;                                                                                   
var $pc_pre: Phase;                                                                                 
var Array.Vector.T._state_pre: [Array.Vector.T]State;                                               
                                                                                                    
var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                         
var $recorded.state_post: int;                                                                      
var Vector.elems_post: [Vector]Array.Vector.T;                                                      
var Array.Vector.T._length_post: [Array.Vector.T]int;                                               
var Vector._lock_post: [Vector]Tid;                                                                 
var $pc_post: Phase;                                                                                
var this_post: Vector;                                                                              
var tid_post: Tid;                                                                                  
var newValue_post: Seq.int;                                                                         
var Vector.count_post: [Vector]int;                                                                 
var Vector._state_post: [Vector]State;                                                              
var Vector.spec_post: [Vector]Seq.int;                                                              
var Array.Vector.T._state_post: [Array.Vector.T]State;                                              
                                                                                                    
assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Vector._state[this], tid);                                                     
 assume Y(tid , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length , Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
 assume Y_Vector.spec(tid, this, newValue , Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
assume Vector._state_post == Vector._state_p && Vector.elems_post == Vector.elems_p && Vector.count_post == Vector.count_p && Vector.spec_post == Vector.spec_p && Vector._lock_post == Vector._lock_p && Array.Vector.T._state_post == Array.Vector.T._state_p && Array.Vector.T._elems_post == Array.Vector.T._elems_p && Array.Vector.T._length_post == Array.Vector.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Vector.spec(tid, this, newValue , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
// Vector._lock:                                                                                    
                                                                                                    
function {:inline} Y_Vector._lock(tid : Tid, this: Vector, newValue: Tid , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int): bool
{                                                                                                   
 ((isAccessible(Vector._state[this], tid) && leq(m#moverPath(ReadEval.Vector._lock(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length)), _R)) ==> (Vector._lock[this] == newValue))
 &&(((Vector._lock[this]==tid)==(newValue==tid)))                                                   
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Vector._lock(tid : Tid, this: Vector, newValue: Tid , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Vector._lock.Subsumes.W(tid : Tid, u : Tid, this: Vector, newValue: Tid , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var newValue_yield: Tid;                                                                            
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var Vector.spec_yield: [Vector]Seq.int;                                                             
var Array.Vector.T._length_yield: [Array.Vector.T]int;                                              
var Array.Vector.T._state_yield: [Array.Vector.T]State;                                             
var Vector._lock_yield: [Vector]Tid;                                                                
var u_yield: Tid;                                                                                   
var this_yield: Vector;                                                                             
var Vector._state_yield: [Vector]State;                                                             
var Array.Vector.T._elems_yield: [Array.Vector.T]([int]int);                                        
var Vector.elems_yield: [Vector]Array.Vector.T;                                                     
var $recorded.state_yield: int;                                                                     
var Vector.count_yield: [Vector]int;                                                                
                                                                                                    
 assume isAccessible(Vector._state[this], tid);                                                     
 assume isAccessible(Vector._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Vector._lock(u: Tid,this: Vector,newValue: Tid,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length)));
 assume leq(m#moverPath(ReadEval.Vector._lock(tid: Tid,this: Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length)), _N);
assume Vector._state_yield == Vector._state && Vector.elems_yield == Vector.elems && Vector.count_yield == Vector.count && Vector.spec_yield == Vector.spec && Vector._lock_yield == Vector._lock && Array.Vector.T._state_yield == Array.Vector.T._state && Array.Vector.T._elems_yield == Array.Vector.T._elems && Array.Vector.T._length_yield == Array.Vector.T._length && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Vector._lock(tid, this, newValue , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Vector._lock.Reflexive(tid : Tid, this: Vector , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var Vector.spec_yield: [Vector]Seq.int;                                                             
var Array.Vector.T._length_yield: [Array.Vector.T]int;                                              
var Array.Vector.T._state_yield: [Array.Vector.T]State;                                             
var Vector._lock_yield: [Vector]Tid;                                                                
var this_yield: Vector;                                                                             
var Vector._state_yield: [Vector]State;                                                             
var Array.Vector.T._elems_yield: [Array.Vector.T]([int]int);                                        
var Vector.elems_yield: [Vector]Array.Vector.T;                                                     
var $recorded.state_yield: int;                                                                     
var Vector.count_yield: [Vector]int;                                                                
                                                                                                    
 assume isAccessible(Vector._state[this], tid);                                                     
assume Vector._state_yield == Vector._state && Vector.elems_yield == Vector.elems && Vector.count_yield == Vector.count && Vector.spec_yield == Vector.spec && Vector._lock_yield == Vector._lock && Array.Vector.T._state_yield == Array.Vector.T._state && Array.Vector.T._elems_yield == Array.Vector.T._elems && Array.Vector.T._length_yield == Array.Vector.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Vector._lock(tid, this, Vector._lock[this] , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Vector._lock.Transitive(tid : Tid, this: Vector, newValue : Tid , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int , Vector._state_p: [Vector]State, Vector.elems_p: [Vector]Array.Vector.T, Vector.count_p: [Vector]int, Vector.spec_p: [Vector]Seq.int, Vector._lock_p: [Vector]Tid, Array.Vector.T._state_p: [Array.Vector.T]State, Array.Vector.T._elems_p: [Array.Vector.T]([int]int), Array.Vector.T._length_p: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires StateInvariant(Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (3.1): Object invariant may not hold.
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (3.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Vector.count_pre: [Vector]int;                                                                  
var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                          
var Vector.elems_pre: [Vector]Array.Vector.T;                                                       
var $recorded.state_pre: int;                                                                       
var Vector.spec_pre: [Vector]Seq.int;                                                               
var Array.Vector.T._length_pre: [Array.Vector.T]int;                                                
var Vector._state_pre: [Vector]State;                                                               
var Vector._lock_pre: [Vector]Tid;                                                                  
var this_pre: Vector;                                                                               
var tid_pre: Tid;                                                                                   
var $pc_pre: Phase;                                                                                 
var newValue_pre: Tid;                                                                              
var Array.Vector.T._state_pre: [Array.Vector.T]State;                                               
                                                                                                    
var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                         
var $recorded.state_post: int;                                                                      
var Vector.elems_post: [Vector]Array.Vector.T;                                                      
var Array.Vector.T._length_post: [Array.Vector.T]int;                                               
var Vector._lock_post: [Vector]Tid;                                                                 
var $pc_post: Phase;                                                                                
var this_post: Vector;                                                                              
var tid_post: Tid;                                                                                  
var Vector.count_post: [Vector]int;                                                                 
var Vector._state_post: [Vector]State;                                                              
var newValue_post: Tid;                                                                             
var Vector.spec_post: [Vector]Seq.int;                                                              
var Array.Vector.T._state_post: [Array.Vector.T]State;                                              
                                                                                                    
assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Vector._state[this], tid);                                                     
 assume Y(tid , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length , Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
 assume Y_Vector._lock(tid, this, newValue , Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
assume Vector._state_post == Vector._state_p && Vector.elems_post == Vector.elems_p && Vector.count_post == Vector.count_p && Vector.spec_post == Vector.spec_p && Vector._lock_post == Vector._lock_p && Array.Vector.T._state_post == Array.Vector.T._state_p && Array.Vector.T._elems_post == Array.Vector.T._elems_p && Array.Vector.T._length_post == Array.Vector.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Vector._lock(tid, this, newValue , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
// Array.Vector.T:                                                                                  
                                                                                                    
function {:inline} Y_Array.Vector.T(tid : Tid, athis: Array.Vector.T, index: int, newValue: int , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int): bool
{                                                                                                   
(var this := Array.Vector.T._this[athis];                                                           
 ((isAccessible(Array.Vector.T._state[athis], tid) && leq(m#moverPath(ReadEval.Array.Vector.T(tid: Tid,Array.Vector.T._this[athis]: Vector,athis: Array.Vector.T,index: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length)), _R)) ==> (Array.Vector.T._elems[athis][index] == newValue))
                                                                                                    
)                                                                                                   
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Array.Vector.T(tid : Tid, athis: Array.Vector.T, index: int, newValue: int , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int): bool
{                                                                                                   
(var this := Array.Vector.T._this[athis];                                                           
true                                                                                                
                                                                                                    
)                                                                                                   
}                                                                                                   
                                                                                                    
procedure Y_Array.Vector.T.Subsumes.W(tid : Tid, u : Tid, this: Vector, athis: Array.Vector.T, index: int, newValue: int , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
 requires this == Array.Vector.T._this[athis];                                                      
{                                                                                                   
var athis_yield: Array.Vector.T;                                                                    
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var Vector.spec_yield: [Vector]Seq.int;                                                             
var Array.Vector.T._length_yield: [Array.Vector.T]int;                                              
var Array.Vector.T._state_yield: [Array.Vector.T]State;                                             
var Vector._lock_yield: [Vector]Tid;                                                                
var index_yield: int;                                                                               
var this_yield: Vector;                                                                             
var Vector._state_yield: [Vector]State;                                                             
var Array.Vector.T._elems_yield: [Array.Vector.T]([int]int);                                        
var Vector.elems_yield: [Vector]Array.Vector.T;                                                     
var $recorded.state_yield: int;                                                                     
var Vector.count_yield: [Vector]int;                                                                
                                                                                                    
 assume isAccessible(Array.Vector.T._state[athis], u);                                              
 assume !isError(m#moverPath(WriteEval.Array.Vector.T(u: Tid,Array.Vector.T._this[athis]: Vector,athis: Array.Vector.T,index: int,newValue: int,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length)));
                                                                                                    
assume Vector._state_yield == Vector._state && Vector.elems_yield == Vector.elems && Vector.count_yield == Vector.count && Vector.spec_yield == Vector.spec && Vector._lock_yield == Vector._lock && Array.Vector.T._state_yield == Array.Vector.T._state && Array.Vector.T._elems_yield == Array.Vector.T._elems && Array.Vector.T._length_yield == Array.Vector.T._length && athis_yield == athis && index_yield == index && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Array.Vector.T(tid, athis, index, newValue , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Array.Vector.T.Reflexive(tid : Tid, this: Vector, athis: Array.Vector.T, index: int , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires ValidTid(tid);                                                                            
 requires this == Array.Vector.T._this[athis];                                                      
{                                                                                                   
var athis_yield: Array.Vector.T;                                                                    
var tid_yield: Tid;                                                                                 
var $pc_yield: Phase;                                                                               
var Vector.spec_yield: [Vector]Seq.int;                                                             
var Array.Vector.T._length_yield: [Array.Vector.T]int;                                              
var Array.Vector.T._state_yield: [Array.Vector.T]State;                                             
var Vector._lock_yield: [Vector]Tid;                                                                
var index_yield: int;                                                                               
var this_yield: Vector;                                                                             
var Vector._state_yield: [Vector]State;                                                             
var Array.Vector.T._elems_yield: [Array.Vector.T]([int]int);                                        
var Vector.elems_yield: [Vector]Array.Vector.T;                                                     
var $recorded.state_yield: int;                                                                     
var Vector.count_yield: [Vector]int;                                                                
                                                                                                    
 assume isAccessible(Array.Vector.T._state[athis], tid);                                            
assume Vector._state_yield == Vector._state && Vector.elems_yield == Vector.elems && Vector.count_yield == Vector.count && Vector.spec_yield == Vector.spec && Vector._lock_yield == Vector._lock && Array.Vector.T._state_yield == Array.Vector.T._state && Array.Vector.T._elems_yield == Array.Vector.T._elems && Array.Vector.T._length_yield == Array.Vector.T._length && athis_yield == athis && index_yield == index && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Array.Vector.T(tid, athis, index, Array.Vector.T._elems[athis][index] , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Array.Vector.T.Transitive(tid : Tid, this: Vector, athis: Array.Vector.T, index: int, newValue : int , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int , Vector._state_p: [Vector]State, Vector.elems_p: [Vector]Array.Vector.T, Vector.count_p: [Vector]int, Vector.spec_p: [Vector]Seq.int, Vector._lock_p: [Vector]Tid, Array.Vector.T._state_p: [Array.Vector.T]State, Array.Vector.T._elems_p: [Array.Vector.T]([int]int), Array.Vector.T._length_p: [Array.Vector.T]int)
 requires StateInvariant(Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
 requires StateInvariant(Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663331(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (7.28): Object invariant may not hold.
requires  (forall _this : Vector ::  { Vector._state[_this] } isAccessible(Vector._state[_this], tid) && true ==> Invariant.Vector.4663360(tid: Tid,_this : Vector,Vector._state,Vector.elems,Vector.count,Vector.spec,Vector._lock,Array.Vector.T._state,Array.Vector.T._elems,Array.Vector.T._length));       // (7.28): Object invariant may not hold.
                                                                                                    
 requires this == Array.Vector.T._this[athis];                                                      
 requires ValidTid(tid);                                                                            
{                                                                                                   
var Vector.count_pre: [Vector]int;                                                                  
var Array.Vector.T._elems_pre: [Array.Vector.T]([int]int);                                          
var Vector.elems_pre: [Vector]Array.Vector.T;                                                       
var $recorded.state_pre: int;                                                                       
var Vector.spec_pre: [Vector]Seq.int;                                                               
var Array.Vector.T._length_pre: [Array.Vector.T]int;                                                
var Vector._state_pre: [Vector]State;                                                               
var index_pre: int;                                                                                 
var Vector._lock_pre: [Vector]Tid;                                                                  
var this_pre: Vector;                                                                               
var tid_pre: Tid;                                                                                   
var athis_pre: Array.Vector.T;                                                                      
var $pc_pre: Phase;                                                                                 
var Array.Vector.T._state_pre: [Array.Vector.T]State;                                               
                                                                                                    
var Array.Vector.T._elems_post: [Array.Vector.T]([int]int);                                         
var $recorded.state_post: int;                                                                      
var Vector.elems_post: [Vector]Array.Vector.T;                                                      
var Array.Vector.T._length_post: [Array.Vector.T]int;                                               
var Vector._lock_post: [Vector]Tid;                                                                 
var $pc_post: Phase;                                                                                
var this_post: Vector;                                                                              
var tid_post: Tid;                                                                                  
var Vector.count_post: [Vector]int;                                                                 
var Vector._state_post: [Vector]State;                                                              
var index_post: int;                                                                                
var athis_post: Array.Vector.T;                                                                     
var Vector.spec_post: [Vector]Seq.int;                                                              
var Array.Vector.T._state_post: [Array.Vector.T]State;                                              
                                                                                                    
assume Vector._state_pre == Vector._state && Vector.elems_pre == Vector.elems && Vector.count_pre == Vector.count && Vector.spec_pre == Vector.spec && Vector._lock_pre == Vector._lock && Array.Vector.T._state_pre == Array.Vector.T._state && Array.Vector.T._elems_pre == Array.Vector.T._elems && Array.Vector.T._length_pre == Array.Vector.T._length && athis_pre == athis && index_pre == index && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
assume Vector._state_post == Vector._state_p && Vector.elems_post == Vector.elems_p && Vector.count_post == Vector.count_p && Vector.spec_post == Vector.spec_p && Vector._lock_post == Vector._lock_p && Array.Vector.T._state_post == Array.Vector.T._state_p && Array.Vector.T._elems_post == Array.Vector.T._elems_p && Array.Vector.T._length_post == Array.Vector.T._length_p && athis_post == athis && index_post == index && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assume isAccessible(Array.Vector.T._state[athis], tid);                                            
 assume Y(tid , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length , Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
 assume Y_Array.Vector.T(tid, athis, index, newValue , Vector._state_p, Vector.elems_p, Vector.count_p, Vector.spec_p, Vector._lock_p, Array.Vector.T._state_p, Array.Vector.T._elems_p, Array.Vector.T._length_p);
 assert Y_Array.Vector.T(tid, athis, index, newValue , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length);
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Vector._state: [Vector]State, Vector.elems: [Vector]Array.Vector.T, Vector.count: [Vector]int, Vector.spec: [Vector]Seq.int, Vector._lock: [Vector]Tid, Array.Vector.T._state: [Array.Vector.T]State, Array.Vector.T._elems: [Array.Vector.T]([int]int), Array.Vector.T._length: [Array.Vector.T]int , Vector._state_p: [Vector]State, Vector.elems_p: [Vector]Array.Vector.T, Vector.count_p: [Vector]int, Vector.spec_p: [Vector]Seq.int, Vector._lock_p: [Vector]Tid, Array.Vector.T._state_p: [Array.Vector.T]State, Array.Vector.T._elems_p: [Array.Vector.T]([int]int), Array.Vector.T._length_p: [Array.Vector.T]int): bool
{                                                                                                   
 (forall this: Vector :: Y_Vector.elems(tid : Tid, this, Vector.elems_p[this] , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length))
 && (forall this: Vector :: Y_Vector.count(tid : Tid, this, Vector.count_p[this] , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length))
 && (forall this: Vector :: Y_Vector.spec(tid : Tid, this, Vector.spec_p[this] , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length))
 && (forall this: Vector :: Y_Vector._lock(tid : Tid, this, Vector._lock_p[this] , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length))
 && (forall athis: Array.Vector.T, index: int :: Y_Array.Vector.T(tid : Tid, athis, index, Array.Vector.T._elems_p[athis][index] , Vector._state, Vector.elems, Vector.count, Vector.spec, Vector._lock, Array.Vector.T._state, Array.Vector.T._elems, Array.Vector.T._length))
 && (forall _i : Vector :: isShared(Vector._state[_i]) ==> isShared(Vector._state_p[_i]))           
 && (forall _i : Vector :: isLocal(Vector._state[_i], tid) <==> isLocal(Vector._state_p[_i], tid))  
 && (forall _i : Array.Vector.T :: isShared(Array.Vector.T._state[_i]) ==> isShared(Array.Vector.T._state_p[_i]))
 && (forall _i : Array.Vector.T :: Array.Vector.T._length[_i] == Array.Vector.T._length_p[_i])      
 && (forall _i : Array.Vector.T :: isLocal(Array.Vector.T._state[_i], tid) <==> isLocal(Array.Vector.T._state_p[_i], tid))
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
/// Seq.int:                                                                                        
                                                                                                    
type {:builtin "(Seq Int)"} Seq.int;                                                                
                                                                                                    
function {:builtin "(as seq.empty (Seq Int))"} SeqEmpty.int(): Seq.int;                             
function {:builtin "seq.len"} SeqLen.int(s: Seq.int): int;                                          
function {:builtin "seq.++"} SeqConcat.int(s1: Seq.int, s2:Seq.int): Seq.int;                       
function {:builtin "seq.unit"} SeqUnit.int(v: int): Seq.int;                                        
function {:builtin "seq.nth"} SeqNth.int(s: Seq.int, i: int): int;                                  
function {:builtin "seq.extract"} SeqExtract.int(s: Seq.int, pos: int, len: int): Seq.int;          
                                                                                                    
function {:inline} SeqEqual.int(a: Seq.int, b: Seq.int) : bool {                                    
SeqLen.int(a) == SeqLen.int(b) &&                                                                   
(forall i : int :: 0 <= i && i < SeqLen.int(a) ==> (SeqNth.int(a, i) == SeqNth.int(b, i)))          
}                                                                                                   
                                                                                                    
function {:inline} SeqSub.int(a: Seq.int, start: int, end: int) : Seq.int {                         
SeqExtract.int(a, start, end-start)                                                                 
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
// 1128.1-1336.2: (Method:20.5)
// 1139.1-1139.24: (20.5): Bad tid
// 1146.1-1146.307: (20.5): Object invariant may not hold.
// 1147.1-1147.307: (20.5): Object invariant may not hold.
// 1150.1-1150.297: (20.5): Object invariant may not hold.
// 1151.1-1151.297: (20.5): Object invariant may not hold.
// 1226.1-1226.215: (20.5): Can only have right-mover memory accesses in requires clause
// 1228.2-1231.51: (class anchor.sink.Assume:20.5)
// 1232.2-1235.33: (class anchor.sink.Assume:20.5)
// 1236.2-1239.55: (class anchor.sink.Assume:20.5)
// 1240.2-1242.2: (class anchor.sink.VarDeclStmt:22.9)
// 1243.2-1246.25: (class anchor.sink.Assign:22.9)
// 1248.2-1264.28: (class anchor.sink.Write:22.9)
// 1260.1-1260.30: (22.9): Cannot have potential null deference in left-mover part.
// 1263.1-1263.27: (22.9): Reduction failure
// 1265.2-1267.2: (class anchor.sink.VarDeclStmt:23.9)
// 1268.2-1271.12: (class anchor.sink.Assign:23.9)
// 1273.2-1289.29: (class anchor.sink.Write:23.9)
// 1285.1-1285.30: (23.9): Cannot have potential null deference in left-mover part.
// 1288.1-1288.27: (23.9): Reduction failure
// 1290.2-1292.2: (class anchor.sink.VarDeclStmt:24.9)
// 1293.2-1301.79: (class anchor.sink.AAlloc:24.9)
// 1303.2-1327.2: (class anchor.sink.Write:24.9)
// 1315.1-1315.30: (24.9): Cannot have potential null deference in left-mover part.
// 1318.1-1318.27: (24.9): Reduction failure
// 1324.1-1324.95: (24.9): tmp3 became shared, but Array.Vector.T._this[tmp3].elems may not be shared.
// 1328.2-1335.9: (class anchor.sink.Return:21.21)
// 1333.1-1333.297: (21.21): Object invariant may not hold.
// 1334.1-1334.297: (21.21): Object invariant may not hold.
// 1337.1-2311.2: (Method:27.5)
// 1348.1-1348.24: (27.5): Bad tid
// 1349.1-1349.40: (27.5): this is not global
// 1352.1-1352.298: (27.5): Object invariant may not hold.
// 1353.1-1353.298: (27.5): Object invariant may not hold.
// 1356.1-1356.297: (27.5): Object invariant may not hold.
// 1357.1-1357.297: (27.5): Object invariant may not hold.
// 1827.1-1827.30: (30.23): Cannot have potential null deference in left-mover part.
// 1831.1-1831.27: (30.23): Reduction failure
// 1833.2-1835.2: (class anchor.sink.VarDeclStmt:31.13)
// 1836.2-1838.2: (class anchor.sink.VarDeclStmt:31.13)
// 1839.2-1856.29: (class anchor.sink.Read:31.13)
// 1851.1-1851.30: (31.13): Cannot have potential null deference in left-mover part.
// 1855.1-1855.27: (31.13): Reduction failure
// 1857.2-1859.2: (class anchor.sink.VarDeclStmt:31.13)
// 1860.2-1862.2: (class anchor.sink.VarDeclStmt:31.13)
// 1863.2-1865.2: (class anchor.sink.VarDeclStmt:31.13)
// 1866.2-1883.29: (class anchor.sink.Read:31.13)
// 1878.1-1878.30: (31.13): Cannot have potential null deference in left-mover part.
// 1882.1-1882.27: (31.13): Reduction failure
// 1884.2-1887.39: (class anchor.sink.Assign:31.13)
// 1888.2-1891.19: (class anchor.sink.Assign:31.13)
// 1892.2-1895.23: (class anchor.sink.Assign:31.13)
// 1897.3-1899.3: (class anchor.sink.VarDeclStmt:32.17)
// 1900.3-1902.3: (class anchor.sink.VarDeclStmt:32.17)
// 1903.3-1905.3: (class anchor.sink.VarDeclStmt:32.17)
// 1906.3-1908.3: (class anchor.sink.VarDeclStmt:32.17)
// 1909.3-1926.31: (class anchor.sink.Read:32.17)
// 1921.1-1921.31: (32.17): Cannot have potential null deference in left-mover part.
// 1925.1-1925.28: (32.17): Reduction failure
// 1927.3-1930.42: (class anchor.sink.Assign:32.17)
// 1931.3-1934.22: (class anchor.sink.Assign:32.17)
// 1935.3-1943.84: (class anchor.sink.AAlloc:32.17)
// 1944.3-1946.3: (class anchor.sink.VarDeclStmt:33.22)
// 1947.3-1950.10: (class anchor.sink.Assign:33.22)
// 1953.3-1957.15: (class anchor.sink.While:33.35)
// 1959.1-1959.28: (27.5): Bad tid
// 1960.1-1960.44: (27.5): this is not global
// 1963.1-1963.302: (33.35): Object invariant may not hold.
// 1964.1-1964.302: (33.35): Object invariant may not hold.
// 1964.302-1965.126: (33.35): invariant forall int i ::0 <= i && i < j ==> newElems[i] == SeqNth<int>(this.spec,i) may not hold
// 1965.126-1966.84: (33.35): invariant holds(this, tid) may not hold
// 1967.1-1967.294: (33.35): Loop does not preserve yields_as annotation for field elems
// 1968.1-1968.294: (33.35): Loop does not preserve yields_as annotation for field count
// 1969.1-1969.292: (33.35): Loop does not preserve yields_as annotation for field spec
// 1970.1-1970.346: (33.35): Loop does not preserve yields_as annotation for field ArrayDecl(T,IntType(),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(Holds(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
// 1971.1-1971.34: (33.35): Phase must be invariant at loop head
// 1972.1-1972.31: (33.35): Potentially infinite loop cannot be in post-commit phase.
// 1974.4-1976.4: (class anchor.sink.VarDeclStmt:33.35)
// 1977.4-1979.4: (class anchor.sink.VarDeclStmt:33.37)
// 1980.4-1997.32: (class anchor.sink.Read:33.37)
// 1992.1-1992.32: (33.37): Cannot have potential null deference in left-mover part.
// 1996.1-1996.29: (33.37): Reduction failure
// 1998.4-2001.23: (class anchor.sink.Assign:33.35)
// 2003.5-2006.11: (class anchor.sink.Break:33.35)
// 2009.4-2011.4: (class anchor.sink.VarDeclStmt:36.21)
// 2012.4-2029.32: (class anchor.sink.Read:36.21)
// 2024.1-2024.32: (36.21): Cannot have potential null deference in left-mover part.
// 2028.1-2028.29: (36.21): Reduction failure
// 2030.4-2032.4: (class anchor.sink.VarDeclStmt:36.21)
// 2033.4-2060.45: (class anchor.sink.ARead:36.21)
// 2045.1-2045.41: (36.21): Cannot have potential null deference in left-mover part.
// 2050.1-2050.19: (36.21): index < 0.
// 2055.1-2055.46: (36.21): index is >= length.
// 2059.1-2059.29: (36.21): Reduction failure
// 2061.4-2088.48: (class anchor.sink.AWrite:36.21)
// 2073.1-2073.44: (36.21): Cannot have potential null deference in left-mover part.
// 2078.1-2078.19: (36.21): index < 0.
// 2083.1-2083.49: (36.21): index is >= length.
// 2087.1-2087.29: (36.21): Reduction failure
// 2089.4-2092.15: (class anchor.sink.Assign:33.49)
// 2095.1-2095.31: (33.35): Phase must be invariant at loop head
// 2098.3-2122.3: (class anchor.sink.Write:38.17)
// 2110.1-2110.31: (38.17): Cannot have potential null deference in left-mover part.
// 2113.1-2113.28: (38.17): Reduction failure
// 2119.1-2119.100: (38.17): newElems became shared, but Array.Vector.T._this[newElems].elems may not be shared.
// 2125.2-2127.2: (class anchor.sink.VarDeclStmt:41.13)
// 2128.2-2145.30: (class anchor.sink.Read:41.13)
// 2140.1-2140.30: (41.13): Cannot have potential null deference in left-mover part.
// 2144.1-2144.27: (41.13): Reduction failure
// 2146.2-2148.2: (class anchor.sink.VarDeclStmt:41.13)
// 2149.2-2166.30: (class anchor.sink.Read:41.13)
// 2161.1-2161.30: (41.13): Cannot have potential null deference in left-mover part.
// 2165.1-2165.27: (41.13): Reduction failure
// 2167.2-2194.43: (class anchor.sink.AWrite:41.13)
// 2179.1-2179.39: (41.13): Cannot have potential null deference in left-mover part.
// 2184.1-2184.21: (41.13): index < 0.
// 2189.1-2189.48: (41.13): index is >= length.
// 2193.1-2193.27: (41.13): Reduction failure
// 2195.2-2197.2: (class anchor.sink.VarDeclStmt:42.13)
// 2198.2-2200.2: (class anchor.sink.VarDeclStmt:42.13)
// 2201.2-2218.30: (class anchor.sink.Read:42.13)
// 2213.1-2213.30: (42.13): Cannot have potential null deference in left-mover part.
// 2217.1-2217.27: (42.13): Reduction failure
// 2219.2-2222.21: (class anchor.sink.Assign:42.13)
// 2224.2-2240.30: (class anchor.sink.Write:42.13)
// 2236.1-2236.30: (42.13): Cannot have potential null deference in left-mover part.
// 2239.1-2239.27: (42.13): Reduction failure
// 2241.2-2243.2: (class anchor.sink.VarDeclStmt:43.13)
// 2244.2-2246.2: (class anchor.sink.VarDeclStmt:43.13)
// 2247.2-2264.29: (class anchor.sink.Read:43.13)
// 2259.1-2259.30: (43.13): Cannot have potential null deference in left-mover part.
// 2263.1-2263.27: (43.13): Reduction failure
// 2265.2-2267.2: (class anchor.sink.VarDeclStmt:43.13)
// 2268.2-2271.26: (class anchor.sink.Assign:43.13)
// 2272.2-2275.38: (class anchor.sink.Assign:43.13)
// 2277.2-2293.29: (class anchor.sink.Write:43.13)
// 2289.1-2289.30: (43.13): Cannot have potential null deference in left-mover part.
// 2292.1-2292.27: (43.13): Reduction failure
// 2297.1-2297.30: (44.9): Cannot have potential null deference in left-mover part.
// 2299.1-2299.35: (44.9): lock not held
// 2301.1-2301.27: (44.9): Reduction failure
// 2303.2-2310.9: (class anchor.sink.Return:29.28)
// 2308.1-2308.297: (29.28): Object invariant may not hold.
// 2309.1-2309.297: (29.28): Object invariant may not hold.
// 2312.1-2688.2: (Method:47.5)
// 2324.1-2324.24: (47.5): Bad tid
// 2325.1-2325.40: (47.5): this is not global
// 2328.1-2328.298: (47.5): Object invariant may not hold.
// 2329.1-2329.298: (47.5): Object invariant may not hold.
// 2332.1-2332.297: (47.5): Object invariant may not hold.
// 2333.1-2333.297: (47.5): Object invariant may not hold.
// 2493.1-2493.30: (49.22): Cannot have potential null deference in left-mover part.
// 2497.1-2497.27: (49.22): Reduction failure
// 2499.2-2501.2: (class anchor.sink.VarDeclStmt:50.18)
// 2502.2-2505.9: (class anchor.sink.Assign:50.18)
// 2508.2-2512.14: (class anchor.sink.While:50.31)
// 2514.1-2514.27: (47.5): Bad tid
// 2515.1-2515.43: (47.5): this is not global
// 2518.1-2518.301: (50.31): Object invariant may not hold.
// 2519.1-2519.301: (50.31): Object invariant may not hold.
// 2519.301-2520.92: (50.31): invariant forall int i ::0 <= i && i < j ==> SeqNth<int>(this.spec,i) != x may not hold
// 2520.92-2521.83: (50.31): invariant holds(this, tid) may not hold
// 2522.1-2522.293: (50.31): Loop does not preserve yields_as annotation for field elems
// 2523.1-2523.293: (50.31): Loop does not preserve yields_as annotation for field count
// 2524.1-2524.291: (50.31): Loop does not preserve yields_as annotation for field spec
// 2525.1-2525.345: (50.31): Loop does not preserve yields_as annotation for field ArrayDecl(T,IntType(),index,Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(Holds(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List()))
// 2526.1-2526.33: (50.31): Phase must be invariant at loop head
// 2527.1-2527.30: (50.31): Potentially infinite loop cannot be in post-commit phase.
// 2529.3-2531.3: (class anchor.sink.VarDeclStmt:50.31)
// 2532.3-2534.3: (class anchor.sink.VarDeclStmt:50.33)
// 2535.3-2552.31: (class anchor.sink.Read:50.33)
// 2547.1-2547.31: (50.33): Cannot have potential null deference in left-mover part.
// 2551.1-2551.28: (50.33): Reduction failure
// 2553.3-2556.22: (class anchor.sink.Assign:50.31)
// 2558.4-2561.10: (class anchor.sink.Break:50.31)
// 2564.3-2566.3: (class anchor.sink.VarDeclStmt:53.17)
// 2567.3-2569.3: (class anchor.sink.VarDeclStmt:53.17)
// 2570.3-2587.31: (class anchor.sink.Read:53.17)
// 2582.1-2582.31: (53.17): Cannot have potential null deference in left-mover part.
// 2586.1-2586.28: (53.17): Reduction failure
// 2588.3-2590.3: (class anchor.sink.VarDeclStmt:53.17)
// 2591.3-2618.44: (class anchor.sink.ARead:53.17)
// 2603.1-2603.40: (53.17): Cannot have potential null deference in left-mover part.
// 2608.1-2608.18: (53.17): index < 0.
// 2613.1-2613.45: (53.17): index is >= length.
// 2617.1-2617.28: (53.17): Reduction failure
// 2619.3-2622.23: (class anchor.sink.Assign:53.17)
// 2627.1-2627.32: (58.9): Cannot have potential null deference in left-mover part.
// 2629.1-2629.37: (58.9): lock not held
// 2631.1-2631.29: (58.9): Reduction failure
// 2633.4-2641.11: (class anchor.sink.Return:54.21)
// 2639.1-2639.299: (54.21): Object invariant may not hold.
// 2640.1-2640.299: (54.21): Object invariant may not hold.
// 2644.3-2647.14: (class anchor.sink.Assign:50.45)
// 2650.1-2650.30: (50.31): Phase must be invariant at loop head
// 2655.1-2655.30: (58.9): Cannot have potential null deference in left-mover part.
// 2657.1-2657.35: (58.9): lock not held
// 2659.1-2659.27: (58.9): Reduction failure
// 2661.2-2669.9: (class anchor.sink.Return:57.13)
// 2667.1-2667.297: (57.13): Object invariant may not hold.
// 2668.1-2668.297: (57.13): Object invariant may not hold.
// 2673.1-2673.30: (58.9): Cannot have potential null deference in left-mover part.
// 2675.1-2675.35: (58.9): lock not held
// 2677.1-2677.27: (58.9): Reduction failure
// 2679.2-2687.9: (class anchor.sink.Return:48.36)
// 2685.1-2685.297: (48.36): Object invariant may not hold.
// 2686.1-2686.297: (48.36): Object invariant may not hold.
// 2830.1-2830.34: (9.5): Vector.elems failed Write-Write Right-Mover Check
// 2897.1-2897.30: (9.5): Vector.elems failed Write-Read Right-Mover Check
// 2968.1-2968.34: (9.5): Vector.elems failed Write-Write Left-Mover Check
// 3036.1-3036.30: (9.5): Vector.elems failed Write-Read Left-Mover Check
// 3101.1-3101.34: (9.5): Vector.elems failed Read-Write Right-Mover Check
// 3169.1-3169.34: (9.5): Vector.elems failed Read-Write Left-Mover Check
// 3236.1-3236.34: (10.5): Vector.count failed Write-Write Right-Mover Check
// 3303.1-3303.30: (10.5): Vector.count failed Write-Read Right-Mover Check
// 3374.1-3374.34: (10.5): Vector.count failed Write-Write Left-Mover Check
// 3442.1-3442.30: (10.5): Vector.count failed Write-Read Left-Mover Check
// 3507.1-3507.34: (10.5): Vector.count failed Read-Write Right-Mover Check
// 3575.1-3575.34: (10.5): Vector.count failed Read-Write Left-Mover Check
// 3642.1-3642.34: (13.5): Vector.spec failed Write-Write Right-Mover Check
// 3709.1-3709.30: (13.5): Vector.spec failed Write-Read Right-Mover Check
// 3780.1-3780.34: (13.5): Vector.spec failed Write-Write Left-Mover Check
// 3848.1-3848.30: (13.5): Vector.spec failed Write-Read Left-Mover Check
// 3913.1-3913.34: (13.5): Vector.spec failed Read-Write Right-Mover Check
// 3981.1-3981.34: (13.5): Vector.spec failed Read-Write Left-Mover Check
// 4054.1-4054.34: (7.5): Array Array.Vector.T failed Write-Write Right-Mover Check
// 4127.1-4127.30: (7.5): Array Array.Vector.T failed Write-Read Right-Mover Check
// 4204.1-4204.34: (7.5): Array Array.Vector.T failed Write-Write Left-Mover Check
// 4278.1-4278.30: (7.5): Array Array.Vector.T failed Write-Read Left-Mover Check
// 4349.1-4349.34: (7.5): Array Array.Vector.T failed Read-Write Right-Mover Check
// 4423.1-4423.34: (7.5): Array Array.Vector.T failed Read-Write Left-Mover Check
// 4502.1-4502.140: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.elems (case A.1)
// 4503.1-4503.101: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.elems (case A.2)
// 4504.1-4504.158: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.elems (case A.3)
// 4612.1-4612.140: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.elems (case C)
// 4725.1-4725.144: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.elems (case D)
// 4726.1-4726.144: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.elems (case R)
// 4805.1-4805.136: (9.5): Vector.elems is not Read-Write Stable with respect to Vector.elems (case F)
// 4806.1-4806.136: (9.5): Vector.elems is not Read-Write Stable with respect to Vector.elems (case H)
// 4807.1-4807.146: (9.5): Vector.elems is not Read-Write Stable with respect to Vector.elems (case I)
// 4885.1-4885.136: (9.5): Vector.elems is not Write-Read Stable with respect to Vector.elems (case J)
// 4886.1-4886.136: (9.5): Vector.elems is not Write-Read Stable with respect to Vector.elems (case K)
// 4887.1-4887.99: (9.5): Vector.elems is not Write-Read Stable with respect to Vector.elems (case L)
// 4967.1-4967.140: (10.5): Vector.count is not Write-Write Stable with respect to Vector.elems (case A.1)
// 4968.1-4968.101: (10.5): Vector.count is not Write-Write Stable with respect to Vector.elems (case A.2)
// 4969.1-4969.158: (10.5): Vector.count is not Write-Write Stable with respect to Vector.elems (case A.3)
// 5077.1-5077.140: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.count (case C)
// 5190.1-5190.144: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.count (case D)
// 5191.1-5191.144: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.count (case R)
// 5270.1-5270.136: (9.5): Vector.elems is not Read-Write Stable with respect to Vector.count (case F)
// 5271.1-5271.136: (9.5): Vector.elems is not Read-Write Stable with respect to Vector.count (case H)
// 5272.1-5272.146: (9.5): Vector.elems is not Read-Write Stable with respect to Vector.count (case I)
// 5350.1-5350.136: (10.5): Vector.count is not Write-Read Stable with respect to Vector.elems (case J)
// 5351.1-5351.136: (10.5): Vector.count is not Write-Read Stable with respect to Vector.elems (case K)
// 5352.1-5352.99: (10.5): Vector.count is not Write-Read Stable with respect to Vector.elems (case L)
// 5432.1-5432.140: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.elems (case A.1)
// 5433.1-5433.101: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.elems (case A.2)
// 5434.1-5434.158: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.elems (case A.3)
// 5542.1-5542.140: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.spec (case C)
// 5655.1-5655.144: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.spec (case D)
// 5656.1-5656.144: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.spec (case R)
// 5735.1-5735.136: (9.5): Vector.elems is not Read-Write Stable with respect to Vector.spec (case F)
// 5736.1-5736.136: (9.5): Vector.elems is not Read-Write Stable with respect to Vector.spec (case H)
// 5737.1-5737.146: (9.5): Vector.elems is not Read-Write Stable with respect to Vector.spec (case I)
// 5815.1-5815.136: (13.5): Vector.spec is not Write-Read Stable with respect to Vector.elems (case J)
// 5816.1-5816.136: (13.5): Vector.spec is not Write-Read Stable with respect to Vector.elems (case K)
// 5817.1-5817.99: (13.5): Vector.spec is not Write-Read Stable with respect to Vector.elems (case L)
// 5902.1-5902.140: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.elems (case A.1)
// 5903.1-5903.101: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.elems (case A.2)
// 5904.1-5904.156: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.elems (case A.3)
// 6019.1-6019.140: (9.5): Vector.elems is not Write-Write Stable with respect to Array Array.Vector.T (case C)
// 6139.1-6139.144: (9.5): Vector.elems is not Write-Write Stable with respect to Array Array.Vector.T (case D)
// 6140.1-6140.144: (9.5): Vector.elems is not Write-Write Stable with respect to Array Array.Vector.T (case R)
// 6224.1-6224.136: (9.5): Vector.elems is not Read-Write Stable with respect to Array Array.Vector.T (case F)
// 6225.1-6225.136: (9.5): Vector.elems is not Read-Write Stable with respect to Array Array.Vector.T (case H)
// 6226.1-6226.144: (9.5): Vector.elems is not Read-Write Stable with respect to Array Array.Vector.T (case I)
// 6309.1-6309.136: (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.elems (case J)
// 6310.1-6310.136: (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.elems (case K)
// 6311.1-6311.99: (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.elems (case L)
// 6391.1-6391.140: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.count (case A.1)
// 6392.1-6392.101: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.count (case A.2)
// 6393.1-6393.158: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.count (case A.3)
// 6501.1-6501.140: (10.5): Vector.count is not Write-Write Stable with respect to Vector.elems (case C)
// 6614.1-6614.144: (10.5): Vector.count is not Write-Write Stable with respect to Vector.elems (case D)
// 6615.1-6615.144: (10.5): Vector.count is not Write-Write Stable with respect to Vector.elems (case R)
// 6694.1-6694.136: (10.5): Vector.count is not Read-Write Stable with respect to Vector.elems (case F)
// 6695.1-6695.136: (10.5): Vector.count is not Read-Write Stable with respect to Vector.elems (case H)
// 6696.1-6696.146: (10.5): Vector.count is not Read-Write Stable with respect to Vector.elems (case I)
// 6774.1-6774.136: (9.5): Vector.elems is not Write-Read Stable with respect to Vector.count (case J)
// 6775.1-6775.136: (9.5): Vector.elems is not Write-Read Stable with respect to Vector.count (case K)
// 6776.1-6776.99: (9.5): Vector.elems is not Write-Read Stable with respect to Vector.count (case L)
// 6856.1-6856.140: (10.5): Vector.count is not Write-Write Stable with respect to Vector.count (case A.1)
// 6857.1-6857.101: (10.5): Vector.count is not Write-Write Stable with respect to Vector.count (case A.2)
// 6858.1-6858.158: (10.5): Vector.count is not Write-Write Stable with respect to Vector.count (case A.3)
// 6966.1-6966.140: (10.5): Vector.count is not Write-Write Stable with respect to Vector.count (case C)
// 7079.1-7079.144: (10.5): Vector.count is not Write-Write Stable with respect to Vector.count (case D)
// 7080.1-7080.144: (10.5): Vector.count is not Write-Write Stable with respect to Vector.count (case R)
// 7159.1-7159.136: (10.5): Vector.count is not Read-Write Stable with respect to Vector.count (case F)
// 7160.1-7160.136: (10.5): Vector.count is not Read-Write Stable with respect to Vector.count (case H)
// 7161.1-7161.146: (10.5): Vector.count is not Read-Write Stable with respect to Vector.count (case I)
// 7239.1-7239.136: (10.5): Vector.count is not Write-Read Stable with respect to Vector.count (case J)
// 7240.1-7240.136: (10.5): Vector.count is not Write-Read Stable with respect to Vector.count (case K)
// 7241.1-7241.99: (10.5): Vector.count is not Write-Read Stable with respect to Vector.count (case L)
// 7321.1-7321.140: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.count (case A.1)
// 7322.1-7322.101: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.count (case A.2)
// 7323.1-7323.158: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.count (case A.3)
// 7431.1-7431.140: (10.5): Vector.count is not Write-Write Stable with respect to Vector.spec (case C)
// 7544.1-7544.144: (10.5): Vector.count is not Write-Write Stable with respect to Vector.spec (case D)
// 7545.1-7545.144: (10.5): Vector.count is not Write-Write Stable with respect to Vector.spec (case R)
// 7624.1-7624.136: (10.5): Vector.count is not Read-Write Stable with respect to Vector.spec (case F)
// 7625.1-7625.136: (10.5): Vector.count is not Read-Write Stable with respect to Vector.spec (case H)
// 7626.1-7626.146: (10.5): Vector.count is not Read-Write Stable with respect to Vector.spec (case I)
// 7704.1-7704.136: (13.5): Vector.spec is not Write-Read Stable with respect to Vector.count (case J)
// 7705.1-7705.136: (13.5): Vector.spec is not Write-Read Stable with respect to Vector.count (case K)
// 7706.1-7706.99: (13.5): Vector.spec is not Write-Read Stable with respect to Vector.count (case L)
// 7791.1-7791.140: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.count (case A.1)
// 7792.1-7792.101: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.count (case A.2)
// 7793.1-7793.156: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.count (case A.3)
// 7908.1-7908.140: (10.5): Vector.count is not Write-Write Stable with respect to Array Array.Vector.T (case C)
// 8028.1-8028.144: (10.5): Vector.count is not Write-Write Stable with respect to Array Array.Vector.T (case D)
// 8029.1-8029.144: (10.5): Vector.count is not Write-Write Stable with respect to Array Array.Vector.T (case R)
// 8113.1-8113.136: (10.5): Vector.count is not Read-Write Stable with respect to Array Array.Vector.T (case F)
// 8114.1-8114.136: (10.5): Vector.count is not Read-Write Stable with respect to Array Array.Vector.T (case H)
// 8115.1-8115.144: (10.5): Vector.count is not Read-Write Stable with respect to Array Array.Vector.T (case I)
// 8198.1-8198.136: (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.count (case J)
// 8199.1-8199.136: (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.count (case K)
// 8200.1-8200.99: (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.count (case L)
// 8280.1-8280.140: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.spec (case A.1)
// 8281.1-8281.101: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.spec (case A.2)
// 8282.1-8282.158: (9.5): Vector.elems is not Write-Write Stable with respect to Vector.spec (case A.3)
// 8390.1-8390.140: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.elems (case C)
// 8503.1-8503.144: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.elems (case D)
// 8504.1-8504.144: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.elems (case R)
// 8583.1-8583.136: (13.5): Vector.spec is not Read-Write Stable with respect to Vector.elems (case F)
// 8584.1-8584.136: (13.5): Vector.spec is not Read-Write Stable with respect to Vector.elems (case H)
// 8585.1-8585.146: (13.5): Vector.spec is not Read-Write Stable with respect to Vector.elems (case I)
// 8663.1-8663.136: (9.5): Vector.elems is not Write-Read Stable with respect to Vector.spec (case J)
// 8664.1-8664.136: (9.5): Vector.elems is not Write-Read Stable with respect to Vector.spec (case K)
// 8665.1-8665.99: (9.5): Vector.elems is not Write-Read Stable with respect to Vector.spec (case L)
// 8745.1-8745.140: (10.5): Vector.count is not Write-Write Stable with respect to Vector.spec (case A.1)
// 8746.1-8746.101: (10.5): Vector.count is not Write-Write Stable with respect to Vector.spec (case A.2)
// 8747.1-8747.158: (10.5): Vector.count is not Write-Write Stable with respect to Vector.spec (case A.3)
// 8855.1-8855.140: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.count (case C)
// 8968.1-8968.144: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.count (case D)
// 8969.1-8969.144: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.count (case R)
// 9048.1-9048.136: (13.5): Vector.spec is not Read-Write Stable with respect to Vector.count (case F)
// 9049.1-9049.136: (13.5): Vector.spec is not Read-Write Stable with respect to Vector.count (case H)
// 9050.1-9050.146: (13.5): Vector.spec is not Read-Write Stable with respect to Vector.count (case I)
// 9128.1-9128.136: (10.5): Vector.count is not Write-Read Stable with respect to Vector.spec (case J)
// 9129.1-9129.136: (10.5): Vector.count is not Write-Read Stable with respect to Vector.spec (case K)
// 9130.1-9130.99: (10.5): Vector.count is not Write-Read Stable with respect to Vector.spec (case L)
// 9210.1-9210.140: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.spec (case A.1)
// 9211.1-9211.101: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.spec (case A.2)
// 9212.1-9212.158: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.spec (case A.3)
// 9320.1-9320.140: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.spec (case C)
// 9433.1-9433.144: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.spec (case D)
// 9434.1-9434.144: (13.5): Vector.spec is not Write-Write Stable with respect to Vector.spec (case R)
// 9513.1-9513.136: (13.5): Vector.spec is not Read-Write Stable with respect to Vector.spec (case F)
// 9514.1-9514.136: (13.5): Vector.spec is not Read-Write Stable with respect to Vector.spec (case H)
// 9515.1-9515.146: (13.5): Vector.spec is not Read-Write Stable with respect to Vector.spec (case I)
// 9593.1-9593.136: (13.5): Vector.spec is not Write-Read Stable with respect to Vector.spec (case J)
// 9594.1-9594.136: (13.5): Vector.spec is not Write-Read Stable with respect to Vector.spec (case K)
// 9595.1-9595.99: (13.5): Vector.spec is not Write-Read Stable with respect to Vector.spec (case L)
// 9680.1-9680.140: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.spec (case A.1)
// 9681.1-9681.101: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.spec (case A.2)
// 9682.1-9682.156: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.spec (case A.3)
// 9797.1-9797.140: (13.5): Vector.spec is not Write-Write Stable with respect to Array Array.Vector.T (case C)
// 9917.1-9917.144: (13.5): Vector.spec is not Write-Write Stable with respect to Array Array.Vector.T (case D)
// 9918.1-9918.144: (13.5): Vector.spec is not Write-Write Stable with respect to Array Array.Vector.T (case R)
// 10002.1-10002.136: (13.5): Vector.spec is not Read-Write Stable with respect to Array Array.Vector.T (case F)
// 10003.1-10003.136: (13.5): Vector.spec is not Read-Write Stable with respect to Array Array.Vector.T (case H)
// 10004.1-10004.144: (13.5): Vector.spec is not Read-Write Stable with respect to Array Array.Vector.T (case I)
// 10087.1-10087.136: (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.spec (case J)
// 10088.1-10088.136: (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.spec (case K)
// 10089.1-10089.99: (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Vector.spec (case L)
// 10174.1-10174.140: (9.5): Vector.elems is not Write-Write Stable with respect to Array Array.Vector.T (case A.1)
// 10175.1-10175.101: (9.5): Vector.elems is not Write-Write Stable with respect to Array Array.Vector.T (case A.2)
// 10176.1-10176.156: (9.5): Vector.elems is not Write-Write Stable with respect to Array Array.Vector.T (case A.3)
// 10291.1-10291.140: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.elems (case C)
// 10411.1-10411.144: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.elems (case D)
// 10412.1-10412.144: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.elems (case R)
// 10496.1-10496.136: (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.elems (case F)
// 10497.1-10497.136: (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.elems (case H)
// 10498.1-10498.144: (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.elems (case I)
// 10581.1-10581.136: (9.5): Vector.elems is not Write-Read Stable with respect to Array Array.Vector.T (case J)
// 10582.1-10582.136: (9.5): Vector.elems is not Write-Read Stable with respect to Array Array.Vector.T (case K)
// 10583.1-10583.99: (9.5): Vector.elems is not Write-Read Stable with respect to Array Array.Vector.T (case L)
// 10668.1-10668.140: (10.5): Vector.count is not Write-Write Stable with respect to Array Array.Vector.T (case A.1)
// 10669.1-10669.101: (10.5): Vector.count is not Write-Write Stable with respect to Array Array.Vector.T (case A.2)
// 10670.1-10670.156: (10.5): Vector.count is not Write-Write Stable with respect to Array Array.Vector.T (case A.3)
// 10785.1-10785.140: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.count (case C)
// 10905.1-10905.144: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.count (case D)
// 10906.1-10906.144: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.count (case R)
// 10990.1-10990.136: (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.count (case F)
// 10991.1-10991.136: (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.count (case H)
// 10992.1-10992.144: (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.count (case I)
// 11075.1-11075.136: (10.5): Vector.count is not Write-Read Stable with respect to Array Array.Vector.T (case J)
// 11076.1-11076.136: (10.5): Vector.count is not Write-Read Stable with respect to Array Array.Vector.T (case K)
// 11077.1-11077.99: (10.5): Vector.count is not Write-Read Stable with respect to Array Array.Vector.T (case L)
// 11162.1-11162.140: (13.5): Vector.spec is not Write-Write Stable with respect to Array Array.Vector.T (case A.1)
// 11163.1-11163.101: (13.5): Vector.spec is not Write-Write Stable with respect to Array Array.Vector.T (case A.2)
// 11164.1-11164.156: (13.5): Vector.spec is not Write-Write Stable with respect to Array Array.Vector.T (case A.3)
// 11279.1-11279.140: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.spec (case C)
// 11399.1-11399.144: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.spec (case D)
// 11400.1-11400.144: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Vector.spec (case R)
// 11484.1-11484.136: (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.spec (case F)
// 11485.1-11485.136: (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.spec (case H)
// 11486.1-11486.144: (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Vector.spec (case I)
// 11569.1-11569.136: (13.5): Vector.spec is not Write-Read Stable with respect to Array Array.Vector.T (case J)
// 11570.1-11570.136: (13.5): Vector.spec is not Write-Read Stable with respect to Array Array.Vector.T (case K)
// 11571.1-11571.99: (13.5): Vector.spec is not Write-Read Stable with respect to Array Array.Vector.T (case L)
// 11661.1-11661.140: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Array Array.Vector.T (case A.1)
// 11662.1-11662.101: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Array Array.Vector.T (case A.2)
// 11663.1-11663.156: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Array Array.Vector.T (case A.3)
// 11785.1-11785.140: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Array Array.Vector.T (case C)
// 11912.1-11912.144: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Array Array.Vector.T (case D)
// 11913.1-11913.144: (7.5): Array Array.Vector.T is not Write-Write Stable with respect to Array Array.Vector.T (case R)
// 12002.1-12002.136: (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Array Array.Vector.T (case F)
// 12003.1-12003.136: (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Array Array.Vector.T (case H)
// 12004.1-12004.144: (7.5): Array Array.Vector.T is not Read-Write Stable with respect to Array Array.Vector.T (case I)
// 12092.1-12092.136: (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Array Array.Vector.T (case J)
// 12093.1-12093.136: (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Array Array.Vector.T (case K)
// 12094.1-12094.99: (7.5): Array Array.Vector.T is not Write-Read Stable with respect to Array Array.Vector.T (case L)
// 12101.1-12101.298: (<undefined position>): Object invariant may not hold.
// 12102.1-12102.298: (<undefined position>): Object invariant may not hold.
// 12112.1-12112.297: (<undefined position>): Object invariant may not hold.
// 12113.1-12113.297: (<undefined position>): Object invariant may not hold.
// 12133.1-12157.2: (9.5): yields_as clause for Vector.elems is not valid
// 12162.1-12181.2: (9.5): yields_as clause for Vector.elems is not reflexive
// 12187.1-12187.298: (9.24): Object invariant may not hold.
// 12188.1-12188.298: (9.24): Object invariant may not hold.
// 12189.1-12227.2: (9.5): yields_as clause for Vector.elems is not transitive
// 12246.1-12270.2: (10.5): yields_as clause for Vector.count is not valid
// 12275.1-12294.2: (10.5): yields_as clause for Vector.count is not reflexive
// 12300.1-12300.298: (10.24): Object invariant may not hold.
// 12301.1-12301.298: (10.24): Object invariant may not hold.
// 12302.1-12340.2: (10.5): yields_as clause for Vector.count is not transitive
// 12359.1-12383.2: (13.5): yields_as clause for Vector.spec is not valid
// 12388.1-12407.2: (13.5): yields_as clause for Vector.spec is not reflexive
// 12413.1-12413.298: (13.37): Object invariant may not hold.
// 12414.1-12414.298: (13.37): Object invariant may not hold.
// 12415.1-12453.2: (13.5): yields_as clause for Vector.spec is not transitive
// 12473.1-12497.2: (7.32): yields_as clause for Vector._lock is not valid
// 12502.1-12521.2: (7.32): yields_as clause for Vector._lock is not reflexive
// 12527.1-12527.298: (3.1): Object invariant may not hold.
// 12528.1-12528.298: (3.1): Object invariant may not hold.
// 12529.1-12567.2: (7.32): yields_as clause for Vector._lock is not transitive
// 12585.1-12613.2: (7.5): yields_as clause for Array.Vector.T is not valid
// 12614.1-12639.2: (7.5): yields_as clause for Array.Vector.T is not reflexive
// 12644.1-12644.298: (7.28): Object invariant may not hold.
// 12645.1-12645.298: (7.28): Object invariant may not hold.
// 12646.1-12688.2: (7.5): yields_as clause for Array.Vector.T is not transitive
