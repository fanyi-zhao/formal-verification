                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/fzhao12/Synchronicity/workspace/Synchronicity/tests/atomic-mark-reference-shaz.anchor:       
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        // return;                                                                                  
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Ref {                                                                                     
       Node reference isLocal(this, tid)                                                            
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(Node reference,boolean mark) {                                                      
        assume this.reference == Node.null;                                                         
        assume this.mark == false;                                                                  
        {                                                                                           
          this.reference := reference;                                                              
          this.mark := mark;                                                                        
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      noABA volatile Ref pair isLocal(this, tid)                                                    
       ? isRead                                                                                     
         ? B                                                                                        
         : isLocal(newValue, tid) ? B : E                                                           
       : isRead                                                                                     
         ? N                                                                                        
         : isLocal(newValue, tid) ? N : E                                                           
        yields_as newValue == this.pair || !isLocal(newValue, tid) && !isShared(newValue) && newValue != Ref.null;
                                                                                                    
                                                                                                    
      invariant  this.pair != Ref.null;                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.pair == Ref.null;                                                               
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public Node getReference() {                                                                  
        Node tmp1;                                                                                  
        Ref tmp2;                                                                                   
        tmp2 := this.pair;                                                                          
        tmp1 := tmp2.reference;                                                                     
         return tmp1;                                                                               
        // return Node.null;                                                                        
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public boolean isMarked() {                                                                   
        boolean tmp3;                                                                               
        Ref tmp4;                                                                                   
        tmp4 := this.pair;                                                                          
        tmp3 := tmp4.mark;                                                                          
         return tmp3;                                                                               
        // return false;                                                                            
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public boolean compareAndSet(Node expectedReference,Node newReference,boolean expectedMark,boolean newMark) {
        Ref current;                                                                                
        current := this.pair;                                                                       
        boolean tmp5;                                                                               
        boolean tmp6;                                                                               
        boolean tmp7;                                                                               
        Node tmp8;                                                                                  
        tmp8 := current.reference;                                                                  
        tmp7 = expectedReference == tmp8;                                                           
        if (tmp7) {                                                                                 
          boolean tmp9;                                                                             
          tmp9 := current.mark;                                                                     
          tmp6 = expectedMark == tmp9;                                                              
        } else {                                                                                    
          tmp6 = false;                                                                             
        }                                                                                           
        if (tmp6) {                                                                                 
          Ref tmp10;                                                                                
          tmp10 = new Ref();                                                                        
          tmp10.init(newReference,newMark)                                                          
          tmp5 = this.pair@current :~ tmp10;                                                        
        } else {                                                                                    
          tmp5 = false;                                                                             
        }                                                                                           
         return tmp5;                                                                               
        // return false;                                                                            
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Ref {                                                                                     
       Node reference isLocal(this, tid)                                                            
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(Node reference,boolean mark) {                                                      
        assume this.reference == Node.null;                                                         
        assume this.mark == false;                                                                  
        {                                                                                           
          this.reference := reference;                                                              
          this.mark := mark;                                                                        
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      hasCASOperation noABA volatile Ref pair isLocal(this, tid)                                    
       ? isRead                                                                                     
         ? B                                                                                        
         : isLocal(newValue, tid) ? B : E                                                           
       : isRead                                                                                     
         ? N                                                                                        
         : isLocal(newValue, tid) ? N : E                                                           
        yields_as newValue == this.pair || !isLocal(newValue, tid) && !isShared(newValue) && newValue != Ref.null;
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid pair_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.pair_nextThread == tid ? N : E                                                        
        yields_as this.pair_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Ref pair_nextValue isLocal(this, tid)                                           
       ? B                                                                                          
       : this.pair_nextThread == tid ? N : E                                                        
        yields_as this.pair_nextThread == tid ==> newValue == this.pair_nextValue;                  
                                                                                                    
                                                                                                    
      invariant  this.pair != Ref.null;                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.pair == Ref.null;                                                               
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public Node getReference() {                                                                  
        Node tmp1;                                                                                  
        Ref tmp2;                                                                                   
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Ref _C_v;                                                                                 
          _C_v := this.pair_nextValue  as B;                                                        
          Ref _currentValue;                                                                        
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp2 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp2 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        tmp1 := tmp2.reference;                                                                     
        {                                                                                           
           return tmp1;                                                                             
        }                                                                                           
        {                                                                                           
          // return Node.null;                                                                      
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public boolean isMarked() {                                                                   
        boolean tmp3;                                                                               
        Ref tmp4;                                                                                   
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Ref _C_v;                                                                                 
          _C_v := this.pair_nextValue  as B;                                                        
          Ref _currentValue;                                                                        
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp4 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp4 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        tmp3 := tmp4.mark;                                                                          
        {                                                                                           
           return tmp3;                                                                             
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public boolean compareAndSet(Node expectedReference,Node newReference,boolean expectedMark,boolean newMark) {
        Ref current;                                                                                
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Ref _C_v;                                                                                 
          _C_v := this.pair_nextValue  as B;                                                        
          Ref _currentValue;                                                                        
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            current := this.pair  as R;                                                             
          } else {                                                                                  
            noop(TraceOn);                                                                          
            current := this.pair;                                                                   
          }                                                                                         
        }                                                                                           
        boolean tmp5;                                                                               
        boolean tmp6;                                                                               
        boolean tmp7;                                                                               
        Node tmp8;                                                                                  
        tmp8 := current.reference;                                                                  
        tmp7 = expectedReference == tmp8;                                                           
        if (tmp7) {                                                                                 
          boolean tmp9;                                                                             
          tmp9 := current.mark;                                                                     
          tmp6 = expectedMark == tmp9;                                                              
        } else {                                                                                    
          tmp6 = false;                                                                             
        }                                                                                           
        if (tmp6) {                                                                                 
          Ref tmp10;                                                                                
          tmp10 = new Ref();                                                                        
          tmp10.init(newReference,newMark)                                                          
          {                                                                                         
            noop(TraceOff);                                                                         
            boolean ctmp192283;                                                                     
            ctmp192283 = *;                                                                         
            if (ctmp192283) {                                                                       
              noop(TraceOn);                                                                        
              tmp5 = false;                                                                         
            } else {                                                                                
              ctmp192283 = *;                                                                       
              if (ctmp192283) {                                                                     
                Tid tmpTid;                                                                         
                Ref tmpValue;                                                                       
                Mover _m;                                                                           
                _m = writePermission(this.pair, tmp10);                                             
                assume this.pair == current;                                                        
                assume !goesWrong(_m);                                                              
                assume this.pair_nextThread == tid;                                                 
                assume this.pair_nextValue == current;                                              
                this.pair_nextThread := tmpTid as B;                                                
                this.pair_nextValue := tmpValue as B;                                               
                noop(TraceOn);                                                                      
                this.pair := tmp10;                                                                 
                tmp5 = true;                                                                        
              } else {                                                                              
                assume this.pair_nextThread == tid;                                                 
                assume this.pair_nextValue == current;                                              
                Ref _currentValue;                                                                  
                _currentValue := this.pair  as B;                                                   
                this.pair := current as B;                                                          
                Mover _m;                                                                           
                _m = writePermission(this.pair, tmp10);                                             
                this.pair := _currentValue as B;                                                    
                assume goesWrong(_m);                                                               
                noop(TraceOn);                                                                      
                this.pair := tmp10;                                                                 
                tmp5 = false;                                                                       
              }                                                                                     
            }                                                                                       
          }                                                                                         
        } else {                                                                                    
          tmp5 = false;                                                                             
        }                                                                                           
        {                                                                                           
           return tmp5;                                                                             
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Ref {                                                                                     
       Node reference isLocal(this, tid)                                                            
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(Node reference,boolean mark) {                                                      
        assume this.reference == Node.null;                                                         
        assume this.mark == false;                                                                  
        {                                                                                           
          this.reference := reference;                                                              
          this.mark := mark;                                                                        
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      hasCASOperation noABA volatile Ref pair isLocal(this, tid)                                    
       ? isRead                                                                                     
         ? B                                                                                        
         : isLocal(newValue, tid) ? B : E                                                           
       : isRead                                                                                     
         ? N                                                                                        
         : isLocal(newValue, tid) ? N : E                                                           
        yields_as newValue == this.pair || !isLocal(newValue, tid) && !isShared(newValue) && newValue != Ref.null;
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid pair_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.pair_nextThread == tid ? N : E                                                        
        yields_as this.pair_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Ref pair_nextValue isLocal(this, tid)                                           
       ? B                                                                                          
       : this.pair_nextThread == tid ? N : E                                                        
        yields_as this.pair_nextThread == tid ==> newValue == this.pair_nextValue;                  
                                                                                                    
                                                                                                    
      invariant  this.pair != Ref.null;                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.pair == Ref.null;                                                               
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public Node getReference() {                                                                  
        Node tmp1;                                                                                  
        Ref tmp2;                                                                                   
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Ref _C_v;                                                                                 
          _C_v := this.pair_nextValue  as B;                                                        
          Ref _currentValue;                                                                        
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp2 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp2 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        tmp1 := tmp2.reference;                                                                     
        {                                                                                           
           return tmp1;                                                                             
        }                                                                                           
        {                                                                                           
          // return Node.null;                                                                      
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public boolean isMarked() {                                                                   
        boolean tmp3;                                                                               
        Ref tmp4;                                                                                   
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Ref _C_v;                                                                                 
          _C_v := this.pair_nextValue  as B;                                                        
          Ref _currentValue;                                                                        
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp4 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp4 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        tmp3 := tmp4.mark;                                                                          
        {                                                                                           
           return tmp3;                                                                             
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public boolean compareAndSet(Node expectedReference,Node newReference,boolean expectedMark,boolean newMark) {
        Ref current;                                                                                
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Ref _C_v;                                                                                 
          _C_v := this.pair_nextValue  as B;                                                        
          Ref _currentValue;                                                                        
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            current := this.pair  as R;                                                             
          } else {                                                                                  
            noop(TraceOn);                                                                          
            current := this.pair;                                                                   
          }                                                                                         
        }                                                                                           
        boolean tmp5;                                                                               
        boolean tmp6;                                                                               
        boolean tmp7;                                                                               
        Node tmp8;                                                                                  
        tmp8 := current.reference;                                                                  
        tmp7 = expectedReference == tmp8;                                                           
        if (tmp7) {                                                                                 
          boolean tmp9;                                                                             
          tmp9 := current.mark;                                                                     
          tmp6 = expectedMark == tmp9;                                                              
        } else {                                                                                    
          tmp6 = false;                                                                             
        }                                                                                           
        if (tmp6) {                                                                                 
          Ref tmp10;                                                                                
          tmp10 = new Ref();                                                                        
          {                                                                                         
            inlined tmp10.init(newReference,newMark);                                               
            exit$1: {                                                                               
              Node reference$1;                                                                     
              boolean mark$1;                                                                       
              Ref this$1;                                                                           
              reference$1 = newReference;                                                           
              mark$1 = newMark;                                                                     
              this$1 = tmp10;                                                                       
              {                                                                                     
                assume this$1.reference == Node.null;                                               
                assume this$1.mark == false;                                                        
                {                                                                                   
                  this$1.reference := reference$1;                                                  
                  this$1.mark := mark$1;                                                            
                  {                                                                                 
                    break exit$1;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            }                                                                                       
            inlined return;                                                                         
          }                                                                                         
          {                                                                                         
            noop(TraceOff);                                                                         
            boolean ctmp192283;                                                                     
            ctmp192283 = *;                                                                         
            if (ctmp192283) {                                                                       
              noop(TraceOn);                                                                        
              tmp5 = false;                                                                         
            } else {                                                                                
              ctmp192283 = *;                                                                       
              if (ctmp192283) {                                                                     
                Tid tmpTid;                                                                         
                Ref tmpValue;                                                                       
                Mover _m;                                                                           
                _m = writePermission(this.pair, tmp10);                                             
                assume this.pair == current;                                                        
                assume !goesWrong(_m);                                                              
                assume this.pair_nextThread == tid;                                                 
                assume this.pair_nextValue == current;                                              
                this.pair_nextThread := tmpTid as B;                                                
                this.pair_nextValue := tmpValue as B;                                               
                noop(TraceOn);                                                                      
                this.pair := tmp10;                                                                 
                tmp5 = true;                                                                        
              } else {                                                                              
                assume this.pair_nextThread == tid;                                                 
                assume this.pair_nextValue == current;                                              
                Ref _currentValue;                                                                  
                _currentValue := this.pair  as B;                                                   
                this.pair := current as B;                                                          
                Mover _m;                                                                           
                _m = writePermission(this.pair, tmp10);                                             
                this.pair := _currentValue as B;                                                    
                assume goesWrong(_m);                                                               
                noop(TraceOn);                                                                      
                this.pair := tmp10;                                                                 
                tmp5 = false;                                                                       
              }                                                                                     
            }                                                                                       
          }                                                                                         
        } else {                                                                                    
          tmp5 = false;                                                                             
        }                                                                                           
        {                                                                                           
           return tmp5;                                                                             
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Ref {                                                                                     
       Node reference isLocal(this, tid)                                                            
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(Node reference,boolean mark) {                                                      
        assume this.reference == Node.null;                                                         
        assume this.mark == false;                                                                  
        {                                                                                           
          this.reference := reference;                                                              
          this.mark := mark;                                                                        
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      hasCASOperation noABA volatile Ref pair isLocal(this, tid)                                    
       ? isRead                                                                                     
         ? B                                                                                        
         : isLocal(newValue, tid) ? B : E                                                           
       : isRead                                                                                     
         ? N                                                                                        
         : isLocal(newValue, tid) ? N : E                                                           
        yields_as newValue == this.pair || !isLocal(newValue, tid) && !isShared(newValue) && newValue != Ref.null;
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid pair_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.pair_nextThread == tid ? N : E                                                        
        yields_as this.pair_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Ref pair_nextValue isLocal(this, tid)                                           
       ? B                                                                                          
       : this.pair_nextThread == tid ? N : E                                                        
        yields_as this.pair_nextThread == tid ==> newValue == this.pair_nextValue;                  
                                                                                                    
                                                                                                    
      invariant  this.pair != Ref.null;                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.pair == Ref.null;                                                               
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public Node getReference() {                                                                  
        Node tmp1;                                                                                  
        Ref tmp2;                                                                                   
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Ref _C_v;                                                                                 
          _C_v := this.pair_nextValue  as B;                                                        
          Ref _currentValue;                                                                        
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp2 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp2 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        tmp1 := tmp2.reference;                                                                     
        {                                                                                           
           return tmp1;                                                                             
        }                                                                                           
        {                                                                                           
          // return Node.null;                                                                      
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public boolean isMarked() {                                                                   
        boolean tmp3;                                                                               
        Ref tmp4;                                                                                   
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Ref _C_v;                                                                                 
          _C_v := this.pair_nextValue  as B;                                                        
          Ref _currentValue;                                                                        
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            tmp4 := this.pair  as R;                                                                
          } else {                                                                                  
            noop(TraceOn);                                                                          
            tmp4 := this.pair;                                                                      
          }                                                                                         
        }                                                                                           
        tmp3 := tmp4.mark;                                                                          
        {                                                                                           
           return tmp3;                                                                             
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public boolean compareAndSet(Node expectedReference,Node newReference,boolean expectedMark,boolean newMark) {
        Ref current;                                                                                
        {                                                                                           
          noop(TraceOff);                                                                           
          Tid _C_t;                                                                                 
          _C_t := this.pair_nextThread  as B;                                                       
          Ref _C_v;                                                                                 
          _C_v := this.pair_nextValue  as B;                                                        
          Ref _currentValue;                                                                        
          _currentValue := this.pair  as B;                                                         
          Mover _R_t;                                                                               
          _R_t = readPermission(this.pair);                                                         
          boolean _casable;                                                                         
          _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
          if (_casable) {                                                                           
            noop(TraceOn);                                                                          
            current := this.pair  as R;                                                             
          } else {                                                                                  
            noop(TraceOn);                                                                          
            current := this.pair;                                                                   
          }                                                                                         
        }                                                                                           
        boolean tmp5;                                                                               
        boolean tmp6;                                                                               
        boolean tmp7;                                                                               
        Node tmp8;                                                                                  
        tmp8 := current.reference;                                                                  
        tmp7 = expectedReference == tmp8;                                                           
        if (tmp7) {                                                                                 
          boolean tmp9;                                                                             
          tmp9 := current.mark;                                                                     
          tmp6 = expectedMark == tmp9;                                                              
        } else {                                                                                    
          tmp6 = false;                                                                             
        }                                                                                           
        if (tmp6) {                                                                                 
          Ref tmp10;                                                                                
          tmp10 = new Ref();                                                                        
          {                                                                                         
            inlined tmp10.init(newReference,newMark);                                               
            exit$1: {                                                                               
              Node reference$1;                                                                     
              boolean mark$1;                                                                       
              Ref this$1;                                                                           
              reference$1 = newReference;                                                           
              mark$1 = newMark;                                                                     
              this$1 = tmp10;                                                                       
              {                                                                                     
                assume this$1.reference == Node.null;                                               
                assume this$1.mark == false;                                                        
                {                                                                                   
                  this$1.reference := reference$1;                                                  
                  this$1.mark := mark$1;                                                            
                  {                                                                                 
                    break exit$1;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            }                                                                                       
            inlined return;                                                                         
          }                                                                                         
          {                                                                                         
            noop(TraceOff);                                                                         
            boolean ctmp192283;                                                                     
            ctmp192283 = *;                                                                         
            if (ctmp192283) {                                                                       
              noop(TraceOn);                                                                        
              tmp5 = false;                                                                         
            } else {                                                                                
              ctmp192283 = *;                                                                       
              if (ctmp192283) {                                                                     
                Tid tmpTid;                                                                         
                Ref tmpValue;                                                                       
                Mover _m;                                                                           
                _m = writePermission(this.pair, tmp10);                                             
                assume this.pair == current;                                                        
                assume !goesWrong(_m);                                                              
                assume this.pair_nextThread == tid;                                                 
                assume this.pair_nextValue == current;                                              
                this.pair_nextThread := tmpTid as B;                                                
                this.pair_nextValue := tmpValue as B;                                               
                noop(TraceOn);                                                                      
                this.pair := tmp10;                                                                 
                tmp5 = true;                                                                        
              } else {                                                                              
                assume this.pair_nextThread == tid;                                                 
                assume this.pair_nextValue == current;                                              
                Ref _currentValue;                                                                  
                _currentValue := this.pair  as B;                                                   
                this.pair := current as B;                                                          
                Mover _m;                                                                           
                _m = writePermission(this.pair, tmp10);                                             
                this.pair := _currentValue as B;                                                    
                assume goesWrong(_m);                                                               
                noop(TraceOn);                                                                      
                this.pair := tmp10;                                                                 
                tmp5 = false;                                                                       
              }                                                                                     
            }                                                                                       
          }                                                                                         
        } else {                                                                                    
          tmp5 = false;                                                                             
        }                                                                                           
        {                                                                                           
           return tmp5;                                                                             
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Node ***/                                                                           
                                                                                                    
type Node;                                                                                          
const unique Node.null: Node;                                                                       
var Node._state: [Node]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Node._lock: [Node]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Node._lock(tid: Tid,this : Node,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node._lock(tid: Tid,this : Node,newValue: Tid,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Ref ***/                                                                            
                                                                                                    
type Ref;                                                                                           
const unique Ref.null: Ref;                                                                         
var Ref._state: [Ref]State;                                                                         
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Ref.reference: [Ref]Node;                                                                       
                                                                                                    
function {:inline} ReadEval.Ref.reference(tid: Tid,this : Ref,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Ref._state[this], tid)) then                                                           
  if (isLocal(Ref._state[this], tid)) then                                                          
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Ref.reference(tid: Tid,this : Ref,newValue: Node,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Ref._state[this], tid)) then                                                           
  if (isLocal(Ref._state[this], tid)) then                                                          
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Ref.mark: [Ref]bool;                                                                            
                                                                                                    
function {:inline} ReadEval.Ref.mark(tid: Tid,this : Ref,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := false;                                                                            
 if (isLocal(Ref._state[this], tid)) then                                                           
  if (isLocal(Ref._state[this], tid)) then                                                          
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Ref.mark(tid: Tid,this : Ref,newValue: bool,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Ref._state[this], tid)) then                                                           
  if (isLocal(Ref._state[this], tid)) then                                                          
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Ref._lock: [Ref]Tid;                                                                            
                                                                                                    
function {:inline} ReadEval.Ref._lock(tid: Tid,this : Ref,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Ref._state[this], tid)) then                                                           
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Ref._lock[this]==tid)) then                                                                 
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Ref._lock[this]==Tid.null)&&(newValue==tid))) then                                         
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Ref._lock[this]==tid)&&(newValue==Tid.null))) then                                        
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Ref._lock(tid: Tid,this : Ref,newValue: Tid,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Ref._state[this], tid)) then                                                           
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Ref._lock[this]==tid)) then                                                                 
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Ref._lock[this]==Tid.null)&&(newValue==tid))) then                                         
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Ref._lock[this]==tid)&&(newValue==Tid.null))) then                                        
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl AtomicMarkableReference ***/                                                        
                                                                                                    
type AtomicMarkableReference;                                                                       
const unique AtomicMarkableReference.null: AtomicMarkableReference;                                 
var AtomicMarkableReference._state: [AtomicMarkableReference]State;                                 
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference.pair: [AtomicMarkableReference]Ref;                                     
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference.pair(tid: Tid,this : AtomicMarkableReference,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Ref.null;                                                                         
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (isLocal(Ref._state[newValue], tid)) then                                                     
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   if (isLocal(Ref._state[newValue], tid)) then                                                     
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference.pair(tid: Tid,this : AtomicMarkableReference,newValue: Ref,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (isLocal(Ref._state[newValue], tid)) then                                                     
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   if (isLocal(Ref._state[newValue], tid)) then                                                     
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference._lock: [AtomicMarkableReference]Tid;                                    
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference._lock(tid: Tid,this : AtomicMarkableReference,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((AtomicMarkableReference._lock[this]==tid)) then                                             
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((AtomicMarkableReference._lock[this]==Tid.null)&&(newValue==tid))) then                     
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((AtomicMarkableReference._lock[this]==tid)&&(newValue==Tid.null))) then                    
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference._lock(tid: Tid,this : AtomicMarkableReference,newValue: Tid,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((AtomicMarkableReference._lock[this]==tid)) then                                             
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((AtomicMarkableReference._lock[this]==Tid.null)&&(newValue==tid))) then                     
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((AtomicMarkableReference._lock[this]==tid)&&(newValue==Tid.null))) then                    
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid;                          
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this : AtomicMarkableReference,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((AtomicMarkableReference.pair_nextThread[this]==tid)) then                                    
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this : AtomicMarkableReference,newValue: Tid,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((AtomicMarkableReference.pair_nextThread[this]==tid)) then                                    
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref;                           
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this : AtomicMarkableReference,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Ref.null;                                                                         
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((AtomicMarkableReference.pair_nextThread[this]==tid)) then                                    
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this : AtomicMarkableReference,newValue: Ref,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((AtomicMarkableReference.pair_nextThread[this]==tid)) then                                    
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.AtomicMarkableReference.204864(tid: Tid,this : AtomicMarkableReference,Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (bool) {
 (AtomicMarkableReference.pair[this]!=Ref.null)                                                     
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  AtomicMarkableReference.getReference(tid:Tid, this : AtomicMarkableReference)            
returns ($result : Node)                                                                            
modifies Node._state;                                                                               
modifies Node._lock;                                                                                
modifies Ref._state;                                                                                
modifies Ref.reference;                                                                             
modifies Ref.mark;                                                                                  
modifies Ref._lock;                                                                                 
modifies AtomicMarkableReference._state;                                                            
modifies AtomicMarkableReference.pair;                                                              
modifies AtomicMarkableReference._lock;                                                             
modifies AtomicMarkableReference.pair_nextThread;                                                   
modifies AtomicMarkableReference.pair_nextValue;                                                    
                                                                                                    
requires ValidTid(tid);                                                                                    // (22.5): Bad tid
requires isShared(AtomicMarkableReference._state[this]);                                                   // (22.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (22.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
ensures  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (22.5): Object invariant may not hold.
{                                                                                                   
 var tid211177: Tid;                                                                                
 var Ref.mark211215: [Ref]bool;                                                                     
 var tid211215: Tid;                                                                                
 var AtomicMarkableReference.pair_nextThread211233: [AtomicMarkableReference]Tid;                   
 var AtomicMarkableReference.pair_nextValue211226: [AtomicMarkableReference]Ref;                    
 var AtomicMarkableReference.pair211228: [AtomicMarkableReference]Ref;                              
 var Ref._state211233: [Ref]State;                                                                  
 var $recorded.state211226: int;                                                                    
 var Node._lock211165: [Node]Tid;                                                                   
 var AtomicMarkableReference._state211228: [AtomicMarkableReference]State;                          
 var Node._state211226: [Node]State;                                                                
 var this211215: AtomicMarkableReference;                                                           
 var AtomicMarkableReference.pair_nextValue211233: [AtomicMarkableReference]Ref;                    
 var Ref._lock211215: [Ref]Tid;                                                                     
 var Node._state211233: [Node]State;                                                                
 var $pc211233: Phase;                                                                              
 var AtomicMarkableReference._lock211226: [AtomicMarkableReference]Tid;                             
 var _C_t: Tid;                                                                                     
 var Ref.mark211233: [Ref]bool;                                                                     
 var Ref._lock211220: [Ref]Tid;                                                                     
 var this211233: AtomicMarkableReference;                                                           
 var Ref.mark211177: [Ref]bool;                                                                     
 var Node._state211177: [Node]State;                                                                
 var tmp1211220: Node;                                                                              
 var $recorded.state211233: int;                                                                    
 var tmp2: Ref;                                                                                     
 var tmp1211165: Node;                                                                              
 var $result211177: Node;                                                                           
 var this211220: AtomicMarkableReference;                                                           
 var Node._lock211228: [Node]Tid;                                                                   
 var this211177: AtomicMarkableReference;                                                           
 var _casable: bool;                                                                                
 var AtomicMarkableReference.pair_nextThread211177: [AtomicMarkableReference]Tid;                   
 var AtomicMarkableReference.pair211165: [AtomicMarkableReference]Ref;                              
 var $pc211165: Phase;                                                                              
 var $pc211177: Phase;                                                                              
 var AtomicMarkableReference._state211215: [AtomicMarkableReference]State;                          
 var AtomicMarkableReference._lock211171: [AtomicMarkableReference]Tid;                             
 var Ref._lock211177: [Ref]Tid;                                                                     
 var Node._lock211171: [Node]Tid;                                                                   
 var tmp2211165: Ref;                                                                               
 var $pc211228: Phase;                                                                              
 var _R_t211220: Mover;                                                                             
 var path211220: int;                                                                               
 var AtomicMarkableReference.pair211220: [AtomicMarkableReference]Ref;                              
 var Ref.mark211220: [Ref]bool;                                                                     
 var $recorded.state211165: int;                                                                    
 var AtomicMarkableReference.pair_nextValue211177: [AtomicMarkableReference]Ref;                    
 var tmp2211226: Ref;                                                                               
 var mover211220: Mover;                                                                            
 var tid211233: Tid;                                                                                
 var path211177: int;                                                                               
 var Ref.reference211228: [Ref]Node;                                                                
 var moverPath211177: MoverPath;                                                                    
 var AtomicMarkableReference.pair_nextValue211215: [AtomicMarkableReference]Ref;                    
 var Ref._state211177: [Ref]State;                                                                  
 var Ref._state211220: [Ref]State;                                                                  
 var Node._lock211226: [Node]Tid;                                                                   
 var moverPath211171: MoverPath;                                                                    
 var tmp1211177: Node;                                                                              
 var Node._state211171: [Node]State;                                                                
 var AtomicMarkableReference.pair_nextThread211226: [AtomicMarkableReference]Tid;                   
 var Node._lock211177: [Node]Tid;                                                                   
 var Node._state211165: [Node]State;                                                                
 var tmp1: Node;                                                                                    
 var AtomicMarkableReference.pair_nextThread211171: [AtomicMarkableReference]Tid;                   
 var this211226: AtomicMarkableReference;                                                           
 var $result211215: Node;                                                                           
 var $result211228: Node;                                                                           
 var $pc211226: Phase;                                                                              
 var _currentValue211215: Ref;                                                                      
 var _C_t211171: Tid;                                                                               
 var Ref.reference211233: [Ref]Node;                                                                
 var tmp2211220: Ref;                                                                               
 var _C_t211220: Tid;                                                                               
 var Ref._lock211228: [Ref]Tid;                                                                     
 var _C_t211215: Tid;                                                                               
 var mover211165: Mover;                                                                            
 var Ref._lock211165: [Ref]Tid;                                                                     
 var Ref._state211165: [Ref]State;                                                                  
 var tid211228: Tid;                                                                                
 var $pc211220: Phase;                                                                              
 var mover211215: Mover;                                                                            
 var _currentValue211220: Ref;                                                                      
 var _C_t211165: Tid;                                                                               
 var Ref.reference211171: [Ref]Node;                                                                
 var Ref.reference211165: [Ref]Node;                                                                
 var _C_v211220: Ref;                                                                               
 var AtomicMarkableReference._state211220: [AtomicMarkableReference]State;                          
 var _C_v211171: Ref;                                                                               
 var Node._lock211220: [Node]Tid;                                                                   
 var $result211226: Node;                                                                           
 var AtomicMarkableReference.pair_nextValue211228: [AtomicMarkableReference]Ref;                    
 var AtomicMarkableReference.pair_nextThread211165: [AtomicMarkableReference]Tid;                   
 var moverPath211165: MoverPath;                                                                    
 var tid211171: Tid;                                                                                
 var Ref.mark211228: [Ref]bool;                                                                     
 var Ref.reference211220: [Ref]Node;                                                                
 var _C_v211215: Ref;                                                                               
 var AtomicMarkableReference._lock211220: [AtomicMarkableReference]Tid;                             
 var mover211177: Mover;                                                                            
 var AtomicMarkableReference._lock211177: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference.pair_nextThread211215: [AtomicMarkableReference]Tid;                   
 var _casable211215: bool;                                                                          
 var $pc211171: Phase;                                                                              
 var $result211220: Node;                                                                           
 var Ref._lock211171: [Ref]Tid;                                                                     
 var Ref.reference211226: [Ref]Node;                                                                
 var Ref._state211226: [Ref]State;                                                                  
 var AtomicMarkableReference.pair_nextThread211220: [AtomicMarkableReference]Tid;                   
 var $recorded.state211228: int;                                                                    
 var AtomicMarkableReference._lock211215: [AtomicMarkableReference]Tid;                             
 var tmp1211233: Node;                                                                              
 var tmp2211233: Ref;                                                                               
 var AtomicMarkableReference._lock211228: [AtomicMarkableReference]Tid;                             
 var Ref._state211171: [Ref]State;                                                                  
 var AtomicMarkableReference.pair211226: [AtomicMarkableReference]Ref;                              
 var AtomicMarkableReference._state211226: [AtomicMarkableReference]State;                          
 var mover211171: Mover;                                                                            
 var AtomicMarkableReference.pair_nextThread211228: [AtomicMarkableReference]Tid;                   
 var Ref.mark211171: [Ref]bool;                                                                     
 var $result211171: Node;                                                                           
 var Ref.reference211215: [Ref]Node;                                                                
 var $recorded.state211215: int;                                                                    
 var _R_t: Mover;                                                                                   
 var moverPath211220: MoverPath;                                                                    
 var tmp1211228: Node;                                                                              
 var _R_t211215: Mover;                                                                             
 var tmp2211228: Ref;                                                                               
 var tid211165: Tid;                                                                                
 var Ref._state211228: [Ref]State;                                                                  
 var path211165: int;                                                                               
 var moverPath211226: MoverPath;                                                                    
 var this211165: AtomicMarkableReference;                                                           
 var AtomicMarkableReference.pair211215: [AtomicMarkableReference]Ref;                              
 var AtomicMarkableReference._state211177: [AtomicMarkableReference]State;                          
 var _casable211220: bool;                                                                          
 var AtomicMarkableReference.pair_nextValue211165: [AtomicMarkableReference]Ref;                    
 var Ref._state211215: [Ref]State;                                                                  
 var Ref._lock211226: [Ref]Tid;                                                                     
 var this211171: AtomicMarkableReference;                                                           
 var moverPath211215: MoverPath;                                                                    
 var AtomicMarkableReference.pair211177: [AtomicMarkableReference]Ref;                              
 var AtomicMarkableReference._state211233: [AtomicMarkableReference]State;                          
 var Node._state211228: [Node]State;                                                                
 var tid211226: Tid;                                                                                
 var AtomicMarkableReference.pair211171: [AtomicMarkableReference]Ref;                              
 var Ref.reference211177: [Ref]Node;                                                                
 var $recorded.state211220: int;                                                                    
 var _C_v211177: Ref;                                                                               
 var $result211233: Node;                                                                           
 var tmp1211226: Node;                                                                              
 var tmp2211177: Ref;                                                                               
 var _currentValue211177: Ref;                                                                      
 var Node._state211215: [Node]State;                                                                
 var Ref.mark211226: [Ref]bool;                                                                     
 var path211171: int;                                                                               
 var path211215: int;                                                                               
 var Node._lock211215: [Node]Tid;                                                                   
 var Ref.mark211165: [Ref]bool;                                                                     
 var _C_t211177: Tid;                                                                               
 var $recorded.state211171: int;                                                                    
 var Ref._lock211233: [Ref]Tid;                                                                     
 var this211228: AtomicMarkableReference;                                                           
 var tmp1211215: Node;                                                                              
 var _C_v: Ref;                                                                                     
 var AtomicMarkableReference.pair_nextValue211171: [AtomicMarkableReference]Ref;                    
 var Node._state211220: [Node]State;                                                                
 var $pc211215: Phase;                                                                              
 var AtomicMarkableReference._state211165: [AtomicMarkableReference]State;                          
 var mover211226: Mover;                                                                            
 var path211226: int;                                                                               
 var AtomicMarkableReference._state211171: [AtomicMarkableReference]State;                          
 var tmp2211215: Ref;                                                                               
 var $result211165: Node;                                                                           
 var $recorded.state211177: int;                                                                    
 var tid211220: Tid;                                                                                
 var _currentValue: Ref;                                                                            
 var tmp1211171: Node;                                                                              
 var AtomicMarkableReference.pair_nextValue211220: [AtomicMarkableReference]Ref;                    
 var AtomicMarkableReference._lock211233: [AtomicMarkableReference]Tid;                             
 var tmp2211171: Ref;                                                                               
 var AtomicMarkableReference._lock211165: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference.pair211233: [AtomicMarkableReference]Ref;                              
 var Node._lock211233: [Node]Tid;                                                                   
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 // 23.9: Node tmp1;                                                                                
                                                                                                    
                                                                                                    
 // 23.9: Ref tmp2;                                                                                 
                                                                                                    
 // NoOp: 'TraceOff'                                                                                
                                                                                                    
 // 23.9: Tid _C_t;                                                                                 
                                                                                                    
                                                                                                    
 // 23.9: _C_t := this.pair_nextThread  as B;                                                       
                                                                                                    
                                                                                                    
 moverPath211165 := ReadEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 mover211165 := m#moverPath(moverPath211165);                                                       
 path211165 := p#moverPath(moverPath211165);                                                        
 assume Node._state211165 == Node._state && Node._lock211165 == Node._lock && Ref._state211165 == Ref._state && Ref.reference211165 == Ref.reference && Ref.mark211165 == Ref.mark && Ref._lock211165 == Ref._lock && AtomicMarkableReference._state211165 == AtomicMarkableReference._state && AtomicMarkableReference.pair211165 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211165 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211165 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211165 == AtomicMarkableReference.pair_nextValue && _C_t211165 == _C_t && tmp2211165 == tmp2 && tmp1211165 == tmp1 && $result211165 == $result && this211165 == this && tid211165 == tid && $pc211165 == $pc;
 assume $recorded.state211165 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this != AtomicMarkableReference.null;                                                      
 } else {                                                                                           
  assert this != AtomicMarkableReference.null;                                                             // (23.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (23.9): Reduction failure
 _C_t := AtomicMarkableReference.pair_nextThread[this];                                             
                                                                                                    
 // 23.9: Ref _C_v;                                                                                 
                                                                                                    
                                                                                                    
 // 23.9: _C_v := this.pair_nextValue  as B;                                                        
                                                                                                    
                                                                                                    
 moverPath211171 := ReadEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 mover211171 := m#moverPath(moverPath211171);                                                       
 path211171 := p#moverPath(moverPath211171);                                                        
 assume Node._state211171 == Node._state && Node._lock211171 == Node._lock && Ref._state211171 == Ref._state && Ref.reference211171 == Ref.reference && Ref.mark211171 == Ref.mark && Ref._lock211171 == Ref._lock && AtomicMarkableReference._state211171 == AtomicMarkableReference._state && AtomicMarkableReference.pair211171 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211171 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211171 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211171 == AtomicMarkableReference.pair_nextValue && _C_v211171 == _C_v && _C_t211171 == _C_t && tmp2211171 == tmp2 && tmp1211171 == tmp1 && $result211171 == $result && this211171 == this && tid211171 == tid && $pc211171 == $pc;
 assume $recorded.state211171 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this != AtomicMarkableReference.null;                                                      
 } else {                                                                                           
  assert this != AtomicMarkableReference.null;                                                             // (23.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (23.9): Reduction failure
 _C_v := AtomicMarkableReference.pair_nextValue[this];                                              
                                                                                                    
 // 23.9: Ref _currentValue;                                                                        
                                                                                                    
                                                                                                    
 // 23.9: _currentValue := this.pair  as B;                                                         
                                                                                                    
                                                                                                    
 moverPath211177 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 mover211177 := m#moverPath(moverPath211177);                                                       
 path211177 := p#moverPath(moverPath211177);                                                        
 assume Node._state211177 == Node._state && Node._lock211177 == Node._lock && Ref._state211177 == Ref._state && Ref.reference211177 == Ref.reference && Ref.mark211177 == Ref.mark && Ref._lock211177 == Ref._lock && AtomicMarkableReference._state211177 == AtomicMarkableReference._state && AtomicMarkableReference.pair211177 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211177 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211177 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211177 == AtomicMarkableReference.pair_nextValue && _currentValue211177 == _currentValue && _C_v211177 == _C_v && _C_t211177 == _C_t && tmp2211177 == tmp2 && tmp1211177 == tmp1 && $result211177 == $result && this211177 == this && tid211177 == tid && $pc211177 == $pc;
 assume $recorded.state211177 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this != AtomicMarkableReference.null;                                                      
 } else {                                                                                           
  assert this != AtomicMarkableReference.null;                                                             // (23.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (23.9): Reduction failure
 _currentValue := AtomicMarkableReference.pair[this];                                               
                                                                                                    
 // 23.9: Mover _R_t;                                                                               
                                                                                                    
                                                                                                    
 // 23.9: _R_t = readPermission(this.pair);                                                         
                                                                                                    
 _R_t := m#moverPath(ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));
                                                                                                    
 // 23.9: boolean _casable;                                                                         
                                                                                                    
                                                                                                    
 // 23.9: _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
                                                                                                    
 _casable := ((((_R_t!=_E)&&true)&&(_C_t==tid))&&(_C_v==_currentValue));                            
 if (_casable) {                                                                                    
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 23.9: tmp2 := this.pair  as R;                                                                 
                                                                                                    
                                                                                                    
  moverPath211215 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
  mover211215 := m#moverPath(moverPath211215);                                                      
  path211215 := p#moverPath(moverPath211215);                                                       
  assume Node._state211215 == Node._state && Node._lock211215 == Node._lock && Ref._state211215 == Ref._state && Ref.reference211215 == Ref.reference && Ref.mark211215 == Ref.mark && Ref._lock211215 == Ref._lock && AtomicMarkableReference._state211215 == AtomicMarkableReference._state && AtomicMarkableReference.pair211215 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211215 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211215 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211215 == AtomicMarkableReference.pair_nextValue && _casable211215 == _casable && _R_t211215 == _R_t && _currentValue211215 == _currentValue && _C_v211215 == _C_v && _C_t211215 == _C_t && tmp2211215 == tmp2 && tmp1211215 == tmp1 && $result211215 == $result && this211215 == this && tid211215 == tid && $pc211215 == $pc;
  assume $recorded.state211215 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this != AtomicMarkableReference.null;                                                     
  } else {                                                                                          
   assert this != AtomicMarkableReference.null;                                                            // (23.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _R);                                                                       
  assert $pc != PhaseError;                                                                                // (23.9): Reduction failure
  tmp2 := AtomicMarkableReference.pair[this];                                                       
 } else {                                                                                           
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 23.9: tmp2 := this.pair;                                                                       
                                                                                                    
                                                                                                    
  moverPath211220 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
  mover211220 := m#moverPath(moverPath211220);                                                      
  path211220 := p#moverPath(moverPath211220);                                                       
  assume Node._state211220 == Node._state && Node._lock211220 == Node._lock && Ref._state211220 == Ref._state && Ref.reference211220 == Ref.reference && Ref.mark211220 == Ref.mark && Ref._lock211220 == Ref._lock && AtomicMarkableReference._state211220 == AtomicMarkableReference._state && AtomicMarkableReference.pair211220 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211220 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211220 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211220 == AtomicMarkableReference.pair_nextValue && _casable211220 == _casable && _R_t211220 == _R_t && _currentValue211220 == _currentValue && _C_v211220 == _C_v && _C_t211220 == _C_t && tmp2211220 == tmp2 && tmp1211220 == tmp1 && $result211220 == $result && this211220 == this && tid211220 == tid && $pc211220 == $pc;
  assume $recorded.state211220 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this != AtomicMarkableReference.null;                                                     
  } else {                                                                                          
   assert this != AtomicMarkableReference.null;                                                            // (23.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover211220);                                                              
  assert $pc != PhaseError;                                                                                // (23.9): Reduction failure
  tmp2 := AtomicMarkableReference.pair[this];                                                       
 }                                                                                                  
                                                                                                    
 // 23.9: tmp1 := tmp2.reference;                                                                   
                                                                                                    
                                                                                                    
 moverPath211226 := ReadEval.Ref.reference(tid: Tid,tmp2: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 mover211226 := m#moverPath(moverPath211226);                                                       
 path211226 := p#moverPath(moverPath211226);                                                        
 assume Node._state211226 == Node._state && Node._lock211226 == Node._lock && Ref._state211226 == Ref._state && Ref.reference211226 == Ref.reference && Ref.mark211226 == Ref.mark && Ref._lock211226 == Ref._lock && AtomicMarkableReference._state211226 == AtomicMarkableReference._state && AtomicMarkableReference.pair211226 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211226 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211226 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211226 == AtomicMarkableReference.pair_nextValue && tmp2211226 == tmp2 && tmp1211226 == tmp1 && $result211226 == $result && this211226 == this && tid211226 == tid && $pc211226 == $pc;
 assume $recorded.state211226 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume tmp2 != Ref.null;                                                                          
 } else {                                                                                           
  assert tmp2 != Ref.null;                                                                                 // (23.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover211226);                                                               
 assert $pc != PhaseError;                                                                                 // (23.9): Reduction failure
 tmp1 := Ref.reference[tmp2];                                                                       
                                                                                                    
 // 23.9:  return tmp1;                                                                             
                                                                                                    
 assume Node._state211228 == Node._state && Node._lock211228 == Node._lock && Ref._state211228 == Ref._state && Ref.reference211228 == Ref.reference && Ref.mark211228 == Ref.mark && Ref._lock211228 == Ref._lock && AtomicMarkableReference._state211228 == AtomicMarkableReference._state && AtomicMarkableReference.pair211228 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211228 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211228 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211228 == AtomicMarkableReference.pair_nextValue && tmp2211228 == tmp2 && tmp1211228 == tmp1 && $result211228 == $result && this211228 == this && tid211228 == tid;
 assume $recorded.state211228 == 1;                                                                 
 if (isLocal(Node._state[tmp1], tid)) {                                                             
  Node._state[tmp1] := SHARED();                                                                    
 }                                                                                                  
                                                                                                    
 $result := tmp1;                                                                                   
 assert  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (23.9): Object invariant may not hold.
 return;                                                                                            
                                                                                                    
 // 22.32: // return Node.null;                                                                     
                                                                                                    
 assume Node._state211233 == Node._state && Node._lock211233 == Node._lock && Ref._state211233 == Ref._state && Ref.reference211233 == Ref.reference && Ref.mark211233 == Ref.mark && Ref._lock211233 == Ref._lock && AtomicMarkableReference._state211233 == AtomicMarkableReference._state && AtomicMarkableReference.pair211233 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211233 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211233 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211233 == AtomicMarkableReference.pair_nextValue && tmp2211233 == tmp2 && tmp1211233 == tmp1 && $result211233 == $result && this211233 == this && tid211233 == tid;
 assume $recorded.state211233 == 1;                                                                 
 $result := Node.null;                                                                              
 assert  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (22.32): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  AtomicMarkableReference.isMarked(tid:Tid, this : AtomicMarkableReference)                
returns ($result : bool)                                                                            
modifies Node._state;                                                                               
modifies Node._lock;                                                                                
modifies Ref._state;                                                                                
modifies Ref.reference;                                                                             
modifies Ref.mark;                                                                                  
modifies Ref._lock;                                                                                 
modifies AtomicMarkableReference._state;                                                            
modifies AtomicMarkableReference.pair;                                                              
modifies AtomicMarkableReference._lock;                                                             
modifies AtomicMarkableReference.pair_nextThread;                                                   
modifies AtomicMarkableReference.pair_nextValue;                                                    
                                                                                                    
requires ValidTid(tid);                                                                                    // (26.5): Bad tid
requires isShared(AtomicMarkableReference._state[this]);                                                   // (26.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (26.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
ensures  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (26.5): Object invariant may not hold.
{                                                                                                   
 var AtomicMarkableReference._lock211255: [AtomicMarkableReference]Tid;                             
 var path211299: int;                                                                               
 var AtomicMarkableReference._lock211312: [AtomicMarkableReference]Tid;                             
 var $pc211304: Phase;                                                                              
 var Ref.mark211299: [Ref]bool;                                                                     
 var Ref._state211255: [Ref]State;                                                                  
 var $result211299: bool;                                                                           
 var tmp4211316: Ref;                                                                               
 var tid211261: Tid;                                                                                
 var $result211255: bool;                                                                           
 var _C_t: Tid;                                                                                     
 var $result211249: bool;                                                                           
 var tid211249: Tid;                                                                                
 var mover211255: Mover;                                                                            
 var $pc211249: Phase;                                                                              
 var _C_t211261: Tid;                                                                               
 var path211304: int;                                                                               
 var Ref._lock211249: [Ref]Tid;                                                                     
 var _R_t211304: Mover;                                                                             
 var AtomicMarkableReference._lock211299: [AtomicMarkableReference]Tid;                             
 var this211299: AtomicMarkableReference;                                                           
 var AtomicMarkableReference.pair_nextThread211261: [AtomicMarkableReference]Tid;                   
 var Node._state211310: [Node]State;                                                                
 var $recorded.state211255: int;                                                                    
 var _casable: bool;                                                                                
 var tmp4211304: Ref;                                                                               
 var AtomicMarkableReference._lock211304: [AtomicMarkableReference]Tid;                             
 var _currentValue211299: Ref;                                                                      
 var Ref._state211261: [Ref]State;                                                                  
 var Node._lock211304: [Node]Tid;                                                                   
 var AtomicMarkableReference._state211255: [AtomicMarkableReference]State;                          
 var Ref._lock211299: [Ref]Tid;                                                                     
 var $result211304: bool;                                                                           
 var AtomicMarkableReference.pair_nextValue211255: [AtomicMarkableReference]Ref;                    
 var AtomicMarkableReference.pair_nextValue211304: [AtomicMarkableReference]Ref;                    
 var tmp4: Ref;                                                                                     
 var $result211261: bool;                                                                           
 var $pc211299: Phase;                                                                              
 var $pc211261: Phase;                                                                              
 var Node._state211316: [Node]State;                                                                
 var AtomicMarkableReference._state211316: [AtomicMarkableReference]State;                          
 var Ref._state211310: [Ref]State;                                                                  
 var Ref.mark211316: [Ref]bool;                                                                     
 var $result211310: bool;                                                                           
 var tmp3211312: bool;                                                                              
 var Node._lock211316: [Node]Tid;                                                                   
 var Node._state211249: [Node]State;                                                                
 var AtomicMarkableReference.pair_nextThread211249: [AtomicMarkableReference]Tid;                   
 var tmp3211261: bool;                                                                              
 var $pc211255: Phase;                                                                              
 var AtomicMarkableReference.pair_nextThread211310: [AtomicMarkableReference]Tid;                   
 var this211312: AtomicMarkableReference;                                                           
 var mover211249: Mover;                                                                            
 var Node._lock211310: [Node]Tid;                                                                   
 var AtomicMarkableReference._state211299: [AtomicMarkableReference]State;                          
 var tid211312: Tid;                                                                                
 var moverPath211304: MoverPath;                                                                    
 var this211316: AtomicMarkableReference;                                                           
 var this211304: AtomicMarkableReference;                                                           
 var Node._state211255: [Node]State;                                                                
 var Ref.mark211312: [Ref]bool;                                                                     
 var Node._state211304: [Node]State;                                                                
 var path211249: int;                                                                               
 var moverPath211310: MoverPath;                                                                    
 var AtomicMarkableReference._state211304: [AtomicMarkableReference]State;                          
 var $recorded.state211299: int;                                                                    
 var $recorded.state211249: int;                                                                    
 var Ref._lock211310: [Ref]Tid;                                                                     
 var AtomicMarkableReference.pair_nextValue211249: [AtomicMarkableReference]Ref;                    
 var Node._lock211261: [Node]Tid;                                                                   
 var Node._lock211249: [Node]Tid;                                                                   
 var AtomicMarkableReference.pair211316: [AtomicMarkableReference]Ref;                              
 var tmp4211255: Ref;                                                                               
 var $recorded.state211310: int;                                                                    
 var AtomicMarkableReference._lock211249: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference._lock211261: [AtomicMarkableReference]Tid;                             
 var Node._state211261: [Node]State;                                                                
 var AtomicMarkableReference.pair_nextValue211299: [AtomicMarkableReference]Ref;                    
 var AtomicMarkableReference._state211312: [AtomicMarkableReference]State;                          
 var this211261: AtomicMarkableReference;                                                           
 var $result211312: bool;                                                                           
 var Ref.reference211312: [Ref]Node;                                                                
 var $pc211316: Phase;                                                                              
 var AtomicMarkableReference._state211310: [AtomicMarkableReference]State;                          
 var this211249: AtomicMarkableReference;                                                           
 var Ref.mark211261: [Ref]bool;                                                                     
 var Ref.reference211316: [Ref]Node;                                                                
 var AtomicMarkableReference.pair_nextThread211304: [AtomicMarkableReference]Tid;                   
 var Node._state211312: [Node]State;                                                                
 var Ref._lock211255: [Ref]Tid;                                                                     
 var _currentValue211261: Ref;                                                                      
 var AtomicMarkableReference.pair211261: [AtomicMarkableReference]Ref;                              
 var this211310: AtomicMarkableReference;                                                           
 var AtomicMarkableReference.pair_nextValue211261: [AtomicMarkableReference]Ref;                    
 var tid211299: Tid;                                                                                
 var tmp3211316: bool;                                                                              
 var _casable211304: bool;                                                                          
 var _C_t211299: Tid;                                                                               
 var Ref.reference211304: [Ref]Node;                                                                
 var _C_t211255: Tid;                                                                               
 var Node._lock211299: [Node]Tid;                                                                   
 var tid211255: Tid;                                                                                
 var AtomicMarkableReference._lock211310: [AtomicMarkableReference]Tid;                             
 var _C_v211299: Ref;                                                                               
 var mover211310: Mover;                                                                            
 var Ref._lock211312: [Ref]Tid;                                                                     
 var Ref._state211316: [Ref]State;                                                                  
 var AtomicMarkableReference._state211261: [AtomicMarkableReference]State;                          
 var mover211299: Mover;                                                                            
 var tmp4211310: Ref;                                                                               
 var $recorded.state211316: int;                                                                    
 var Ref._state211299: [Ref]State;                                                                  
 var path211310: int;                                                                               
 var AtomicMarkableReference.pair_nextValue211316: [AtomicMarkableReference]Ref;                    
 var _R_t: Mover;                                                                                   
 var moverPath211255: MoverPath;                                                                    
 var AtomicMarkableReference._lock211316: [AtomicMarkableReference]Tid;                             
 var Ref._lock211304: [Ref]Tid;                                                                     
 var $recorded.state211312: int;                                                                    
 var Ref.mark211249: [Ref]bool;                                                                     
 var Node._lock211312: [Node]Tid;                                                                   
 var AtomicMarkableReference.pair_nextThread211299: [AtomicMarkableReference]Tid;                   
 var Node._lock211255: [Node]Tid;                                                                   
 var Ref.mark211255: [Ref]bool;                                                                     
 var moverPath211249: MoverPath;                                                                    
 var Node._state211299: [Node]State;                                                                
 var mover211304: Mover;                                                                            
 var mover211261: Mover;                                                                            
 var tid211304: Tid;                                                                                
 var $pc211310: Phase;                                                                              
 var moverPath211299: MoverPath;                                                                    
 var tmp4211312: Ref;                                                                               
 var AtomicMarkableReference.pair211299: [AtomicMarkableReference]Ref;                              
 var Ref.reference211310: [Ref]Node;                                                                
 var Ref.mark211304: [Ref]bool;                                                                     
 var _currentValue211304: Ref;                                                                      
 var _C_t211249: Tid;                                                                               
 var tid211316: Tid;                                                                                
 var _C_v211255: Ref;                                                                               
 var tmp3: bool;                                                                                    
 var AtomicMarkableReference.pair_nextThread211312: [AtomicMarkableReference]Tid;                   
 var AtomicMarkableReference.pair211304: [AtomicMarkableReference]Ref;                              
 var Ref.reference211261: [Ref]Node;                                                                
 var tmp3211310: bool;                                                                              
 var Ref._lock211261: [Ref]Tid;                                                                     
 var Ref._state211304: [Ref]State;                                                                  
 var AtomicMarkableReference.pair_nextThread211316: [AtomicMarkableReference]Tid;                   
 var tmp3211249: bool;                                                                              
 var Ref.reference211299: [Ref]Node;                                                                
 var Ref._state211312: [Ref]State;                                                                  
 var tmp3211304: bool;                                                                              
 var AtomicMarkableReference.pair_nextValue211312: [AtomicMarkableReference]Ref;                    
 var $result211316: bool;                                                                           
 var tmp4211261: Ref;                                                                               
 var path211255: int;                                                                               
 var $recorded.state211304: int;                                                                    
 var _C_v: Ref;                                                                                     
 var $recorded.state211261: int;                                                                    
 var Ref._state211249: [Ref]State;                                                                  
 var tmp3211255: bool;                                                                              
 var tmp3211299: bool;                                                                              
 var this211255: AtomicMarkableReference;                                                           
 var AtomicMarkableReference.pair_nextThread211255: [AtomicMarkableReference]Tid;                   
 var AtomicMarkableReference.pair211249: [AtomicMarkableReference]Ref;                              
 var AtomicMarkableReference.pair_nextValue211310: [AtomicMarkableReference]Ref;                    
 var _R_t211299: Mover;                                                                             
 var tmp4211249: Ref;                                                                               
 var _C_v211261: Ref;                                                                               
 var _C_t211304: Tid;                                                                               
 var _currentValue: Ref;                                                                            
 var $pc211312: Phase;                                                                              
 var AtomicMarkableReference.pair211310: [AtomicMarkableReference]Ref;                              
 var Ref.mark211310: [Ref]bool;                                                                     
 var AtomicMarkableReference._state211249: [AtomicMarkableReference]State;                          
 var AtomicMarkableReference.pair211312: [AtomicMarkableReference]Ref;                              
 var Ref._lock211316: [Ref]Tid;                                                                     
 var tid211310: Tid;                                                                                
 var moverPath211261: MoverPath;                                                                    
 var AtomicMarkableReference.pair211255: [AtomicMarkableReference]Ref;                              
 var Ref.reference211255: [Ref]Node;                                                                
 var tmp4211299: Ref;                                                                               
 var Ref.reference211249: [Ref]Node;                                                                
 var path211261: int;                                                                               
 var _casable211299: bool;                                                                          
 var _C_v211304: Ref;                                                                               
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 // 27.9: boolean tmp3;                                                                             
                                                                                                    
                                                                                                    
 // 27.9: Ref tmp4;                                                                                 
                                                                                                    
 // NoOp: 'TraceOff'                                                                                
                                                                                                    
 // 27.9: Tid _C_t;                                                                                 
                                                                                                    
                                                                                                    
 // 27.9: _C_t := this.pair_nextThread  as B;                                                       
                                                                                                    
                                                                                                    
 moverPath211249 := ReadEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 mover211249 := m#moverPath(moverPath211249);                                                       
 path211249 := p#moverPath(moverPath211249);                                                        
 assume Node._state211249 == Node._state && Node._lock211249 == Node._lock && Ref._state211249 == Ref._state && Ref.reference211249 == Ref.reference && Ref.mark211249 == Ref.mark && Ref._lock211249 == Ref._lock && AtomicMarkableReference._state211249 == AtomicMarkableReference._state && AtomicMarkableReference.pair211249 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211249 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211249 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211249 == AtomicMarkableReference.pair_nextValue && _C_t211249 == _C_t && tmp4211249 == tmp4 && tmp3211249 == tmp3 && $result211249 == $result && this211249 == this && tid211249 == tid && $pc211249 == $pc;
 assume $recorded.state211249 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this != AtomicMarkableReference.null;                                                      
 } else {                                                                                           
  assert this != AtomicMarkableReference.null;                                                             // (27.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (27.9): Reduction failure
 _C_t := AtomicMarkableReference.pair_nextThread[this];                                             
                                                                                                    
 // 27.9: Ref _C_v;                                                                                 
                                                                                                    
                                                                                                    
 // 27.9: _C_v := this.pair_nextValue  as B;                                                        
                                                                                                    
                                                                                                    
 moverPath211255 := ReadEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 mover211255 := m#moverPath(moverPath211255);                                                       
 path211255 := p#moverPath(moverPath211255);                                                        
 assume Node._state211255 == Node._state && Node._lock211255 == Node._lock && Ref._state211255 == Ref._state && Ref.reference211255 == Ref.reference && Ref.mark211255 == Ref.mark && Ref._lock211255 == Ref._lock && AtomicMarkableReference._state211255 == AtomicMarkableReference._state && AtomicMarkableReference.pair211255 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211255 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211255 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211255 == AtomicMarkableReference.pair_nextValue && _C_v211255 == _C_v && _C_t211255 == _C_t && tmp4211255 == tmp4 && tmp3211255 == tmp3 && $result211255 == $result && this211255 == this && tid211255 == tid && $pc211255 == $pc;
 assume $recorded.state211255 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this != AtomicMarkableReference.null;                                                      
 } else {                                                                                           
  assert this != AtomicMarkableReference.null;                                                             // (27.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (27.9): Reduction failure
 _C_v := AtomicMarkableReference.pair_nextValue[this];                                              
                                                                                                    
 // 27.9: Ref _currentValue;                                                                        
                                                                                                    
                                                                                                    
 // 27.9: _currentValue := this.pair  as B;                                                         
                                                                                                    
                                                                                                    
 moverPath211261 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 mover211261 := m#moverPath(moverPath211261);                                                       
 path211261 := p#moverPath(moverPath211261);                                                        
 assume Node._state211261 == Node._state && Node._lock211261 == Node._lock && Ref._state211261 == Ref._state && Ref.reference211261 == Ref.reference && Ref.mark211261 == Ref.mark && Ref._lock211261 == Ref._lock && AtomicMarkableReference._state211261 == AtomicMarkableReference._state && AtomicMarkableReference.pair211261 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211261 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211261 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211261 == AtomicMarkableReference.pair_nextValue && _currentValue211261 == _currentValue && _C_v211261 == _C_v && _C_t211261 == _C_t && tmp4211261 == tmp4 && tmp3211261 == tmp3 && $result211261 == $result && this211261 == this && tid211261 == tid && $pc211261 == $pc;
 assume $recorded.state211261 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this != AtomicMarkableReference.null;                                                      
 } else {                                                                                           
  assert this != AtomicMarkableReference.null;                                                             // (27.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (27.9): Reduction failure
 _currentValue := AtomicMarkableReference.pair[this];                                               
                                                                                                    
 // 27.9: Mover _R_t;                                                                               
                                                                                                    
                                                                                                    
 // 27.9: _R_t = readPermission(this.pair);                                                         
                                                                                                    
 _R_t := m#moverPath(ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));
                                                                                                    
 // 27.9: boolean _casable;                                                                         
                                                                                                    
                                                                                                    
 // 27.9: _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
                                                                                                    
 _casable := ((((_R_t!=_E)&&true)&&(_C_t==tid))&&(_C_v==_currentValue));                            
 if (_casable) {                                                                                    
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 27.9: tmp4 := this.pair  as R;                                                                 
                                                                                                    
                                                                                                    
  moverPath211299 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
  mover211299 := m#moverPath(moverPath211299);                                                      
  path211299 := p#moverPath(moverPath211299);                                                       
  assume Node._state211299 == Node._state && Node._lock211299 == Node._lock && Ref._state211299 == Ref._state && Ref.reference211299 == Ref.reference && Ref.mark211299 == Ref.mark && Ref._lock211299 == Ref._lock && AtomicMarkableReference._state211299 == AtomicMarkableReference._state && AtomicMarkableReference.pair211299 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211299 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211299 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211299 == AtomicMarkableReference.pair_nextValue && _casable211299 == _casable && _R_t211299 == _R_t && _currentValue211299 == _currentValue && _C_v211299 == _C_v && _C_t211299 == _C_t && tmp4211299 == tmp4 && tmp3211299 == tmp3 && $result211299 == $result && this211299 == this && tid211299 == tid && $pc211299 == $pc;
  assume $recorded.state211299 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this != AtomicMarkableReference.null;                                                     
  } else {                                                                                          
   assert this != AtomicMarkableReference.null;                                                            // (27.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _R);                                                                       
  assert $pc != PhaseError;                                                                                // (27.9): Reduction failure
  tmp4 := AtomicMarkableReference.pair[this];                                                       
 } else {                                                                                           
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 27.9: tmp4 := this.pair;                                                                       
                                                                                                    
                                                                                                    
  moverPath211304 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
  mover211304 := m#moverPath(moverPath211304);                                                      
  path211304 := p#moverPath(moverPath211304);                                                       
  assume Node._state211304 == Node._state && Node._lock211304 == Node._lock && Ref._state211304 == Ref._state && Ref.reference211304 == Ref.reference && Ref.mark211304 == Ref.mark && Ref._lock211304 == Ref._lock && AtomicMarkableReference._state211304 == AtomicMarkableReference._state && AtomicMarkableReference.pair211304 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211304 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211304 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211304 == AtomicMarkableReference.pair_nextValue && _casable211304 == _casable && _R_t211304 == _R_t && _currentValue211304 == _currentValue && _C_v211304 == _C_v && _C_t211304 == _C_t && tmp4211304 == tmp4 && tmp3211304 == tmp3 && $result211304 == $result && this211304 == this && tid211304 == tid && $pc211304 == $pc;
  assume $recorded.state211304 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this != AtomicMarkableReference.null;                                                     
  } else {                                                                                          
   assert this != AtomicMarkableReference.null;                                                            // (27.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover211304);                                                              
  assert $pc != PhaseError;                                                                                // (27.9): Reduction failure
  tmp4 := AtomicMarkableReference.pair[this];                                                       
 }                                                                                                  
                                                                                                    
 // 27.9: tmp3 := tmp4.mark;                                                                        
                                                                                                    
                                                                                                    
 moverPath211310 := ReadEval.Ref.mark(tid: Tid,tmp4: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 mover211310 := m#moverPath(moverPath211310);                                                       
 path211310 := p#moverPath(moverPath211310);                                                        
 assume Node._state211310 == Node._state && Node._lock211310 == Node._lock && Ref._state211310 == Ref._state && Ref.reference211310 == Ref.reference && Ref.mark211310 == Ref.mark && Ref._lock211310 == Ref._lock && AtomicMarkableReference._state211310 == AtomicMarkableReference._state && AtomicMarkableReference.pair211310 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211310 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211310 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211310 == AtomicMarkableReference.pair_nextValue && tmp4211310 == tmp4 && tmp3211310 == tmp3 && $result211310 == $result && this211310 == this && tid211310 == tid && $pc211310 == $pc;
 assume $recorded.state211310 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume tmp4 != Ref.null;                                                                          
 } else {                                                                                           
  assert tmp4 != Ref.null;                                                                                 // (27.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover211310);                                                               
 assert $pc != PhaseError;                                                                                 // (27.9): Reduction failure
 tmp3 := Ref.mark[tmp4];                                                                            
                                                                                                    
 // 27.9:  return tmp3;                                                                             
                                                                                                    
 assume Node._state211312 == Node._state && Node._lock211312 == Node._lock && Ref._state211312 == Ref._state && Ref.reference211312 == Ref.reference && Ref.mark211312 == Ref.mark && Ref._lock211312 == Ref._lock && AtomicMarkableReference._state211312 == AtomicMarkableReference._state && AtomicMarkableReference.pair211312 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211312 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211312 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211312 == AtomicMarkableReference.pair_nextValue && tmp4211312 == tmp4 && tmp3211312 == tmp3 && $result211312 == $result && this211312 == this && tid211312 == tid;
 assume $recorded.state211312 == 1;                                                                 
 $result := tmp3;                                                                                   
 assert  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (27.9): Object invariant may not hold.
 return;                                                                                            
                                                                                                    
 // 26.31: // return false;                                                                         
                                                                                                    
 assume Node._state211316 == Node._state && Node._lock211316 == Node._lock && Ref._state211316 == Ref._state && Ref.reference211316 == Ref.reference && Ref.mark211316 == Ref.mark && Ref._lock211316 == Ref._lock && AtomicMarkableReference._state211316 == AtomicMarkableReference._state && AtomicMarkableReference.pair211316 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211316 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211316 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211316 == AtomicMarkableReference.pair_nextValue && tmp4211316 == tmp4 && tmp3211316 == tmp3 && $result211316 == $result && this211316 == this && tid211316 == tid;
 assume $recorded.state211316 == 1;                                                                 
 $result := false;                                                                                  
 assert  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (26.31): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  AtomicMarkableReference.compareAndSet(tid:Tid, this : AtomicMarkableReference, expectedReference : Node, newReference : Node, expectedMark : bool, newMark : bool)
returns ($result : bool)                                                                            
modifies Node._state;                                                                               
modifies Node._lock;                                                                                
modifies Ref._state;                                                                                
modifies Ref.reference;                                                                             
modifies Ref.mark;                                                                                  
modifies Ref._lock;                                                                                 
modifies AtomicMarkableReference._state;                                                            
modifies AtomicMarkableReference.pair;                                                              
modifies AtomicMarkableReference._lock;                                                             
modifies AtomicMarkableReference.pair_nextThread;                                                   
modifies AtomicMarkableReference.pair_nextValue;                                                    
                                                                                                    
requires ValidTid(tid);                                                                                    // (30.5): Bad tid
requires isSharedAssignable(Node._state[expectedReference]);                                               // (30.5): Parameter VarDecl(ClassType(Node),expectedReference) is not global
requires isSharedAssignable(Node._state[newReference]);                                                    // (30.5): Parameter VarDecl(ClassType(Node),newReference) is not global
requires isShared(AtomicMarkableReference._state[this]);                                                   // (30.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (30.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
ensures  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (30.5): Object invariant may not hold.
{                                                                                                   
 var mover211467: Mover;                                                                            
 var Node._lock211569: [Node]Tid;                                                                   
 var tmp7211470: bool;                                                                              
 var newMark211539: bool;                                                                           
 var $recorded.state211379: int;                                                                    
 var newMark211402: bool;                                                                           
 var AtomicMarkableReference.pair211467: [AtomicMarkableReference]Ref;                              
 var current211546: Ref;                                                                            
 var mover211546: Mover;                                                                            
 var Ref.reference211539: [Ref]Node;                                                                
 var AtomicMarkableReference.pair_nextThread211609: [AtomicMarkableReference]Tid;                   
 var Ref.mark211569: [Ref]bool;                                                                     
 var tmp5211613: bool;                                                                              
 var tid211335: Tid;                                                                                
 var expectedReference211384: Node;                                                                 
 var reference$1211467: Node;                                                                       
 var tmp5211572: bool;                                                                              
 var $recorded.state211591: int;                                                                    
 var this211470: AtomicMarkableReference;                                                           
 var AtomicMarkableReference.pair211546: [AtomicMarkableReference]Ref;                              
 var Ref.reference211470: [Ref]Node;                                                                
 var expectedMark211379: bool;                                                                      
 var newMark211546: bool;                                                                           
 var Ref._state211402: [Ref]State;                                                                  
 var $result211584: bool;                                                                           
 var expectedMark211335: bool;                                                                      
 var AtomicMarkableReference._lock211569: [AtomicMarkableReference]Tid;                             
 var _currentValue211572: Ref;                                                                      
 var current211584: Ref;                                                                            
 var path211569: int;                                                                               
 var expectedReference211341: Node;                                                                 
 var expectedReference211470: Node;                                                                 
 var expectedReference211591: Node;                                                                 
 var _currentValue211341: Ref;                                                                      
 var AtomicMarkableReference.pair_nextValue211384: [AtomicMarkableReference]Ref;                    
 var $recorded.state211414: int;                                                                    
 var $recorded.state211329: int;                                                                    
 var $recorded.state211402: int;                                                                    
 var _C_t: Tid;                                                                                     
 var Node._state211609: [Node]State;                                                                
 var current211329: Ref;                                                                            
 var Ref.mark211379: [Ref]bool;                                                                     
 var _m211591: Mover;                                                                               
 var tmp7211613: bool;                                                                              
 var _currentValue211584: Ref;                                                                      
 var path211542: int;                                                                               
 var tmp6211613: bool;                                                                              
 var _R_t211384: Mover;                                                                             
 var $recorded.state211470: int;                                                                    
 var Ref.mark211402: [Ref]bool;                                                                     
 var expectedReference211539: Node;                                                                 
 var current211569: Ref;                                                                            
 var AtomicMarkableReference._lock211542: [AtomicMarkableReference]Tid;                             
 var Ref.mark211414: [Ref]bool;                                                                     
 var _m211546: Mover;                                                                               
 var expectedMark211539: bool;                                                                      
 var AtomicMarkableReference._state211470: [AtomicMarkableReference]State;                          
 var expectedMark211470: bool;                                                                      
 var AtomicMarkableReference._state211384: [AtomicMarkableReference]State;                          
 var tmp10211569: Ref;                                                                              
 var tid211546: Tid;                                                                                
 var expectedReference211329: Node;                                                                 
 var $pc211569: Phase;                                                                              
 var AtomicMarkableReference.pair_nextValue211572: [AtomicMarkableReference]Ref;                    
 var Ref.mark211341: [Ref]bool;                                                                     
 var tmp5211584: bool;                                                                              
 var this211341: AtomicMarkableReference;                                                           
 var Node._lock211542: [Node]Tid;                                                                   
 var tmp6211572: bool;                                                                              
 var path211379: int;                                                                               
 var tmp10: Ref;                                                                                    
 var tmp6211584: bool;                                                                              
 var Ref._state211546: [Ref]State;                                                                  
 var AtomicMarkableReference.pair_nextThread211584: [AtomicMarkableReference]Tid;                   
 var Ref.mark211584: [Ref]bool;                                                                     
 var Ref._lock211402: [Ref]Tid;                                                                     
 var Ref.reference211379: [Ref]Node;                                                                
 var $result211467: bool;                                                                           
 var tmp5: bool;                                                                                    
 var tmp10211584: Ref;                                                                              
 var $recorded.state211341: int;                                                                    
 var _casable: bool;                                                                                
 var expectedMark211341: bool;                                                                      
 var AtomicMarkableReference.pair_nextValue211329: [AtomicMarkableReference]Ref;                    
 var tmp9211414: bool;                                                                              
 var $pc211329: Phase;                                                                              
 var current211379: Ref;                                                                            
 var AtomicMarkableReference.pair211539: [AtomicMarkableReference]Ref;                              
 var Ref.mark211609: [Ref]bool;                                                                     
 var mark$1211467: bool;                                                                            
 var _C_t211379: Tid;                                                                               
 var Ref.mark211470: [Ref]bool;                                                                     
 var moverPath211542: MoverPath;                                                                    
 var current211467: Ref;                                                                            
 var moverPath211467: MoverPath;                                                                    
 var tmp10211467: Ref;                                                                              
 var AtomicMarkableReference._state211546: [AtomicMarkableReference]State;                          
 var Ref._lock211467: [Ref]Tid;                                                                     
 var Node._state211546: [Node]State;                                                                
 var Node._lock211470: [Node]Tid;                                                                   
 var AtomicMarkableReference._state211591: [AtomicMarkableReference]State;                          
 var $result211591: bool;                                                                           
 var tmpValue211539: Ref;                                                                           
 var AtomicMarkableReference.pair_nextThread211470: [AtomicMarkableReference]Tid;                   
 var Ref.mark211546: [Ref]bool;                                                                     
 var newMark211379: bool;                                                                           
 var tmp6211402: bool;                                                                              
 var AtomicMarkableReference.pair_nextThread211613: [AtomicMarkableReference]Tid;                   
 var _C_t211341: Tid;                                                                               
 var Ref.reference211569: [Ref]Node;                                                                
 var AtomicMarkableReference._state211542: [AtomicMarkableReference]State;                          
 var tmp10211591: Ref;                                                                              
 var mover211542: Mover;                                                                            
 var tmp10211470: Ref;                                                                              
 var Node._state211329: [Node]State;                                                                
 var tid211569: Tid;                                                                                
 var AtomicMarkableReference._state211329: [AtomicMarkableReference]State;                          
 var mover211341: Mover;                                                                            
 var expectedReference211414: Node;                                                                 
 var AtomicMarkableReference._state211341: [AtomicMarkableReference]State;                          
 var tmp7211609: bool;                                                                              
 var Ref.mark211335: [Ref]bool;                                                                     
 var Ref.reference211546: [Ref]Node;                                                                
 var tmp7211546: bool;                                                                              
 var Ref.reference211335: [Ref]Node;                                                                
 var $pc211335: Phase;                                                                              
 var current211335: Ref;                                                                            
 var Ref.reference211414: [Ref]Node;                                                                
 var Node._lock211546: [Node]Tid;                                                                   
 var Ref.reference211613: [Ref]Node;                                                                
 var mover211572: Mover;                                                                            
 var expectedMark211329: bool;                                                                      
 var tmp7211542: bool;                                                                              
 var expectedMark211569: bool;                                                                      
 var expectedMark211546: bool;                                                                      
 var mover211569: Mover;                                                                            
 var Ref._lock211542: [Ref]Tid;                                                                     
 var $pc211467: Phase;                                                                              
 var ctmp192283211591: bool;                                                                        
 var $pc211584: Phase;                                                                              
 var expectedReference211572: Node;                                                                 
 var this211569: AtomicMarkableReference;                                                           
 var tid211613: Tid;                                                                                
 var current211591: Ref;                                                                            
 var AtomicMarkableReference.pair_nextValue211569: [AtomicMarkableReference]Ref;                    
 var $result211572: bool;                                                                           
 var $recorded.state211539: int;                                                                    
 var Ref._state211609: [Ref]State;                                                                  
 var AtomicMarkableReference.pair_nextThread211402: [AtomicMarkableReference]Tid;                   
 var Ref._lock211613: [Ref]Tid;                                                                     
 var mark$1211470: bool;                                                                            
 var tid211329: Tid;                                                                                
 var Ref.mark211329: [Ref]bool;                                                                     
 var AtomicMarkableReference._lock211467: [AtomicMarkableReference]Tid;                             
 var ctmp192283211539: bool;                                                                        
 var Ref._lock211470: [Ref]Tid;                                                                     
 var this211542: AtomicMarkableReference;                                                           
 var Node._lock211539: [Node]Tid;                                                                   
 var Node._lock211414: [Node]Tid;                                                                   
 var Node._lock211379: [Node]Tid;                                                                   
 var moverPath211584: MoverPath;                                                                    
 var this211546: AtomicMarkableReference;                                                           
 var AtomicMarkableReference.pair211379: [AtomicMarkableReference]Ref;                              
 var AtomicMarkableReference.pair_nextValue211546: [AtomicMarkableReference]Ref;                    
 var Node._lock211329: [Node]Tid;                                                                   
 var tmp10211539: Ref;                                                                              
 var AtomicMarkableReference._lock211335: [AtomicMarkableReference]Tid;                             
 var _m211584: Mover;                                                                               
 var AtomicMarkableReference.pair_nextThread211329: [AtomicMarkableReference]Tid;                   
 var AtomicMarkableReference.pair211341: [AtomicMarkableReference]Ref;                              
 var Ref._state211572: [Ref]State;                                                                  
 var $pc211591: Phase;                                                                              
 var $result211546: bool;                                                                           
 var $recorded.state211384: int;                                                                    
 var tmp5211414: bool;                                                                              
 var tmp6211546: bool;                                                                              
 var Ref._state211384: [Ref]State;                                                                  
 var AtomicMarkableReference._state211613: [AtomicMarkableReference]State;                          
 var _m211542: Mover;                                                                               
 var $result211542: bool;                                                                           
 var Ref._lock211341: [Ref]Tid;                                                                     
 var tmp8211613: Node;                                                                              
 var Ref.reference211584: [Ref]Node;                                                                
 var Node._state211467: [Node]State;                                                                
 var $result211414: bool;                                                                           
 var expectedReference211335: Node;                                                                 
 var $result211569: bool;                                                                           
 var newMark211569: bool;                                                                           
 var newReference211569: Node;                                                                      
 var AtomicMarkableReference.pair_nextThread211384: [AtomicMarkableReference]Tid;                   
 var AtomicMarkableReference.pair211572: [AtomicMarkableReference]Ref;                              
 var $pc211402: Phase;                                                                              
 var moverPath211402: MoverPath;                                                                    
 var AtomicMarkableReference.pair_nextThread211591: [AtomicMarkableReference]Tid;                   
 var expectedReference211546: Node;                                                                 
 var Node._lock211609: [Node]Tid;                                                                   
 var _m211539: Mover;                                                                               
 var path211414: int;                                                                               
 var _C_t211335: Tid;                                                                               
 var tmp5211609: bool;                                                                              
 var moverPath211379: MoverPath;                                                                    
 var this211609: AtomicMarkableReference;                                                           
 var Ref.reference211384: [Ref]Node;                                                                
 var $recorded.state211609: int;                                                                    
 var tmp6211539: bool;                                                                              
 var newMark211542: bool;                                                                           
 var AtomicMarkableReference.pair211402: [AtomicMarkableReference]Ref;                              
 var _C_v211335: Ref;                                                                               
 var path211329: int;                                                                               
 var AtomicMarkableReference.pair_nextValue211542: [AtomicMarkableReference]Ref;                    
 var $recorded.state211542: int;                                                                    
 var Ref.mark211539: [Ref]bool;                                                                     
 var Node._lock211384: [Node]Tid;                                                                   
 var moverPath211591: MoverPath;                                                                    
 var AtomicMarkableReference._state211467: [AtomicMarkableReference]State;                          
 var tmp8211572: Node;                                                                              
 var Ref._lock211539: [Ref]Tid;                                                                     
 var ctmp192283211542: bool;                                                                        
 var current211402: Ref;                                                                            
 var Ref.mark211572: [Ref]bool;                                                                     
 var tid211542: Tid;                                                                                
 var $result211402: bool;                                                                           
 var AtomicMarkableReference.pair_nextThread211542: [AtomicMarkableReference]Tid;                   
 var tmp6211591: bool;                                                                              
 var AtomicMarkableReference.pair211613: [AtomicMarkableReference]Ref;                              
 var newReference211402: Node;                                                                      
 var tmp8211414: Node;                                                                              
 var _C_v211379: Ref;                                                                               
 var moverPath211414: MoverPath;                                                                    
 var tmp8211470: Node;                                                                              
 var tid211384: Tid;                                                                                
 var tmp5211470: bool;                                                                              
 var current211341: Ref;                                                                            
 var expectedReference211402: Node;                                                                 
 var newMark211384: bool;                                                                           
 var $pc211572: Phase;                                                                              
 var $pc211379: Phase;                                                                              
 var tmpTid211546: Tid;                                                                             
 var $result211613: bool;                                                                           
 var newReference211414: Node;                                                                      
 var Ref._lock211569: [Ref]Tid;                                                                     
 var Ref._state211467: [Ref]State;                                                                  
 var AtomicMarkableReference.pair211414: [AtomicMarkableReference]Ref;                              
 var AtomicMarkableReference.pair_nextValue211414: [AtomicMarkableReference]Ref;                    
 var $result211335: bool;                                                                           
 var Node._state211584: [Node]State;                                                                
 var tmp10211572: Ref;                                                                              
 var Node._lock211613: [Node]Tid;                                                                   
 var $result211470: bool;                                                                           
 var $result211384: bool;                                                                           
 var Node._state211414: [Node]State;                                                                
 var newReference211384: Node;                                                                      
 var this211379: AtomicMarkableReference;                                                           
 var path211572: int;                                                                               
 var newReference211341: Node;                                                                      
 var tmp6211467: bool;                                                                              
 var mover211591: Mover;                                                                            
 var tmp5211546: bool;                                                                              
 var current211470: Ref;                                                                            
 var mover211402: Mover;                                                                            
 var Node._state211613: [Node]State;                                                                
 var $pc211609: Phase;                                                                              
 var AtomicMarkableReference.pair211542: [AtomicMarkableReference]Ref;                              
 var _C_v211384: Ref;                                                                               
 var AtomicMarkableReference._lock211379: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference._lock211613: [AtomicMarkableReference]Tid;                             
 var expectedMark211572: bool;                                                                      
 var Node._lock211572: [Node]Tid;                                                                   
 var newReference211542: Node;                                                                      
 var Ref.mark211542: [Ref]bool;                                                                     
 var Node._state211384: [Node]State;                                                                
 var current211609: Ref;                                                                            
 var Node._lock211467: [Node]Tid;                                                                   
 var $pc211613: Phase;                                                                              
 var tmp6211414: bool;                                                                              
 var Ref._state211591: [Ref]State;                                                                  
 var mark$1: bool;                                                                                  
 var Node._state211591: [Node]State;                                                                
 var newMark211591: bool;                                                                           
 var AtomicMarkableReference._lock211609: [AtomicMarkableReference]Tid;                             
 var Ref.mark211613: [Ref]bool;                                                                     
 var tmp8211402: Node;                                                                              
 var AtomicMarkableReference.pair_nextThread211379: [AtomicMarkableReference]Tid;                   
 var $pc211542: Phase;                                                                              
 var AtomicMarkableReference.pair211584: [AtomicMarkableReference]Ref;                              
 var newMark211329: bool;                                                                           
 var Ref._state211613: [Ref]State;                                                                  
 var $pc211384: Phase;                                                                              
 var AtomicMarkableReference._lock211414: [AtomicMarkableReference]Tid;                             
 var ctmp192283: bool;                                                                              
 var AtomicMarkableReference._lock211384: [AtomicMarkableReference]Tid;                             
 var tmp7211572: bool;                                                                              
 var path211341: int;                                                                               
 var AtomicMarkableReference.pair_nextValue211591: [AtomicMarkableReference]Ref;                    
 var tmpValue: Ref;                                                                                 
 var tmp6211470: bool;                                                                              
 var Node._state211539: [Node]State;                                                                
 var expectedMark211414: bool;                                                                      
 var tmp5211591: bool;                                                                              
 var tmp8: Node;                                                                                    
 var expectedMark211584: bool;                                                                      
 var Ref._lock211379: [Ref]Tid;                                                                     
 var expectedMark211384: bool;                                                                      
 var this$1: Ref;                                                                                   
 var AtomicMarkableReference.pair_nextValue211613: [AtomicMarkableReference]Ref;                    
 var Ref.reference211609: [Ref]Node;                                                                
 var tid211470: Tid;                                                                                
 var expectedMark211591: bool;                                                                      
 var current211542: Ref;                                                                            
 var _casable211379: bool;                                                                          
 var newMark211414: bool;                                                                           
 var moverPath211470: MoverPath;                                                                    
 var $pc211414: Phase;                                                                              
 var AtomicMarkableReference.pair211609: [AtomicMarkableReference]Ref;                              
 var Node._lock211402: [Node]Tid;                                                                   
 var Ref._state211414: [Ref]State;                                                                  
 var Node._state211341: [Node]State;                                                                
 var tmp9: bool;                                                                                    
 var path211335: int;                                                                               
 var Node._state211542: [Node]State;                                                                
 var AtomicMarkableReference.pair_nextThread211341: [AtomicMarkableReference]Tid;                   
 var tmp5211402: bool;                                                                              
 var AtomicMarkableReference._lock211341: [AtomicMarkableReference]Tid;                             
 var expectedReference211569: Node;                                                                 
 var this$1211467: Ref;                                                                             
 var tmp8211546: Node;                                                                              
 var Ref.reference211341: [Ref]Node;                                                                
 var AtomicMarkableReference.pair_nextThread211335: [AtomicMarkableReference]Tid;                   
 var Ref._state211542: [Ref]State;                                                                  
 var AtomicMarkableReference.pair_nextValue211402: [AtomicMarkableReference]Ref;                    
 var AtomicMarkableReference._state211414: [AtomicMarkableReference]State;                          
 var this211572: AtomicMarkableReference;                                                           
 var this211414: AtomicMarkableReference;                                                           
 var AtomicMarkableReference.pair_nextValue211379: [AtomicMarkableReference]Ref;                    
 var current211613: Ref;                                                                            
 var Ref._lock211546: [Ref]Tid;                                                                     
 var newMark211572: bool;                                                                           
 var _R_t: Mover;                                                                                   
 var tmp7211414: bool;                                                                              
 var AtomicMarkableReference._state211335: [AtomicMarkableReference]State;                          
 var AtomicMarkableReference.pair_nextValue211467: [AtomicMarkableReference]Ref;                    
 var expectedReference211379: Node;                                                                 
 var AtomicMarkableReference._lock211572: [AtomicMarkableReference]Tid;                             
 var tmp5211569: bool;                                                                              
 var this$1211470: Ref;                                                                             
 var expectedMark211467: bool;                                                                      
 var Ref._lock211572: [Ref]Tid;                                                                     
 var mover211584: Mover;                                                                            
 var AtomicMarkableReference._state211379: [AtomicMarkableReference]State;                          
 var tmp7: bool;                                                                                    
 var expectedMark211542: bool;                                                                      
 var Ref.reference211329: [Ref]Node;                                                                
 var tmp10211542: Ref;                                                                              
 var $recorded.state211572: int;                                                                    
 var tmpTid211539: Tid;                                                                             
 var _m: Mover;                                                                                     
 var expectedMark211402: bool;                                                                      
 var AtomicMarkableReference.pair211591: [AtomicMarkableReference]Ref;                              
 var $result211341: bool;                                                                           
 var tmp7211539: bool;                                                                              
 var $recorded.state211584: int;                                                                    
 var Ref.reference211542: [Ref]Node;                                                                
 var tid211591: Tid;                                                                                
 var Ref._state211379: [Ref]State;                                                                  
 var ctmp192283211584: bool;                                                                        
 var Node._lock211341: [Node]Tid;                                                                   
 var Ref._lock211609: [Ref]Tid;                                                                     
 var $recorded.state211546: int;                                                                    
 var AtomicMarkableReference._lock211402: [AtomicMarkableReference]Tid;                             
 var newReference211613: Node;                                                                      
 var moverPath211539: MoverPath;                                                                    
 var $result211379: bool;                                                                           
 var $recorded.state211335: int;                                                                    
 var path211402: int;                                                                               
 var tmp7211569: bool;                                                                              
 var _casable211384: bool;                                                                          
 var this211467: AtomicMarkableReference;                                                           
 var Ref.reference211572: [Ref]Node;                                                                
 var _C_v211341: Ref;                                                                               
 var tmp5211542: bool;                                                                              
 var ctmp192283211569: bool;                                                                        
 var Ref._state211341: [Ref]State;                                                                  
 var newReference211546: Node;                                                                      
 var $result211539: bool;                                                                           
 var $pc211470: Phase;                                                                              
 var tmp7211591: bool;                                                                              
 var AtomicMarkableReference._state211402: [AtomicMarkableReference]State;                          
 var Node._lock211584: [Node]Tid;                                                                   
 var AtomicMarkableReference.pair_nextThread211546: [AtomicMarkableReference]Tid;                   
 var path211584: int;                                                                               
 var Ref._lock211335: [Ref]Tid;                                                                     
 var current211384: Ref;                                                                            
 var AtomicMarkableReference._state211609: [AtomicMarkableReference]State;                          
 var expectedMark211609: bool;                                                                      
 var AtomicMarkableReference._state211584: [AtomicMarkableReference]State;                          
 var expectedMark211613: bool;                                                                      
 var AtomicMarkableReference.pair_nextThread211572: [AtomicMarkableReference]Tid;                   
 var path211470: int;                                                                               
 var tmp8211569: Node;                                                                              
 var Ref._state211584: [Ref]State;                                                                  
 var Ref._state211335: [Ref]State;                                                                  
 var Node._lock211335: [Node]Tid;                                                                   
 var tmpTid211542: Tid;                                                                             
 var AtomicMarkableReference.pair211470: [AtomicMarkableReference]Ref;                              
 var expectedReference211542: Node;                                                                 
 var newMark211613: bool;                                                                           
 var tmp6211609: bool;                                                                              
 var newReference211379: Node;                                                                      
 var tmp8211467: Node;                                                                              
 var newMark211335: bool;                                                                           
 var newReference211591: Node;                                                                      
 var AtomicMarkableReference._state211569: [AtomicMarkableReference]State;                          
 var $pc211539: Phase;                                                                              
 var tid211467: Tid;                                                                                
 var AtomicMarkableReference.pair_nextValue211470: [AtomicMarkableReference]Ref;                    
 var expectedReference211584: Node;                                                                 
 var this211591: AtomicMarkableReference;                                                           
 var tid211379: Tid;                                                                                
 var expectedReference211609: Node;                                                                 
 var this211613: AtomicMarkableReference;                                                           
 var newReference211335: Node;                                                                      
 var Ref.reference211591: [Ref]Node;                                                                
 var newMark211467: bool;                                                                           
 var path211591: int;                                                                               
 var tmp8211609: Node;                                                                              
 var moverPath211329: MoverPath;                                                                    
 var path211546: int;                                                                               
 var Node._state211470: [Node]State;                                                                
 var Ref._state211569: [Ref]State;                                                                  
 var tid211572: Tid;                                                                                
 var Ref._state211539: [Ref]State;                                                                  
 var Ref._lock211329: [Ref]Tid;                                                                     
 var _currentValue211384: Ref;                                                                      
 var tmp6: bool;                                                                                    
 var tmpTid: Tid;                                                                                   
 var moverPath211546: MoverPath;                                                                    
 var mover211470: Mover;                                                                            
 var moverPath211341: MoverPath;                                                                    
 var ctmp192283211572: bool;                                                                        
 var tmp7211467: bool;                                                                              
 var tmp8211539: Node;                                                                              
 var this211584: AtomicMarkableReference;                                                           
 var AtomicMarkableReference.pair211384: [AtomicMarkableReference]Ref;                              
 var moverPath211572: MoverPath;                                                                    
 var _C_t211384: Tid;                                                                               
 var moverPath211384: MoverPath;                                                                    
 var reference$1211470: Node;                                                                       
 var tid211414: Tid;                                                                                
 var _currentValue211569: Ref;                                                                      
 var path211467: int;                                                                               
 var newMark211341: bool;                                                                           
 var Ref._lock211584: [Ref]Tid;                                                                     
 var AtomicMarkableReference.pair_nextValue211539: [AtomicMarkableReference]Ref;                    
 var this211329: AtomicMarkableReference;                                                           
 var _currentValue211591: Ref;                                                                      
 var moverPath211569: MoverPath;                                                                    
 var Node._state211569: [Node]State;                                                                
 var AtomicMarkableReference._state211572: [AtomicMarkableReference]State;                          
 var AtomicMarkableReference.pair211335: [AtomicMarkableReference]Ref;                              
 var mover211329: Mover;                                                                            
 var AtomicMarkableReference._state211539: [AtomicMarkableReference]State;                          
 var tmp5211539: bool;                                                                              
 var tmp7211402: bool;                                                                              
 var current211572: Ref;                                                                            
 var Ref._lock211414: [Ref]Tid;                                                                     
 var AtomicMarkableReference.pair211329: [AtomicMarkableReference]Ref;                              
 var Node._state211572: [Node]State;                                                                
 var newMark211609: bool;                                                                           
 var AtomicMarkableReference._lock211329: [AtomicMarkableReference]Tid;                             
 var $result211329: bool;                                                                           
 var Ref.mark211384: [Ref]bool;                                                                     
 var tid211609: Tid;                                                                                
 var AtomicMarkableReference._lock211584: [AtomicMarkableReference]Tid;                             
 var Node._lock211591: [Node]Tid;                                                                   
 var tmpValue211542: Ref;                                                                           
 var $result211609: bool;                                                                           
 var reference$1: Node;                                                                             
 var mover211539: Mover;                                                                            
 var Node._state211379: [Node]State;                                                                
 var AtomicMarkableReference.pair_nextThread211414: [AtomicMarkableReference]Tid;                   
 var path211384: int;                                                                               
 var Ref.mark211591: [Ref]bool;                                                                     
 var mover211379: Mover;                                                                            
 var _C_v: Ref;                                                                                     
 var AtomicMarkableReference._lock211591: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference.pair_nextThread211569: [AtomicMarkableReference]Tid;                   
 var $recorded.state211613: int;                                                                    
 var Ref.mark211467: [Ref]bool;                                                                     
 var tmp5211467: bool;                                                                              
 var AtomicMarkableReference.pair_nextValue211584: [AtomicMarkableReference]Ref;                    
 var tmp6211569: bool;                                                                              
 var ctmp192283211546: bool;                                                                        
 var current: Ref;                                                                                  
 var Ref.reference211467: [Ref]Node;                                                                
 var Ref._lock211591: [Ref]Tid;                                                                     
 var newReference211539: Node;                                                                      
 var tid211539: Tid;                                                                                
 var tmp6211542: bool;                                                                              
 var this211384: AtomicMarkableReference;                                                           
 var Ref._state211329: [Ref]State;                                                                  
 var tmp8211584: Node;                                                                              
 var AtomicMarkableReference._lock211539: [AtomicMarkableReference]Tid;                             
 var tmp10211546: Ref;                                                                              
 var $recorded.state211569: int;                                                                    
 var current211539: Ref;                                                                            
 var tid211584: Tid;                                                                                
 var moverPath211335: MoverPath;                                                                    
 var $recorded.state211467: int;                                                                    
 var Ref.reference211402: [Ref]Node;                                                                
 var expectedReference211613: Node;                                                                 
 var tmp8211542: Node;                                                                              
 var _R_t211379: Mover;                                                                             
 var expectedReference211467: Node;                                                                 
 var newReference211572: Node;                                                                      
 var AtomicMarkableReference.pair_nextValue211609: [AtomicMarkableReference]Ref;                    
 var AtomicMarkableReference.pair_nextValue211341: [AtomicMarkableReference]Ref;                    
 var newReference211584: Node;                                                                      
 var newMark211584: bool;                                                                           
 var newReference211609: Node;                                                                      
 var newMark211470: bool;                                                                           
 var _currentValue: Ref;                                                                            
 var this211539: AtomicMarkableReference;                                                           
 var Ref._state211470: [Ref]State;                                                                  
 var path211539: int;                                                                               
 var tmp7211584: bool;                                                                              
 var Node._state211335: [Node]State;                                                                
 var this211335: AtomicMarkableReference;                                                           
 var this211402: AtomicMarkableReference;                                                           
 var AtomicMarkableReference.pair211569: [AtomicMarkableReference]Ref;                              
 var newReference211329: Node;                                                                      
 var tid211402: Tid;                                                                                
 var tid211341: Tid;                                                                                
 var _C_t211329: Tid;                                                                               
 var newReference211470: Node;                                                                      
 var mover211384: Mover;                                                                            
 var AtomicMarkableReference.pair_nextValue211335: [AtomicMarkableReference]Ref;                    
 var Node._state211402: [Node]State;                                                                
 var AtomicMarkableReference.pair_nextThread211467: [AtomicMarkableReference]Tid;                   
 var mover211414: Mover;                                                                            
 var current211414: Ref;                                                                            
 var tmpValue211546: Ref;                                                                           
 var Ref._lock211384: [Ref]Tid;                                                                     
 var mover211335: Mover;                                                                            
 var AtomicMarkableReference.pair_nextThread211539: [AtomicMarkableReference]Tid;                   
 var $pc211341: Phase;                                                                              
 var AtomicMarkableReference._lock211470: [AtomicMarkableReference]Tid;                             
 var _currentValue211379: Ref;                                                                      
 var tmp8211591: Node;                                                                              
 var $pc211546: Phase;                                                                              
 var AtomicMarkableReference._lock211546: [AtomicMarkableReference]Tid;                             
 var newReference211467: Node;                                                                      
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 // 35.9: Ref current;                                                                              
                                                                                                    
 // NoOp: 'TraceOff'                                                                                
                                                                                                    
 // 35.9: Tid _C_t;                                                                                 
                                                                                                    
                                                                                                    
 // 35.9: _C_t := this.pair_nextThread  as B;                                                       
                                                                                                    
                                                                                                    
 moverPath211329 := ReadEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 mover211329 := m#moverPath(moverPath211329);                                                       
 path211329 := p#moverPath(moverPath211329);                                                        
 assume Node._state211329 == Node._state && Node._lock211329 == Node._lock && Ref._state211329 == Ref._state && Ref.reference211329 == Ref.reference && Ref.mark211329 == Ref.mark && Ref._lock211329 == Ref._lock && AtomicMarkableReference._state211329 == AtomicMarkableReference._state && AtomicMarkableReference.pair211329 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211329 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211329 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211329 == AtomicMarkableReference.pair_nextValue && _C_t211329 == _C_t && current211329 == current && $result211329 == $result && expectedReference211329 == expectedReference && newReference211329 == newReference && expectedMark211329 == expectedMark && newMark211329 == newMark && this211329 == this && tid211329 == tid && $pc211329 == $pc;
 assume $recorded.state211329 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this != AtomicMarkableReference.null;                                                      
 } else {                                                                                           
  assert this != AtomicMarkableReference.null;                                                             // (35.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (35.9): Reduction failure
 _C_t := AtomicMarkableReference.pair_nextThread[this];                                             
                                                                                                    
 // 35.9: Ref _C_v;                                                                                 
                                                                                                    
                                                                                                    
 // 35.9: _C_v := this.pair_nextValue  as B;                                                        
                                                                                                    
                                                                                                    
 moverPath211335 := ReadEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 mover211335 := m#moverPath(moverPath211335);                                                       
 path211335 := p#moverPath(moverPath211335);                                                        
 assume Node._state211335 == Node._state && Node._lock211335 == Node._lock && Ref._state211335 == Ref._state && Ref.reference211335 == Ref.reference && Ref.mark211335 == Ref.mark && Ref._lock211335 == Ref._lock && AtomicMarkableReference._state211335 == AtomicMarkableReference._state && AtomicMarkableReference.pair211335 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211335 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211335 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211335 == AtomicMarkableReference.pair_nextValue && _C_v211335 == _C_v && _C_t211335 == _C_t && current211335 == current && $result211335 == $result && expectedReference211335 == expectedReference && newReference211335 == newReference && expectedMark211335 == expectedMark && newMark211335 == newMark && this211335 == this && tid211335 == tid && $pc211335 == $pc;
 assume $recorded.state211335 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this != AtomicMarkableReference.null;                                                      
 } else {                                                                                           
  assert this != AtomicMarkableReference.null;                                                             // (35.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (35.9): Reduction failure
 _C_v := AtomicMarkableReference.pair_nextValue[this];                                              
                                                                                                    
 // 35.9: Ref _currentValue;                                                                        
                                                                                                    
                                                                                                    
 // 35.9: _currentValue := this.pair  as B;                                                         
                                                                                                    
                                                                                                    
 moverPath211341 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 mover211341 := m#moverPath(moverPath211341);                                                       
 path211341 := p#moverPath(moverPath211341);                                                        
 assume Node._state211341 == Node._state && Node._lock211341 == Node._lock && Ref._state211341 == Ref._state && Ref.reference211341 == Ref.reference && Ref.mark211341 == Ref.mark && Ref._lock211341 == Ref._lock && AtomicMarkableReference._state211341 == AtomicMarkableReference._state && AtomicMarkableReference.pair211341 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211341 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211341 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211341 == AtomicMarkableReference.pair_nextValue && _currentValue211341 == _currentValue && _C_v211341 == _C_v && _C_t211341 == _C_t && current211341 == current && $result211341 == $result && expectedReference211341 == expectedReference && newReference211341 == newReference && expectedMark211341 == expectedMark && newMark211341 == newMark && this211341 == this && tid211341 == tid && $pc211341 == $pc;
 assume $recorded.state211341 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this != AtomicMarkableReference.null;                                                      
 } else {                                                                                           
  assert this != AtomicMarkableReference.null;                                                             // (35.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, _B);                                                                        
 assert $pc != PhaseError;                                                                                 // (35.9): Reduction failure
 _currentValue := AtomicMarkableReference.pair[this];                                               
                                                                                                    
 // 35.9: Mover _R_t;                                                                               
                                                                                                    
                                                                                                    
 // 35.9: _R_t = readPermission(this.pair);                                                         
                                                                                                    
 _R_t := m#moverPath(ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));
                                                                                                    
 // 35.9: boolean _casable;                                                                         
                                                                                                    
                                                                                                    
 // 35.9: _casable = _R_t != E && true && _C_t == tid && _C_v == _currentValue;                     
                                                                                                    
 _casable := ((((_R_t!=_E)&&true)&&(_C_t==tid))&&(_C_v==_currentValue));                            
 if (_casable) {                                                                                    
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 35.9: current := this.pair  as R;                                                              
                                                                                                    
                                                                                                    
  moverPath211379 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
  mover211379 := m#moverPath(moverPath211379);                                                      
  path211379 := p#moverPath(moverPath211379);                                                       
  assume Node._state211379 == Node._state && Node._lock211379 == Node._lock && Ref._state211379 == Ref._state && Ref.reference211379 == Ref.reference && Ref.mark211379 == Ref.mark && Ref._lock211379 == Ref._lock && AtomicMarkableReference._state211379 == AtomicMarkableReference._state && AtomicMarkableReference.pair211379 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211379 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211379 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211379 == AtomicMarkableReference.pair_nextValue && _casable211379 == _casable && _R_t211379 == _R_t && _currentValue211379 == _currentValue && _C_v211379 == _C_v && _C_t211379 == _C_t && current211379 == current && $result211379 == $result && expectedReference211379 == expectedReference && newReference211379 == newReference && expectedMark211379 == expectedMark && newMark211379 == newMark && this211379 == this && tid211379 == tid && $pc211379 == $pc;
  assume $recorded.state211379 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this != AtomicMarkableReference.null;                                                     
  } else {                                                                                          
   assert this != AtomicMarkableReference.null;                                                            // (35.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _R);                                                                       
  assert $pc != PhaseError;                                                                                // (35.9): Reduction failure
  current := AtomicMarkableReference.pair[this];                                                    
 } else {                                                                                           
  // NoOp: 'TraceOn'                                                                                
                                                                                                    
  // 35.9: current := this.pair;                                                                    
                                                                                                    
                                                                                                    
  moverPath211384 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
  mover211384 := m#moverPath(moverPath211384);                                                      
  path211384 := p#moverPath(moverPath211384);                                                       
  assume Node._state211384 == Node._state && Node._lock211384 == Node._lock && Ref._state211384 == Ref._state && Ref.reference211384 == Ref.reference && Ref.mark211384 == Ref.mark && Ref._lock211384 == Ref._lock && AtomicMarkableReference._state211384 == AtomicMarkableReference._state && AtomicMarkableReference.pair211384 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211384 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211384 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211384 == AtomicMarkableReference.pair_nextValue && _casable211384 == _casable && _R_t211384 == _R_t && _currentValue211384 == _currentValue && _C_v211384 == _C_v && _C_t211384 == _C_t && current211384 == current && $result211384 == $result && expectedReference211384 == expectedReference && newReference211384 == newReference && expectedMark211384 == expectedMark && newMark211384 == newMark && this211384 == this && tid211384 == tid && $pc211384 == $pc;
  assume $recorded.state211384 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this != AtomicMarkableReference.null;                                                     
  } else {                                                                                          
   assert this != AtomicMarkableReference.null;                                                            // (35.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover211384);                                                              
  assert $pc != PhaseError;                                                                                // (35.9): Reduction failure
  current := AtomicMarkableReference.pair[this];                                                    
 }                                                                                                  
                                                                                                    
 // 36.9: boolean tmp5;                                                                             
                                                                                                    
                                                                                                    
 // 36.9: boolean tmp6;                                                                             
                                                                                                    
                                                                                                    
 // 36.9: boolean tmp7;                                                                             
                                                                                                    
                                                                                                    
 // 36.9: Node tmp8;                                                                                
                                                                                                    
                                                                                                    
 // 36.9: tmp8 := current.reference;                                                                
                                                                                                    
                                                                                                    
 moverPath211402 := ReadEval.Ref.reference(tid: Tid,current: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 mover211402 := m#moverPath(moverPath211402);                                                       
 path211402 := p#moverPath(moverPath211402);                                                        
 assume Node._state211402 == Node._state && Node._lock211402 == Node._lock && Ref._state211402 == Ref._state && Ref.reference211402 == Ref.reference && Ref.mark211402 == Ref.mark && Ref._lock211402 == Ref._lock && AtomicMarkableReference._state211402 == AtomicMarkableReference._state && AtomicMarkableReference.pair211402 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211402 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211402 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211402 == AtomicMarkableReference.pair_nextValue && tmp8211402 == tmp8 && tmp7211402 == tmp7 && tmp6211402 == tmp6 && tmp5211402 == tmp5 && current211402 == current && $result211402 == $result && expectedReference211402 == expectedReference && newReference211402 == newReference && expectedMark211402 == expectedMark && newMark211402 == newMark && this211402 == this && tid211402 == tid && $pc211402 == $pc;
 assume $recorded.state211402 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume current != Ref.null;                                                                       
 } else {                                                                                           
  assert current != Ref.null;                                                                              // (36.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover211402);                                                               
 assert $pc != PhaseError;                                                                                 // (36.9): Reduction failure
 tmp8 := Ref.reference[current];                                                                    
                                                                                                    
 // 36.9: tmp7 = expectedReference == tmp8;                                                         
                                                                                                    
 tmp7 := (expectedReference==tmp8);                                                                 
 if (tmp7) {                                                                                        
                                                                                                    
  // 38.41: boolean tmp9;                                                                           
                                                                                                    
                                                                                                    
  // 38.41: tmp9 := current.mark;                                                                   
                                                                                                    
                                                                                                    
  moverPath211414 := ReadEval.Ref.mark(tid: Tid,current: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
  mover211414 := m#moverPath(moverPath211414);                                                      
  path211414 := p#moverPath(moverPath211414);                                                       
  assume Node._state211414 == Node._state && Node._lock211414 == Node._lock && Ref._state211414 == Ref._state && Ref.reference211414 == Ref.reference && Ref.mark211414 == Ref.mark && Ref._lock211414 == Ref._lock && AtomicMarkableReference._state211414 == AtomicMarkableReference._state && AtomicMarkableReference.pair211414 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211414 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211414 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211414 == AtomicMarkableReference.pair_nextValue && tmp9211414 == tmp9 && tmp8211414 == tmp8 && tmp7211414 == tmp7 && tmp6211414 == tmp6 && tmp5211414 == tmp5 && current211414 == current && $result211414 == $result && expectedReference211414 == expectedReference && newReference211414 == newReference && expectedMark211414 == expectedMark && newMark211414 == newMark && this211414 == this && tid211414 == tid && $pc211414 == $pc;
  assume $recorded.state211414 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume current != Ref.null;                                                                      
  } else {                                                                                          
   assert current != Ref.null;                                                                             // (38.41): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover211414);                                                              
  assert $pc != PhaseError;                                                                                // (38.41): Reduction failure
  tmp9 := Ref.mark[current];                                                                        
                                                                                                    
  // 38.38: tmp6 = expectedMark == tmp9;                                                            
                                                                                                    
  tmp6 := (expectedMark==tmp9);                                                                     
 } else {                                                                                           
                                                                                                    
  // <undefined position>: tmp6 = false;                                                            
                                                                                                    
  tmp6 := false;                                                                                    
 }                                                                                                  
 if (tmp6) {                                                                                        
                                                                                                    
  // 39.50: Ref tmp10;                                                                              
                                                                                                    
                                                                                                    
  // 39.50: tmp10 = new Ref();                                                                      
                                                                                                    
  havoc tmp10;                                                                                      
  assume tmp10 != Ref.null && isFresh(Ref._state[tmp10]);                                           
  Ref._state[tmp10] := LOCAL(tid);                                                                  
  assume Ref.reference[tmp10]  == Node.null;                                                        
  assume Ref.mark[tmp10]  == false;                                                                 
  assume Ref._lock[tmp10]  == Tid.null;                                                             
  // inlined: tmp10.init(newReference,newMark)}                                                     
  exit$1_top:                                                                                       
                                                                                                    
  // 39.50: Node reference$1;                                                                       
                                                                                                    
                                                                                                    
  // 39.50: boolean mark$1;                                                                         
                                                                                                    
                                                                                                    
  // 39.50: Ref this$1;                                                                             
                                                                                                    
                                                                                                    
  // 39.50: reference$1 = newReference;                                                             
                                                                                                    
  reference$1 := newReference;                                                                      
                                                                                                    
  // 39.50: mark$1 = newMark;                                                                       
                                                                                                    
  mark$1 := newMark;                                                                                
                                                                                                    
  // 39.50: this$1 = tmp10;                                                                         
                                                                                                    
  this$1 := tmp10;                                                                                  
                                                                                                    
  // 7.5: assume this$1.reference == Node.null;                                                     
                                                                                                    
  assume (Ref.reference[this$1]==Node.null);                                                        
                                                                                                    
  // 7.5: assume this$1.mark == false;                                                              
                                                                                                    
  assume (Ref.mark[this$1]==false);                                                                 
                                                                                                    
                                                                                                    
  // 8.9: this$1.reference := reference$1;                                                          
                                                                                                    
                                                                                                    
  moverPath211467 := WriteEval.Ref.reference(tid: Tid,this$1: Ref,reference$1: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
  mover211467 := m#moverPath(moverPath211467);                                                      
  path211467 := p#moverPath(moverPath211467);                                                       
  assume Node._state211467 == Node._state && Node._lock211467 == Node._lock && Ref._state211467 == Ref._state && Ref.reference211467 == Ref.reference && Ref.mark211467 == Ref.mark && Ref._lock211467 == Ref._lock && AtomicMarkableReference._state211467 == AtomicMarkableReference._state && AtomicMarkableReference.pair211467 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211467 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211467 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211467 == AtomicMarkableReference.pair_nextValue && this$1211467 == this$1 && mark$1211467 == mark$1 && reference$1211467 == reference$1 && tmp10211467 == tmp10 && tmp8211467 == tmp8 && tmp7211467 == tmp7 && tmp6211467 == tmp6 && tmp5211467 == tmp5 && current211467 == current && $result211467 == $result && expectedReference211467 == expectedReference && newReference211467 == newReference && expectedMark211467 == expectedMark && newMark211467 == newMark && this211467 == this && tid211467 == tid && $pc211467 == $pc;
  assume $recorded.state211467 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this$1 != Ref.null;                                                                       
  } else {                                                                                          
   assert this$1 != Ref.null;                                                                              // (8.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover211467);                                                              
  assert $pc != PhaseError;                                                                                // (8.9): Reduction failure
  Ref.reference[this$1] := reference$1;                                                             
  if (isLocal(Node._state[reference$1], tid)) {                                                     
   Node._state[reference$1] := SHARED();                                                            
  }                                                                                                 
                                                                                                    
                                                                                                    
                                                                                                    
  // 9.9: this$1.mark := mark$1;                                                                    
                                                                                                    
                                                                                                    
  moverPath211470 := WriteEval.Ref.mark(tid: Tid,this$1: Ref,mark$1: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
  mover211470 := m#moverPath(moverPath211470);                                                      
  path211470 := p#moverPath(moverPath211470);                                                       
  assume Node._state211470 == Node._state && Node._lock211470 == Node._lock && Ref._state211470 == Ref._state && Ref.reference211470 == Ref.reference && Ref.mark211470 == Ref.mark && Ref._lock211470 == Ref._lock && AtomicMarkableReference._state211470 == AtomicMarkableReference._state && AtomicMarkableReference.pair211470 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211470 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211470 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211470 == AtomicMarkableReference.pair_nextValue && this$1211470 == this$1 && mark$1211470 == mark$1 && reference$1211470 == reference$1 && tmp10211470 == tmp10 && tmp8211470 == tmp8 && tmp7211470 == tmp7 && tmp6211470 == tmp6 && tmp5211470 == tmp5 && current211470 == current && $result211470 == $result && expectedReference211470 == expectedReference && newReference211470 == newReference && expectedMark211470 == expectedMark && newMark211470 == newMark && this211470 == this && tid211470 == tid && $pc211470 == $pc;
  assume $recorded.state211470 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this$1 != Ref.null;                                                                       
  } else {                                                                                          
   assert this$1 != Ref.null;                                                                              // (9.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover211470);                                                              
  assert $pc != PhaseError;                                                                                // (9.9): Reduction failure
  Ref.mark[this$1] := mark$1;                                                                       
                                                                                                    
  // 7.40: break exit$1;                                                                            
                                                                                                    
  goto exit$1_bottom;                                                                               
  exit$1_bottom:                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 39.25: boolean ctmp192283;                                                                     
                                                                                                    
                                                                                                    
  // 39.25: ctmp192283 = *;                                                                         
                                                                                                    
  havoc ctmp192283;                                                                                 
  if (ctmp192283) {                                                                                 
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 39.25: tmp5 = false;                                                                          
                                                                                                    
   tmp5 := false;                                                                                   
  } else {                                                                                          
                                                                                                    
   // 39.25: ctmp192283 = *;                                                                        
                                                                                                    
   havoc ctmp192283;                                                                                
   if (ctmp192283) {                                                                                
                                                                                                    
    // 39.25: Tid tmpTid;                                                                           
                                                                                                    
                                                                                                    
    // 39.25: Ref tmpValue;                                                                         
                                                                                                    
                                                                                                    
    // 39.25: Mover _m;                                                                             
                                                                                                    
                                                                                                    
    // 39.25: _m = writePermission(this.pair, tmp10);                                               
                                                                                                    
    _m := m#moverPath(WriteEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,tmp10: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));
                                                                                                    
    // 39.25: assume this.pair == current;                                                          
                                                                                                    
    assume (AtomicMarkableReference.pair[this]==current);                                           
                                                                                                    
    // 39.25: assume !goesWrong(_m);                                                                
                                                                                                    
    assume !(transition($pc, _m) == PhaseError);                                                    
                                                                                                    
    // 39.25: assume this.pair_nextThread == tid;                                                   
                                                                                                    
    assume (AtomicMarkableReference.pair_nextThread[this]==tid);                                    
                                                                                                    
    // 39.25: assume this.pair_nextValue == current;                                                
                                                                                                    
    assume (AtomicMarkableReference.pair_nextValue[this]==current);                                 
                                                                                                    
                                                                                                    
    // 39.25: this.pair_nextThread := tmpTid as B;                                                  
                                                                                                    
                                                                                                    
    moverPath211539 := WriteEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this: AtomicMarkableReference,tmpTid: Tid,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
    mover211539 := m#moverPath(moverPath211539);                                                    
    path211539 := p#moverPath(moverPath211539);                                                     
    assume Node._state211539 == Node._state && Node._lock211539 == Node._lock && Ref._state211539 == Ref._state && Ref.reference211539 == Ref.reference && Ref.mark211539 == Ref.mark && Ref._lock211539 == Ref._lock && AtomicMarkableReference._state211539 == AtomicMarkableReference._state && AtomicMarkableReference.pair211539 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211539 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211539 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211539 == AtomicMarkableReference.pair_nextValue && _m211539 == _m && tmpValue211539 == tmpValue && tmpTid211539 == tmpTid && ctmp192283211539 == ctmp192283 && tmp10211539 == tmp10 && tmp8211539 == tmp8 && tmp7211539 == tmp7 && tmp6211539 == tmp6 && tmp5211539 == tmp5 && current211539 == current && $result211539 == $result && expectedReference211539 == expectedReference && newReference211539 == newReference && expectedMark211539 == expectedMark && newMark211539 == newMark && this211539 == this && tid211539 == tid && $pc211539 == $pc;
    assume $recorded.state211539 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this != AtomicMarkableReference.null;                                                   
    } else {                                                                                        
     assert this != AtomicMarkableReference.null;                                                          // (39.25): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (39.25): Reduction failure
    AtomicMarkableReference.pair_nextThread[this] := tmpTid;                                        
                                                                                                    
                                                                                                    
    // 39.25: this.pair_nextValue := tmpValue as B;                                                 
                                                                                                    
                                                                                                    
    moverPath211542 := WriteEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this: AtomicMarkableReference,tmpValue: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
    mover211542 := m#moverPath(moverPath211542);                                                    
    path211542 := p#moverPath(moverPath211542);                                                     
    assume Node._state211542 == Node._state && Node._lock211542 == Node._lock && Ref._state211542 == Ref._state && Ref.reference211542 == Ref.reference && Ref.mark211542 == Ref.mark && Ref._lock211542 == Ref._lock && AtomicMarkableReference._state211542 == AtomicMarkableReference._state && AtomicMarkableReference.pair211542 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211542 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211542 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211542 == AtomicMarkableReference.pair_nextValue && _m211542 == _m && tmpValue211542 == tmpValue && tmpTid211542 == tmpTid && ctmp192283211542 == ctmp192283 && tmp10211542 == tmp10 && tmp8211542 == tmp8 && tmp7211542 == tmp7 && tmp6211542 == tmp6 && tmp5211542 == tmp5 && current211542 == current && $result211542 == $result && expectedReference211542 == expectedReference && newReference211542 == newReference && expectedMark211542 == expectedMark && newMark211542 == newMark && this211542 == this && tid211542 == tid && $pc211542 == $pc;
    assume $recorded.state211542 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this != AtomicMarkableReference.null;                                                   
    } else {                                                                                        
     assert this != AtomicMarkableReference.null;                                                          // (39.25): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (39.25): Reduction failure
    AtomicMarkableReference.pair_nextValue[this] := tmpValue;                                       
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 39.25: this.pair := tmp10;                                                                   
                                                                                                    
                                                                                                    
    moverPath211546 := WriteEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,tmp10: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
    mover211546 := m#moverPath(moverPath211546);                                                    
    path211546 := p#moverPath(moverPath211546);                                                     
    assume Node._state211546 == Node._state && Node._lock211546 == Node._lock && Ref._state211546 == Ref._state && Ref.reference211546 == Ref.reference && Ref.mark211546 == Ref.mark && Ref._lock211546 == Ref._lock && AtomicMarkableReference._state211546 == AtomicMarkableReference._state && AtomicMarkableReference.pair211546 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211546 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211546 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211546 == AtomicMarkableReference.pair_nextValue && _m211546 == _m && tmpValue211546 == tmpValue && tmpTid211546 == tmpTid && ctmp192283211546 == ctmp192283 && tmp10211546 == tmp10 && tmp8211546 == tmp8 && tmp7211546 == tmp7 && tmp6211546 == tmp6 && tmp5211546 == tmp5 && current211546 == current && $result211546 == $result && expectedReference211546 == expectedReference && newReference211546 == newReference && expectedMark211546 == expectedMark && newMark211546 == newMark && this211546 == this && tid211546 == tid && $pc211546 == $pc;
    assume $recorded.state211546 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this != AtomicMarkableReference.null;                                                   
    } else {                                                                                        
     assert this != AtomicMarkableReference.null;                                                          // (39.25): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover211546);                                                            
    assert $pc != PhaseError;                                                                              // (39.25): Reduction failure
    AtomicMarkableReference.pair[this] := tmp10;                                                    
    if (isLocal(Ref._state[tmp10], tid)) {                                                          
     Ref._state[tmp10] := SHARED();                                                                 
     assert isSharedAssignable(Node._state[Ref.reference[tmp10]]);                                         // (39.25): tmp10 became shared, but tmp10.reference may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 39.25: tmp5 = true;                                                                          
                                                                                                    
    tmp5 := true;                                                                                   
   } else {                                                                                         
                                                                                                    
    // 39.25: assume this.pair_nextThread == tid;                                                   
                                                                                                    
    assume (AtomicMarkableReference.pair_nextThread[this]==tid);                                    
                                                                                                    
    // 39.25: assume this.pair_nextValue == current;                                                
                                                                                                    
    assume (AtomicMarkableReference.pair_nextValue[this]==current);                                 
                                                                                                    
    // 39.25: Ref _currentValue;                                                                    
                                                                                                    
                                                                                                    
    // 39.25: _currentValue := this.pair  as B;                                                     
                                                                                                    
                                                                                                    
    moverPath211569 := ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
    mover211569 := m#moverPath(moverPath211569);                                                    
    path211569 := p#moverPath(moverPath211569);                                                     
    assume Node._state211569 == Node._state && Node._lock211569 == Node._lock && Ref._state211569 == Ref._state && Ref.reference211569 == Ref.reference && Ref.mark211569 == Ref.mark && Ref._lock211569 == Ref._lock && AtomicMarkableReference._state211569 == AtomicMarkableReference._state && AtomicMarkableReference.pair211569 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211569 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211569 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211569 == AtomicMarkableReference.pair_nextValue && _currentValue211569 == _currentValue && ctmp192283211569 == ctmp192283 && tmp10211569 == tmp10 && tmp8211569 == tmp8 && tmp7211569 == tmp7 && tmp6211569 == tmp6 && tmp5211569 == tmp5 && current211569 == current && $result211569 == $result && expectedReference211569 == expectedReference && newReference211569 == newReference && expectedMark211569 == expectedMark && newMark211569 == newMark && this211569 == this && tid211569 == tid && $pc211569 == $pc;
    assume $recorded.state211569 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this != AtomicMarkableReference.null;                                                   
    } else {                                                                                        
     assert this != AtomicMarkableReference.null;                                                          // (39.25): Cannot have potential null deference in left-mover part.
    }                                                                                               
                                                                                                    
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (39.25): Reduction failure
    _currentValue := AtomicMarkableReference.pair[this];                                            
                                                                                                    
                                                                                                    
    // 39.25: this.pair := current as B;                                                            
                                                                                                    
                                                                                                    
    moverPath211572 := WriteEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,current: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
    mover211572 := m#moverPath(moverPath211572);                                                    
    path211572 := p#moverPath(moverPath211572);                                                     
    assume Node._state211572 == Node._state && Node._lock211572 == Node._lock && Ref._state211572 == Ref._state && Ref.reference211572 == Ref.reference && Ref.mark211572 == Ref.mark && Ref._lock211572 == Ref._lock && AtomicMarkableReference._state211572 == AtomicMarkableReference._state && AtomicMarkableReference.pair211572 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211572 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211572 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211572 == AtomicMarkableReference.pair_nextValue && _currentValue211572 == _currentValue && ctmp192283211572 == ctmp192283 && tmp10211572 == tmp10 && tmp8211572 == tmp8 && tmp7211572 == tmp7 && tmp6211572 == tmp6 && tmp5211572 == tmp5 && current211572 == current && $result211572 == $result && expectedReference211572 == expectedReference && newReference211572 == newReference && expectedMark211572 == expectedMark && newMark211572 == newMark && this211572 == this && tid211572 == tid && $pc211572 == $pc;
    assume $recorded.state211572 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this != AtomicMarkableReference.null;                                                   
    } else {                                                                                        
     assert this != AtomicMarkableReference.null;                                                          // (39.25): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (39.25): Reduction failure
    AtomicMarkableReference.pair[this] := current;                                                  
    if (isLocal(Ref._state[current], tid)) {                                                        
     Ref._state[current] := SHARED();                                                               
     assert isSharedAssignable(Node._state[Ref.reference[current]]);                                       // (39.25): current became shared, but current.reference may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 39.25: Mover _m;                                                                             
                                                                                                    
                                                                                                    
    // 39.25: _m = writePermission(this.pair, tmp10);                                               
                                                                                                    
    _m := m#moverPath(WriteEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,tmp10: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));
                                                                                                    
                                                                                                    
    // 39.25: this.pair := _currentValue as B;                                                      
                                                                                                    
                                                                                                    
    moverPath211584 := WriteEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,_currentValue: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
    mover211584 := m#moverPath(moverPath211584);                                                    
    path211584 := p#moverPath(moverPath211584);                                                     
    assume Node._state211584 == Node._state && Node._lock211584 == Node._lock && Ref._state211584 == Ref._state && Ref.reference211584 == Ref.reference && Ref.mark211584 == Ref.mark && Ref._lock211584 == Ref._lock && AtomicMarkableReference._state211584 == AtomicMarkableReference._state && AtomicMarkableReference.pair211584 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211584 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211584 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211584 == AtomicMarkableReference.pair_nextValue && _m211584 == _m && _currentValue211584 == _currentValue && ctmp192283211584 == ctmp192283 && tmp10211584 == tmp10 && tmp8211584 == tmp8 && tmp7211584 == tmp7 && tmp6211584 == tmp6 && tmp5211584 == tmp5 && current211584 == current && $result211584 == $result && expectedReference211584 == expectedReference && newReference211584 == newReference && expectedMark211584 == expectedMark && newMark211584 == newMark && this211584 == this && tid211584 == tid && $pc211584 == $pc;
    assume $recorded.state211584 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this != AtomicMarkableReference.null;                                                   
    } else {                                                                                        
     assert this != AtomicMarkableReference.null;                                                          // (39.25): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, _B);                                                                     
    assert $pc != PhaseError;                                                                              // (39.25): Reduction failure
    AtomicMarkableReference.pair[this] := _currentValue;                                            
    if (isLocal(Ref._state[_currentValue], tid)) {                                                  
     Ref._state[_currentValue] := SHARED();                                                         
     assert isSharedAssignable(Node._state[Ref.reference[_currentValue]]);                                 // (39.25): _currentValue became shared, but _currentValue.reference may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 39.25: assume goesWrong(_m);                                                                 
                                                                                                    
    assume transition($pc, _m) == PhaseError;                                                       
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
                                                                                                    
    // 39.25: this.pair := tmp10;                                                                   
                                                                                                    
                                                                                                    
    moverPath211591 := WriteEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,tmp10: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
    mover211591 := m#moverPath(moverPath211591);                                                    
    path211591 := p#moverPath(moverPath211591);                                                     
    assume Node._state211591 == Node._state && Node._lock211591 == Node._lock && Ref._state211591 == Ref._state && Ref.reference211591 == Ref.reference && Ref.mark211591 == Ref.mark && Ref._lock211591 == Ref._lock && AtomicMarkableReference._state211591 == AtomicMarkableReference._state && AtomicMarkableReference.pair211591 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211591 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211591 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211591 == AtomicMarkableReference.pair_nextValue && _m211591 == _m && _currentValue211591 == _currentValue && ctmp192283211591 == ctmp192283 && tmp10211591 == tmp10 && tmp8211591 == tmp8 && tmp7211591 == tmp7 && tmp6211591 == tmp6 && tmp5211591 == tmp5 && current211591 == current && $result211591 == $result && expectedReference211591 == expectedReference && newReference211591 == newReference && expectedMark211591 == expectedMark && newMark211591 == newMark && this211591 == this && tid211591 == tid && $pc211591 == $pc;
    assume $recorded.state211591 == 1;                                                              
    if ($pc == PreCommit) {                                                                         
     assume this != AtomicMarkableReference.null;                                                   
    } else {                                                                                        
     assert this != AtomicMarkableReference.null;                                                          // (39.25): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover211591);                                                            
    assert $pc != PhaseError;                                                                              // (39.25): Reduction failure
    AtomicMarkableReference.pair[this] := tmp10;                                                    
    if (isLocal(Ref._state[tmp10], tid)) {                                                          
     Ref._state[tmp10] := SHARED();                                                                 
     assert isSharedAssignable(Node._state[Ref.reference[tmp10]]);                                         // (39.25): tmp10 became shared, but tmp10.reference may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
    // 39.25: tmp5 = false;                                                                         
                                                                                                    
    tmp5 := false;                                                                                  
   }                                                                                                
  }                                                                                                 
 } else {                                                                                           
                                                                                                    
  // <undefined position>: tmp5 = false;                                                            
                                                                                                    
  tmp5 := false;                                                                                    
 }                                                                                                  
                                                                                                    
 // 36.9:  return tmp5;                                                                             
                                                                                                    
 assume Node._state211609 == Node._state && Node._lock211609 == Node._lock && Ref._state211609 == Ref._state && Ref.reference211609 == Ref.reference && Ref.mark211609 == Ref.mark && Ref._lock211609 == Ref._lock && AtomicMarkableReference._state211609 == AtomicMarkableReference._state && AtomicMarkableReference.pair211609 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211609 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211609 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211609 == AtomicMarkableReference.pair_nextValue && tmp8211609 == tmp8 && tmp7211609 == tmp7 && tmp6211609 == tmp6 && tmp5211609 == tmp5 && current211609 == current && $result211609 == $result && expectedReference211609 == expectedReference && newReference211609 == newReference && expectedMark211609 == expectedMark && newMark211609 == newMark && this211609 == this && tid211609 == tid;
 assume $recorded.state211609 == 1;                                                                 
 $result := tmp5;                                                                                   
 assert  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (36.9): Object invariant may not hold.
 return;                                                                                            
                                                                                                    
 // 33.41: // return false;                                                                         
                                                                                                    
 assume Node._state211613 == Node._state && Node._lock211613 == Node._lock && Ref._state211613 == Ref._state && Ref.reference211613 == Ref.reference && Ref.mark211613 == Ref.mark && Ref._lock211613 == Ref._lock && AtomicMarkableReference._state211613 == AtomicMarkableReference._state && AtomicMarkableReference.pair211613 == AtomicMarkableReference.pair && AtomicMarkableReference._lock211613 == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread211613 == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue211613 == AtomicMarkableReference.pair_nextValue && tmp8211613 == tmp8 && tmp7211613 == tmp7 && tmp6211613 == tmp6 && tmp5211613 == tmp5 && current211613 == current && $result211613 == $result && expectedReference211613 == expectedReference && newReference211613 == newReference && expectedMark211613 == expectedMark && newMark211613 == newMark && this211613 == this && tid211613 == tid;
 assume $recorded.state211613 == 1;                                                                 
 $result := false;                                                                                  
 assert  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (33.41): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Node._state: [Node]State,Node._lock: [Node]Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid,AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref) returns (bool) {
  true &&                                                                                           
  (forall _i: Node  :: _i == Node.null <==> isNull(Node._state[_i])) &&                             
  (forall _i: Ref  :: _i == Ref.null <==> isNull(Ref._state[_i])) &&                                
  (forall _i: AtomicMarkableReference  :: _i == AtomicMarkableReference.null <==> isNull(AtomicMarkableReference._state[_i])) &&
  (forall _i: Ref ::  (isShared(Ref._state[_i]) ==> isSharedAssignable(Node._state[Ref.reference[_i]]))) &&
  (forall _i: Ref ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Ref._state[_i],_t) ==> isLocalAssignable(Node._state[Ref.reference[_i]], _t)))) &&
  (forall _i: AtomicMarkableReference ::  (isShared(AtomicMarkableReference._state[_i]) ==> isSharedAssignable(Ref._state[AtomicMarkableReference.pair[_i]]))) &&
  (forall _i: AtomicMarkableReference ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(AtomicMarkableReference._state[_i],_t) ==> isLocalAssignable(Ref._state[AtomicMarkableReference.pair[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, x: Ref)      
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Ref.reference[x] := v;                                                                             
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Ref.reference(u: Tid,x: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.5): Ref.reference failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, x: Ref)       
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Ref.reference[x] := v;                                                                             
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Ref.reference(u: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (5.5): Ref.reference failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, x: Ref)       
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Ref.reference[x];                                                                      
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Ref.reference[x] := havocValue;                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Ref.reference(u: Tid,x: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.5): Ref.reference failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, x: Ref)        
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Ref.reference[x];                                                                      
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Ref.reference(u: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (5.5): Ref.reference failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, x: Ref)            
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Ref.reference(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Ref.reference(u: Tid,x: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.5): Ref.reference failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, x: Ref)             
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Ref.reference[x];                                                                      
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Ref.reference(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Ref.reference[x] := havocValue;                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Ref.reference(u: Tid,x: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.5): Ref.reference failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, x: Ref)           
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Ref.mark[x] := v;                                                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Ref.mark(u: Tid,x: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.5): Ref.mark failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, x: Ref)            
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Ref.mark[x] := v;                                                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Ref.mark(u: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (6.5): Ref.mark failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, x: Ref)            
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Ref.mark[x];                                                                           
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Ref.mark[x] := havocValue;                                                                         
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Ref.mark(u: Tid,x: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.5): Ref.mark failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, x: Ref)             
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : bool;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Ref.mark[x];                                                                           
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Ref.mark(u: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (6.5): Ref.mark failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, x: Ref)                 
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Ref.mark(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Ref.mark(u: Tid,x: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.5): Ref.mark failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, x: Ref)                  
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Ref.mark[x];                                                                           
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Ref.mark(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Ref.mark[x] := havocValue;                                                                         
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Ref.mark(u: Tid,x: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.5): Ref.mark failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, x: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (15.5): AtomicMarkableReference.pair failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, x: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (15.5): AtomicMarkableReference.pair failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, x: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Ref;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReference.pair[x];                                                       
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 AtomicMarkableReference.pair[x] := havocValue;                                                     
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (15.5): AtomicMarkableReference.pair failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, x: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Ref;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReference.pair[x];                                                       
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (15.5): AtomicMarkableReference.pair failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, x: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (15.5): AtomicMarkableReference.pair failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, x: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Ref;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == AtomicMarkableReference.pair[x];                                                       
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 AtomicMarkableReference.pair[x] := havocValue;                                                     
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (15.5): AtomicMarkableReference.pair failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.reference.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.reference.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
                                                                                                    
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.reference.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.reference.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.reference(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[y] := w;                                                                             
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.reference(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.reference is not Read-Write Stable with respect to Ref.reference (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.reference is not Read-Write Stable with respect to Ref.reference (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.reference is not Read-Write Stable with respect to Ref.reference (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.reference.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.reference(u: Tid,y: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.reference(u: Tid,y: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.reference is not Write-Read Stable with respect to Ref.reference (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.reference is not Write-Read Stable with respect to Ref.reference (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Ref.reference is not Write-Read Stable with respect to Ref.reference (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.reference.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.reference.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
                                                                                                    
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.reference.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.reference.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.reference(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[y] := w;                                                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.reference(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.reference is not Read-Write Stable with respect to Ref.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.reference is not Read-Write Stable with respect to Ref.mark (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.reference is not Read-Write Stable with respect to Ref.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.reference.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.mark(u: Tid,y: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.mark(u: Tid,y: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Ref.mark is not Write-Read Stable with respect to Ref.reference (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Ref.mark is not Write-Read Stable with respect to Ref.reference (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Ref.mark is not Write-Read Stable with respect to Ref.reference (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.reference;                                                                            
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.reference;                                                                            
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var w0_mid: Ref;                                                                                   
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
                                                                                                    
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.reference;                                                                            
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var w0_mid: Ref;                                                                                   
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.reference;                                                                            
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.reference(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[y] := w;                                                              
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.reference(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.reference;                                                                            
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.reference (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.reference (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.reference (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.mark.Ref.reference(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.mark.Ref.reference(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var w0_mid: Node;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
                                                                                                    
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.mark.Ref.reference(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var w0_mid: Node;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.mark.Ref.reference(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.mark(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[y] := w;                                                                             
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.mark(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Ref.mark is not Read-Write Stable with respect to Ref.reference (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Ref.mark is not Read-Write Stable with respect to Ref.reference (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Ref.mark is not Read-Write Stable with respect to Ref.reference (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.mark.Ref.reference(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.reference(u: Tid,y: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.reference(u: Tid,y: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.reference is not Write-Read Stable with respect to Ref.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.reference is not Write-Read Stable with respect to Ref.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Ref.reference is not Write-Read Stable with respect to Ref.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.mark.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.mark.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
                                                                                                    
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.mark.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.mark.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.mark(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[y] := w;                                                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.mark(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Ref.mark is not Read-Write Stable with respect to Ref.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Ref.mark is not Read-Write Stable with respect to Ref.mark (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Ref.mark is not Read-Write Stable with respect to Ref.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.mark.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.mark(u: Tid,y: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.mark(u: Tid,y: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Ref.mark is not Write-Read Stable with respect to Ref.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Ref.mark is not Write-Read Stable with respect to Ref.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Ref.mark is not Write-Read Stable with respect to Ref.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.mark;                                                                                 
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var w_post: Ref;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.mark;                                                                                 
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var w0_mid: Ref;                                                                                   
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var w_post: Ref;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
                                                                                                    
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.mark;                                                                                 
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var w0_mid: Ref;                                                                                   
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var w_post: Ref;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.mark;                                                                                 
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var w_post: Ref;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.mark(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[y] := w;                                                              
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.mark(t: Tid,x: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Ref.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Ref.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Ref.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.mark;                                                                                 
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var w_post: Ref;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.pair.Ref.reference(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.pair.Ref.reference(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
                                                                                                    
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.pair.Ref.reference(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.pair.Ref.reference(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[y] := w;                                                                             
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.reference (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.reference (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.reference (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.pair.Ref.reference(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.reference(u: Tid,y: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.reference(u: Tid,y: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Ref.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.AtomicMarkableReference.pair.Ref.reference(t: Tid, u: Tid, v: Ref, w1: Node, w2: Node, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var w2_pre: Node;                                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w2_mid: Node;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w1: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Ref.reference[y];                                                                          
 Ref.reference[y] := w1;                                                                            
                                                                                                    
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Ref.reference(u: Tid,y: Ref,w2: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Ref.reference[y] := tmpW;                                                                          
                                                                                                    
 AtomicMarkableReference.pair[x] := v;                                                              
 Ref.reference[y] := w1;                                                                            
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Ref.reference(u: Tid,y: Ref,w2: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.AtomicMarkableReference.pair.Ref.reference(t: Tid, u: Tid, v1: Ref, v2: Ref, w: Node, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV: Ref;                                                                                     
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v2_pre: Ref;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var v1_pre: Ref;                                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var v2_mid: Ref;                                                                                   
 var v1_mid: Ref;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var v1_post: Ref;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var v2_post: Ref;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v1;                                                             
 _writeByTAfterT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v2: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 AtomicMarkableReference.pair[x] := tmpV;                                                           
                                                                                                    
 Ref.reference[y] := w;                                                                             
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v1: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 AtomicMarkableReference.pair[x] := v1;                                                             
 _writeByTAfterUAndT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v2: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.pair.Ref.mark(t: Tid, u: Tid, v: Ref, w: bool, w0: bool, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.pair.Ref.mark(t: Tid, u: Tid, v: Ref, w: bool, w0: bool, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
                                                                                                    
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.pair.Ref.mark(t: Tid, u: Tid, v: Ref, w: bool, w0: bool, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.pair.Ref.mark(t: Tid, u: Tid, v: Ref, w: bool, w0: bool, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[y] := w;                                                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.mark (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.pair.Ref.mark(t: Tid, u: Tid, v: Ref, w: bool, w0: bool, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.mark(u: Tid,y: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.mark(u: Tid,y: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Ref.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Ref.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Ref.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.AtomicMarkableReference.pair.Ref.mark(t: Tid, u: Tid, v: Ref, w1: bool, w2: bool, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpW: bool;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w2_pre: bool;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
 var w1_pre: bool;                                                                                  
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var y_mid: Ref;                                                                                    
 var w1_mid: bool;                                                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w2_mid: bool;                                                                                  
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w2_post: bool;                                                                                 
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w1_post: bool;                                                                                 
 var v_post: Ref;                                                                                   
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w1: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Ref.mark[y];                                                                               
 Ref.mark[y] := w1;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Ref.mark(u: Tid,y: Ref,w2: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Ref.mark[y] := tmpW;                                                                               
                                                                                                    
 AtomicMarkableReference.pair[x] := v;                                                              
 Ref.mark[y] := w1;                                                                                 
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Ref.mark(u: Tid,y: Ref,w2: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.AtomicMarkableReference.pair.Ref.mark(t: Tid, u: Tid, v1: Ref, v2: Ref, w: bool, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV: Ref;                                                                                     
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v2_pre: Ref;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var v1_pre: Ref;                                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var v2_mid: Ref;                                                                                   
 var v1_mid: Ref;                                                                                   
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var v1_post: Ref;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var v2_post: Ref;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v1;                                                             
 _writeByTAfterT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v2: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 AtomicMarkableReference.pair[x] := tmpV;                                                           
                                                                                                    
 Ref.mark[y] := w;                                                                                  
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v1: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 AtomicMarkableReference.pair[x] := v1;                                                             
 _writeByTAfterUAndT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v2: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, w0: Ref, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: Ref;                                                                                   
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, w0: Ref, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var w0_mid: Ref;                                                                                   
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: Ref;                                                                                   
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
                                                                                                    
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, w0: Ref, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var w0_mid: Ref;                                                                                   
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: Ref;                                                                                   
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, w0: Ref, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: Ref;                                                                                   
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[y] := w;                                                              
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, w0: Ref, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: Ref;                                                                                   
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w1: Ref, w2: Ref, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpW: Ref;                                                                                     
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w2_pre: Ref;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var w1_pre: Ref;                                                                                   
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var w2_mid: Ref;                                                                                   
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w1_mid: Ref;                                                                                   
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var w2_post: Ref;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var w1_post: Ref;                                                                                  
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w1: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := AtomicMarkableReference.pair[y];                                                           
 AtomicMarkableReference.pair[y] := w1;                                                             
                                                                                                    
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w2: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 AtomicMarkableReference.pair[y] := tmpW;                                                           
                                                                                                    
 AtomicMarkableReference.pair[x] := v;                                                              
 AtomicMarkableReference.pair[y] := w1;                                                             
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w2: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v1: Ref, v2: Ref, w: Ref, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV: Ref;                                                                                     
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                     
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                      
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v2_pre: Ref;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var v1_pre: Ref;                                                                                   
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var AtomicMarkableReference.pair_nextValue_mid: [AtomicMarkableReference]Ref;                      
 var v2_mid: Ref;                                                                                   
 var v1_mid: Ref;                                                                                   
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var AtomicMarkableReference.pair_nextThread_mid: [AtomicMarkableReference]Tid;                     
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var v1_post: Ref;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var v2_post: Ref;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                    
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                     
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v1;                                                             
 _writeByTAfterT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v2: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 AtomicMarkableReference.pair[x] := tmpV;                                                           
                                                                                                    
 AtomicMarkableReference.pair[y] := w;                                                              
 assume Node._state_mid == Node._state && Node._lock_mid == Node._lock && Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_mid == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_mid == AtomicMarkableReference.pair_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v1: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 AtomicMarkableReference.pair[x] := v1;                                                             
 _writeByTAfterUAndT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v2: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
requires ValidTid(tid);                                                                             
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (<undefined position>): Object invariant may not hold.
modifies Node._state;                                                                               
modifies Node._lock;                                                                                
modifies Ref._state;                                                                                
modifies Ref.reference;                                                                             
modifies Ref.mark;                                                                                  
modifies Ref._lock;                                                                                 
modifies AtomicMarkableReference._state;                                                            
modifies AtomicMarkableReference.pair;                                                              
modifies AtomicMarkableReference._lock;                                                             
modifies AtomicMarkableReference.pair_nextThread;                                                   
modifies AtomicMarkableReference.pair_nextValue;                                                    
ensures StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
ensures Y(tid , old(Node._state), old(Node._lock), old(Ref._state), old(Ref.reference), old(Ref.mark), old(Ref._lock), old(AtomicMarkableReference._state), old(AtomicMarkableReference.pair), old(AtomicMarkableReference._lock), old(AtomicMarkableReference.pair_nextThread), old(AtomicMarkableReference.pair_nextValue) , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
ensures  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// Node._lock:                                                                                      
                                                                                                    
function {:inline} Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)), _R)) ==> (Node._lock[this] == newValue))
 &&(((Node._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var this_yield: Node;                                                                               
var Ref._lock_yield: [Ref]Tid;                                                                      
var newValue_yield: Tid;                                                                            
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Ref;                     
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node._lock(u: Tid,this: Node,newValue: Tid,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)));
 assume leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)), _N);
assume Node._state_yield == Node._state && Node._lock_yield == Node._lock && Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, newValue , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var this_yield: Node;                                                                               
var Ref._lock_yield: [Ref]Tid;                                                                      
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Ref;                     
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node._lock_yield == Node._lock && Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, Node._lock[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Transitive(tid : Tid, this: Node, newValue : Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref , Node._state_p: [Node]State, Node._lock_p: [Node]Tid, Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires StateInvariant(Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (2.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var Ref.reference_pre: [Ref]Node;                                                                   
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                       
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
var this_post: Node;                                                                                
var newValue_post: Tid;                                                                             
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                      
                                                                                                    
assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue , Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
 assume Y_Node._lock(tid, this, newValue , Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
assume Node._state_post == Node._state_p && Node._lock_post == Node._lock_p && Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread_p && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node._lock(tid, this, newValue , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
// Ref.reference:                                                                                   
                                                                                                    
function {:inline} Y_Ref.reference(tid : Tid, this: Ref, newValue: Node , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 ((isAccessible(Ref._state[this], tid) && leq(m#moverPath(ReadEval.Ref.reference(tid: Tid,this: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)), _R)) ==> (Ref.reference[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Ref.reference(tid : Tid, this: Ref, newValue: Node , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Ref.reference.Subsumes.W(tid : Tid, u : Tid, this: Ref, newValue: Node , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var this_yield: Ref;                                                                                
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Node;                                                                           
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Ref;                     
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
 assume isAccessible(Ref._state[this], u);                                                          
 assume !isError(m#moverPath(WriteEval.Ref.reference(u: Tid,this: Ref,newValue: Node,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node._lock_yield == Node._lock && Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Ref.reference(tid, this, newValue , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Ref.reference.Reflexive(tid : Tid, this: Ref , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var this_yield: Ref;                                                                                
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Ref;                     
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
assume Node._state_yield == Node._state && Node._lock_yield == Node._lock && Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Ref.reference(tid, this, Ref.reference[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Ref.reference.Transitive(tid : Tid, this: Ref, newValue : Node , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref , Node._state_p: [Node]State, Node._lock_p: [Node]Tid, Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires StateInvariant(Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (5.32): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var Ref.reference_pre: [Ref]Node;                                                                   
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                       
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var this_pre: Ref;                                                                                  
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var this_post: Ref;                                                                                 
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                      
                                                                                                    
assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
 assume Y(tid , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue , Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
 assume Y_Ref.reference(tid, this, newValue , Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
assume Node._state_post == Node._state_p && Node._lock_post == Node._lock_p && Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread_p && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Ref.reference(tid, this, newValue , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
// Ref.mark:                                                                                        
                                                                                                    
function {:inline} Y_Ref.mark(tid : Tid, this: Ref, newValue: bool , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 ((isAccessible(Ref._state[this], tid) && leq(m#moverPath(ReadEval.Ref.mark(tid: Tid,this: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)), _R)) ==> (Ref.mark[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Ref.mark(tid : Tid, this: Ref, newValue: bool , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Ref.mark.Subsumes.W(tid : Tid, u : Tid, this: Ref, newValue: bool , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var newValue_yield: bool;                                                                           
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var this_yield: Ref;                                                                                
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Ref;                     
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
 assume isAccessible(Ref._state[this], u);                                                          
 assume !isError(m#moverPath(WriteEval.Ref.mark(u: Tid,this: Ref,newValue: bool,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node._lock_yield == Node._lock && Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Ref.mark(tid, this, newValue , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Ref.mark.Reflexive(tid : Tid, this: Ref , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var this_yield: Ref;                                                                                
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Ref;                     
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
assume Node._state_yield == Node._state && Node._lock_yield == Node._lock && Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Ref.mark(tid, this, Ref.mark[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Ref.mark.Transitive(tid : Tid, this: Ref, newValue : bool , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref , Node._state_p: [Node]State, Node._lock_p: [Node]Tid, Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires StateInvariant(Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (6.35): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var Ref.reference_pre: [Ref]Node;                                                                   
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                       
var newValue_pre: bool;                                                                             
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var this_pre: Ref;                                                                                  
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var this_post: Ref;                                                                                 
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var newValue_post: bool;                                                                            
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                      
                                                                                                    
assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
 assume Y(tid , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue , Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
 assume Y_Ref.mark(tid, this, newValue , Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
assume Node._state_post == Node._state_p && Node._lock_post == Node._lock_p && Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread_p && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Ref.mark(tid, this, newValue , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
// Ref._lock:                                                                                       
                                                                                                    
function {:inline} Y_Ref._lock(tid : Tid, this: Ref, newValue: Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 ((isAccessible(Ref._state[this], tid) && leq(m#moverPath(ReadEval.Ref._lock(tid: Tid,this: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)), _R)) ==> (Ref._lock[this] == newValue))
 &&(((Ref._lock[this]==tid)==(newValue==tid)))                                                      
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Ref._lock(tid : Tid, this: Ref, newValue: Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Ref._lock.Subsumes.W(tid : Tid, u : Tid, this: Ref, newValue: Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var newValue_yield: Tid;                                                                            
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var this_yield: Ref;                                                                                
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Ref;                     
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
 assume isAccessible(Ref._state[this], u);                                                          
 assume !isError(m#moverPath(WriteEval.Ref._lock(u: Tid,this: Ref,newValue: Tid,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)));
 assume leq(m#moverPath(ReadEval.Ref._lock(tid: Tid,this: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)), _N);
assume Node._state_yield == Node._state && Node._lock_yield == Node._lock && Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Ref._lock(tid, this, newValue , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Ref._lock.Reflexive(tid : Tid, this: Ref , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var this_yield: Ref;                                                                                
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Ref;                     
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
assume Node._state_yield == Node._state && Node._lock_yield == Node._lock && Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Ref._lock(tid, this, Ref._lock[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Ref._lock.Transitive(tid : Tid, this: Ref, newValue : Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref , Node._state_p: [Node]State, Node._lock_p: [Node]Tid, Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires StateInvariant(Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (4.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var Ref.reference_pre: [Ref]Node;                                                                   
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                       
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var this_pre: Ref;                                                                                  
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var this_post: Ref;                                                                                 
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
var newValue_post: Tid;                                                                             
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                      
                                                                                                    
assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
 assume Y(tid , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue , Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
 assume Y_Ref._lock(tid, this, newValue , Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
assume Node._state_post == Node._state_p && Node._lock_post == Node._lock_p && Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread_p && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Ref._lock(tid, this, newValue , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
// AtomicMarkableReference.pair:                                                                    
                                                                                                    
function {:inline} Y_AtomicMarkableReference.pair(tid : Tid, this: AtomicMarkableReference, newValue: Ref , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)), _R)) ==> (AtomicMarkableReference.pair[this] == newValue))
 &&(((newValue==AtomicMarkableReference.pair[this])||((!(isLocal(Ref._state[newValue], tid))&&!(isShared(Ref._state[newValue])))&&(newValue!=Ref.null))))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference.pair(tid : Tid, this: AtomicMarkableReference, newValue: Ref , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.pair.Subsumes.W(tid : Tid, u : Tid, this: AtomicMarkableReference, newValue: Ref , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Ref;                                                                            
var this_yield: AtomicMarkableReference;                                                            
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Ref;                     
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume isAccessible(AtomicMarkableReference._state[this], u);                                      
 assume !isError(m#moverPath(WriteEval.AtomicMarkableReference.pair(u: Tid,this: AtomicMarkableReference,newValue: Ref,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node._lock_yield == Node._lock && Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference.pair(tid, this, newValue , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.pair.Reflexive(tid : Tid, this: AtomicMarkableReference , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var this_yield: AtomicMarkableReference;                                                            
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Ref;                     
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
assume Node._state_yield == Node._state && Node._lock_yield == Node._lock && Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference.pair(tid, this, AtomicMarkableReference.pair[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.pair.Transitive(tid : Tid, this: AtomicMarkableReference, newValue : Ref , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref , Node._state_p: [Node]State, Node._lock_p: [Node]Tid, Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires StateInvariant(Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (15.39): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var this_pre: AtomicMarkableReference;                                                              
var Ref.reference_pre: [Ref]Node;                                                                   
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                       
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var newValue_pre: Ref;                                                                              
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var newValue_post: Ref;                                                                             
var this_post: AtomicMarkableReference;                                                             
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                      
                                                                                                    
assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume Y(tid , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue , Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
 assume Y_AtomicMarkableReference.pair(tid, this, newValue , Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
assume Node._state_post == Node._state_p && Node._lock_post == Node._lock_p && Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread_p && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_AtomicMarkableReference.pair(tid, this, newValue , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
                                                                                                    
procedure Check_AtomicMarkableReference.pair.ABAFree(tid : Tid, this: AtomicMarkableReference, A : Ref, B : Ref)
 modifies AtomicMarkableReference.pair;                                                             
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires AtomicMarkableReference.pair[this] == A;                                                  
 requires isAccessible(AtomicMarkableReference._state[this], tid);                                  
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (15.39): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var this_pre: AtomicMarkableReference;                                                              
var Ref.reference_pre: [Ref]Node;                                                                   
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                       
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var A_pre: Ref;                                                                                     
var Node._state_pre: [Node]State;                                                                   
var B_pre: Ref;                                                                                     
var tid_pre: Tid;                                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var B_post: Ref;                                                                                    
var tid_post: Tid;                                                                                  
var A_post: Ref;                                                                                    
var this_post: AtomicMarkableReference;                                                             
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                      
                                                                                                    
assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && B_pre == B && A_pre == A && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume Y_AtomicMarkableReference.pair(tid, this, B , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 assume A != B;                                                                                     
AtomicMarkableReference.pair[this] := B;                                                            
assume Node._state_post == Node._state && Node._lock_post == Node._lock && Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue && B_post == B && A_post == A && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert !(Y_AtomicMarkableReference.pair(tid, this, A , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue));
}                                                                                                   
// AtomicMarkableReference._lock:                                                                   
                                                                                                    
function {:inline} Y_AtomicMarkableReference._lock(tid : Tid, this: AtomicMarkableReference, newValue: Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference._lock(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)), _R)) ==> (AtomicMarkableReference._lock[this] == newValue))
 &&(((AtomicMarkableReference._lock[this]==tid)==(newValue==tid)))                                  
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference._lock(tid : Tid, this: AtomicMarkableReference, newValue: Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference._lock.Subsumes.W(tid : Tid, u : Tid, this: AtomicMarkableReference, newValue: Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var newValue_yield: Tid;                                                                            
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var this_yield: AtomicMarkableReference;                                                            
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Ref;                     
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume isAccessible(AtomicMarkableReference._state[this], u);                                      
 assume !isError(m#moverPath(WriteEval.AtomicMarkableReference._lock(u: Tid,this: AtomicMarkableReference,newValue: Tid,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)));
 assume leq(m#moverPath(ReadEval.AtomicMarkableReference._lock(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)), _N);
assume Node._state_yield == Node._state && Node._lock_yield == Node._lock && Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference._lock(tid, this, newValue , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference._lock.Reflexive(tid : Tid, this: AtomicMarkableReference , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var this_yield: AtomicMarkableReference;                                                            
var AtomicMarkableReference.pair_nextThread_yield: [AtomicMarkableReference]Tid;                    
var AtomicMarkableReference.pair_nextValue_yield: [AtomicMarkableReference]Ref;                     
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
assume Node._state_yield == Node._state && Node._lock_yield == Node._lock && Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_yield == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_yield == AtomicMarkableReference.pair_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference._lock(tid, this, AtomicMarkableReference._lock[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference._lock.Transitive(tid : Tid, this: AtomicMarkableReference, newValue : Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref , Node._state_p: [Node]State, Node._lock_p: [Node]Tid, Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Ref)
 requires StateInvariant(Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
 requires StateInvariant(Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.204864(tid: Tid,_this : AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue));       // (13.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var this_pre: AtomicMarkableReference;                                                              
var Ref.reference_pre: [Ref]Node;                                                                   
var AtomicMarkableReference.pair_nextThread_pre: [AtomicMarkableReference]Tid;                      
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_nextValue_pre: [AtomicMarkableReference]Ref;                       
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var this_post: AtomicMarkableReference;                                                             
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var AtomicMarkableReference.pair_nextThread_post: [AtomicMarkableReference]Tid;                     
var newValue_post: Tid;                                                                             
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
var AtomicMarkableReference.pair_nextValue_post: [AtomicMarkableReference]Ref;                      
                                                                                                    
assume Node._state_pre == Node._state && Node._lock_pre == Node._lock && Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && AtomicMarkableReference.pair_nextThread_pre == AtomicMarkableReference.pair_nextThread && AtomicMarkableReference.pair_nextValue_pre == AtomicMarkableReference.pair_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume Y(tid , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue , Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
 assume Y_AtomicMarkableReference._lock(tid, this, newValue , Node._state_p, Node._lock_p, Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, AtomicMarkableReference.pair_nextThread_p, AtomicMarkableReference.pair_nextValue_p);
assume Node._state_post == Node._state_p && Node._lock_post == Node._lock_p && Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && AtomicMarkableReference.pair_nextThread_post == AtomicMarkableReference.pair_nextThread_p && AtomicMarkableReference.pair_nextValue_post == AtomicMarkableReference.pair_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_AtomicMarkableReference._lock(tid, this, newValue , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue);
}                                                                                                   
// AtomicMarkableReference.pair_nextThread:                                                         
                                                                                                    
function {:inline} Y_AtomicMarkableReference.pair_nextThread(tid : Tid, this: AtomicMarkableReference, newValue: Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference.pair_nextThread(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)), _R)) ==> (AtomicMarkableReference.pair_nextThread[this] == newValue))
 &&(((AtomicMarkableReference.pair_nextThread[this]==tid)==>(newValue==tid)))                       
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference.pair_nextThread(tid : Tid, this: AtomicMarkableReference, newValue: Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// AtomicMarkableReference.pair_nextValue:                                                          
                                                                                                    
function {:inline} Y_AtomicMarkableReference.pair_nextValue(tid : Tid, this: AtomicMarkableReference, newValue: Ref , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference.pair_nextValue(tid: Tid,this: AtomicMarkableReference,Node._state,Node._lock,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,AtomicMarkableReference.pair_nextThread,AtomicMarkableReference.pair_nextValue)), _R)) ==> (AtomicMarkableReference.pair_nextValue[this] == newValue))
 &&(((AtomicMarkableReference.pair_nextThread[this]==tid)==>(newValue==AtomicMarkableReference.pair_nextValue[this])))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference.pair_nextValue(tid : Tid, this: AtomicMarkableReference, newValue: Ref , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Node._state: [Node]State, Node._lock: [Node]Tid, Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue: [AtomicMarkableReference]Ref , Node._state_p: [Node]State, Node._lock_p: [Node]Tid, Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextThread_p: [AtomicMarkableReference]Tid, AtomicMarkableReference.pair_nextValue_p: [AtomicMarkableReference]Ref): bool
{                                                                                                   
 (forall this: Node :: Y_Node._lock(tid : Tid, this, Node._lock_p[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue))
 && (forall this: Ref :: Y_Ref.reference(tid : Tid, this, Ref.reference_p[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue))
 && (forall this: Ref :: Y_Ref.mark(tid : Tid, this, Ref.mark_p[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue))
 && (forall this: Ref :: Y_Ref._lock(tid : Tid, this, Ref._lock_p[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference.pair(tid : Tid, this, AtomicMarkableReference.pair_p[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference._lock(tid : Tid, this, AtomicMarkableReference._lock_p[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference.pair_nextThread(tid : Tid, this, AtomicMarkableReference.pair_nextThread_p[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference.pair_nextValue(tid : Tid, this, AtomicMarkableReference.pair_nextValue_p[this] , Node._state, Node._lock, Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, AtomicMarkableReference.pair_nextThread, AtomicMarkableReference.pair_nextValue))
 && (forall _i : Node :: isShared(Node._state[_i]) ==> isShared(Node._state_p[_i]))                 
 && (forall _i : Node :: isLocal(Node._state[_i], tid) <==> isLocal(Node._state_p[_i], tid))        
 && (forall _i : Ref :: isShared(Ref._state[_i]) ==> isShared(Ref._state_p[_i]))                    
 && (forall _i : Ref :: isLocal(Ref._state[_i], tid) <==> isLocal(Ref._state_p[_i], tid))           
 && (forall _i : AtomicMarkableReference :: isShared(AtomicMarkableReference._state[_i]) ==> isShared(AtomicMarkableReference._state_p[_i]))
 && (forall _i : AtomicMarkableReference :: isLocal(AtomicMarkableReference._state[_i], tid) <==> isLocal(AtomicMarkableReference._state_p[_i], tid))
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 1563.1-1941.2: (Method:22.5)
// 1579.1-1579.24: (22.5): Bad tid
// 1580.1-1580.57: (22.5): this is not global
// 1583.1-1583.486: (22.5): Object invariant may not hold.
// 1586.1-1586.485: (22.5): Object invariant may not hold.
// 1778.2-1780.2: (class anchor.sink.VarDeclStmt:23.9)
// 1781.2-1783.2: (class anchor.sink.VarDeclStmt:23.9)
// 1785.2-1787.2: (class anchor.sink.VarDeclStmt:23.9)
// 1788.2-1805.56: (class anchor.sink.Read:23.9)
// 1800.1-1800.47: (23.9): Cannot have potential null deference in left-mover part.
// 1804.1-1804.27: (23.9): Reduction failure
// 1806.2-1808.2: (class anchor.sink.VarDeclStmt:23.9)
// 1809.2-1826.55: (class anchor.sink.Read:23.9)
// 1821.1-1821.47: (23.9): Cannot have potential null deference in left-mover part.
// 1825.1-1825.27: (23.9): Reduction failure
// 1827.2-1829.2: (class anchor.sink.VarDeclStmt:23.9)
// 1830.2-1847.54: (class anchor.sink.Read:23.9)
// 1842.1-1842.47: (23.9): Cannot have potential null deference in left-mover part.
// 1846.1-1846.27: (23.9): Reduction failure
// 1848.2-1850.2: (class anchor.sink.VarDeclStmt:23.9)
// 1851.2-1854.337: (class anchor.sink.Assign:23.9)
// 1855.2-1857.2: (class anchor.sink.VarDeclStmt:23.9)
// 1858.2-1861.73: (class anchor.sink.Assign:23.9)
// 1864.3-1881.46: (class anchor.sink.Read:23.9)
// 1876.1-1876.48: (23.9): Cannot have potential null deference in left-mover part.
// 1880.1-1880.28: (23.9): Reduction failure
// 1884.3-1901.46: (class anchor.sink.Read:23.9)
// 1896.1-1896.48: (23.9): Cannot have potential null deference in left-mover part.
// 1900.1-1900.28: (23.9): Reduction failure
// 1903.2-1920.30: (class anchor.sink.Read:23.9)
// 1915.1-1915.27: (23.9): Cannot have potential null deference in left-mover part.
// 1919.1-1919.27: (23.9): Reduction failure
// 1921.2-1932.9: (class anchor.sink.Return:23.9)
// 1931.1-1931.485: (23.9): Object invariant may not hold.
// 1933.2-1940.9: (class anchor.sink.Return:22.32)
// 1939.1-1939.485: (22.32): Object invariant may not hold.
// 1942.1-2316.2: (Method:26.5)
// 1958.1-1958.24: (26.5): Bad tid
// 1959.1-1959.57: (26.5): this is not global
// 1962.1-1962.486: (26.5): Object invariant may not hold.
// 1965.1-1965.485: (26.5): Object invariant may not hold.
// 2157.2-2159.2: (class anchor.sink.VarDeclStmt:27.9)
// 2160.2-2162.2: (class anchor.sink.VarDeclStmt:27.9)
// 2164.2-2166.2: (class anchor.sink.VarDeclStmt:27.9)
// 2167.2-2184.56: (class anchor.sink.Read:27.9)
// 2179.1-2179.47: (27.9): Cannot have potential null deference in left-mover part.
// 2183.1-2183.27: (27.9): Reduction failure
// 2185.2-2187.2: (class anchor.sink.VarDeclStmt:27.9)
// 2188.2-2205.55: (class anchor.sink.Read:27.9)
// 2200.1-2200.47: (27.9): Cannot have potential null deference in left-mover part.
// 2204.1-2204.27: (27.9): Reduction failure
// 2206.2-2208.2: (class anchor.sink.VarDeclStmt:27.9)
// 2209.2-2226.54: (class anchor.sink.Read:27.9)
// 2221.1-2221.47: (27.9): Cannot have potential null deference in left-mover part.
// 2225.1-2225.27: (27.9): Reduction failure
// 2227.2-2229.2: (class anchor.sink.VarDeclStmt:27.9)
// 2230.2-2233.337: (class anchor.sink.Assign:27.9)
// 2234.2-2236.2: (class anchor.sink.VarDeclStmt:27.9)
// 2237.2-2240.73: (class anchor.sink.Assign:27.9)
// 2243.3-2260.46: (class anchor.sink.Read:27.9)
// 2255.1-2255.48: (27.9): Cannot have potential null deference in left-mover part.
// 2259.1-2259.28: (27.9): Reduction failure
// 2263.3-2280.46: (class anchor.sink.Read:27.9)
// 2275.1-2275.48: (27.9): Cannot have potential null deference in left-mover part.
// 2279.1-2279.28: (27.9): Reduction failure
// 2282.2-2299.25: (class anchor.sink.Read:27.9)
// 2294.1-2294.27: (27.9): Cannot have potential null deference in left-mover part.
// 2298.1-2298.27: (27.9): Reduction failure
// 2300.2-2307.9: (class anchor.sink.Return:27.9)
// 2306.1-2306.485: (27.9): Object invariant may not hold.
// 2308.2-2315.9: (class anchor.sink.Return:26.31)
// 2314.1-2314.485: (26.31): Object invariant may not hold.
// 2317.1-3429.2: (Method:30.5)
// 2333.1-2333.24: (30.5): Bad tid
// 2334.1-2334.61: (30.5): Parameter VarDecl(ClassType(Node),expectedReference) is not global
// 2335.1-2335.56: (30.5): Parameter VarDecl(ClassType(Node),newReference) is not global
// 2336.1-2336.57: (30.5): this is not global
// 2339.1-2339.486: (30.5): Object invariant may not hold.
// 2342.1-2342.485: (30.5): Object invariant may not hold.
// 2900.2-2902.2: (class anchor.sink.VarDeclStmt:35.9)
// 2904.2-2906.2: (class anchor.sink.VarDeclStmt:35.9)
// 2907.2-2924.56: (class anchor.sink.Read:35.9)
// 2919.1-2919.47: (35.9): Cannot have potential null deference in left-mover part.
// 2923.1-2923.27: (35.9): Reduction failure
// 2925.2-2927.2: (class anchor.sink.VarDeclStmt:35.9)
// 2928.2-2945.55: (class anchor.sink.Read:35.9)
// 2940.1-2940.47: (35.9): Cannot have potential null deference in left-mover part.
// 2944.1-2944.27: (35.9): Reduction failure
// 2946.2-2948.2: (class anchor.sink.VarDeclStmt:35.9)
// 2949.2-2966.54: (class anchor.sink.Read:35.9)
// 2961.1-2961.47: (35.9): Cannot have potential null deference in left-mover part.
// 2965.1-2965.27: (35.9): Reduction failure
// 2967.2-2969.2: (class anchor.sink.VarDeclStmt:35.9)
// 2970.2-2973.337: (class anchor.sink.Assign:35.9)
// 2974.2-2976.2: (class anchor.sink.VarDeclStmt:35.9)
// 2977.2-2980.73: (class anchor.sink.Assign:35.9)
// 2983.3-3000.49: (class anchor.sink.Read:35.9)
// 2995.1-2995.48: (35.9): Cannot have potential null deference in left-mover part.
// 2999.1-2999.28: (35.9): Reduction failure
// 3003.3-3020.49: (class anchor.sink.Read:35.9)
// 3015.1-3015.48: (35.9): Cannot have potential null deference in left-mover part.
// 3019.1-3019.28: (35.9): Reduction failure
// 3022.2-3024.2: (class anchor.sink.VarDeclStmt:36.9)
// 3025.2-3027.2: (class anchor.sink.VarDeclStmt:36.9)
// 3028.2-3030.2: (class anchor.sink.VarDeclStmt:36.9)
// 3031.2-3033.2: (class anchor.sink.VarDeclStmt:36.9)
// 3034.2-3051.33: (class anchor.sink.Read:36.9)
// 3046.1-3046.30: (36.9): Cannot have potential null deference in left-mover part.
// 3050.1-3050.27: (36.9): Reduction failure
// 3052.2-3055.36: (class anchor.sink.Assign:36.9)
// 3057.3-3059.3: (class anchor.sink.VarDeclStmt:38.41)
// 3060.3-3077.29: (class anchor.sink.Read:38.41)
// 3072.1-3072.31: (38.41): Cannot have potential null deference in left-mover part.
// 3076.1-3076.28: (38.41): Reduction failure
// 3078.3-3081.32: (class anchor.sink.Assign:38.38)
// 3083.3-3086.17: (class anchor.sink.Assign:<undefined position>)
// 3089.3-3091.3: (class anchor.sink.VarDeclStmt:39.50)
// 3092.3-3100.40: (class anchor.sink.Alloc:39.50)
// 3103.3-3105.3: (class anchor.sink.VarDeclStmt:39.50)
// 3106.3-3108.3: (class anchor.sink.VarDeclStmt:39.50)
// 3109.3-3111.3: (class anchor.sink.VarDeclStmt:39.50)
// 3112.3-3115.31: (class anchor.sink.Assign:39.50)
// 3116.3-3119.21: (class anchor.sink.Assign:39.50)
// 3120.3-3123.19: (class anchor.sink.Assign:39.50)
// 3124.3-3127.45: (class anchor.sink.Assume:7.5)
// 3128.3-3131.36: (class anchor.sink.Assume:7.5)
// 3133.3-3153.3: (class anchor.sink.Write:8.9)
// 3145.1-3145.30: (8.9): Cannot have potential null deference in left-mover part.
// 3148.1-3148.28: (8.9): Reduction failure
// 3155.3-3171.30: (class anchor.sink.Write:9.9)
// 3167.1-3167.30: (9.9): Cannot have potential null deference in left-mover part.
// 3170.1-3170.28: (9.9): Reduction failure
// 3172.3-3175.22: (class anchor.sink.Break:7.40)
// 3178.3-3180.3: (class anchor.sink.VarDeclStmt:39.25)
// 3181.3-3184.20: (class anchor.sink.Assign:39.25)
// 3187.4-3190.18: (class anchor.sink.Assign:39.25)
// 3192.4-3195.21: (class anchor.sink.Assign:39.25)
// 3197.5-3199.5: (class anchor.sink.VarDeclStmt:39.25)
// 3200.5-3202.5: (class anchor.sink.VarDeclStmt:39.25)
// 3203.5-3205.5: (class anchor.sink.VarDeclStmt:39.25)
// 3206.5-3209.350: (class anchor.sink.Assign:39.25)
// 3210.5-3213.58: (class anchor.sink.Assume:39.25)
// 3214.5-3217.49: (class anchor.sink.Assume:39.25)
// 3218.5-3221.65: (class anchor.sink.Assume:39.25)
// 3222.5-3225.68: (class anchor.sink.Assume:39.25)
// 3227.5-3243.61: (class anchor.sink.Write:39.25)
// 3239.1-3239.50: (39.25): Cannot have potential null deference in left-mover part.
// 3242.1-3242.30: (39.25): Reduction failure
// 3245.5-3261.62: (class anchor.sink.Write:39.25)
// 3257.1-3257.50: (39.25): Cannot have potential null deference in left-mover part.
// 3260.1-3260.30: (39.25): Reduction failure
// 3264.5-3285.5: (class anchor.sink.Write:39.25)
// 3276.1-3276.50: (39.25): Cannot have potential null deference in left-mover part.
// 3279.1-3279.30: (39.25): Reduction failure
// 3283.1-3283.67: (39.25): tmp10 became shared, but tmp10.reference may not be shared.
// 3286.5-3289.18: (class anchor.sink.Assign:39.25)
// 3291.5-3294.65: (class anchor.sink.Assume:39.25)
// 3295.5-3298.68: (class anchor.sink.Assume:39.25)
// 3299.5-3301.5: (class anchor.sink.VarDeclStmt:39.25)
// 3302.5-3319.57: (class anchor.sink.Read:39.25)
// 3314.1-3314.50: (39.25): Cannot have potential null deference in left-mover part.
// 3318.1-3318.30: (39.25): Reduction failure
// 3321.5-3342.5: (class anchor.sink.Write:39.25)
// 3333.1-3333.50: (39.25): Cannot have potential null deference in left-mover part.
// 3336.1-3336.30: (39.25): Reduction failure
// 3340.1-3340.69: (39.25): current became shared, but current.reference may not be shared.
// 3343.5-3345.5: (class anchor.sink.VarDeclStmt:39.25)
// 3346.5-3349.350: (class anchor.sink.Assign:39.25)
// 3351.5-3372.5: (class anchor.sink.Write:39.25)
// 3363.1-3363.50: (39.25): Cannot have potential null deference in left-mover part.
// 3366.1-3366.30: (39.25): Reduction failure
// 3370.1-3370.75: (39.25): _currentValue became shared, but _currentValue.reference may not be shared.
// 3373.5-3376.46: (class anchor.sink.Assume:39.25)
// 3379.5-3400.5: (class anchor.sink.Write:39.25)
// 3391.1-3391.50: (39.25): Cannot have potential null deference in left-mover part.
// 3394.1-3394.30: (39.25): Reduction failure
// 3398.1-3398.67: (39.25): tmp10 became shared, but tmp10.reference may not be shared.
// 3401.5-3404.19: (class anchor.sink.Assign:39.25)
// 3408.3-3411.17: (class anchor.sink.Assign:<undefined position>)
// 3413.2-3420.9: (class anchor.sink.Return:36.9)
// 3419.1-3419.485: (36.9): Object invariant may not hold.
// 3421.2-3428.9: (class anchor.sink.Return:33.41)
// 3427.1-3427.485: (33.41): Object invariant may not hold.
// 3525.1-3525.34: (5.5): Ref.reference failed Write-Write Right-Mover Check
// 3598.1-3598.30: (5.5): Ref.reference failed Write-Read Right-Mover Check
// 3675.1-3675.34: (5.5): Ref.reference failed Write-Write Left-Mover Check
// 3749.1-3749.30: (5.5): Ref.reference failed Write-Read Left-Mover Check
// 3820.1-3820.34: (5.5): Ref.reference failed Read-Write Right-Mover Check
// 3894.1-3894.34: (5.5): Ref.reference failed Read-Write Left-Mover Check
// 3967.1-3967.34: (6.5): Ref.mark failed Write-Write Right-Mover Check
// 4040.1-4040.30: (6.5): Ref.mark failed Write-Read Right-Mover Check
// 4117.1-4117.34: (6.5): Ref.mark failed Write-Write Left-Mover Check
// 4191.1-4191.30: (6.5): Ref.mark failed Write-Read Left-Mover Check
// 4262.1-4262.34: (6.5): Ref.mark failed Read-Write Right-Mover Check
// 4336.1-4336.34: (6.5): Ref.mark failed Read-Write Left-Mover Check
// 4409.1-4409.34: (15.5): AtomicMarkableReference.pair failed Write-Write Right-Mover Check
// 4482.1-4482.30: (15.5): AtomicMarkableReference.pair failed Write-Read Right-Mover Check
// 4559.1-4559.34: (15.5): AtomicMarkableReference.pair failed Write-Write Left-Mover Check
// 4633.1-4633.30: (15.5): AtomicMarkableReference.pair failed Write-Read Left-Mover Check
// 4704.1-4704.34: (15.5): AtomicMarkableReference.pair failed Read-Write Right-Mover Check
// 4778.1-4778.34: (15.5): AtomicMarkableReference.pair failed Read-Write Left-Mover Check
// 4863.1-4863.140: (5.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case A.1)
// 4864.1-4864.101: (5.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case A.2)
// 4865.1-4865.158: (5.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case A.3)
// 4982.1-4982.140: (5.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case C)
// 5104.1-5104.144: (5.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case D)
// 5105.1-5105.144: (5.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case R)
// 5190.1-5190.136: (5.5): Ref.reference is not Read-Write Stable with respect to Ref.reference (case F)
// 5191.1-5191.136: (5.5): Ref.reference is not Read-Write Stable with respect to Ref.reference (case H)
// 5192.1-5192.146: (5.5): Ref.reference is not Read-Write Stable with respect to Ref.reference (case I)
// 5276.1-5276.136: (5.5): Ref.reference is not Write-Read Stable with respect to Ref.reference (case J)
// 5277.1-5277.136: (5.5): Ref.reference is not Write-Read Stable with respect to Ref.reference (case K)
// 5278.1-5278.99: (5.5): Ref.reference is not Write-Read Stable with respect to Ref.reference (case L)
// 5364.1-5364.140: (6.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case A.1)
// 5365.1-5365.101: (6.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case A.2)
// 5366.1-5366.158: (6.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case A.3)
// 5483.1-5483.140: (5.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case C)
// 5605.1-5605.144: (5.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case D)
// 5606.1-5606.144: (5.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case R)
// 5691.1-5691.136: (5.5): Ref.reference is not Read-Write Stable with respect to Ref.mark (case F)
// 5692.1-5692.136: (5.5): Ref.reference is not Read-Write Stable with respect to Ref.mark (case H)
// 5693.1-5693.146: (5.5): Ref.reference is not Read-Write Stable with respect to Ref.mark (case I)
// 5777.1-5777.136: (6.5): Ref.mark is not Write-Read Stable with respect to Ref.reference (case J)
// 5778.1-5778.136: (6.5): Ref.mark is not Write-Read Stable with respect to Ref.reference (case K)
// 5779.1-5779.99: (6.5): Ref.mark is not Write-Read Stable with respect to Ref.reference (case L)
// 5865.1-5865.140: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case A.1)
// 5866.1-5866.101: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case A.2)
// 5867.1-5867.156: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case A.3)
// 5984.1-5984.140: (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
// 6106.1-6106.144: (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
// 6107.1-6107.144: (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
// 6192.1-6192.136: (5.5): Ref.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
// 6193.1-6193.136: (5.5): Ref.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
// 6194.1-6194.144: (5.5): Ref.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
// 6278.1-6278.136: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.reference (case J)
// 6279.1-6279.136: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.reference (case K)
// 6280.1-6280.99: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.reference (case L)
// 6366.1-6366.140: (5.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case A.1)
// 6367.1-6367.101: (5.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case A.2)
// 6368.1-6368.158: (5.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case A.3)
// 6485.1-6485.140: (6.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case C)
// 6607.1-6607.144: (6.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case D)
// 6608.1-6608.144: (6.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case R)
// 6693.1-6693.136: (6.5): Ref.mark is not Read-Write Stable with respect to Ref.reference (case F)
// 6694.1-6694.136: (6.5): Ref.mark is not Read-Write Stable with respect to Ref.reference (case H)
// 6695.1-6695.146: (6.5): Ref.mark is not Read-Write Stable with respect to Ref.reference (case I)
// 6779.1-6779.136: (5.5): Ref.reference is not Write-Read Stable with respect to Ref.mark (case J)
// 6780.1-6780.136: (5.5): Ref.reference is not Write-Read Stable with respect to Ref.mark (case K)
// 6781.1-6781.99: (5.5): Ref.reference is not Write-Read Stable with respect to Ref.mark (case L)
// 6867.1-6867.140: (6.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case A.1)
// 6868.1-6868.101: (6.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case A.2)
// 6869.1-6869.158: (6.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case A.3)
// 6986.1-6986.140: (6.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case C)
// 7108.1-7108.144: (6.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case D)
// 7109.1-7109.144: (6.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case R)
// 7194.1-7194.136: (6.5): Ref.mark is not Read-Write Stable with respect to Ref.mark (case F)
// 7195.1-7195.136: (6.5): Ref.mark is not Read-Write Stable with respect to Ref.mark (case H)
// 7196.1-7196.146: (6.5): Ref.mark is not Read-Write Stable with respect to Ref.mark (case I)
// 7280.1-7280.136: (6.5): Ref.mark is not Write-Read Stable with respect to Ref.mark (case J)
// 7281.1-7281.136: (6.5): Ref.mark is not Write-Read Stable with respect to Ref.mark (case K)
// 7282.1-7282.99: (6.5): Ref.mark is not Write-Read Stable with respect to Ref.mark (case L)
// 7368.1-7368.140: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case A.1)
// 7369.1-7369.101: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case A.2)
// 7370.1-7370.156: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case A.3)
// 7487.1-7487.140: (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
// 7609.1-7609.144: (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
// 7610.1-7610.144: (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
// 7695.1-7695.136: (6.5): Ref.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
// 7696.1-7696.136: (6.5): Ref.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
// 7697.1-7697.144: (6.5): Ref.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
// 7781.1-7781.136: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.mark (case J)
// 7782.1-7782.136: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.mark (case K)
// 7783.1-7783.99: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.mark (case L)
// 7869.1-7869.140: (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
// 7870.1-7870.101: (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
// 7871.1-7871.156: (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
// 7988.1-7988.140: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case C)
// 8110.1-8110.144: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case D)
// 8111.1-8111.144: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case R)
// 8196.1-8196.136: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.reference (case F)
// 8197.1-8197.136: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.reference (case H)
// 8198.1-8198.144: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.reference (case I)
// 8282.1-8282.136: (5.5): Ref.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
// 8283.1-8283.136: (5.5): Ref.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
// 8284.1-8284.99: (5.5): Ref.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
// 8411.1-8411.142: (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case M)
// 8536.1-8536.130: (5.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case N)
// 8623.1-8623.140: (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
// 8624.1-8624.101: (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
// 8625.1-8625.156: (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
// 8742.1-8742.140: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case C)
// 8864.1-8864.144: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case D)
// 8865.1-8865.144: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case R)
// 8950.1-8950.136: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.mark (case F)
// 8951.1-8951.136: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.mark (case H)
// 8952.1-8952.144: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.mark (case I)
// 9036.1-9036.136: (6.5): Ref.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
// 9037.1-9037.136: (6.5): Ref.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
// 9038.1-9038.99: (6.5): Ref.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
// 9165.1-9165.142: (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case M)
// 9290.1-9290.130: (6.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case N)
// 9377.1-9377.140: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
// 9378.1-9378.101: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
// 9379.1-9379.158: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
// 9496.1-9496.140: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
// 9618.1-9618.144: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
// 9619.1-9619.144: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
// 9704.1-9704.136: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
// 9705.1-9705.136: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
// 9706.1-9706.146: (15.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
// 9790.1-9790.136: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
// 9791.1-9791.136: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
// 9792.1-9792.99: (15.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
// 9919.1-9919.142: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case M)
// 10044.1-10044.130: (15.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case N)
// 10052.1-10052.486: (<undefined position>): Object invariant may not hold.
// 10066.1-10066.485: (<undefined position>): Object invariant may not hold.
// 10087.1-10114.2: (7.32): yields_as clause for Node._lock is not valid
// 10119.1-10141.2: (7.32): yields_as clause for Node._lock is not reflexive
// 10147.1-10147.486: (2.1): Object invariant may not hold.
// 10148.1-10192.2: (7.32): yields_as clause for Node._lock is not transitive
// 10211.1-10238.2: (5.5): yields_as clause for Ref.reference is not valid
// 10243.1-10265.2: (5.5): yields_as clause for Ref.reference is not reflexive
// 10271.1-10271.486: (5.32): Object invariant may not hold.
// 10272.1-10316.2: (5.5): yields_as clause for Ref.reference is not transitive
// 10335.1-10362.2: (6.5): yields_as clause for Ref.mark is not valid
// 10367.1-10389.2: (6.5): yields_as clause for Ref.mark is not reflexive
// 10395.1-10395.486: (6.35): Object invariant may not hold.
// 10396.1-10440.2: (6.5): yields_as clause for Ref.mark is not transitive
// 10460.1-10487.2: (7.32): yields_as clause for Ref._lock is not valid
// 10492.1-10514.2: (7.32): yields_as clause for Ref._lock is not reflexive
// 10520.1-10520.486: (4.1): Object invariant may not hold.
// 10521.1-10565.2: (7.32): yields_as clause for Ref._lock is not transitive
// 10585.1-10612.2: (18.28): yields_as clause for AtomicMarkableReference.pair is not valid
// 10617.1-10639.2: (18.28): yields_as clause for AtomicMarkableReference.pair is not reflexive
// 10645.1-10645.486: (15.39): Object invariant may not hold.
// 10646.1-10690.2: (18.28): yields_as clause for AtomicMarkableReference.pair is not transitive
// 10698.1-10698.486: (15.39): Object invariant may not hold.
// 10699.1-10745.2: (18.28): AtomicMarkableReference.pair is not ABA-free
// 10765.1-10792.2: (7.32): yields_as clause for AtomicMarkableReference._lock is not valid
// 10797.1-10819.2: (7.32): yields_as clause for AtomicMarkableReference._lock is not reflexive
// 10825.1-10825.486: (13.1): Object invariant may not hold.
// 10826.1-10870.2: (7.32): yields_as clause for AtomicMarkableReference._lock is not transitive
