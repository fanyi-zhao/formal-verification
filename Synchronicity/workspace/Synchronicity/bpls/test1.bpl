                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/test1.anchor:                           
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      volatile Node next isLocal(this, tid)                                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid)                                                                           
         ? isRead ? B : N                                                                           
         : isRead ? N : E                                                                           
                                                                                                    
      invariant  -5 <= this.item && this.item <= 5;                                                 
      invariant  this.next != Node.null ==> this.item < this.next.item;                             
      invariant  this.next == Node.null ==> this.item == 5;                                         
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class OptimisticList {                                                                          
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -5;                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean validate(Node pred,Node curr,int item) {                                              
        Node node;                                                                                  
        node := this.head;                                                                          
        yield;                                                                                      
        while (true)                                                                                
          invariant isShared(node);                                                                 
          invariant isShared(curr);                                                                 
          invariant isShared(pred);                                                                 
          invariant holds(curr, tid);                                                               
          invariant holds(pred, tid);                                                               
          invariant pred.item < item;                                                               
          invariant curr.item >= item;                                                              
          {                                                                                         
          boolean tmp1;                                                                             
          int tmp2;                                                                                 
          tmp2 := node.item;                                                                        
          int tmp3;                                                                                 
          tmp3 := pred.item;                                                                        
          tmp1 = tmp2 <= tmp3;                                                                      
          if (!tmp1) break; else {                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            boolean tmp4;                                                                           
            tmp4 = node == pred;                                                                    
            if (tmp4 /* == node == pred */) {                                                       
              boolean tmp5;                                                                         
              Node tmp6;                                                                            
              tmp6 := pred.next;                                                                    
              tmp5 = tmp6 == curr;                                                                  
               return tmp5;                                                                         
            } else {                                                                                
                                                                                                    
            }                                                                                       
            node := node.next;                                                                      
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
         return false;                                                                              
        // return false;                                                                            
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -5 < item && item < 5;                                                               
                                                                                                    
      public boolean add(int item) {                                                                
        while (true)   {                                                                            
          boolean tmp7;                                                                             
          tmp7 = true;                                                                              
          if (!tmp7) break; else {                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            yield;                                                                                  
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              {                                                                                     
              boolean tmp8;                                                                         
              int tmp9;                                                                             
              tmp9 := curr.item;                                                                    
              tmp8 = tmp9 < item;                                                                   
              if (!tmp8) break; else {                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                yield;                                                                              
                curr := curr.next;                                                                  
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            boolean tmp10;                                                                          
            int tmp11;                                                                              
            tmp11 := pred.item;                                                                     
            tmp10 = tmp11 < item;                                                                   
            assert tmp10 /* == pred.item < item */;                                                 
            yield;                                                                                  
            boolean tmp12;                                                                          
            int tmp13;                                                                              
            tmp13 := pred.item;                                                                     
            tmp12 = tmp13 < item;                                                                   
            assert tmp12 /* == pred.item < item */;                                                 
            acquire(pred);                                                                          
            acquire(curr);                                                                          
            boolean tmp14;                                                                          
            int tmp15;                                                                              
            tmp15 := pred.item;                                                                     
            tmp14 = tmp15 < item;                                                                   
            assert tmp14 /* == pred.item < item */;                                                 
            boolean tmp16;                                                                          
            int tmp17;                                                                              
            tmp17 := curr.item;                                                                     
            tmp16 = tmp17 >= item;                                                                  
            assert tmp16 /* == curr.item >= item */;                                                
            boolean tmp18;                                                                          
            tmp18 = this.validate(pred,curr,item)                                                   
            if (tmp18) {                                                                            
              Node tmp19;                                                                           
              tmp19 := pred.next;                                                                   
              assert tmp19 == curr;                                                                 
              boolean tmp20;                                                                        
              int tmp21;                                                                            
              tmp21 := pred.item;                                                                   
              tmp20 = tmp21 < item;                                                                 
              assert tmp20 /* == pred.item < item */;                                               
              boolean tmp22;                                                                        
              int tmp23;                                                                            
              tmp23 := curr.item;                                                                   
              tmp22 = tmp23 >= item;                                                                
              assert tmp22 /* == curr.item >= item */;                                              
              boolean tmp24;                                                                        
              int tmp25;                                                                            
              tmp25 := curr.item;                                                                   
              tmp24 = tmp25 == item;                                                                
              if (tmp24 /* == curr.item == item */) {                                               
                release(curr);                                                                      
                release(pred);                                                                      
                 return false;                                                                      
              } else {                                                                              
                Node node2;                                                                         
                node2 = new Node();                                                                 
                node2.init()                                                                        
                node2.item := item;                                                                 
                node2.next := curr;                                                                 
                pred.next := node2;                                                                 
                release(curr);                                                                      
                release(pred);                                                                      
                 return true;                                                                       
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        // return false;                                                                            
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -5 < item && item < 5;                                                               
                                                                                                    
      public boolean contains(int item) {                                                           
        while (true)   {                                                                            
          boolean tmp26;                                                                            
          tmp26 = true;                                                                             
          if (!tmp26) break; else {                                                                 
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            yield;                                                                                  
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              {                                                                                     
              boolean tmp27;                                                                        
              int tmp28;                                                                            
              tmp28 := curr.item;                                                                   
              tmp27 = tmp28 < item;                                                                 
              if (!tmp27) break; else {                                                             
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                yield;                                                                              
                curr := curr.next;                                                                  
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            acquire(pred);                                                                          
            acquire(curr);                                                                          
            boolean tmp29;                                                                          
            tmp29 = this.validate(pred,curr,item)                                                   
            if (tmp29) {                                                                            
              boolean b;                                                                            
              int tmp30;                                                                            
              tmp30 := curr.item;                                                                   
              b = tmp30 == item;                                                                    
              release(curr);                                                                        
              release(pred);                                                                        
               return b;                                                                            
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        // return false;                                                                            
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      volatile Node next isLocal(this, tid)                                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid)                                                                           
         ? isRead ? B : N                                                                           
         : isRead ? N : E                                                                           
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  -5 <= this.item && this.item <= 5;                                                 
      invariant  this.next != Node.null ==> this.item < this.next.item;                             
      invariant  this.next == Node.null ==> this.item == 5;                                         
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class OptimisticList {                                                                          
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -5;                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean validate(Node pred,Node curr,int item) {                                              
        Node node;                                                                                  
        node := this.head;                                                                          
        yield;                                                                                      
        while (true)                                                                                
          invariant isShared(node);                                                                 
          invariant isShared(curr);                                                                 
          invariant isShared(pred);                                                                 
          invariant holds(curr, tid);                                                               
          invariant holds(pred, tid);                                                               
          invariant pred.item < item;                                                               
          invariant curr.item >= item;                                                              
          {                                                                                         
          boolean tmp1;                                                                             
          int tmp2;                                                                                 
          tmp2 := node.item;                                                                        
          int tmp3;                                                                                 
          tmp3 := pred.item;                                                                        
          tmp1 = tmp2 <= tmp3;                                                                      
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            boolean tmp4;                                                                           
            tmp4 = node == pred;                                                                    
            if (tmp4 /* == node == pred */) {                                                       
              boolean tmp5;                                                                         
              Node tmp6;                                                                            
              tmp6 := pred.next;                                                                    
              tmp5 = tmp6 == curr;                                                                  
              {                                                                                     
                 return tmp5;                                                                       
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
            node := node.next;                                                                      
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
           return false;                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -5 < item && item < 5;                                                               
                                                                                                    
      public boolean add(int item) {                                                                
        while (true)   {                                                                            
          boolean tmp7;                                                                             
          tmp7 = true;                                                                              
          if (!tmp7) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            yield;                                                                                  
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              {                                                                                     
              boolean tmp8;                                                                         
              int tmp9;                                                                             
              tmp9 := curr.item;                                                                    
              tmp8 = tmp9 < item;                                                                   
              if (!tmp8) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                yield;                                                                              
                curr := curr.next;                                                                  
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            boolean tmp10;                                                                          
            int tmp11;                                                                              
            tmp11 := pred.item;                                                                     
            tmp10 = tmp11 < item;                                                                   
            assert tmp10 /* == pred.item < item */;                                                 
            yield;                                                                                  
            boolean tmp12;                                                                          
            int tmp13;                                                                              
            tmp13 := pred.item;                                                                     
            tmp12 = tmp13 < item;                                                                   
            assert tmp12 /* == pred.item < item */;                                                 
            acquire(pred);                                                                          
            acquire(curr);                                                                          
            boolean tmp14;                                                                          
            int tmp15;                                                                              
            tmp15 := pred.item;                                                                     
            tmp14 = tmp15 < item;                                                                   
            assert tmp14 /* == pred.item < item */;                                                 
            boolean tmp16;                                                                          
            int tmp17;                                                                              
            tmp17 := curr.item;                                                                     
            tmp16 = tmp17 >= item;                                                                  
            assert tmp16 /* == curr.item >= item */;                                                
            boolean tmp18;                                                                          
            tmp18 = this.validate(pred,curr,item)                                                   
            if (tmp18) {                                                                            
              Node tmp19;                                                                           
              tmp19 := pred.next;                                                                   
              assert tmp19 == curr;                                                                 
              boolean tmp20;                                                                        
              int tmp21;                                                                            
              tmp21 := pred.item;                                                                   
              tmp20 = tmp21 < item;                                                                 
              assert tmp20 /* == pred.item < item */;                                               
              boolean tmp22;                                                                        
              int tmp23;                                                                            
              tmp23 := curr.item;                                                                   
              tmp22 = tmp23 >= item;                                                                
              assert tmp22 /* == curr.item >= item */;                                              
              boolean tmp24;                                                                        
              int tmp25;                                                                            
              tmp25 := curr.item;                                                                   
              tmp24 = tmp25 == item;                                                                
              if (tmp24 /* == curr.item == item */) {                                               
                release(curr);                                                                      
                release(pred);                                                                      
                {                                                                                   
                   return false;                                                                    
                }                                                                                   
              } else {                                                                              
                Node node2;                                                                         
                node2 = new Node();                                                                 
                node2.init()                                                                        
                node2.item := item;                                                                 
                node2.next := curr;                                                                 
                pred.next := node2;                                                                 
                release(curr);                                                                      
                release(pred);                                                                      
                {                                                                                   
                   return true;                                                                     
                }                                                                                   
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -5 < item && item < 5;                                                               
                                                                                                    
      public boolean contains(int item) {                                                           
        while (true)   {                                                                            
          boolean tmp26;                                                                            
          tmp26 = true;                                                                             
          if (!tmp26) {                                                                             
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            yield;                                                                                  
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              {                                                                                     
              boolean tmp27;                                                                        
              int tmp28;                                                                            
              tmp28 := curr.item;                                                                   
              tmp27 = tmp28 < item;                                                                 
              if (!tmp27) {                                                                         
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                yield;                                                                              
                curr := curr.next;                                                                  
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            acquire(pred);                                                                          
            acquire(curr);                                                                          
            boolean tmp29;                                                                          
            tmp29 = this.validate(pred,curr,item)                                                   
            if (tmp29) {                                                                            
              boolean b;                                                                            
              int tmp30;                                                                            
              tmp30 := curr.item;                                                                   
              b = tmp30 == item;                                                                    
              release(curr);                                                                        
              release(pred);                                                                        
              {                                                                                     
                 return b;                                                                          
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      volatile Node next isLocal(this, tid)                                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid)                                                                           
         ? isRead ? B : N                                                                           
         : isRead ? N : E                                                                           
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  -5 <= this.item && this.item <= 5;                                                 
      invariant  this.next != Node.null ==> this.item < this.next.item;                             
      invariant  this.next == Node.null ==> this.item == 5;                                         
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class OptimisticList {                                                                          
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -5;                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean validate(Node pred,Node curr,int item) {                                              
        Node node;                                                                                  
        node := this.head;                                                                          
        yield;                                                                                      
        while (true)                                                                                
          invariant isShared(node);                                                                 
          invariant isShared(curr);                                                                 
          invariant isShared(pred);                                                                 
          invariant holds(curr, tid);                                                               
          invariant holds(pred, tid);                                                               
          invariant pred.item < item;                                                               
          invariant curr.item >= item;                                                              
          {                                                                                         
          boolean tmp1;                                                                             
          int tmp2;                                                                                 
          tmp2 := node.item;                                                                        
          int tmp3;                                                                                 
          tmp3 := pred.item;                                                                        
          tmp1 = tmp2 <= tmp3;                                                                      
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            boolean tmp4;                                                                           
            tmp4 = node == pred;                                                                    
            if (tmp4 /* == node == pred */) {                                                       
              boolean tmp5;                                                                         
              Node tmp6;                                                                            
              tmp6 := pred.next;                                                                    
              tmp5 = tmp6 == curr;                                                                  
              {                                                                                     
                 return tmp5;                                                                       
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
            node := node.next;                                                                      
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
           return false;                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -5 < item && item < 5;                                                               
                                                                                                    
      public boolean add(int item) {                                                                
        while (true)   {                                                                            
          boolean tmp7;                                                                             
          tmp7 = true;                                                                              
          if (!tmp7) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            yield;                                                                                  
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              {                                                                                     
              boolean tmp8;                                                                         
              int tmp9;                                                                             
              tmp9 := curr.item;                                                                    
              tmp8 = tmp9 < item;                                                                   
              if (!tmp8) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                yield;                                                                              
                curr := curr.next;                                                                  
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            boolean tmp10;                                                                          
            int tmp11;                                                                              
            tmp11 := pred.item;                                                                     
            tmp10 = tmp11 < item;                                                                   
            assert tmp10 /* == pred.item < item */;                                                 
            yield;                                                                                  
            boolean tmp12;                                                                          
            int tmp13;                                                                              
            tmp13 := pred.item;                                                                     
            tmp12 = tmp13 < item;                                                                   
            assert tmp12 /* == pred.item < item */;                                                 
            acquire(pred);                                                                          
            acquire(curr);                                                                          
            boolean tmp14;                                                                          
            int tmp15;                                                                              
            tmp15 := pred.item;                                                                     
            tmp14 = tmp15 < item;                                                                   
            assert tmp14 /* == pred.item < item */;                                                 
            boolean tmp16;                                                                          
            int tmp17;                                                                              
            tmp17 := curr.item;                                                                     
            tmp16 = tmp17 >= item;                                                                  
            assert tmp16 /* == curr.item >= item */;                                                
            boolean tmp18;                                                                          
            {                                                                                       
              inlined tmp18 = this.validate(pred,curr,item);                                        
              exit$256: {                                                                           
                Node pred$256;                                                                      
                Node curr$256;                                                                      
                int item$256;                                                                       
                OptimisticList this$256;                                                            
                pred$256 = pred;                                                                    
                curr$256 = curr;                                                                    
                item$256 = item;                                                                    
                this$256 = this;                                                                    
                {                                                                                   
                  Node node$256;                                                                    
                  node$256 := this$256.head;                                                        
                  yield;                                                                            
                  while (true)                                                                      
                    invariant isShared(node$256);                                                   
                    invariant isShared(curr$256);                                                   
                    invariant isShared(pred$256);                                                   
                    invariant holds(curr$256, tid);                                                 
                    invariant holds(pred$256, tid);                                                 
                    invariant pred$256.item < item$256;                                             
                    invariant curr$256.item >= item$256;                                            
                    {                                                                               
                    boolean tmp1$256;                                                               
                    int tmp2$256;                                                                   
                    tmp2$256 := node$256.item;                                                      
                    int tmp3$256;                                                                   
                    tmp3$256 := pred$256.item;                                                      
                    tmp1$256 = tmp2$256 <= tmp3$256;                                                
                    if (!tmp1$256) {                                                                
                      break;                                                                        
                    } else {                                                                        
                                                                                                    
                    }                                                                               
                    {                                                                               
                      boolean tmp4$256;                                                             
                      tmp4$256 = node$256 == pred$256;                                              
                      if (tmp4$256 /* == node$256 == pred$256 */) {                                 
                        boolean tmp5$256;                                                           
                        Node tmp6$256;                                                              
                        tmp6$256 := pred$256.next;                                                  
                        tmp5$256 = tmp6$256 == curr$256;                                            
                        {                                                                           
                          {                                                                         
                            tmp18 = tmp5$256;                                                       
                            break exit$256;                                                         
                          }                                                                         
                        }                                                                           
                      } else {                                                                      
                                                                                                    
                      }                                                                             
                      node$256 := node$256.next;                                                    
                      yield;                                                                        
                    }                                                                               
                  }                                                                                 
                  {                                                                                 
                    {                                                                               
                      tmp18 = false;                                                                
                      break exit$256;                                                               
                    }                                                                               
                  }                                                                                 
                  {                                                                                 
                    {                                                                               
                      tmp18 = false;                                                                
                      break exit$256;                                                               
                    }                                                                               
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              inlined return;                                                                       
            }                                                                                       
            if (tmp18) {                                                                            
              Node tmp19;                                                                           
              tmp19 := pred.next;                                                                   
              assert tmp19 == curr;                                                                 
              boolean tmp20;                                                                        
              int tmp21;                                                                            
              tmp21 := pred.item;                                                                   
              tmp20 = tmp21 < item;                                                                 
              assert tmp20 /* == pred.item < item */;                                               
              boolean tmp22;                                                                        
              int tmp23;                                                                            
              tmp23 := curr.item;                                                                   
              tmp22 = tmp23 >= item;                                                                
              assert tmp22 /* == curr.item >= item */;                                              
              boolean tmp24;                                                                        
              int tmp25;                                                                            
              tmp25 := curr.item;                                                                   
              tmp24 = tmp25 == item;                                                                
              if (tmp24 /* == curr.item == item */) {                                               
                release(curr);                                                                      
                release(pred);                                                                      
                {                                                                                   
                   return false;                                                                    
                }                                                                                   
              } else {                                                                              
                Node node2;                                                                         
                node2 = new Node();                                                                 
                {                                                                                   
                  inlined node2.init();                                                             
                  exit$257: {                                                                       
                    Node this$257;                                                                  
                    this$257 = node2;                                                               
                    {                                                                               
                      assume this$257.item == 0;                                                    
                      assume this$257.next == Node.null;                                            
                      {                                                                             
                        {                                                                           
                          break exit$257;                                                           
                        }                                                                           
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                  inlined return;                                                                   
                }                                                                                   
                node2.item := item;                                                                 
                node2.next := curr;                                                                 
                pred.next := node2;                                                                 
                release(curr);                                                                      
                release(pred);                                                                      
                {                                                                                   
                   return true;                                                                     
                }                                                                                   
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -5 < item && item < 5;                                                               
                                                                                                    
      public boolean contains(int item) {                                                           
        while (true)   {                                                                            
          boolean tmp26;                                                                            
          tmp26 = true;                                                                             
          if (!tmp26) {                                                                             
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            yield;                                                                                  
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              {                                                                                     
              boolean tmp27;                                                                        
              int tmp28;                                                                            
              tmp28 := curr.item;                                                                   
              tmp27 = tmp28 < item;                                                                 
              if (!tmp27) {                                                                         
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                yield;                                                                              
                curr := curr.next;                                                                  
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            acquire(pred);                                                                          
            acquire(curr);                                                                          
            boolean tmp29;                                                                          
            {                                                                                       
              inlined tmp29 = this.validate(pred,curr,item);                                        
              exit$258: {                                                                           
                Node pred$258;                                                                      
                Node curr$258;                                                                      
                int item$258;                                                                       
                OptimisticList this$258;                                                            
                pred$258 = pred;                                                                    
                curr$258 = curr;                                                                    
                item$258 = item;                                                                    
                this$258 = this;                                                                    
                {                                                                                   
                  Node node$258;                                                                    
                  node$258 := this$258.head;                                                        
                  yield;                                                                            
                  while (true)                                                                      
                    invariant isShared(node$258);                                                   
                    invariant isShared(curr$258);                                                   
                    invariant isShared(pred$258);                                                   
                    invariant holds(curr$258, tid);                                                 
                    invariant holds(pred$258, tid);                                                 
                    invariant pred$258.item < item$258;                                             
                    invariant curr$258.item >= item$258;                                            
                    {                                                                               
                    boolean tmp1$258;                                                               
                    int tmp2$258;                                                                   
                    tmp2$258 := node$258.item;                                                      
                    int tmp3$258;                                                                   
                    tmp3$258 := pred$258.item;                                                      
                    tmp1$258 = tmp2$258 <= tmp3$258;                                                
                    if (!tmp1$258) {                                                                
                      break;                                                                        
                    } else {                                                                        
                                                                                                    
                    }                                                                               
                    {                                                                               
                      boolean tmp4$258;                                                             
                      tmp4$258 = node$258 == pred$258;                                              
                      if (tmp4$258 /* == node$258 == pred$258 */) {                                 
                        boolean tmp5$258;                                                           
                        Node tmp6$258;                                                              
                        tmp6$258 := pred$258.next;                                                  
                        tmp5$258 = tmp6$258 == curr$258;                                            
                        {                                                                           
                          {                                                                         
                            tmp29 = tmp5$258;                                                       
                            break exit$258;                                                         
                          }                                                                         
                        }                                                                           
                      } else {                                                                      
                                                                                                    
                      }                                                                             
                      node$258 := node$258.next;                                                    
                      yield;                                                                        
                    }                                                                               
                  }                                                                                 
                  {                                                                                 
                    {                                                                               
                      tmp29 = false;                                                                
                      break exit$258;                                                               
                    }                                                                               
                  }                                                                                 
                  {                                                                                 
                    {                                                                               
                      tmp29 = false;                                                                
                      break exit$258;                                                               
                    }                                                                               
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              inlined return;                                                                       
            }                                                                                       
            if (tmp29) {                                                                            
              boolean b;                                                                            
              int tmp30;                                                                            
              tmp30 := curr.item;                                                                   
              b = tmp30 == item;                                                                    
              release(curr);                                                                        
              release(pred);                                                                        
              {                                                                                     
                 return b;                                                                          
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      volatile Node next isLocal(this, tid)                                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid)                                                                           
         ? isRead ? B : N                                                                           
         : isRead ? N : E                                                                           
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  -5 <= this.item && this.item <= 5;                                                 
      invariant  this.next != Node.null ==> this.item < this.next.item;                             
      invariant  this.next == Node.null ==> this.item == 5;                                         
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class OptimisticList {                                                                          
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -5;                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean validate(Node pred,Node curr,int item) {                                              
        Node node;                                                                                  
        node := this.head;                                                                          
        yield;                                                                                      
        while (true)                                                                                
          invariant isShared(node);                                                                 
          invariant isShared(curr);                                                                 
          invariant isShared(pred);                                                                 
          invariant holds(curr, tid);                                                               
          invariant holds(pred, tid);                                                               
          invariant pred.item < item;                                                               
          invariant curr.item >= item;                                                              
          {                                                                                         
          boolean tmp1;                                                                             
          int tmp2;                                                                                 
          tmp2 := node.item;                                                                        
          int tmp3;                                                                                 
          tmp3 := pred.item;                                                                        
          tmp1 = tmp2 <= tmp3;                                                                      
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            boolean tmp4;                                                                           
            tmp4 = node == pred;                                                                    
            if (tmp4 /* == node == pred */) {                                                       
              boolean tmp5;                                                                         
              Node tmp6;                                                                            
              tmp6 := pred.next;                                                                    
              tmp5 = tmp6 == curr;                                                                  
              {                                                                                     
                 return tmp5;                                                                       
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
            node := node.next;                                                                      
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
           return false;                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -5 < item && item < 5;                                                               
                                                                                                    
      public boolean add(int item) {                                                                
        while (true)   {                                                                            
          boolean tmp7;                                                                             
          tmp7 = true;                                                                              
          if (!tmp7) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            yield;                                                                                  
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              {                                                                                     
              boolean tmp8;                                                                         
              int tmp9;                                                                             
              tmp9 := curr.item;                                                                    
              tmp8 = tmp9 < item;                                                                   
              if (!tmp8) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                yield;                                                                              
                curr := curr.next;                                                                  
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            boolean tmp10;                                                                          
            int tmp11;                                                                              
            tmp11 := pred.item;                                                                     
            tmp10 = tmp11 < item;                                                                   
            assert tmp10 /* == pred.item < item */;                                                 
            yield;                                                                                  
            boolean tmp12;                                                                          
            int tmp13;                                                                              
            tmp13 := pred.item;                                                                     
            tmp12 = tmp13 < item;                                                                   
            assert tmp12 /* == pred.item < item */;                                                 
            acquire(pred);                                                                          
            acquire(curr);                                                                          
            boolean tmp14;                                                                          
            int tmp15;                                                                              
            tmp15 := pred.item;                                                                     
            tmp14 = tmp15 < item;                                                                   
            assert tmp14 /* == pred.item < item */;                                                 
            boolean tmp16;                                                                          
            int tmp17;                                                                              
            tmp17 := curr.item;                                                                     
            tmp16 = tmp17 >= item;                                                                  
            assert tmp16 /* == curr.item >= item */;                                                
            boolean tmp18;                                                                          
            {                                                                                       
              inlined tmp18 = this.validate(pred,curr,item);                                        
              exit$256: {                                                                           
                Node pred$256;                                                                      
                Node curr$256;                                                                      
                int item$256;                                                                       
                OptimisticList this$256;                                                            
                pred$256 = pred;                                                                    
                curr$256 = curr;                                                                    
                item$256 = item;                                                                    
                this$256 = this;                                                                    
                {                                                                                   
                  Node node$256;                                                                    
                  node$256 := this$256.head;                                                        
                  yield;                                                                            
                  while (true)                                                                      
                    invariant isShared(node$256);                                                   
                    invariant isShared(curr$256);                                                   
                    invariant isShared(pred$256);                                                   
                    invariant holds(curr$256, tid);                                                 
                    invariant holds(pred$256, tid);                                                 
                    invariant pred$256.item < item$256;                                             
                    invariant curr$256.item >= item$256;                                            
                    {                                                                               
                    boolean tmp1$256;                                                               
                    int tmp2$256;                                                                   
                    tmp2$256 := node$256.item;                                                      
                    int tmp3$256;                                                                   
                    tmp3$256 := pred$256.item;                                                      
                    tmp1$256 = tmp2$256 <= tmp3$256;                                                
                    if (!tmp1$256) {                                                                
                      break;                                                                        
                    } else {                                                                        
                                                                                                    
                    }                                                                               
                    {                                                                               
                      boolean tmp4$256;                                                             
                      tmp4$256 = node$256 == pred$256;                                              
                      if (tmp4$256 /* == node$256 == pred$256 */) {                                 
                        boolean tmp5$256;                                                           
                        Node tmp6$256;                                                              
                        tmp6$256 := pred$256.next;                                                  
                        tmp5$256 = tmp6$256 == curr$256;                                            
                        {                                                                           
                          {                                                                         
                            tmp18 = tmp5$256;                                                       
                            break exit$256;                                                         
                          }                                                                         
                        }                                                                           
                      } else {                                                                      
                                                                                                    
                      }                                                                             
                      node$256 := node$256.next;                                                    
                      yield;                                                                        
                    }                                                                               
                  }                                                                                 
                  {                                                                                 
                    {                                                                               
                      tmp18 = false;                                                                
                      break exit$256;                                                               
                    }                                                                               
                  }                                                                                 
                  {                                                                                 
                    {                                                                               
                      tmp18 = false;                                                                
                      break exit$256;                                                               
                    }                                                                               
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              inlined return;                                                                       
            }                                                                                       
            if (tmp18) {                                                                            
              Node tmp19;                                                                           
              tmp19 := pred.next;                                                                   
              assert tmp19 == curr;                                                                 
              boolean tmp20;                                                                        
              int tmp21;                                                                            
              tmp21 := pred.item;                                                                   
              tmp20 = tmp21 < item;                                                                 
              assert tmp20 /* == pred.item < item */;                                               
              boolean tmp22;                                                                        
              int tmp23;                                                                            
              tmp23 := curr.item;                                                                   
              tmp22 = tmp23 >= item;                                                                
              assert tmp22 /* == curr.item >= item */;                                              
              boolean tmp24;                                                                        
              int tmp25;                                                                            
              tmp25 := curr.item;                                                                   
              tmp24 = tmp25 == item;                                                                
              if (tmp24 /* == curr.item == item */) {                                               
                release(curr);                                                                      
                release(pred);                                                                      
                {                                                                                   
                   return false;                                                                    
                }                                                                                   
              } else {                                                                              
                Node node2;                                                                         
                node2 = new Node();                                                                 
                {                                                                                   
                  inlined node2.init();                                                             
                  exit$257: {                                                                       
                    Node this$257;                                                                  
                    this$257 = node2;                                                               
                    {                                                                               
                      assume this$257.item == 0;                                                    
                      assume this$257.next == Node.null;                                            
                      {                                                                             
                        {                                                                           
                          break exit$257;                                                           
                        }                                                                           
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                  inlined return;                                                                   
                }                                                                                   
                node2.item := item;                                                                 
                node2.next := curr;                                                                 
                pred.next := node2;                                                                 
                release(curr);                                                                      
                release(pred);                                                                      
                {                                                                                   
                   return true;                                                                     
                }                                                                                   
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -5 < item && item < 5;                                                               
                                                                                                    
      public boolean contains(int item) {                                                           
        while (true)   {                                                                            
          boolean tmp26;                                                                            
          tmp26 = true;                                                                             
          if (!tmp26) {                                                                             
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            yield;                                                                                  
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              {                                                                                     
              boolean tmp27;                                                                        
              int tmp28;                                                                            
              tmp28 := curr.item;                                                                   
              tmp27 = tmp28 < item;                                                                 
              if (!tmp27) {                                                                         
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                yield;                                                                              
                curr := curr.next;                                                                  
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            acquire(pred);                                                                          
            acquire(curr);                                                                          
            boolean tmp29;                                                                          
            {                                                                                       
              inlined tmp29 = this.validate(pred,curr,item);                                        
              exit$258: {                                                                           
                Node pred$258;                                                                      
                Node curr$258;                                                                      
                int item$258;                                                                       
                OptimisticList this$258;                                                            
                pred$258 = pred;                                                                    
                curr$258 = curr;                                                                    
                item$258 = item;                                                                    
                this$258 = this;                                                                    
                {                                                                                   
                  Node node$258;                                                                    
                  node$258 := this$258.head;                                                        
                  yield;                                                                            
                  while (true)                                                                      
                    invariant isShared(node$258);                                                   
                    invariant isShared(curr$258);                                                   
                    invariant isShared(pred$258);                                                   
                    invariant holds(curr$258, tid);                                                 
                    invariant holds(pred$258, tid);                                                 
                    invariant pred$258.item < item$258;                                             
                    invariant curr$258.item >= item$258;                                            
                    {                                                                               
                    boolean tmp1$258;                                                               
                    int tmp2$258;                                                                   
                    tmp2$258 := node$258.item;                                                      
                    int tmp3$258;                                                                   
                    tmp3$258 := pred$258.item;                                                      
                    tmp1$258 = tmp2$258 <= tmp3$258;                                                
                    if (!tmp1$258) {                                                                
                      break;                                                                        
                    } else {                                                                        
                                                                                                    
                    }                                                                               
                    {                                                                               
                      boolean tmp4$258;                                                             
                      tmp4$258 = node$258 == pred$258;                                              
                      if (tmp4$258 /* == node$258 == pred$258 */) {                                 
                        boolean tmp5$258;                                                           
                        Node tmp6$258;                                                              
                        tmp6$258 := pred$258.next;                                                  
                        tmp5$258 = tmp6$258 == curr$258;                                            
                        {                                                                           
                          {                                                                         
                            tmp29 = tmp5$258;                                                       
                            break exit$258;                                                         
                          }                                                                         
                        }                                                                           
                      } else {                                                                      
                                                                                                    
                      }                                                                             
                      node$258 := node$258.next;                                                    
                      yield;                                                                        
                    }                                                                               
                  }                                                                                 
                  {                                                                                 
                    {                                                                               
                      tmp29 = false;                                                                
                      break exit$258;                                                               
                    }                                                                               
                  }                                                                                 
                  {                                                                                 
                    {                                                                               
                      tmp29 = false;                                                                
                      break exit$258;                                                               
                    }                                                                               
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              inlined return;                                                                       
            }                                                                                       
            if (tmp29) {                                                                            
              boolean b;                                                                            
              int tmp30;                                                                            
              tmp30 := curr.item;                                                                   
              b = tmp30 == item;                                                                    
              release(curr);                                                                        
              release(pred);                                                                        
              {                                                                                     
                 return b;                                                                          
              }                                                                                     
            } else {                                                                                
                                                                                                    
            }                                                                                       
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Node ***/                                                                           
                                                                                                    
type Node;                                                                                          
const unique Node.null: Node;                                                                       
var Node._state: [Node]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.item: [Node]int;                                                                           
                                                                                                    
function {:inline} ReadEval.Node.item(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.item(tid: Tid,this : Node,newValue: int,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.next: [Node]Node;                                                                          
                                                                                                    
function {:inline} ReadEval.Node.next(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Node._state[this], tid) && Node._lock[this] == tid)) then                       
   if (isRead) then                                                                                 
    moverPath(_B, 6)                                                                                
   else                                                                                             
    moverPath(_N, 2)                                                                                
  else                                                                                              
   if (isRead) then                                                                                 
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.next(tid: Tid,this : Node,newValue: Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Node._state[this], tid) && Node._lock[this] == tid)) then                       
   if (isRead) then                                                                                 
    moverPath(_B, 6)                                                                                
   else                                                                                             
    moverPath(_N, 2)                                                                                
  else                                                                                              
   if (isRead) then                                                                                 
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node._lock: [Node]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Node._lock(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node._lock(tid: Tid,this : Node,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.Node.4527810(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (bool) {
 ((-(5)<=Node.item[this])&&(Node.item[this]<=5))                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Node.4527827(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (bool) {
 ((Node.next[this]!=Node.null)==>(Node.item[this]<Node.item[Node.next[this]]))                      
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Node.4527843(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (bool) {
 ((Node.next[this]==Node.null)==>(Node.item[this]==5))                                              
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl OptimisticList ***/                                                                 
                                                                                                    
type OptimisticList;                                                                                
const unique OptimisticList.null: OptimisticList;                                                   
var OptimisticList._state: [OptimisticList]State;                                                   
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var OptimisticList.head: [OptimisticList]Node;                                                      
                                                                                                    
function {:inline} ReadEval.OptimisticList.head(tid: Tid,this : OptimisticList,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(OptimisticList._state[this], tid)) then                                                
  if (isLocal(OptimisticList._state[this], tid)) then                                               
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.OptimisticList.head(tid: Tid,this : OptimisticList,newValue: Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(OptimisticList._state[this], tid)) then                                                
  if (isLocal(OptimisticList._state[this], tid)) then                                               
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var OptimisticList._lock: [OptimisticList]Tid;                                                      
                                                                                                    
function {:inline} ReadEval.OptimisticList._lock(tid: Tid,this : OptimisticList,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(OptimisticList._state[this], tid)) then                                                
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((OptimisticList._lock[this]==tid)) then                                                      
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((OptimisticList._lock[this]==Tid.null)&&(newValue==tid))) then                              
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((OptimisticList._lock[this]==tid)&&(newValue==Tid.null))) then                             
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.OptimisticList._lock(tid: Tid,this : OptimisticList,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(OptimisticList._state[this], tid)) then                                                
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((OptimisticList._lock[this]==tid)) then                                                      
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((OptimisticList._lock[this]==Tid.null)&&(newValue==tid))) then                              
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((OptimisticList._lock[this]==tid)&&(newValue==Tid.null))) then                             
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.OptimisticList.4528594(tid: Tid,this : OptimisticList,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (bool) {
 ((OptimisticList.head[this]!=Node.null)&&(Node.item[OptimisticList.head[this]]==-(5)))             
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  OptimisticList.add(tid:Tid, this : OptimisticList, item : int)                           
returns ($result : bool)                                                                            
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies OptimisticList._state;                                                                     
modifies OptimisticList.head;                                                                       
modifies OptimisticList._lock;                                                                      
                                                                                                    
requires ValidTid(tid);                                                                                    // (37.5): Bad tid
requires isShared(OptimisticList._state[this]);                                                            // (37.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
requires ((-(5)<item)&&(item<5));                                                                   
                                                                                                    
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (37.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (37.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (37.5): Object invariant may not hold.
requires  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (37.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (37.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (37.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (37.5): Object invariant may not hold.
ensures  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (37.5): Object invariant may not hold.
{                                                                                                   
 var OptimisticList._state4535383: [OptimisticList]State;                                           
 var pred4535340_bottom: Node;                                                                      
 var this4535506_bottom: OptimisticList;                                                            
 var Node.item4535406: [Node]int;                                                                   
 var $result4535487: bool;                                                                          
 var Node.item4535497: [Node]int;                                                                   
 var tmp94535111_post: int;                                                                         
 var pred4535161: Node;                                                                             
 var $result4535297: bool;                                                                          
 var $pc4535420: Phase;                                                                             
 var item$2564535315: int;                                                                          
 var Node.next4535242: [Node]Node;                                                                  
 var tmp154535420: int;                                                                             
 var tmp74535369: bool;                                                                             
 var tmp124535197: bool;                                                                            
 var OptimisticList._state4535497: [OptimisticList]State;                                           
 var OptimisticList.head4535077: [OptimisticList]Node;                                              
 var pred4535429: Node;                                                                             
 var this4535429: OptimisticList;                                                                   
 var pred4535093: Node;                                                                             
 var tmp234535442: int;                                                                             
 var tmp144535340_bottom: bool;                                                                     
 var Node._lock4535137: [Node]Tid;                                                                  
 var Node.item4535260: [Node]int;                                                                   
 var $recorded.state4535506_bottom: int;                                                            
 var tmp134535340: int;                                                                             
 var item$2564535243: int;                                                                          
 var this4535442: OptimisticList;                                                                   
 var tmp84535111_post: bool;                                                                        
 var curr4535111: Node;                                                                             
 var tmp134535161: int;                                                                             
 var tmp154535314: int;                                                                             
 var tmp204535442: bool;                                                                            
 var OptimisticList.head4535110: [OptimisticList]Node;                                              
 var Node.item4535314: [Node]int;                                                                   
 var item4535254: int;                                                                              
 var OptimisticList._lock4535420: [OptimisticList]Tid;                                              
 var $result4535397: bool;                                                                          
 var tmp124535484: bool;                                                                            
 var tmp84535093: bool;                                                                             
 var OptimisticList.head4535114: [OptimisticList]Node;                                              
 var tmp134535315: int;                                                                             
 var pred4535084_post: Node;                                                                        
 var OptimisticList.head4535484: [OptimisticList]Node;                                              
 var pred4535107: Node;                                                                             
 var tmp114535197: int;                                                                             
 var path4535242: int;                                                                              
 var tmp17: int;                                                                                    
 var tmp104535297: bool;                                                                            
 var tmp174535197: int;                                                                             
 var tmp174535340_bottom: int;                                                                      
 var Node.next4535429: [Node]Node;                                                                  
 var tid4535497: Tid;                                                                               
 var Node.next4535114: [Node]Node;                                                                  
 var Node.item4535114: [Node]int;                                                                   
 var $recorded.state4535197: int;                                                                   
 var pred4535260: Node;                                                                             
 var Node.item4535174: [Node]int;                                                                   
 var Node._lock4535314: [Node]Tid;                                                                  
 var $recorded.state4535084: int;                                                                   
 var pred4535397: Node;                                                                             
 var item$256: int;                                                                                 
 var item4535490: int;                                                                              
 var Node._state4535490: [Node]State;                                                               
 var $recorded.state4535114_bottom: int;                                                            
 var curr4535197: Node;                                                                             
 var Node._state4535161: [Node]State;                                                               
 var tmp124535442: bool;                                                                            
 var tmp254535497: int;                                                                             
 var this4535315: OptimisticList;                                                                   
 var path4535147: int;                                                                              
 var Node._lock4535369: [Node]Tid;                                                                  
 var tmp224535497: bool;                                                                            
 var tmp114535490: int;                                                                             
 var node$2564535315: Node;                                                                         
 var tmp4$2564535315: bool;                                                                         
 var tmp144535260: bool;                                                                            
 var item$2564535243_post: int;                                                                     
 var Node._state4535107: [Node]State;                                                               
 var Node.item4535137: [Node]int;                                                                   
 var tmp134535188: int;                                                                             
 var $recorded.state4535314: int;                                                                   
 var item4535243: int;                                                                              
 var Node._lock4535397: [Node]Tid;                                                                  
 var tmp74535490: bool;                                                                             
 var tmp134535397: int;                                                                             
 var this4535315_post: OptimisticList;                                                              
 var item4535147: int;                                                                              
 var moverPath4535174: MoverPath;                                                                   
 var Node._lock4535147: [Node]Tid;                                                                  
 var OptimisticList._state4535211: [OptimisticList]State;                                           
 var $result4535484: bool;                                                                          
 var $recorded.state4535383: int;                                                                   
 var pred4535114_bottom: Node;                                                                      
 var $pc4535084: Phase;                                                                             
 var tmp154535315: int;                                                                             
 var pred4535174: Node;                                                                             
 var pred4535147: Node;                                                                             
 var Node._state4535083: [Node]State;                                                               
 var $pc4535083: Phase;                                                                             
 var tid4535397: Tid;                                                                               
 var this4535314: OptimisticList;                                                                   
 var $result4535114_bottom: bool;                                                                   
 var tmp254535442: int;                                                                             
 var this4535107: OptimisticList;                                                                   
 var OptimisticList._state4535315_post: [OptimisticList]State;                                      
 var tmp254535487: int;                                                                             
 var moverPath4535383: MoverPath;                                                                   
 var $result4535314: bool;                                                                          
 var OptimisticList._lock4535260: [OptimisticList]Tid;                                              
 var this4535138_post: OptimisticList;                                                              
 var Node.item4535188: [Node]int;                                                                   
 var mover4535297: Mover;                                                                           
 var tmp114535254: int;                                                                             
 var Node.item4535147: [Node]int;                                                                   
 var pred4535315_post: Node;                                                                        
 var curr4535093: Node;                                                                             
 var tid4535161: Tid;                                                                               
 var curr$2564535315: Node;                                                                         
 var OptimisticList.head4535084: [OptimisticList]Node;                                              
 var OptimisticList.head4535188: [OptimisticList]Node;                                              
 var tmp124535420: bool;                                                                            
 var pred4535138_post: Node;                                                                        
 var this$2564535314: OptimisticList;                                                               
 var curr4535429: Node;                                                                             
 var tmp134535442: int;                                                                             
 var pred4535420: Node;                                                                             
 var Node._lock4535506: [Node]Tid;                                                                  
 var Node._lock4535487: [Node]Tid;                                                                  
 var $recorded.state4535242: int;                                                                   
 var moverPath4535297: MoverPath;                                                                   
 var Node.next4535490: [Node]Node;                                                                  
 var item4535174: int;                                                                              
 var curr4535420: Node;                                                                             
 var this4535123: OptimisticList;                                                                   
 var Node.item4535315_post: [Node]int;                                                              
 var OptimisticList._state4535084: [OptimisticList]State;                                           
 var item4535111: int;                                                                              
 var curr4535111_post: Node;                                                                        
 var tmp124535174: bool;                                                                            
 var $pc4535107_post: Phase;                                                                        
 var OptimisticList.head4535138: [OptimisticList]Node;                                              
 var $pc4535147: Phase;                                                                             
 var tmp254535490: int;                                                                             
 var tmp224535429: bool;                                                                            
 var tid4535084: Tid;                                                                               
 var tid4535188: Tid;                                                                               
 var curr4535397: Node;                                                                             
 var tmp154535243_post: int;                                                                        
 var Node.next4535340: [Node]Node;                                                                  
 var $pc4535110: Phase;                                                                             
 var tmp124535383: bool;                                                                            
 var OptimisticList._lock4535315_post: [OptimisticList]Tid;                                         
 var tmp104535487: bool;                                                                            
 var OptimisticList.head4535509: [OptimisticList]Node;                                              
 var OptimisticList._state4535137: [OptimisticList]State;                                           
 var pred$2564535314: Node;                                                                         
 var $result4535260: bool;                                                                          
 var tmp234535497: int;                                                                             
 var $pc4535123: Phase;                                                                             
 var tmp74535374: bool;                                                                             
 var node$2564535314: Node;                                                                         
 var Node.next4535506: [Node]Node;                                                                  
 var $recorded.state4535297: int;                                                                   
 var tmp124535254: bool;                                                                            
 var mover4535083: Mover;                                                                           
 var tmp144535242: bool;                                                                            
 var tid4535315_post: Tid;                                                                          
 var node$256: Node;                                                                                
 var curr4535110: Node;                                                                             
 var OptimisticList.head4535429: [OptimisticList]Node;                                              
 var Node._lock4535197: [Node]Tid;                                                                  
 var pred$2564535315_post: Node;                                                                    
 var OptimisticList._lock4535114: [OptimisticList]Tid;                                              
 var $pc4535114: Phase;                                                                             
 var tmp124535260: bool;                                                                            
 var Node._lock4535254: [Node]Tid;                                                                  
 var tmp74535383: bool;                                                                             
 var tmp124535340: bool;                                                                            
 var tmp194535487: Node;                                                                            
 var $pc4535138: Phase;                                                                             
 var tid4535374: Tid;                                                                               
 var Node._state4535484: [Node]State;                                                               
 var OptimisticList._lock4535243_post: [OptimisticList]Tid;                                         
 var tmp114535340: int;                                                                             
 var moverPath4535123: MoverPath;                                                                   
 var tmp74535107_post: bool;                                                                        
 var tmp94535111: int;                                                                              
 var tmp74535429: bool;                                                                             
 var OptimisticList.head4535254: [OptimisticList]Node;                                              
 var $result4535315: bool;                                                                          
 var tmp74535243_post: bool;                                                                        
 var tmp184535484: bool;                                                                            
 var OptimisticList._lock4535123: [OptimisticList]Tid;                                              
 var tmp184535490: bool;                                                                            
 var tmp234535484: int;                                                                             
 var path4535314: int;                                                                              
 var node24535484: Node;                                                                            
 var pred4535243_post: Node;                                                                        
 var tmp244535497: bool;                                                                            
 var OptimisticList.head4535111_post: [OptimisticList]Node;                                         
 var tmp3$2564535315_post: int;                                                                     
 var path4535197: int;                                                                              
 var Node._state4535243: [Node]State;                                                               
 var tmp104535254: bool;                                                                            
 var tmp164535487: bool;                                                                            
 var Node._state4535242: [Node]State;                                                               
 var Node.next4535110: [Node]Node;                                                                  
 var OptimisticList._state4535243: [OptimisticList]State;                                           
 var mover4535174: Mover;                                                                           
 var item4535340_bottom: int;                                                                       
 var tmp114535340_bottom: int;                                                                      
 var tmp114535243_post: int;                                                                        
 var tid4535506: Tid;                                                                               
 var tmp154535383: int;                                                                             
 var tmp154535211: int;                                                                             
 var tmp174535340: int;                                                                             
 var tmp234535487: int;                                                                             
 var OptimisticList._lock4535188: [OptimisticList]Tid;                                              
 var OptimisticList._state4535506: [OptimisticList]State;                                           
 var $pc4535369: Phase;                                                                             
 var curr4535314: Node;                                                                             
 var Node.next4535383: [Node]Node;                                                                  
 var tmp1$2564535315: bool;                                                                         
 var tid4535093: Tid;                                                                               
 var OptimisticList.head4535314: [OptimisticList]Node;                                              
 var Node.next4535211: [Node]Node;                                                                  
 var $result4535383: bool;                                                                          
 var OptimisticList._lock4535110: [OptimisticList]Tid;                                              
 var pred4535077: Node;                                                                             
 var $result4535147: bool;                                                                          
 var $recorded.state4535506: int;                                                                   
 var OptimisticList._state4535107_post: [OptimisticList]State;                                      
 var tmp94535107_post: int;                                                                         
 var pred4535314: Node;                                                                             
 var Node.next4535123: [Node]Node;                                                                  
 var OptimisticList.head4535490: [OptimisticList]Node;                                              
 var item4535123: int;                                                                              
 var Node._lock4535506_bottom: [Node]Tid;                                                           
 var tmp104535374: bool;                                                                            
 var tmp104535161: bool;                                                                            
 var OptimisticList.head4535243: [OptimisticList]Node;                                              
 var Node._state4535174: [Node]State;                                                               
 var moverPath4535254: MoverPath;                                                                   
 var Node._lock4535315_post: [Node]Tid;                                                             
 var item4535506_bottom: int;                                                                       
 var OptimisticList._lock4535340: [OptimisticList]Tid;                                              
 var item4535138: int;                                                                              
 var $pc4535397: Phase;                                                                             
 var curr4535383: Node;                                                                             
 var Node.next4535188: [Node]Node;                                                                  
 var tmp16: bool;                                                                                   
 var curr4535084_post: Node;                                                                        
 var OptimisticList.head4535084_post: [OptimisticList]Node;                                         
 var $result4535509: bool;                                                                          
 var $pc4535107: Phase;                                                                             
 var Node.next4535315_post: [Node]Node;                                                             
 var Node._state4535506: [Node]State;                                                               
 var tmp74535174: bool;                                                                             
 var tmp154535340_bottom: int;                                                                      
 var $pc4535497: Phase;                                                                             
 var Node._lock4535084: [Node]Tid;                                                                  
 var $recorded.state4535374: int;                                                                   
 var item4535340: int;                                                                              
 var pred4535254: Node;                                                                             
 var OptimisticList._state4535111_post: [OptimisticList]State;                                      
 var tid4535254: Tid;                                                                               
 var item4535083: int;                                                                              
 var pred$2564535340: Node;                                                                         
 var this4535254: OptimisticList;                                                                   
 var item4535242: int;                                                                              
 var item4535114: int;                                                                              
 var tmp174535374: int;                                                                             
 var Node._lock4535114: [Node]Tid;                                                                  
 var Node.next4535083: [Node]Node;                                                                  
 var curr4535315: Node;                                                                             
 var pred4535107_post: Node;                                                                        
 var Node.next4535111: [Node]Node;                                                                  
 var tmp84535107: bool;                                                                             
 var this4535114: OptimisticList;                                                                   
 var Node.item4535243_post: [Node]int;                                                              
 var tmp124535340_bottom: bool;                                                                     
 var Node._state4535420: [Node]State;                                                               
 var Node._state4535110: [Node]State;                                                               
 var tmp164535260: bool;                                                                            
 var node24535490: Node;                                                                            
 var $result4535497: bool;                                                                          
 var tid4535429: Tid;                                                                               
 var tmp104535260: bool;                                                                            
 var OptimisticList._lock4535369: [OptimisticList]Tid;                                              
 var $recorded.state4535114: int;                                                                   
 var tmp1$2564535315_post: bool;                                                                    
 var item$2564535260: int;                                                                          
 var tid4535243: Tid;                                                                               
 var OptimisticList._state4535114: [OptimisticList]State;                                           
 var this4535374: OptimisticList;                                                                   
 var tid4535490: Tid;                                                                               
 var Node._state4535260: [Node]State;                                                               
 var Node.next4535297: [Node]Node;                                                                  
 var curr4535161: Node;                                                                             
 var this4535174: OptimisticList;                                                                   
 var $pc4535374: Phase;                                                                             
 var tmp224535442: bool;                                                                            
 var Node.item4535242: [Node]int;                                                                   
 var OptimisticList._state4535420: [OptimisticList]State;                                           
 var tmp114535138_post: int;                                                                        
 var item4535197: int;                                                                              
 var item4535077: int;                                                                              
 var item4535406: int;                                                                              
 var item4535138_post: int;                                                                         
 var tmp104535369: bool;                                                                            
 var pred4535340: Node;                                                                             
 var OptimisticList._state4535138: [OptimisticList]State;                                           
 var $pc4535442: Phase;                                                                             
 var tmp224535490: bool;                                                                            
 var $recorded.state4535442: int;                                                                   
 var Node.item4535374: [Node]int;                                                                   
 var pred4535383: Node;                                                                             
 var mover4535490: Mover;                                                                           
 var $result4535254: bool;                                                                          
 var tmp74535397: bool;                                                                             
 var OptimisticList.head4535197: [OptimisticList]Node;                                              
 var Node._state4535114: [Node]State;                                                               
 var $pc4535506_bottom: Phase;                                                                      
 var tmp214535429: int;                                                                             
 var curr4535137: Node;                                                                             
 var Node._state4535315_post: [Node]State;                                                          
 var $pc4535254: Phase;                                                                             
 var pred$2564535243_post: Node;                                                                    
 var tmp134535315_post: int;                                                                        
 var tmp114535484: int;                                                                             
 var OptimisticList._lock4535243: [OptimisticList]Tid;                                              
 var tmp84535111: bool;                                                                             
 var tmp144535497: bool;                                                                            
 var tmp4$2564535314: bool;                                                                         
 var tid4535084_post: Tid;                                                                          
 var tmp114535383: int;                                                                             
 var tmp4$256: bool;                                                                                
 var Node._lock4535211: [Node]Tid;                                                                  
 var tmp174535254: int;                                                                             
 var tmp5$256: bool;                                                                                
 var tmp174535487: int;                                                                             
 var tid4535114_bottom: Tid;                                                                        
 var curr4535211: Node;                                                                             
 var tmp194535397: Node;                                                                            
 var tid4535111: Tid;                                                                               
 var moverPath4535429: MoverPath;                                                                   
 var tmp164535243_post: bool;                                                                       
 var pred4535197: Node;                                                                             
 var tmp184535383: bool;                                                                            
 var Node.item4535211: [Node]int;                                                                   
 var OptimisticList._lock4535083: [OptimisticList]Tid;                                              
 var tmp144535383: bool;                                                                            
 var Node._lock4535490: [Node]Tid;                                                                  
 var this$2564535340_bottom: OptimisticList;                                                        
 var tmp2$2564535315_post: int;                                                                     
 var OptimisticList._lock4535147: [OptimisticList]Tid;                                              
 var Node.item4535243: [Node]int;                                                                   
 var tmp2$2564535297: int;                                                                          
 var OptimisticList.head4535297: [OptimisticList]Node;                                              
 var Node._state4535383: [Node]State;                                                               
 var Node.next4535147: [Node]Node;                                                                  
 var tmp1$2564535297: bool;                                                                         
 var item4535509: int;                                                                              
 var $result4535340_bottom: bool;                                                                   
 var OptimisticList._state4535107: [OptimisticList]State;                                           
 var Node.item4535138_post: [Node]int;                                                              
 var tmp164535374: bool;                                                                            
 var mover4535254: Mover;                                                                           
 var item4535243_post: int;                                                                         
 var this4535369: OptimisticList;                                                                   
 var tid4535297: Tid;                                                                               
 var curr$2564535315_post: Node;                                                                    
 var Node._state4535211: [Node]State;                                                               
 var tmp74535084_post: bool;                                                                        
 var tmp74535442: bool;                                                                             
 var OptimisticList._lock4535484: [OptimisticList]Tid;                                              
 var $recorded.state4535315: int;                                                                   
 var $recorded.state4535406: int;                                                                   
 var $recorded.state4535260: int;                                                                   
 var tmp164535406: bool;                                                                            
 var tmp214535397: int;                                                                             
 var tmp22: bool;                                                                                   
 var this4535484: OptimisticList;                                                                   
 var item$2564535242: int;                                                                          
 var tmp134535314: int;                                                                             
 var item4535297: int;                                                                              
 var tmp74535406: bool;                                                                             
 var pred$2564535242: Node;                                                                         
 var tmp174535297: int;                                                                             
 var $pc4535260: Phase;                                                                             
 var curr$2564535340: Node;                                                                         
 var Node.next4535420: [Node]Node;                                                                  
 var this$2564535297: OptimisticList;                                                               
 var $recorded.state4535211: int;                                                                   
 var tmp214535406: int;                                                                             
 var Node.item4535509: [Node]int;                                                                   
 var tmp134535484: int;                                                                             
 var moverPath4535260: MoverPath;                                                                   
 var tmp74535093: bool;                                                                             
 var curr$256: Node;                                                                                
 var OptimisticList._lock4535107: [OptimisticList]Tid;                                              
 var OptimisticList._state4535161: [OptimisticList]State;                                           
 var OptimisticList._state4535260: [OptimisticList]State;                                           
 var path4535077: int;                                                                              
 var OptimisticList._state4535506_bottom: [OptimisticList]State;                                    
 var Node._lock4535242: [Node]Tid;                                                                  
 var tmp174535383: int;                                                                             
 var OptimisticList.head4535114_bottom: [OptimisticList]Node;                                       
 var node2: Node;                                                                                   
 var OptimisticList.head4535487: [OptimisticList]Node;                                              
 var tmp224535484: bool;                                                                            
 var this$2564535243_post: OptimisticList;                                                          
 var tmp74535114_bottom: bool;                                                                      
 var tmp124535429: bool;                                                                            
 var tmp9: int;                                                                                     
 var tmp114535242: int;                                                                             
 var OptimisticList._state4535429: [OptimisticList]State;                                           
 var item4535093: int;                                                                              
 var Node.item4535111: [Node]int;                                                                   
 var this$2564535254: OptimisticList;                                                               
 var OptimisticList._lock4535487: [OptimisticList]Tid;                                              
 var tmp224535420: bool;                                                                            
 var Node.next4535340_bottom: [Node]Node;                                                           
 var $result4535107_post: bool;                                                                     
 var tmp184535374: bool;                                                                            
 var curr4535487: Node;                                                                             
 var $result4535123: bool;                                                                          
 var this$2564535315_post: OptimisticList;                                                          
 var OptimisticList.head4535315: [OptimisticList]Node;                                              
 var Node.item4535490: [Node]int;                                                                   
 var tmp114535137: int;                                                                             
 var tmp164535490: bool;                                                                            
 var item4535084: int;                                                                              
 var this4535487: OptimisticList;                                                                   
 var item4535137: int;                                                                              
 var pred4535211: Node;                                                                             
 var item4535114_bottom: int;                                                                       
 var tmp114535429: int;                                                                             
 var tid4535083: Tid;                                                                               
 var tmp244535429: bool;                                                                            
 var OptimisticList._state4535110: [OptimisticList]State;                                           
 var tmp134535340_bottom: int;                                                                      
 var OptimisticList._lock4535497: [OptimisticList]Tid;                                              
 var pred$2564535254: Node;                                                                         
 var this$2564535315: OptimisticList;                                                               
 var Node._lock4535110: [Node]Tid;                                                                  
 var $recorded.state4535174: int;                                                                   
 var Node.item4535484: [Node]int;                                                                   
 var pred4535138: Node;                                                                             
 var pred$2564535297: Node;                                                                         
 var item4535107: int;                                                                              
 var tmp194535420: Node;                                                                            
 var mover4535197: Mover;                                                                           
 var tmp21: int;                                                                                    
 var tmp2$256: int;                                                                                 
 var tmp114535420: int;                                                                             
 var item4535315: int;                                                                              
 var tid4535123: Tid;                                                                               
 var tmp74535315_post: bool;                                                                        
 var tmp74535197: bool;                                                                             
 var tmp114535243: int;                                                                             
 var $recorded.state4535243: int;                                                                   
 var Node.next4535243_post: [Node]Node;                                                             
 var pred4535084: Node;                                                                             
 var OptimisticList._state4535487: [OptimisticList]State;                                           
 var $recorded.state4535077: int;                                                                   
 var tmp214535484: int;                                                                             
 var OptimisticList.head4535111: [OptimisticList]Node;                                              
 var tmp184535260: bool;                                                                            
 var tmp74535340_bottom: bool;                                                                      
 var tmp164535420: bool;                                                                            
 var $recorded.state4535138_post: int;                                                              
 var curr4535083: Node;                                                                             
 var OptimisticList.head4535161: [OptimisticList]Node;                                              
 var tmp164535429: bool;                                                                            
 var tmp74535242: bool;                                                                             
 var moverPath4535093: MoverPath;                                                                   
 var tmp134535147: int;                                                                             
 var tmp104535429: bool;                                                                            
 var moverPath4535487: MoverPath;                                                                   
 var Node.item4535297: [Node]int;                                                                   
 var item$2564535340_bottom: int;                                                                   
 var OptimisticList._state4535111: [OptimisticList]State;                                           
 var OptimisticList.head4535243_post: [OptimisticList]Node;                                         
 var this4535114_bottom: OptimisticList;                                                            
 var $result4535340: bool;                                                                          
 var Node.item4535107_post: [Node]int;                                                              
 var tmp234535429: int;                                                                             
 var Node._state4535188: [Node]State;                                                               
 var tmp174535243: int;                                                                             
 var Node.next4535442: [Node]Node;                                                                  
 var Node._lock4535442: [Node]Tid;                                                                  
 var OptimisticList.head4535138_post: [OptimisticList]Node;                                         
 var Node.next4535487: [Node]Node;                                                                  
 var $recorded.state4535497: int;                                                                   
 var path4535297: int;                                                                              
 var tmp214535420: int;                                                                             
 var $result4535114: bool;                                                                          
 var item4535188: int;                                                                              
 var OptimisticList.head4535174: [OptimisticList]Node;                                              
 var $result4535406: bool;                                                                          
 var this4535243_post: OptimisticList;                                                              
 var Node.next4535509: [Node]Node;                                                                  
 var tmp104535243_post: bool;                                                                       
 var mover4535484: Mover;                                                                           
 var tmp74535147: bool;                                                                             
 var $result4535084: bool;                                                                          
 var this4535497: OptimisticList;                                                                   
 var Node.next4535497: [Node]Node;                                                                  
 var tid4535383: Tid;                                                                               
 var Node._lock4535497: [Node]Tid;                                                                  
 var item4535107_post: int;                                                                         
 var tmp74535497: bool;                                                                             
 var OptimisticList._lock4535374: [OptimisticList]Tid;                                              
 var Node._state4535314: [Node]State;                                                               
 var tmp74535138_post: bool;                                                                        
 var moverPath4535484: MoverPath;                                                                   
 var $result4535197: bool;                                                                          
 var tmp124535374: bool;                                                                            
 var $recorded.state4535111_post: int;                                                              
 var $recorded.state4535123: int;                                                                   
 var OptimisticList.head4535242: [OptimisticList]Node;                                              
 var this4535137: OptimisticList;                                                                   
 var $result4535374: bool;                                                                          
 var curr: Node;                                                                                    
 var OptimisticList._lock4535397: [OptimisticList]Tid;                                              
 var tid4535174: Tid;                                                                               
 var tmp124535243_post: bool;                                                                       
 var Node._lock4535077: [Node]Tid;                                                                  
 var path4535369: int;                                                                              
 var tmp174535315_post: int;                                                                        
 var tmp104535137: bool;                                                                            
 var tmp184535406: bool;                                                                            
 var $result4535161: bool;                                                                          
 var tmp194535406: Node;                                                                            
 var tmp144535211: bool;                                                                            
 var item4535506: int;                                                                              
 var tmp174535497: int;                                                                             
 var pred4535110: Node;                                                                             
 var moverPath4535110: MoverPath;                                                                   
 var tmp124535242: bool;                                                                            
 var moverPath4535242: MoverPath;                                                                   
 var tmp184535442: bool;                                                                            
 var tmp134535254: int;                                                                             
 var Node._state4535254: [Node]State;                                                               
 var tmp3$2564535297: int;                                                                          
 var tmp20: bool;                                                                                   
 var $pc4535509: Phase;                                                                             
 var item4535487: int;                                                                              
 var tmp114535211: int;                                                                             
 var $result4535369: bool;                                                                          
 var OptimisticList._state4535242: [OptimisticList]State;                                           
 var tmp74535110: bool;                                                                             
 var OptimisticList._state4535442: [OptimisticList]State;                                           
 var tmp1$256: bool;                                                                                
 var this4535260: OptimisticList;                                                                   
 var this4535242: OptimisticList;                                                                   
 var tmp104535497: bool;                                                                            
 var tmp194535369: Node;                                                                            
 var Node.next4535114_bottom: [Node]Node;                                                           
 var tid4535406: Tid;                                                                               
 var this$2564535242: OptimisticList;                                                               
 var OptimisticList._lock4535242: [OptimisticList]Tid;                                              
 var tid4535138: Tid;                                                                               
 var Node._lock4535107_post: [Node]Tid;                                                             
 var OptimisticList.head4535497: [OptimisticList]Node;                                              
 var mover4535123: Mover;                                                                           
 var OptimisticList._lock4535084_post: [OptimisticList]Tid;                                         
 var mover4535429: Mover;                                                                           
 var this4535084_post: OptimisticList;                                                              
 var Node._state4535509: [Node]State;                                                               
 var tmp74535487: bool;                                                                             
 var OptimisticList._state4535297: [OptimisticList]State;                                           
 var curr4535084: Node;                                                                             
 var curr4535123: Node;                                                                             
 var tmp104535340_bottom: bool;                                                                     
 var Node._state4535093: [Node]State;                                                               
 var OptimisticList.head4535506_bottom: [OptimisticList]Node;                                       
 var tmp114535397: int;                                                                             
 var Node.item4535315: [Node]int;                                                                   
 var $recorded.state4535147: int;                                                                   
 var item$2564535297: int;                                                                          
 var $pc4535077: Phase;                                                                             
 var Node.item4535083: [Node]int;                                                                   
 var tmp1$2564535314: bool;                                                                         
 var OptimisticList.head4535107_post: [OptimisticList]Node;                                         
 var $result4535188: bool;                                                                          
 var Node._state4535429: [Node]State;                                                               
 var tmp124535490: bool;                                                                            
 var tmp134535497: int;                                                                             
 var Node.next4535161: [Node]Node;                                                                  
 var tmp184535497: bool;                                                                            
 var tmp11: int;                                                                                    
 var tmp144535197: bool;                                                                            
 var OptimisticList._state4535174: [OptimisticList]State;                                           
 var item4535374: int;                                                                              
 var tmp194535484: Node;                                                                            
 var $result4535138: bool;                                                                          
 var tid4535077: Tid;                                                                               
 var $recorded.state4535369: int;                                                                   
 var tmp124535314: bool;                                                                            
 var tmp164535243: bool;                                                                            
 var $recorded.state4535138: int;                                                                   
 var pred4535243: Node;                                                                             
 var OptimisticList._lock4535111_post: [OptimisticList]Tid;                                         
 var Node._lock4535084_post: [Node]Tid;                                                             
 var this4535111: OptimisticList;                                                                   
 var path4535123: int;                                                                              
 var curr4535174: Node;                                                                             
 var tid4535107_post: Tid;                                                                          
 var moverPath4535406: MoverPath;                                                                   
 var tmp204535487: bool;                                                                            
 var tmp124535161: bool;                                                                            
 var Node._state4535111_post: [Node]State;                                                          
 var tmp114535123: int;                                                                             
 var Node._state4535197: [Node]State;                                                               
 var tmp94535110: int;                                                                              
 var $result4535211: bool;                                                                          
 var Node.next4535077: [Node]Node;                                                                  
 var tmp4$2564535315_post: bool;                                                                    
 var tmp104535484: bool;                                                                            
 var tmp184535315_post: bool;                                                                       
 var OptimisticList._lock4535077: [OptimisticList]Tid;                                              
 var $recorded.state4535243_post: int;                                                              
 var OptimisticList._state4535077: [OptimisticList]State;                                           
 var tmp144535315: bool;                                                                            
 var this$2564535243: OptimisticList;                                                               
 var pred4535487: Node;                                                                             
 var this4535197: OptimisticList;                                                                   
 var tmp184535254: bool;                                                                            
 var this4535490: OptimisticList;                                                                   
 var tmp124535397: bool;                                                                            
 var tmp154535429: int;                                                                             
 var $result4535084_post: bool;                                                                     
 var tid4535340_bottom: Tid;                                                                        
 var OptimisticList.head4535406: [OptimisticList]Node;                                              
 var $result4535442: bool;                                                                          
 var Node.next4535314: [Node]Node;                                                                  
 var tmp184535369: bool;                                                                            
 var $recorded.state4535429: int;                                                                   
 var tmp74535243: bool;                                                                             
 var path4535174: int;                                                                              
 var tmp244535484: bool;                                                                            
 var Node.item4535397: [Node]int;                                                                   
 var curr4535107_post: Node;                                                                        
 var OptimisticList._state4535188: [OptimisticList]State;                                           
 var tmp74535111_post: bool;                                                                        
 var Node._lock4535123: [Node]Tid;                                                                  
 var $recorded.state4535490: int;                                                                   
 var Node._state4535243_post: [Node]State;                                                          
 var pred4535369: Node;                                                                             
 var item4535420: int;                                                                              
 var Node._state4535297: [Node]State;                                                               
 var tmp184535487: bool;                                                                            
 var tmp134535406: int;                                                                             
 var tmp134535374: int;                                                                             
 var Node._lock4535429: [Node]Tid;                                                                  
 var $recorded.state4535484: int;                                                                   
 var tmp154535188: int;                                                                             
 var tmp74535340: bool;                                                                             
 var tmp174535484: int;                                                                             
 var this4535406: OptimisticList;                                                                   
 var $pc4535484: Phase;                                                                             
 var tid4535314: Tid;                                                                               
 var this4535509: OptimisticList;                                                                   
 var Node.item4535197: [Node]int;                                                                   
 var curr4535188: Node;                                                                             
 var $pc4535093: Phase;                                                                             
 var pred$2564535243: Node;                                                                         
 var Node.item4535442: [Node]int;                                                                   
 var Node.item4535487: [Node]int;                                                                   
 var Node.next4535107: [Node]Node;                                                                  
 var Node.next4535374: [Node]Node;                                                                  
 var Node._state4535084: [Node]State;                                                               
 var Node._state4535442: [Node]State;                                                               
 var $recorded.state4535397: int;                                                                   
 var tid4535243_post: Tid;                                                                          
 var curr$2564535243: Node;                                                                         
 var OptimisticList._lock4535506: [OptimisticList]Tid;                                              
 var tmp154535297: int;                                                                             
 var tmp164535297: bool;                                                                            
 var curr4535243: Node;                                                                             
 var tmp164535315: bool;                                                                            
 var Node.next4535243: [Node]Node;                                                                  
 var Node._lock4535340_bottom: [Node]Tid;                                                           
 var tmp114535138: int;                                                                             
 var tmp204535484: bool;                                                                            
 var Node.item4535161: [Node]int;                                                                   
 var tmp94535093: int;                                                                              
 var OptimisticList._lock4535383: [OptimisticList]Tid;                                              
 var tid4535242: Tid;                                                                               
 var $recorded.state4535093: int;                                                                   
 var $result4535242: bool;                                                                          
 var tid4535442: Tid;                                                                               
 var phase4535340: Phase;                                                                           
 var tmp214535490: int;                                                                             
 var item4535315_post: int;                                                                         
 var tmp214535383: int;                                                                             
 var tmp194535429: Node;                                                                            
 var tmp74535420: bool;                                                                             
 var pred4535315: Node;                                                                             
 var tmp114535487: int;                                                                             
 var $result4535506: bool;                                                                          
 var tmp204535429: bool;                                                                            
 var OptimisticList._lock4535509: [OptimisticList]Tid;                                              
 var Node.next4535138: [Node]Node;                                                                  
 var path4535093: int;                                                                              
 var tmp74535137: bool;                                                                             
 var tmp2$2564535260: int;                                                                          
 var tmp194535374: Node;                                                                            
 var tmp194535442: Node;                                                                            
 var Node._lock4535111: [Node]Tid;                                                                  
 var phase4535114: Phase;                                                                           
 var Node._lock4535509: [Node]Tid;                                                                  
 var mover4535110: Mover;                                                                           
 var tid4535110: Tid;                                                                               
 var tmp204535383: bool;                                                                            
 var Node._lock4535083: [Node]Tid;                                                                  
 var tmp184535420: bool;                                                                            
 var tmp10: bool;                                                                                   
 var $recorded.state4535111: int;                                                                   
 var moverPath4535083: MoverPath;                                                                   
 var tmp154535490: int;                                                                             
 var moverPath4535369: MoverPath;                                                                   
 var tmp134535197: int;                                                                             
 var this4535297: OptimisticList;                                                                   
 var tmp244535442: bool;                                                                            
 var item4535397: int;                                                                              
 var curr4535243_post: Node;                                                                        
 var item$2564535254: int;                                                                          
 var item4535383: int;                                                                              
 var Node.next4535197: [Node]Node;                                                                  
 var tmp104535147: bool;                                                                            
 var OptimisticList.head4535211: [OptimisticList]Node;                                              
 var path4535487: int;                                                                              
 var $result4535077: bool;                                                                          
 var curr4535260: Node;                                                                             
 var path4535490: int;                                                                              
 var $recorded.state4535188: int;                                                                   
 var tmp144535188: bool;                                                                            
 var path4535254: int;                                                                              
 var tmp12: bool;                                                                                   
 var Node._lock4535093: [Node]Tid;                                                                  
 var path4535484: int;                                                                              
 var tmp114535174: int;                                                                             
 var Node.next4535406: [Node]Node;                                                                  
 var tmp104535420: bool;                                                                            
 var curr$2564535242: Node;                                                                         
 var curr4535374: Node;                                                                             
 var Node.item4535107: [Node]int;                                                                   
 var mover4535077: Mover;                                                                           
 var $recorded.state4535107_post: int;                                                              
 var Node.next4535107_post: [Node]Node;                                                             
 var Node.item4535420: [Node]int;                                                                   
 var $result4535111_post: bool;                                                                     
 var curr4535254: Node;                                                                             
 var Node._state4535138_post: [Node]State;                                                          
 var tmp24: bool;                                                                                   
 var $pc4535111: Phase;                                                                             
 var item4535260: int;                                                                              
 var Node.next4535254: [Node]Node;                                                                  
 var tid4535260: Tid;                                                                               
 var tmp3$2564535314: int;                                                                          
 var tid4535114: Tid;                                                                               
 var this$256: OptimisticList;                                                                      
 var mover4535383: Mover;                                                                           
 var tid4535506_bottom: Tid;                                                                        
 var OptimisticList.head4535369: [OptimisticList]Node;                                              
 var OptimisticList._lock4535093: [OptimisticList]Tid;                                              
 var tmp74535083: bool;                                                                             
 var Node._lock4535111_post: [Node]Tid;                                                             
 var OptimisticList._state4535123: [OptimisticList]State;                                           
 var OptimisticList._state4535406: [OptimisticList]State;                                           
 var tmp254535429: int;                                                                             
 var OptimisticList._state4535397: [OptimisticList]State;                                           
 var $result4535243_post: bool;                                                                     
 var Node.item4535254: [Node]int;                                                                   
 var OptimisticList._state4535374: [OptimisticList]State;                                           
 var $pc4535315_post: Phase;                                                                        
 var tmp15: int;                                                                                    
 var tmp2$2564535254: int;                                                                          
 var $recorded.state4535083: int;                                                                   
 var tmp104535315_post: bool;                                                                       
 var tmp144535420: bool;                                                                            
 var tmp23: int;                                                                                    
 var OptimisticList._state4535254: [OptimisticList]State;                                           
 var $pc4535506: Phase;                                                                             
 var this$2564535260: OptimisticList;                                                               
 var tmp164535211: bool;                                                                            
 var tmp144535243: bool;                                                                            
 var $recorded.state4535487: int;                                                                   
 var tmp13: int;                                                                                    
 var this4535083: OptimisticList;                                                                   
 var pred4535497: Node;                                                                             
 var Node._state4535487: [Node]State;                                                               
 var tmp144535429: bool;                                                                            
 var Node._state4535114_bottom: [Node]State;                                                        
 var tmp234535406: int;                                                                             
 var tmp74535188: bool;                                                                             
 var item4535369: int;                                                                              
 var OptimisticList.head4535093: [OptimisticList]Node;                                              
 var item4535484: int;                                                                              
 var tmp214535497: int;                                                                             
 var Node.item4535093: [Node]int;                                                                   
 var Node._state4535369: [Node]State;                                                               
 var Node._state4535374: [Node]State;                                                               
 var tmp154535243: int;                                                                             
 var curr4535406: Node;                                                                             
 var tmp154535374: int;                                                                             
 var curr$2564535243_post: Node;                                                                    
 var $pc4535084_post: Phase;                                                                        
 var Node.item4535506_bottom: [Node]int;                                                            
 var tmp7: bool;                                                                                    
 var curr4535107: Node;                                                                             
 var tmp134535243_post: int;                                                                        
 var Node._lock4535138_post: [Node]Tid;                                                             
 var tmp164535315_post: bool;                                                                       
 var curr4535315_post: Node;                                                                        
 var pred$256: Node;                                                                                
 var tmp244535487: bool;                                                                            
 var OptimisticList._lock4535340_bottom: [OptimisticList]Tid;                                       
 var $recorded.state4535340_bottom: int;                                                            
 var curr4535497: Node;                                                                             
 var item4535429: int;                                                                              
 var tmp19: Node;                                                                                   
 var $result4535429: bool;                                                                          
 var tmp174535260: int;                                                                             
 var OptimisticList._state4535147: [OptimisticList]State;                                           
 var tmp174535442: int;                                                                             
 var tmp104535243: bool;                                                                            
 var $pc4535242: Phase;                                                                             
 var $pc4535314: Phase;                                                                             
 var item$2564535314: int;                                                                          
 var curr4535297: Node;                                                                             
 var tmp124535147: bool;                                                                            
 var tmp74535123: bool;                                                                             
 var item4535442: int;                                                                              
 var this4535077: OptimisticList;                                                                   
 var this4535161: OptimisticList;                                                                   
 var OptimisticList.head4535260: [OptimisticList]Node;                                              
 var $result4535137: bool;                                                                          
 var this4535211: OptimisticList;                                                                   
 var this4535111_post: OptimisticList;                                                              
 var tmp104535315: bool;                                                                            
 var tmp234535420: int;                                                                             
 var $result4535110: bool;                                                                          
 var curr4535369: Node;                                                                             
 var $pc4535138_post: Phase;                                                                        
 var curr4535442: Node;                                                                             
 var tmp124535369: bool;                                                                            
 var OptimisticList._state4535114_bottom: [OptimisticList]State;                                    
 var $result4535138_post: bool;                                                                     
 var tid4535369: Tid;                                                                               
 var tmp164535442: bool;                                                                            
 var pred4535484: Node;                                                                             
 var tmp174535406: int;                                                                             
 var tid4535509: Tid;                                                                               
 var node$2564535297: Node;                                                                         
 var $recorded.state4535110: int;                                                                   
 var node$2564535243_post: Node;                                                                    
 var tmp154535369: int;                                                                             
 var curr4535484: Node;                                                                             
 var curr4535490: Node;                                                                             
 var pred$2564535315: Node;                                                                         
 var OptimisticList._state4535315: [OptimisticList]State;                                           
 var path4535110: int;                                                                              
 var Node._state4535111: [Node]State;                                                               
 var tmp144535487: bool;                                                                            
 var tmp164535340_bottom: bool;                                                                     
 var Node._state4535138: [Node]State;                                                               
 var path4535383: int;                                                                              
 var $pc4535188: Phase;                                                                             
 var Node._lock4535114_bottom: [Node]Tid;                                                           
 var OptimisticList._state4535093: [OptimisticList]State;                                           
 var tmp224535406: bool;                                                                            
 var tmp104535490: bool;                                                                            
 var mover4535487: Mover;                                                                           
 var $recorded.state4535340: int;                                                                   
 var tmp174535397: int;                                                                             
 var Node.item4535084: [Node]int;                                                                   
 var Node._state4535147: [Node]State;                                                               
 var Node._lock4535315: [Node]Tid;                                                                  
 var tmp144535314: bool;                                                                            
 var Node.next4535174: [Node]Node;                                                                  
 var tmp234535490: int;                                                                             
 var tmp74535315: bool;                                                                             
 var tmp74535260: bool;                                                                             
 var pred4535406: Node;                                                                             
 var tmp164535242: bool;                                                                            
 var Node.next4535315: [Node]Node;                                                                  
 var tmp154535254: int;                                                                             
 var $recorded.state4535315_post: int;                                                              
 var tmp74535484: bool;                                                                             
 var tmp154535487: int;                                                                             
 var tmp124535315: bool;                                                                            
 var OptimisticList._lock4535138: [OptimisticList]Tid;                                              
 var OptimisticList._lock4535442: [OptimisticList]Tid;                                              
 var pred4535137: Node;                                                                             
 var tmp1$2564535254: bool;                                                                         
 var $recorded.state4535137: int;                                                                   
 var mover4535369: Mover;                                                                           
 var pred4535442: Node;                                                                             
 var curr4535138_post: Node;                                                                        
 var tid4535107: Tid;                                                                               
 var tmp154535242: int;                                                                             
 var tmp114535314: int;                                                                             
 var $recorded.state4535420: int;                                                                   
 var item4535110: int;                                                                              
 var this4535084: OptimisticList;                                                                   
 var tmp174535211: int;                                                                             
 var Node.item4535429: [Node]int;                                                                   
 var pred4535111: Node;                                                                             
 var tmp104535138_post: bool;                                                                       
 var tmp114535161: int;                                                                             
 var OptimisticList._state4535083: [OptimisticList]State;                                           
 var tmp174535314: int;                                                                             
 var OptimisticList._state4535509: [OptimisticList]State;                                           
 var Node._state4535137: [Node]State;                                                               
 var $recorded.state4535509: int;                                                                   
 var node24535487: Node;                                                                            
 var Node.item4535138: [Node]int;                                                                   
 var this4535340_bottom: OptimisticList;                                                            
 var tmp184535397: bool;                                                                            
 var tmp144535406: bool;                                                                            
 var tmp184535315: bool;                                                                            
 var tmp184535297: bool;                                                                            
 var $pc4535114_bottom: Phase;                                                                      
 var OptimisticList._lock4535429: [OptimisticList]Tid;                                              
 var curr4535340: Node;                                                                             
 var tmp164535383: bool;                                                                            
 var moverPath4535490: MoverPath;                                                                   
 var $pc4535340_bottom: Phase;                                                                      
 var tmp104535242: bool;                                                                            
 var tmp174535315: int;                                                                             
 var tmp134535420: int;                                                                             
 var tmp144535340: bool;                                                                            
 var this4535110: OptimisticList;                                                                   
 var Node.next4535484: [Node]Node;                                                                  
 var tmp124535315_post: bool;                                                                       
 var node$2564535315_post: Node;                                                                    
 var Node._lock4535406: [Node]Tid;                                                                  
 var tid4535147: Tid;                                                                               
 var this$2564535340: OptimisticList;                                                               
 var tid4535138_post: Tid;                                                                          
 var mover4535406: Mover;                                                                           
 var item$2564535340: int;                                                                          
 var tmp114535442: int;                                                                             
 var OptimisticList._state4535084_post: [OptimisticList]State;                                      
 var Node.item4535077: [Node]int;                                                                   
 var tmp2$2564535315: int;                                                                          
 var node$2564535243: Node;                                                                         
 var tmp164535314: bool;                                                                            
 var OptimisticList._lock4535161: [OptimisticList]Tid;                                              
 var this4535243: OptimisticList;                                                                   
 var tmp174535429: int;                                                                             
 var tmp184535243: bool;                                                                            
 var tmp134535369: int;                                                                             
 var Node._state4535340: [Node]State;                                                               
 var tmp144535369: bool;                                                                            
 var pred4535188: Node;                                                                             
 var tmp184535340_bottom: bool;                                                                     
 var tmp164535484: bool;                                                                            
 var pred4535123: Node;                                                                             
 var tmp74535297: bool;                                                                             
 var $pc4535137: Phase;                                                                             
 var OptimisticList._lock4535138_post: [OptimisticList]Tid;                                         
 var tmp74535107: bool;                                                                             
 var tmp74535138: bool;                                                                             
 var path4535083: int;                                                                              
 var OptimisticList._lock4535406: [OptimisticList]Tid;                                              
 var OptimisticList._state4535243_post: [OptimisticList]State;                                      
 var curr4535147: Node;                                                                             
 var tmp124535211: bool;                                                                            
 var Node.next4535111_post: [Node]Node;                                                             
 var tmp154535260: int;                                                                             
 var tmp104535197: bool;                                                                            
 var tmp114535297: int;                                                                             
 var tmp214535487: int;                                                                             
 var tmp194535490: Node;                                                                            
 var OptimisticList._lock4535490: [OptimisticList]Tid;                                              
 var node$2564535340: Node;                                                                         
 var tmp114535315: int;                                                                             
 var pred4535297: Node;                                                                             
 var item4535497: int;                                                                              
 var $pc4535429: Phase;                                                                             
 var OptimisticList.head4535506: [OptimisticList]Node;                                              
 var tmp134535487: int;                                                                             
 var tmp174535420: int;                                                                             
 var $pc4535161: Phase;                                                                             
 var tmp114535315_post: int;                                                                        
 var tmp204535490: bool;                                                                            
 var mover4535242: Mover;                                                                           
 var tmp184535242: bool;                                                                            
 var tmp164535369: bool;                                                                            
 var path4535429: int;                                                                              
 var Node.item4535111_post: [Node]int;                                                              
 var Node._state4535315: [Node]State;                                                               
 var Node._lock4535243: [Node]Tid;                                                                  
 var curr4535340_bottom: Node;                                                                      
 var Node._state4535506_bottom: [Node]State;                                                        
 var item4535111_post: int;                                                                         
 var OptimisticList._lock4535137: [OptimisticList]Tid;                                              
 var OptimisticList._lock4535174: [OptimisticList]Tid;                                              
 var OptimisticList._lock4535506_bottom: [OptimisticList]Tid;                                       
 var Node._lock4535374: [Node]Tid;                                                                  
 var Node.next4535084: [Node]Node;                                                                  
 var $result4535093: bool;                                                                          
 var tmp104535383: bool;                                                                            
 var OptimisticList._lock4535197: [OptimisticList]Tid;                                              
 var OptimisticList._state4535340: [OptimisticList]State;                                           
 var $pc4535340: Phase;                                                                             
 var this4535383: OptimisticList;                                                                   
 var tmp144535174: bool;                                                                            
 var $recorded.state4535084_post: int;                                                              
 var tmp14: bool;                                                                                   
 var Node._lock4535138: [Node]Tid;                                                                  
 var curr4535138: Node;                                                                             
 var tmp124535487: bool;                                                                            
 var tmp254535484: int;                                                                             
 var OptimisticList._lock4535315: [OptimisticList]Tid;                                              
 var tmp204535497: bool;                                                                            
 var curr$2564535340_bottom: Node;                                                                  
 var $pc4535315: Phase;                                                                             
 var pred$2564535260: Node;                                                                         
 var tmp154535315_post: int;                                                                        
 var tmp164535197: bool;                                                                            
 var tmp74535211: bool;                                                                             
 var Node.next4535260: [Node]Node;                                                                  
 var $pc4535174: Phase;                                                                             
 var $recorded.state4535161: int;                                                                   
 var Node._state4535107_post: [Node]State;                                                          
 var tmp164535397: bool;                                                                            
 var tmp144535254: bool;                                                                            
 var tmp164535340: bool;                                                                            
 var Node.item4535340: [Node]int;                                                                   
 var OptimisticList._state4535490: [OptimisticList]State;                                           
 var Node._lock4535107: [Node]Tid;                                                                  
 var Node.item4535084_post: [Node]int;                                                              
 var tmp194535383: Node;                                                                            
 var OptimisticList.head4535340: [OptimisticList]Node;                                              
 var tmp4$2564535297: bool;                                                                         
 var tmp74535114: bool;                                                                             
 var Node._state4535123: [Node]State;                                                               
 var tid4535484: Tid;                                                                               
 var $pc4535383: Phase;                                                                             
 var tmp74535161: bool;                                                                             
 var Node._lock4535484: [Node]Tid;                                                                  
 var tmp144535374: bool;                                                                            
 var moverPath4535147: MoverPath;                                                                   
 var tmp124535497: bool;                                                                            
 var this4535138: OptimisticList;                                                                   
 var pred4535374: Node;                                                                             
 var Node.item4535123: [Node]int;                                                                   
 var item4535084_post: int;                                                                         
 var tmp104535442: bool;                                                                            
 var Node.next4535397: [Node]Node;                                                                  
 var $pc4535297: Phase;                                                                             
 var tmp3$2564535260: int;                                                                          
 var tmp134535211: int;                                                                             
 var Node._state4535084_post: [Node]State;                                                          
 var Node._lock4535161: [Node]Tid;                                                                  
 var $result4535174: bool;                                                                          
 var tmp224535487: bool;                                                                            
 var tmp124535188: bool;                                                                            
 var item4535211: int;                                                                              
 var OptimisticList._lock4535254: [OptimisticList]Tid;                                              
 var path4535260: int;                                                                              
 var $pc4535243: Phase;                                                                             
 var Node._state4535406: [Node]State;                                                               
 var tmp134535260: int;                                                                             
 var pred: Node;                                                                                    
 var tmp194535497: Node;                                                                            
 var tmp104535406: bool;                                                                            
 var tmp144535243_post: bool;                                                                       
 var Node._lock4535340: [Node]Tid;                                                                  
 var tmp5$2564535297: bool;                                                                         
 var tmp74535254: bool;                                                                             
 var $pc4535406: Phase;                                                                             
 var OptimisticList.head4535420: [OptimisticList]Node;                                              
 var OptimisticList._lock4535297: [OptimisticList]Tid;                                              
 var tmp74535314: bool;                                                                             
 var this4535506: OptimisticList;                                                                   
 var tid4535111_post: Tid;                                                                          
 var Node._lock4535174: [Node]Tid;                                                                  
 var OptimisticList._state4535369: [OptimisticList]State;                                           
 var tmp134535242: int;                                                                             
 var tmp134535490: int;                                                                             
 var OptimisticList.head4535107: [OptimisticList]Node;                                              
 var tmp144535490: bool;                                                                            
 var curr4535114_bottom: Node;                                                                      
 var node$2564535254: Node;                                                                         
 var OptimisticList.head4535315_post: [OptimisticList]Node;                                         
 var moverPath4535197: MoverPath;                                                                   
 var tmp2$2564535314: int;                                                                          
 var tmp6$256: Node;                                                                                
 var mover4535314: Mover;                                                                           
 var Node.item4535369: [Node]int;                                                                   
 var OptimisticList.head4535083: [OptimisticList]Node;                                              
 var OptimisticList._lock4535084: [OptimisticList]Tid;                                              
 var item4535161: int;                                                                              
 var tmp154535197: int;                                                                             
 var tmp174535242: int;                                                                             
 var tmp74535077: bool;                                                                             
 var tmp3$256: int;                                                                                 
 var $pc4535243_post: Phase;                                                                        
 var item$2564535315_post: int;                                                                     
 var tmp104535340: bool;                                                                            
 var Node._lock4535188: [Node]Tid;                                                                  
 var tmp114535260: int;                                                                             
 var this$257: Node;                                                                                
 var OptimisticList.head4535340_bottom: [OptimisticList]Node;                                       
 var $result4535315_post: bool;                                                                     
 var moverPath4535077: MoverPath;                                                                   
 var tmp114535369: int;                                                                             
 var Node.next4535093: [Node]Node;                                                                  
 var tmp204535420: bool;                                                                            
 var tmp154535406: int;                                                                             
 var Node._lock4535383: [Node]Tid;                                                                  
 var OptimisticList.head4535397: [OptimisticList]Node;                                              
 var OptimisticList._lock4535314: [OptimisticList]Tid;                                              
 var Node._state4535077: [Node]State;                                                               
 var tid4535137: Tid;                                                                               
 var OptimisticList._state4535314: [OptimisticList]State;                                           
 var OptimisticList.head4535374: [OptimisticList]Node;                                              
 var tmp84535107_post: bool;                                                                        
 var tid4535340: Tid;                                                                               
 var tmp134535297: int;                                                                             
 var tmp184535314: bool;                                                                            
 var pred4535242: Node;                                                                             
 var $result4535420: bool;                                                                          
 var OptimisticList._lock4535111: [OptimisticList]Tid;                                              
 var tmp174535490: int;                                                                             
 var tmp144535484: bool;                                                                            
 var $result4535107: bool;                                                                          
 var tmp204535406: bool;                                                                            
 var tmp144535442: bool;                                                                            
 var Node.next4535506_bottom: [Node]Node;                                                           
 var $pc4535490: Phase;                                                                             
 var tmp184535429: bool;                                                                            
 var this4535420: OptimisticList;                                                                   
 var tmp8: bool;                                                                                    
 var curr4535242: Node;                                                                             
 var tmp154535484: int;                                                                             
 var pred4535114: Node;                                                                             
 var tmp25: int;                                                                                    
 var mover4535093: Mover;                                                                           
 var Node.item4535340_bottom: [Node]int;                                                            
 var tmp84535110: bool;                                                                             
 var tmp184535243_post: bool;                                                                       
 var Node.next4535138_post: [Node]Node;                                                             
 var $pc4535197: Phase;                                                                             
 var Node._state4535397: [Node]State;                                                               
 var node$2564535260: Node;                                                                         
 var this4535397: OptimisticList;                                                                   
 var tmp124535243: bool;                                                                            
 var Node._state4535340_bottom: [Node]State;                                                        
 var OptimisticList._lock4535107_post: [OptimisticList]Tid;                                         
 var curr$2564535260: Node;                                                                         
 var Node.next4535084_post: [Node]Node;                                                             
 var Node._lock4535420: [Node]Tid;                                                                  
 var moverPath4535314: MoverPath;                                                                   
 var OptimisticList._state4535138_post: [OptimisticList]State;                                      
 var tmp154535442: int;                                                                             
 var tmp114535497: int;                                                                             
 var node24535497: Node;                                                                            
 var OptimisticList._lock4535211: [OptimisticList]Tid;                                              
 var curr$2564535314: Node;                                                                         
 var tmp204535397: bool;                                                                            
 var Node._lock4535297: [Node]Tid;                                                                  
 var tmp144535397: bool;                                                                            
 var tmp174535243_post: int;                                                                        
 var pred4535111_post: Node;                                                                        
 var Node.item4535506: [Node]int;                                                                   
 var tmp104535123: bool;                                                                            
 var OptimisticList.head4535137: [OptimisticList]Node;                                              
 var tmp154535174: int;                                                                             
 var Node.next4535369: [Node]Node;                                                                  
 var tmp104535314: bool;                                                                            
 var phase4535506: Phase;                                                                           
 var tmp114535406: int;                                                                             
 var tmp154535397: int;                                                                             
 var tmp114535374: int;                                                                             
 var tmp244535490: bool;                                                                            
 var $result4535506_bottom: bool;                                                                   
 var this4535340: OptimisticList;                                                                   
 var tmp154535340: int;                                                                             
 var item4535314: int;                                                                              
 var tmp164535254: bool;                                                                            
 var pred4535490: Node;                                                                             
 var curr4535114: Node;                                                                             
 var Node._state4535497: [Node]State;                                                               
 var tmp104535138: bool;                                                                            
 var tmp6$2564535297: Node;                                                                         
 var tmp104535188: bool;                                                                            
 var tmp134535383: int;                                                                             
 var $recorded.state4535107: int;                                                                   
 var pred$2564535340_bottom: Node;                                                                  
 var OptimisticList.head4535147: [OptimisticList]Node;                                              
 var node$2564535242: Node;                                                                         
 var tmp124535406: bool;                                                                            
 var $pc4535487: Phase;                                                                             
 var OptimisticList.head4535123: [OptimisticList]Node;                                              
 var this4535188: OptimisticList;                                                                   
 var OptimisticList._state4535197: [OptimisticList]State;                                           
 var tid4535211: Tid;                                                                               
 var Node.item4535110: [Node]int;                                                                   
 var tmp74535111: bool;                                                                             
 var tmp134535429: int;                                                                             
 var tmp114535188: int;                                                                             
 var $result4535083: bool;                                                                          
 var OptimisticList._state4535484: [OptimisticList]State;                                           
 var tmp74535084: bool;                                                                             
 var tmp124535297: bool;                                                                            
 var tmp144535297: bool;                                                                            
 var tmp1$2564535260: bool;                                                                         
 var $result4535111: bool;                                                                          
 var this4535147: OptimisticList;                                                                   
 var Node._lock4535243_post: [Node]Tid;                                                             
 var tmp134535174: int;                                                                             
 var tmp134535243: int;                                                                             
 var tmp104535174: bool;                                                                            
 var tmp18: bool;                                                                                   
 var Node._lock4535260: [Node]Tid;                                                                  
 var curr$2564535297: Node;                                                                         
 var node$2564535340_bottom: Node;                                                                  
 var this4535093: OptimisticList;                                                                   
 var Node.next4535137: [Node]Node;                                                                  
 var tid4535315: Tid;                                                                               
 var tmp104535211: bool;                                                                            
 var $pc4535111_post: Phase;                                                                        
 var tmp94535107: int;                                                                              
 var tmp164535497: bool;                                                                            
 var tid4535420: Tid;                                                                               
 var tmp154535497: int;                                                                             
 var $result4535490: bool;                                                                          
 var $recorded.state4535254: int;                                                                   
 var tmp104535397: bool;                                                                            
 var pred4535083: Node;                                                                             
 var curr$2564535254: Node;                                                                         
 var $pc4535211: Phase;                                                                             
 var mover4535260: Mover;                                                                           
 var tid4535487: Tid;                                                                               
 var tmp3$2564535315: int;                                                                          
 var OptimisticList.head4535383: [OptimisticList]Node;                                              
 var Node.item4535114_bottom: [Node]int;                                                            
 var tmp114535147: int;                                                                             
 var tid4535197: Tid;                                                                               
 var tmp184535340: bool;                                                                            
 var tmp214535442: int;                                                                             
 var $result4535243: bool;                                                                          
 var OptimisticList.head4535442: [OptimisticList]Node;                                              
 var mover4535147: Mover;                                                                           
 var tmp174535369: int;                                                                             
 var this4535107_post: OptimisticList;                                                              
 var path4535406: int;                                                                              
 var OptimisticList._lock4535114_bottom: [OptimisticList]Tid;                                       
 var OptimisticList._state4535340_bottom: [OptimisticList]State;                                    
 var tmp144535315_post: bool;                                                                       
 var Node.item4535383: [Node]int;                                                                   
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true;                                                                                              // (37.24): Can only have right-mover memory accesses in requires clause
                                                                                                    
 assume Node._state4535506 == Node._state && Node.item4535506 == Node.item && Node.next4535506 == Node.next && Node._lock4535506 == Node._lock && OptimisticList._state4535506 == OptimisticList._state && OptimisticList.head4535506 == OptimisticList.head && OptimisticList._lock4535506 == OptimisticList._lock && $result4535506 == $result && item4535506 == item && this4535506 == this && tid4535506 == tid;
 assume $recorded.state4535506 == 1;                                                                
                                                                                                    
 // 39.7: while (true)   {                                                                          
                                                                                                    
 phase4535506 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (37.5): Bad tid
  invariant isShared(OptimisticList._state[this]);                                                         // (37.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (39.7): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (39.7): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (39.7): Object invariant may not hold.
  invariant  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (39.7): Object invariant may not hold.
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state4535506,Node.item4535506,Node.next4535506,Node._lock4535506,OptimisticList._state4535506,OptimisticList.head4535506,OptimisticList._lock4535506));       // (39.7): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state4535506,Node.item4535506,Node.next4535506,Node._lock4535506,OptimisticList._state4535506,OptimisticList.head4535506,OptimisticList._lock4535506));       // (39.7): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : OptimisticList :: Invariant.Y_OptimisticList.head(tid : Tid, _this, OptimisticList.head[_this] ,Node._state4535506,Node.item4535506,Node.next4535506,Node._lock4535506,OptimisticList._state4535506,OptimisticList.head4535506,OptimisticList._lock4535506));       // (39.7): Loop does not preserve yields_as annotation for field head
  invariant phase4535506 == $pc;                                                                           // (39.7): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (39.7): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 39.14: boolean tmp7;                                                                           
                                                                                                    
                                                                                                    
  // 39.14: tmp7 = true;                                                                            
                                                                                                    
  tmp7 := true;                                                                                     
  if (!(tmp7)) {                                                                                    
                                                                                                    
   // 39.7: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 40.9: Node pred;                                                                               
                                                                                                    
                                                                                                    
  // 40.9: pred := this.head;                                                                       
                                                                                                    
                                                                                                    
  moverPath4535077 := ReadEval.OptimisticList.head(tid: Tid,this: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
  mover4535077 := m#moverPath(moverPath4535077);                                                    
  path4535077 := p#moverPath(moverPath4535077);                                                     
  assume Node._state4535077 == Node._state && Node.item4535077 == Node.item && Node.next4535077 == Node.next && Node._lock4535077 == Node._lock && OptimisticList._state4535077 == OptimisticList._state && OptimisticList.head4535077 == OptimisticList.head && OptimisticList._lock4535077 == OptimisticList._lock && pred4535077 == pred && tmp74535077 == tmp7 && $result4535077 == $result && item4535077 == item && this4535077 == this && tid4535077 == tid && $pc4535077 == $pc;
  assume $recorded.state4535077 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != OptimisticList.null;                                                              
  } else {                                                                                          
   assert this != OptimisticList.null;                                                                     // (40.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4535077);                                                             
  assert $pc != PhaseError;                                                                                // (40.9): Reduction failure
  pred := OptimisticList.head[this];                                                                
                                                                                                    
  // 41.9: Node curr;                                                                               
                                                                                                    
                                                                                                    
  // 41.9: curr := pred.next;                                                                       
                                                                                                    
                                                                                                    
  moverPath4535083 := ReadEval.Node.next(tid: Tid,pred: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
  mover4535083 := m#moverPath(moverPath4535083);                                                    
  path4535083 := p#moverPath(moverPath4535083);                                                     
  assume Node._state4535083 == Node._state && Node.item4535083 == Node.item && Node.next4535083 == Node.next && Node._lock4535083 == Node._lock && OptimisticList._state4535083 == OptimisticList._state && OptimisticList.head4535083 == OptimisticList.head && OptimisticList._lock4535083 == OptimisticList._lock && curr4535083 == curr && pred4535083 == pred && tmp74535083 == tmp7 && $result4535083 == $result && item4535083 == item && this4535083 == this && tid4535083 == tid && $pc4535083 == $pc;
  assume $recorded.state4535083 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume pred != Node.null;                                                                        
  } else {                                                                                          
   assert pred != Node.null;                                                                               // (41.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4535083);                                                             
  assert $pc != PhaseError;                                                                                // (41.9): Reduction failure
  curr := Node.next[pred];                                                                          
                                                                                                    
  // 42.9: yield;                                                                                   
                                                                                                    
  assume Node._state4535084 == Node._state && Node.item4535084 == Node.item && Node.next4535084 == Node.next && Node._lock4535084 == Node._lock && OptimisticList._state4535084 == OptimisticList._state && OptimisticList.head4535084 == OptimisticList.head && OptimisticList._lock4535084 == OptimisticList._lock && curr4535084 == curr && pred4535084 == pred && tmp74535084 == tmp7 && $result4535084 == $result && item4535084 == item && this4535084 == this && tid4535084 == tid;
  assume $recorded.state4535084 == 1;                                                               
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (42.9): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (42.9): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (42.9): Object invariant may not hold.
  assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (42.9): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (42.9): Object invariant may not hold.
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (42.9): Object invariant may not hold.
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (42.9): Object invariant may not hold.
  assume  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (42.9): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Node._state4535084_post == Node._state && Node.item4535084_post == Node.item && Node.next4535084_post == Node.next && Node._lock4535084_post == Node._lock && OptimisticList._state4535084_post == OptimisticList._state && OptimisticList.head4535084_post == OptimisticList.head && OptimisticList._lock4535084_post == OptimisticList._lock && curr4535084_post == curr && pred4535084_post == pred && tmp74535084_post == tmp7 && $result4535084_post == $result && item4535084_post == item && this4535084_post == this && tid4535084_post == tid;
  assume $recorded.state4535084_post == 1;                                                          
  assume Node._state4535114 == Node._state && Node.item4535114 == Node.item && Node.next4535114 == Node.next && Node._lock4535114 == Node._lock && OptimisticList._state4535114 == OptimisticList._state && OptimisticList.head4535114 == OptimisticList.head && OptimisticList._lock4535114 == OptimisticList._lock && curr4535114 == curr && pred4535114 == pred && tmp74535114 == tmp7 && $result4535114 == $result && item4535114 == item && this4535114 == this && tid4535114 == tid;
  assume $recorded.state4535114 == 1;                                                               
                                                                                                    
  // 43.9: while (true)                                                                             
                                                                                                    
  phase4535114 := $pc;                                                                              
  while (true)                                                                                      
                                                                                                    
   invariant ValidTid(tid);                                                                                // (37.5): Bad tid
   invariant isShared(OptimisticList._state[this]);                                                        // (37.5): this is not global
                                                                                                    
   invariant StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
   invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (43.9): Object invariant may not hold.
   invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (43.9): Object invariant may not hold.
   invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (43.9): Object invariant may not hold.
   invariant  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (43.9): Object invariant may not hold.
   invariant isShared(Node._state[curr]);                                                           
   invariant isShared(Node._state[pred]);                                                           
   invariant (Node.item[pred]<item);                                                                
   invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state4535114,Node.item4535114,Node.next4535114,Node._lock4535114,OptimisticList._state4535114,OptimisticList.head4535114,OptimisticList._lock4535114));       // (43.9): Loop does not preserve yields_as annotation for field item
   invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state4535114,Node.item4535114,Node.next4535114,Node._lock4535114,OptimisticList._state4535114,OptimisticList.head4535114,OptimisticList._lock4535114));       // (43.9): Loop does not preserve yields_as annotation for field next
   invariant (forall _this : OptimisticList :: Invariant.Y_OptimisticList.head(tid : Tid, _this, OptimisticList.head[_this] ,Node._state4535114,Node.item4535114,Node.next4535114,Node._lock4535114,OptimisticList._state4535114,OptimisticList.head4535114,OptimisticList._lock4535114));       // (43.9): Loop does not preserve yields_as annotation for field head
   invariant phase4535114 == $pc;                                                                          // (43.9): Phase must be invariant at loop head
   invariant $pc == PreCommit;                                                                             // (43.9): Potentially infinite loop cannot be in post-commit phase.
  {                                                                                                 
                                                                                                    
   // 43.26: boolean tmp8;                                                                          
                                                                                                    
                                                                                                    
   // 43.16: int tmp9;                                                                              
                                                                                                    
                                                                                                    
   // 43.16: tmp9 := curr.item;                                                                     
                                                                                                    
                                                                                                    
   moverPath4535093 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535093 := m#moverPath(moverPath4535093);                                                   
   path4535093 := p#moverPath(moverPath4535093);                                                    
   assume Node._state4535093 == Node._state && Node.item4535093 == Node.item && Node.next4535093 == Node.next && Node._lock4535093 == Node._lock && OptimisticList._state4535093 == OptimisticList._state && OptimisticList.head4535093 == OptimisticList.head && OptimisticList._lock4535093 == OptimisticList._lock && tmp94535093 == tmp9 && tmp84535093 == tmp8 && curr4535093 == curr && pred4535093 == pred && tmp74535093 == tmp7 && $result4535093 == $result && item4535093 == item && this4535093 == this && tid4535093 == tid && $pc4535093 == $pc;
   assume $recorded.state4535093 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume curr != Node.null;                                                                       
   } else {                                                                                         
    assert curr != Node.null;                                                                              // (43.16): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535093);                                                            
   assert $pc != PhaseError;                                                                               // (43.16): Reduction failure
   tmp9 := Node.item[curr];                                                                         
                                                                                                    
   // 43.26: tmp8 = tmp9 < item;                                                                    
                                                                                                    
   tmp8 := (tmp9<item);                                                                             
   if (!(tmp8)) {                                                                                   
                                                                                                    
    // 43.9: break;                                                                                 
                                                                                                    
    break;                                                                                          
   } else {                                                                                         
   }                                                                                                
                                                                                                    
   // 48.11: pred = curr;                                                                           
                                                                                                    
   pred := curr;                                                                                    
                                                                                                    
   // 49.11: yield;                                                                                 
                                                                                                    
   assume Node._state4535107 == Node._state && Node.item4535107 == Node.item && Node.next4535107 == Node.next && Node._lock4535107 == Node._lock && OptimisticList._state4535107 == OptimisticList._state && OptimisticList.head4535107 == OptimisticList.head && OptimisticList._lock4535107 == OptimisticList._lock && tmp94535107 == tmp9 && tmp84535107 == tmp8 && curr4535107 == curr && pred4535107 == pred && tmp74535107 == tmp7 && $result4535107 == $result && item4535107 == item && this4535107 == this && tid4535107 == tid;
   assume $recorded.state4535107 == 1;                                                              
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (49.11): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (49.11): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (49.11): Object invariant may not hold.
   assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (49.11): Object invariant may not hold.
   call Yield(tid);                                                                                 
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (49.11): Object invariant may not hold.
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (49.11): Object invariant may not hold.
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (49.11): Object invariant may not hold.
   assume  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (49.11): Object invariant may not hold.
   $pc := PreCommit;                                                                                
   assume Node._state4535107_post == Node._state && Node.item4535107_post == Node.item && Node.next4535107_post == Node.next && Node._lock4535107_post == Node._lock && OptimisticList._state4535107_post == OptimisticList._state && OptimisticList.head4535107_post == OptimisticList.head && OptimisticList._lock4535107_post == OptimisticList._lock && tmp94535107_post == tmp9 && tmp84535107_post == tmp8 && curr4535107_post == curr && pred4535107_post == pred && tmp74535107_post == tmp7 && $result4535107_post == $result && item4535107_post == item && this4535107_post == this && tid4535107_post == tid;
   assume $recorded.state4535107_post == 1;                                                         
                                                                                                    
   // 50.11: curr := curr.next;                                                                     
                                                                                                    
                                                                                                    
   moverPath4535110 := ReadEval.Node.next(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535110 := m#moverPath(moverPath4535110);                                                   
   path4535110 := p#moverPath(moverPath4535110);                                                    
   assume Node._state4535110 == Node._state && Node.item4535110 == Node.item && Node.next4535110 == Node.next && Node._lock4535110 == Node._lock && OptimisticList._state4535110 == OptimisticList._state && OptimisticList.head4535110 == OptimisticList.head && OptimisticList._lock4535110 == OptimisticList._lock && tmp94535110 == tmp9 && tmp84535110 == tmp8 && curr4535110 == curr && pred4535110 == pred && tmp74535110 == tmp7 && $result4535110 == $result && item4535110 == item && this4535110 == this && tid4535110 == tid && $pc4535110 == $pc;
   assume $recorded.state4535110 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume curr != Node.null;                                                                       
   } else {                                                                                         
    assert curr != Node.null;                                                                              // (50.11): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535110);                                                            
   assert $pc != PhaseError;                                                                               // (50.11): Reduction failure
   curr := Node.next[curr];                                                                         
                                                                                                    
   // 51.11: yield;                                                                                 
                                                                                                    
   assume Node._state4535111 == Node._state && Node.item4535111 == Node.item && Node.next4535111 == Node.next && Node._lock4535111 == Node._lock && OptimisticList._state4535111 == OptimisticList._state && OptimisticList.head4535111 == OptimisticList.head && OptimisticList._lock4535111 == OptimisticList._lock && tmp94535111 == tmp9 && tmp84535111 == tmp8 && curr4535111 == curr && pred4535111 == pred && tmp74535111 == tmp7 && $result4535111 == $result && item4535111 == item && this4535111 == this && tid4535111 == tid;
   assume $recorded.state4535111 == 1;                                                              
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (51.11): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (51.11): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (51.11): Object invariant may not hold.
   assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (51.11): Object invariant may not hold.
   call Yield(tid);                                                                                 
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (51.11): Object invariant may not hold.
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (51.11): Object invariant may not hold.
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (51.11): Object invariant may not hold.
   assume  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (51.11): Object invariant may not hold.
   $pc := PreCommit;                                                                                
   assume Node._state4535111_post == Node._state && Node.item4535111_post == Node.item && Node.next4535111_post == Node.next && Node._lock4535111_post == Node._lock && OptimisticList._state4535111_post == OptimisticList._state && OptimisticList.head4535111_post == OptimisticList.head && OptimisticList._lock4535111_post == OptimisticList._lock && tmp94535111_post == tmp9 && tmp84535111_post == tmp8 && curr4535111_post == curr && pred4535111_post == pred && tmp74535111_post == tmp7 && $result4535111_post == $result && item4535111_post == item && this4535111_post == this && tid4535111_post == tid;
   assume $recorded.state4535111_post == 1;                                                         
   assume Node._state4535114_bottom == Node._state && Node.item4535114_bottom == Node.item && Node.next4535114_bottom == Node.next && Node._lock4535114_bottom == Node._lock && OptimisticList._state4535114_bottom == OptimisticList._state && OptimisticList.head4535114_bottom == OptimisticList.head && OptimisticList._lock4535114_bottom == OptimisticList._lock && curr4535114_bottom == curr && pred4535114_bottom == pred && tmp74535114_bottom == tmp7 && $result4535114_bottom == $result && item4535114_bottom == item && this4535114_bottom == this && tid4535114_bottom == tid;
   assume $recorded.state4535114_bottom == 1;                                                       
   assert phase4535114 == $pc;                                                                             // (43.9): Phase must be invariant at loop head
  }                                                                                                 
                                                                                                    
  // 53.10: boolean tmp10;                                                                          
                                                                                                    
                                                                                                    
  // 53.10: int tmp11;                                                                              
                                                                                                    
                                                                                                    
  // 53.10: tmp11 := pred.item;                                                                     
                                                                                                    
                                                                                                    
  moverPath4535123 := ReadEval.Node.item(tid: Tid,pred: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
  mover4535123 := m#moverPath(moverPath4535123);                                                    
  path4535123 := p#moverPath(moverPath4535123);                                                     
  assume Node._state4535123 == Node._state && Node.item4535123 == Node.item && Node.next4535123 == Node.next && Node._lock4535123 == Node._lock && OptimisticList._state4535123 == OptimisticList._state && OptimisticList.head4535123 == OptimisticList.head && OptimisticList._lock4535123 == OptimisticList._lock && tmp114535123 == tmp11 && tmp104535123 == tmp10 && curr4535123 == curr && pred4535123 == pred && tmp74535123 == tmp7 && $result4535123 == $result && item4535123 == item && this4535123 == this && tid4535123 == tid && $pc4535123 == $pc;
  assume $recorded.state4535123 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume pred != Node.null;                                                                        
  } else {                                                                                          
   assert pred != Node.null;                                                                               // (53.10): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4535123);                                                             
  assert $pc != PhaseError;                                                                                // (53.10): Reduction failure
  tmp11 := Node.item[pred];                                                                         
                                                                                                    
  // 53.10: tmp10 = tmp11 < item;                                                                   
                                                                                                    
  tmp10 := (tmp11<item);                                                                            
                                                                                                    
  // 53.10: assert tmp10 /* == pred.item < item */;                                                 
                                                                                                    
  assume Node._state4535137 == Node._state && Node.item4535137 == Node.item && Node.next4535137 == Node.next && Node._lock4535137 == Node._lock && OptimisticList._state4535137 == OptimisticList._state && OptimisticList.head4535137 == OptimisticList.head && OptimisticList._lock4535137 == OptimisticList._lock && tmp114535137 == tmp11 && tmp104535137 == tmp10 && curr4535137 == curr && pred4535137 == pred && tmp74535137 == tmp7 && $result4535137 == $result && item4535137 == item && this4535137 == this && tid4535137 == tid;
  assume $recorded.state4535137 == 1;                                                               
  assert tmp10 /* lowered (Node.item[pred]<item) */;                                                       // (53.10): This assertion may not hold.
                                                                                                    
  // 54.9: yield;                                                                                   
                                                                                                    
  assume Node._state4535138 == Node._state && Node.item4535138 == Node.item && Node.next4535138 == Node.next && Node._lock4535138 == Node._lock && OptimisticList._state4535138 == OptimisticList._state && OptimisticList.head4535138 == OptimisticList.head && OptimisticList._lock4535138 == OptimisticList._lock && tmp114535138 == tmp11 && tmp104535138 == tmp10 && curr4535138 == curr && pred4535138 == pred && tmp74535138 == tmp7 && $result4535138 == $result && item4535138 == item && this4535138 == this && tid4535138 == tid;
  assume $recorded.state4535138 == 1;                                                               
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (54.9): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (54.9): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (54.9): Object invariant may not hold.
  assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (54.9): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (54.9): Object invariant may not hold.
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (54.9): Object invariant may not hold.
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (54.9): Object invariant may not hold.
  assume  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (54.9): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Node._state4535138_post == Node._state && Node.item4535138_post == Node.item && Node.next4535138_post == Node.next && Node._lock4535138_post == Node._lock && OptimisticList._state4535138_post == OptimisticList._state && OptimisticList.head4535138_post == OptimisticList.head && OptimisticList._lock4535138_post == OptimisticList._lock && tmp114535138_post == tmp11 && tmp104535138_post == tmp10 && curr4535138_post == curr && pred4535138_post == pred && tmp74535138_post == tmp7 && $result4535138_post == $result && item4535138_post == item && this4535138_post == this && tid4535138_post == tid;
  assume $recorded.state4535138_post == 1;                                                          
                                                                                                    
  // 55.10: boolean tmp12;                                                                          
                                                                                                    
                                                                                                    
  // 55.10: int tmp13;                                                                              
                                                                                                    
                                                                                                    
  // 55.10: tmp13 := pred.item;                                                                     
                                                                                                    
                                                                                                    
  moverPath4535147 := ReadEval.Node.item(tid: Tid,pred: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
  mover4535147 := m#moverPath(moverPath4535147);                                                    
  path4535147 := p#moverPath(moverPath4535147);                                                     
  assume Node._state4535147 == Node._state && Node.item4535147 == Node.item && Node.next4535147 == Node.next && Node._lock4535147 == Node._lock && OptimisticList._state4535147 == OptimisticList._state && OptimisticList.head4535147 == OptimisticList.head && OptimisticList._lock4535147 == OptimisticList._lock && tmp134535147 == tmp13 && tmp124535147 == tmp12 && tmp114535147 == tmp11 && tmp104535147 == tmp10 && curr4535147 == curr && pred4535147 == pred && tmp74535147 == tmp7 && $result4535147 == $result && item4535147 == item && this4535147 == this && tid4535147 == tid && $pc4535147 == $pc;
  assume $recorded.state4535147 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume pred != Node.null;                                                                        
  } else {                                                                                          
   assert pred != Node.null;                                                                               // (55.10): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4535147);                                                             
  assert $pc != PhaseError;                                                                                // (55.10): Reduction failure
  tmp13 := Node.item[pred];                                                                         
                                                                                                    
  // 55.10: tmp12 = tmp13 < item;                                                                   
                                                                                                    
  tmp12 := (tmp13<item);                                                                            
                                                                                                    
  // 55.10: assert tmp12 /* == pred.item < item */;                                                 
                                                                                                    
  assume Node._state4535161 == Node._state && Node.item4535161 == Node.item && Node.next4535161 == Node.next && Node._lock4535161 == Node._lock && OptimisticList._state4535161 == OptimisticList._state && OptimisticList.head4535161 == OptimisticList.head && OptimisticList._lock4535161 == OptimisticList._lock && tmp134535161 == tmp13 && tmp124535161 == tmp12 && tmp114535161 == tmp11 && tmp104535161 == tmp10 && curr4535161 == curr && pred4535161 == pred && tmp74535161 == tmp7 && $result4535161 == $result && item4535161 == item && this4535161 == this && tid4535161 == tid;
  assume $recorded.state4535161 == 1;                                                               
  assert tmp12 /* lowered (Node.item[pred]<item) */;                                                       // (55.10): This assertion may not hold.
  if ($pc == PreCommit) {                                                                           
   assume pred != Node.null;                                                                        
  } else {                                                                                          
   assert pred != Node.null;                                                                               // (56.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assume Node._lock[pred] == Tid.null;                                                              
  $pc := transition($pc, _R);                                                                       
  assert $pc != PhaseError;                                                                                // (56.9): Reduction failure
  Node._lock[pred] := tid;                                                                          
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (57.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assume Node._lock[curr] == Tid.null;                                                              
  $pc := transition($pc, _R);                                                                       
  assert $pc != PhaseError;                                                                                // (57.9): Reduction failure
  Node._lock[curr] := tid;                                                                          
                                                                                                    
  // 58.10: boolean tmp14;                                                                          
                                                                                                    
                                                                                                    
  // 58.10: int tmp15;                                                                              
                                                                                                    
                                                                                                    
  // 58.10: tmp15 := pred.item;                                                                     
                                                                                                    
                                                                                                    
  moverPath4535174 := ReadEval.Node.item(tid: Tid,pred: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
  mover4535174 := m#moverPath(moverPath4535174);                                                    
  path4535174 := p#moverPath(moverPath4535174);                                                     
  assume Node._state4535174 == Node._state && Node.item4535174 == Node.item && Node.next4535174 == Node.next && Node._lock4535174 == Node._lock && OptimisticList._state4535174 == OptimisticList._state && OptimisticList.head4535174 == OptimisticList.head && OptimisticList._lock4535174 == OptimisticList._lock && tmp154535174 == tmp15 && tmp144535174 == tmp14 && tmp134535174 == tmp13 && tmp124535174 == tmp12 && tmp114535174 == tmp11 && tmp104535174 == tmp10 && curr4535174 == curr && pred4535174 == pred && tmp74535174 == tmp7 && $result4535174 == $result && item4535174 == item && this4535174 == this && tid4535174 == tid && $pc4535174 == $pc;
  assume $recorded.state4535174 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume pred != Node.null;                                                                        
  } else {                                                                                          
   assert pred != Node.null;                                                                               // (58.10): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4535174);                                                             
  assert $pc != PhaseError;                                                                                // (58.10): Reduction failure
  tmp15 := Node.item[pred];                                                                         
                                                                                                    
  // 58.10: tmp14 = tmp15 < item;                                                                   
                                                                                                    
  tmp14 := (tmp15<item);                                                                            
                                                                                                    
  // 58.10: assert tmp14 /* == pred.item < item */;                                                 
                                                                                                    
  assume Node._state4535188 == Node._state && Node.item4535188 == Node.item && Node.next4535188 == Node.next && Node._lock4535188 == Node._lock && OptimisticList._state4535188 == OptimisticList._state && OptimisticList.head4535188 == OptimisticList.head && OptimisticList._lock4535188 == OptimisticList._lock && tmp154535188 == tmp15 && tmp144535188 == tmp14 && tmp134535188 == tmp13 && tmp124535188 == tmp12 && tmp114535188 == tmp11 && tmp104535188 == tmp10 && curr4535188 == curr && pred4535188 == pred && tmp74535188 == tmp7 && $result4535188 == $result && item4535188 == item && this4535188 == this && tid4535188 == tid;
  assume $recorded.state4535188 == 1;                                                               
  assert tmp14 /* lowered (Node.item[pred]<item) */;                                                       // (58.10): This assertion may not hold.
                                                                                                    
  // 59.10: boolean tmp16;                                                                          
                                                                                                    
                                                                                                    
  // 59.10: int tmp17;                                                                              
                                                                                                    
                                                                                                    
  // 59.10: tmp17 := curr.item;                                                                     
                                                                                                    
                                                                                                    
  moverPath4535197 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
  mover4535197 := m#moverPath(moverPath4535197);                                                    
  path4535197 := p#moverPath(moverPath4535197);                                                     
  assume Node._state4535197 == Node._state && Node.item4535197 == Node.item && Node.next4535197 == Node.next && Node._lock4535197 == Node._lock && OptimisticList._state4535197 == OptimisticList._state && OptimisticList.head4535197 == OptimisticList.head && OptimisticList._lock4535197 == OptimisticList._lock && tmp174535197 == tmp17 && tmp164535197 == tmp16 && tmp154535197 == tmp15 && tmp144535197 == tmp14 && tmp134535197 == tmp13 && tmp124535197 == tmp12 && tmp114535197 == tmp11 && tmp104535197 == tmp10 && curr4535197 == curr && pred4535197 == pred && tmp74535197 == tmp7 && $result4535197 == $result && item4535197 == item && this4535197 == this && tid4535197 == tid && $pc4535197 == $pc;
  assume $recorded.state4535197 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (59.10): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4535197);                                                             
  assert $pc != PhaseError;                                                                                // (59.10): Reduction failure
  tmp17 := Node.item[curr];                                                                         
                                                                                                    
  // 59.10: tmp16 = tmp17 >= item;                                                                  
                                                                                                    
  tmp16 := (tmp17>=item);                                                                           
                                                                                                    
  // 59.10: assert tmp16 /* == curr.item >= item */;                                                
                                                                                                    
  assume Node._state4535211 == Node._state && Node.item4535211 == Node.item && Node.next4535211 == Node.next && Node._lock4535211 == Node._lock && OptimisticList._state4535211 == OptimisticList._state && OptimisticList.head4535211 == OptimisticList.head && OptimisticList._lock4535211 == OptimisticList._lock && tmp174535211 == tmp17 && tmp164535211 == tmp16 && tmp154535211 == tmp15 && tmp144535211 == tmp14 && tmp134535211 == tmp13 && tmp124535211 == tmp12 && tmp114535211 == tmp11 && tmp104535211 == tmp10 && curr4535211 == curr && pred4535211 == pred && tmp74535211 == tmp7 && $result4535211 == $result && item4535211 == item && this4535211 == this && tid4535211 == tid;
  assume $recorded.state4535211 == 1;                                                               
  assert tmp16 /* lowered (Node.item[curr]>=item) */;                                                      // (59.10): This assertion may not hold.
                                                                                                    
  // 61.8: boolean tmp18;                                                                           
                                                                                                    
  // inlined: this.validate(pred,curr,item)}                                                        
  exit$256_top:                                                                                     
                                                                                                    
  // 61.8: Node pred$256;                                                                           
                                                                                                    
                                                                                                    
  // 61.8: Node curr$256;                                                                           
                                                                                                    
                                                                                                    
  // 61.8: int item$256;                                                                            
                                                                                                    
                                                                                                    
  // 61.8: OptimisticList this$256;                                                                 
                                                                                                    
                                                                                                    
  // 61.8: pred$256 = pred;                                                                         
                                                                                                    
  pred$256 := pred;                                                                                 
                                                                                                    
  // 61.8: curr$256 = curr;                                                                         
                                                                                                    
  curr$256 := curr;                                                                                 
                                                                                                    
  // 61.8: item$256 = item;                                                                         
                                                                                                    
  item$256 := item;                                                                                 
                                                                                                    
  // 61.8: this$256 = this;                                                                         
                                                                                                    
  this$256 := this;                                                                                 
                                                                                                    
  // 17.9: Node node$256;                                                                           
                                                                                                    
                                                                                                    
  // 17.9: node$256 := this$256.head;                                                               
                                                                                                    
                                                                                                    
  moverPath4535242 := ReadEval.OptimisticList.head(tid: Tid,this$256: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
  mover4535242 := m#moverPath(moverPath4535242);                                                    
  path4535242 := p#moverPath(moverPath4535242);                                                     
  assume Node._state4535242 == Node._state && Node.item4535242 == Node.item && Node.next4535242 == Node.next && Node._lock4535242 == Node._lock && OptimisticList._state4535242 == OptimisticList._state && OptimisticList.head4535242 == OptimisticList.head && OptimisticList._lock4535242 == OptimisticList._lock && node$2564535242 == node$256 && this$2564535242 == this$256 && item$2564535242 == item$256 && curr$2564535242 == curr$256 && pred$2564535242 == pred$256 && tmp184535242 == tmp18 && tmp174535242 == tmp17 && tmp164535242 == tmp16 && tmp154535242 == tmp15 && tmp144535242 == tmp14 && tmp134535242 == tmp13 && tmp124535242 == tmp12 && tmp114535242 == tmp11 && tmp104535242 == tmp10 && curr4535242 == curr && pred4535242 == pred && tmp74535242 == tmp7 && $result4535242 == $result && item4535242 == item && this4535242 == this && tid4535242 == tid && $pc4535242 == $pc;
  assume $recorded.state4535242 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this$256 != OptimisticList.null;                                                          
  } else {                                                                                          
   assert this$256 != OptimisticList.null;                                                                 // (17.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4535242);                                                             
  assert $pc != PhaseError;                                                                                // (17.9): Reduction failure
  node$256 := OptimisticList.head[this$256];                                                        
                                                                                                    
  // 18.9: yield;                                                                                   
                                                                                                    
  assume Node._state4535243 == Node._state && Node.item4535243 == Node.item && Node.next4535243 == Node.next && Node._lock4535243 == Node._lock && OptimisticList._state4535243 == OptimisticList._state && OptimisticList.head4535243 == OptimisticList.head && OptimisticList._lock4535243 == OptimisticList._lock && node$2564535243 == node$256 && this$2564535243 == this$256 && item$2564535243 == item$256 && curr$2564535243 == curr$256 && pred$2564535243 == pred$256 && tmp184535243 == tmp18 && tmp174535243 == tmp17 && tmp164535243 == tmp16 && tmp154535243 == tmp15 && tmp144535243 == tmp14 && tmp134535243 == tmp13 && tmp124535243 == tmp12 && tmp114535243 == tmp11 && tmp104535243 == tmp10 && curr4535243 == curr && pred4535243 == pred && tmp74535243 == tmp7 && $result4535243 == $result && item4535243 == item && this4535243 == this && tid4535243 == tid;
  assume $recorded.state4535243 == 1;                                                               
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  assume  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Node._state4535243_post == Node._state && Node.item4535243_post == Node.item && Node.next4535243_post == Node.next && Node._lock4535243_post == Node._lock && OptimisticList._state4535243_post == OptimisticList._state && OptimisticList.head4535243_post == OptimisticList.head && OptimisticList._lock4535243_post == OptimisticList._lock && node$2564535243_post == node$256 && this$2564535243_post == this$256 && item$2564535243_post == item$256 && curr$2564535243_post == curr$256 && pred$2564535243_post == pred$256 && tmp184535243_post == tmp18 && tmp174535243_post == tmp17 && tmp164535243_post == tmp16 && tmp154535243_post == tmp15 && tmp144535243_post == tmp14 && tmp134535243_post == tmp13 && tmp124535243_post == tmp12 && tmp114535243_post == tmp11 && tmp104535243_post == tmp10 && curr4535243_post == curr && pred4535243_post == pred && tmp74535243_post == tmp7 && $result4535243_post == $result && item4535243_post == item && this4535243_post == this && tid4535243_post == tid;
  assume $recorded.state4535243_post == 1;                                                          
  assume Node._state4535340 == Node._state && Node.item4535340 == Node.item && Node.next4535340 == Node.next && Node._lock4535340 == Node._lock && OptimisticList._state4535340 == OptimisticList._state && OptimisticList.head4535340 == OptimisticList.head && OptimisticList._lock4535340 == OptimisticList._lock && node$2564535340 == node$256 && this$2564535340 == this$256 && item$2564535340 == item$256 && curr$2564535340 == curr$256 && pred$2564535340 == pred$256 && tmp184535340 == tmp18 && tmp174535340 == tmp17 && tmp164535340 == tmp16 && tmp154535340 == tmp15 && tmp144535340 == tmp14 && tmp134535340 == tmp13 && tmp124535340 == tmp12 && tmp114535340 == tmp11 && tmp104535340 == tmp10 && curr4535340 == curr && pred4535340 == pred && tmp74535340 == tmp7 && $result4535340 == $result && item4535340 == item && this4535340 == this && tid4535340 == tid;
  assume $recorded.state4535340 == 1;                                                               
                                                                                                    
  // 19.9: while (true)                                                                             
                                                                                                    
  phase4535340 := $pc;                                                                              
  while (true)                                                                                      
                                                                                                    
   invariant ValidTid(tid);                                                                                // (37.5): Bad tid
   invariant isShared(OptimisticList._state[this]);                                                        // (37.5): this is not global
                                                                                                    
   invariant StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
   invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (19.9): Object invariant may not hold.
   invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (19.9): Object invariant may not hold.
   invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (19.9): Object invariant may not hold.
   invariant  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (19.9): Object invariant may not hold.
   invariant isShared(Node._state[node$256]);                                                       
   invariant isShared(Node._state[curr$256]);                                                       
   invariant isShared(Node._state[pred$256]);                                                       
   invariant (isAccessible(Node._state[curr$256], tid) && Node._lock[curr$256] == tid);             
   invariant (isAccessible(Node._state[pred$256], tid) && Node._lock[pred$256] == tid);             
   invariant (Node.item[pred$256]<item$256);                                                        
   invariant (Node.item[curr$256]>=item$256);                                                       
   invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state4535340,Node.item4535340,Node.next4535340,Node._lock4535340,OptimisticList._state4535340,OptimisticList.head4535340,OptimisticList._lock4535340));       // (19.9): Loop does not preserve yields_as annotation for field item
   invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state4535340,Node.item4535340,Node.next4535340,Node._lock4535340,OptimisticList._state4535340,OptimisticList.head4535340,OptimisticList._lock4535340));       // (19.9): Loop does not preserve yields_as annotation for field next
   invariant (forall _this : OptimisticList :: Invariant.Y_OptimisticList.head(tid : Tid, _this, OptimisticList.head[_this] ,Node._state4535340,Node.item4535340,Node.next4535340,Node._lock4535340,OptimisticList._state4535340,OptimisticList.head4535340,OptimisticList._lock4535340));       // (19.9): Loop does not preserve yields_as annotation for field head
   invariant phase4535340 == $pc;                                                                          // (19.9): Phase must be invariant at loop head
   invariant $pc == PreCommit;                                                                             // (19.9): Potentially infinite loop cannot be in post-commit phase.
  {                                                                                                 
                                                                                                    
   // 19.26: boolean tmp1$256;                                                                      
                                                                                                    
                                                                                                    
   // 19.16: int tmp2$256;                                                                          
                                                                                                    
                                                                                                    
   // 19.16: tmp2$256 := node$256.item;                                                             
                                                                                                    
                                                                                                    
   moverPath4535254 := ReadEval.Node.item(tid: Tid,node$256: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535254 := m#moverPath(moverPath4535254);                                                   
   path4535254 := p#moverPath(moverPath4535254);                                                    
   assume Node._state4535254 == Node._state && Node.item4535254 == Node.item && Node.next4535254 == Node.next && Node._lock4535254 == Node._lock && OptimisticList._state4535254 == OptimisticList._state && OptimisticList.head4535254 == OptimisticList.head && OptimisticList._lock4535254 == OptimisticList._lock && tmp2$2564535254 == tmp2$256 && tmp1$2564535254 == tmp1$256 && node$2564535254 == node$256 && this$2564535254 == this$256 && item$2564535254 == item$256 && curr$2564535254 == curr$256 && pred$2564535254 == pred$256 && tmp184535254 == tmp18 && tmp174535254 == tmp17 && tmp164535254 == tmp16 && tmp154535254 == tmp15 && tmp144535254 == tmp14 && tmp134535254 == tmp13 && tmp124535254 == tmp12 && tmp114535254 == tmp11 && tmp104535254 == tmp10 && curr4535254 == curr && pred4535254 == pred && tmp74535254 == tmp7 && $result4535254 == $result && item4535254 == item && this4535254 == this && tid4535254 == tid && $pc4535254 == $pc;
   assume $recorded.state4535254 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume node$256 != Node.null;                                                                   
   } else {                                                                                         
    assert node$256 != Node.null;                                                                          // (19.16): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535254);                                                            
   assert $pc != PhaseError;                                                                               // (19.16): Reduction failure
   tmp2$256 := Node.item[node$256];                                                                 
                                                                                                    
   // 19.29: int tmp3$256;                                                                          
                                                                                                    
                                                                                                    
   // 19.29: tmp3$256 := pred$256.item;                                                             
                                                                                                    
                                                                                                    
   moverPath4535260 := ReadEval.Node.item(tid: Tid,pred$256: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535260 := m#moverPath(moverPath4535260);                                                   
   path4535260 := p#moverPath(moverPath4535260);                                                    
   assume Node._state4535260 == Node._state && Node.item4535260 == Node.item && Node.next4535260 == Node.next && Node._lock4535260 == Node._lock && OptimisticList._state4535260 == OptimisticList._state && OptimisticList.head4535260 == OptimisticList.head && OptimisticList._lock4535260 == OptimisticList._lock && tmp3$2564535260 == tmp3$256 && tmp2$2564535260 == tmp2$256 && tmp1$2564535260 == tmp1$256 && node$2564535260 == node$256 && this$2564535260 == this$256 && item$2564535260 == item$256 && curr$2564535260 == curr$256 && pred$2564535260 == pred$256 && tmp184535260 == tmp18 && tmp174535260 == tmp17 && tmp164535260 == tmp16 && tmp154535260 == tmp15 && tmp144535260 == tmp14 && tmp134535260 == tmp13 && tmp124535260 == tmp12 && tmp114535260 == tmp11 && tmp104535260 == tmp10 && curr4535260 == curr && pred4535260 == pred && tmp74535260 == tmp7 && $result4535260 == $result && item4535260 == item && this4535260 == this && tid4535260 == tid && $pc4535260 == $pc;
   assume $recorded.state4535260 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume pred$256 != Node.null;                                                                   
   } else {                                                                                         
    assert pred$256 != Node.null;                                                                          // (19.29): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535260);                                                            
   assert $pc != PhaseError;                                                                               // (19.29): Reduction failure
   tmp3$256 := Node.item[pred$256];                                                                 
                                                                                                    
   // 19.26: tmp1$256 = tmp2$256 <= tmp3$256;                                                       
                                                                                                    
   tmp1$256 := (tmp2$256<=tmp3$256);                                                                
   if (!(tmp1$256)) {                                                                               
                                                                                                    
    // 19.9: break;                                                                                 
                                                                                                    
    break;                                                                                          
   } else {                                                                                         
   }                                                                                                
                                                                                                    
   // 28.11: boolean tmp4$256;                                                                      
                                                                                                    
                                                                                                    
   // 28.11: tmp4$256 = node$256 == pred$256;                                                       
                                                                                                    
   tmp4$256 := (node$256==pred$256);                                                                
   if (tmp4$256 /* lowered (node$256==pred$256) */) {                                               
                                                                                                    
    // 29.13: boolean tmp5$256;                                                                     
                                                                                                    
                                                                                                    
    // 29.13: Node tmp6$256;                                                                        
                                                                                                    
                                                                                                    
    // 29.13: tmp6$256 := pred$256.next;                                                            
                                                                                                    
                                                                                                    
    moverPath4535297 := ReadEval.Node.next(tid: Tid,pred$256: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
    mover4535297 := m#moverPath(moverPath4535297);                                                  
    path4535297 := p#moverPath(moverPath4535297);                                                   
    assume Node._state4535297 == Node._state && Node.item4535297 == Node.item && Node.next4535297 == Node.next && Node._lock4535297 == Node._lock && OptimisticList._state4535297 == OptimisticList._state && OptimisticList.head4535297 == OptimisticList.head && OptimisticList._lock4535297 == OptimisticList._lock && tmp6$2564535297 == tmp6$256 && tmp5$2564535297 == tmp5$256 && tmp4$2564535297 == tmp4$256 && tmp3$2564535297 == tmp3$256 && tmp2$2564535297 == tmp2$256 && tmp1$2564535297 == tmp1$256 && node$2564535297 == node$256 && this$2564535297 == this$256 && item$2564535297 == item$256 && curr$2564535297 == curr$256 && pred$2564535297 == pred$256 && tmp184535297 == tmp18 && tmp174535297 == tmp17 && tmp164535297 == tmp16 && tmp154535297 == tmp15 && tmp144535297 == tmp14 && tmp134535297 == tmp13 && tmp124535297 == tmp12 && tmp114535297 == tmp11 && tmp104535297 == tmp10 && curr4535297 == curr && pred4535297 == pred && tmp74535297 == tmp7 && $result4535297 == $result && item4535297 == item && this4535297 == this && tid4535297 == tid && $pc4535297 == $pc;
    assume $recorded.state4535297 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume pred$256 != Node.null;                                                                  
    } else {                                                                                        
     assert pred$256 != Node.null;                                                                         // (29.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
                                                                                                    
    $pc := transition($pc, mover4535297);                                                           
    assert $pc != PhaseError;                                                                              // (29.13): Reduction failure
    tmp6$256 := Node.next[pred$256];                                                                
                                                                                                    
    // 29.13: tmp5$256 = tmp6$256 == curr$256;                                                      
                                                                                                    
    tmp5$256 := (tmp6$256==curr$256);                                                               
                                                                                                    
    // 29.13: tmp18 = tmp5$256;                                                                     
                                                                                                    
    tmp18 := tmp5$256;                                                                              
                                                                                                    
    // 29.13: break exit$256;                                                                       
                                                                                                    
    goto exit$256_bottom;                                                                           
   } else {                                                                                         
   }                                                                                                
                                                                                                    
   // 31.11: node$256 := node$256.next;                                                             
                                                                                                    
                                                                                                    
   moverPath4535314 := ReadEval.Node.next(tid: Tid,node$256: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535314 := m#moverPath(moverPath4535314);                                                   
   path4535314 := p#moverPath(moverPath4535314);                                                    
   assume Node._state4535314 == Node._state && Node.item4535314 == Node.item && Node.next4535314 == Node.next && Node._lock4535314 == Node._lock && OptimisticList._state4535314 == OptimisticList._state && OptimisticList.head4535314 == OptimisticList.head && OptimisticList._lock4535314 == OptimisticList._lock && tmp4$2564535314 == tmp4$256 && tmp3$2564535314 == tmp3$256 && tmp2$2564535314 == tmp2$256 && tmp1$2564535314 == tmp1$256 && node$2564535314 == node$256 && this$2564535314 == this$256 && item$2564535314 == item$256 && curr$2564535314 == curr$256 && pred$2564535314 == pred$256 && tmp184535314 == tmp18 && tmp174535314 == tmp17 && tmp164535314 == tmp16 && tmp154535314 == tmp15 && tmp144535314 == tmp14 && tmp134535314 == tmp13 && tmp124535314 == tmp12 && tmp114535314 == tmp11 && tmp104535314 == tmp10 && curr4535314 == curr && pred4535314 == pred && tmp74535314 == tmp7 && $result4535314 == $result && item4535314 == item && this4535314 == this && tid4535314 == tid && $pc4535314 == $pc;
   assume $recorded.state4535314 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume node$256 != Node.null;                                                                   
   } else {                                                                                         
    assert node$256 != Node.null;                                                                          // (31.11): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535314);                                                            
   assert $pc != PhaseError;                                                                               // (31.11): Reduction failure
   node$256 := Node.next[node$256];                                                                 
                                                                                                    
   // 32.11: yield;                                                                                 
                                                                                                    
   assume Node._state4535315 == Node._state && Node.item4535315 == Node.item && Node.next4535315 == Node.next && Node._lock4535315 == Node._lock && OptimisticList._state4535315 == OptimisticList._state && OptimisticList.head4535315 == OptimisticList.head && OptimisticList._lock4535315 == OptimisticList._lock && tmp4$2564535315 == tmp4$256 && tmp3$2564535315 == tmp3$256 && tmp2$2564535315 == tmp2$256 && tmp1$2564535315 == tmp1$256 && node$2564535315 == node$256 && this$2564535315 == this$256 && item$2564535315 == item$256 && curr$2564535315 == curr$256 && pred$2564535315 == pred$256 && tmp184535315 == tmp18 && tmp174535315 == tmp17 && tmp164535315 == tmp16 && tmp154535315 == tmp15 && tmp144535315 == tmp14 && tmp134535315 == tmp13 && tmp124535315 == tmp12 && tmp114535315 == tmp11 && tmp104535315 == tmp10 && curr4535315 == curr && pred4535315 == pred && tmp74535315 == tmp7 && $result4535315 == $result && item4535315 == item && this4535315 == this && tid4535315 == tid;
   assume $recorded.state4535315 == 1;                                                              
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   call Yield(tid);                                                                                 
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   assume  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   $pc := PreCommit;                                                                                
   assume Node._state4535315_post == Node._state && Node.item4535315_post == Node.item && Node.next4535315_post == Node.next && Node._lock4535315_post == Node._lock && OptimisticList._state4535315_post == OptimisticList._state && OptimisticList.head4535315_post == OptimisticList.head && OptimisticList._lock4535315_post == OptimisticList._lock && tmp4$2564535315_post == tmp4$256 && tmp3$2564535315_post == tmp3$256 && tmp2$2564535315_post == tmp2$256 && tmp1$2564535315_post == tmp1$256 && node$2564535315_post == node$256 && this$2564535315_post == this$256 && item$2564535315_post == item$256 && curr$2564535315_post == curr$256 && pred$2564535315_post == pred$256 && tmp184535315_post == tmp18 && tmp174535315_post == tmp17 && tmp164535315_post == tmp16 && tmp154535315_post == tmp15 && tmp144535315_post == tmp14 && tmp134535315_post == tmp13 && tmp124535315_post == tmp12 && tmp114535315_post == tmp11 && tmp104535315_post == tmp10 && curr4535315_post == curr && pred4535315_post == pred && tmp74535315_post == tmp7 && $result4535315_post == $result && item4535315_post == item && this4535315_post == this && tid4535315_post == tid;
   assume $recorded.state4535315_post == 1;                                                         
   assume Node._state4535340_bottom == Node._state && Node.item4535340_bottom == Node.item && Node.next4535340_bottom == Node.next && Node._lock4535340_bottom == Node._lock && OptimisticList._state4535340_bottom == OptimisticList._state && OptimisticList.head4535340_bottom == OptimisticList.head && OptimisticList._lock4535340_bottom == OptimisticList._lock && node$2564535340_bottom == node$256 && this$2564535340_bottom == this$256 && item$2564535340_bottom == item$256 && curr$2564535340_bottom == curr$256 && pred$2564535340_bottom == pred$256 && tmp184535340_bottom == tmp18 && tmp174535340_bottom == tmp17 && tmp164535340_bottom == tmp16 && tmp154535340_bottom == tmp15 && tmp144535340_bottom == tmp14 && tmp134535340_bottom == tmp13 && tmp124535340_bottom == tmp12 && tmp114535340_bottom == tmp11 && tmp104535340_bottom == tmp10 && curr4535340_bottom == curr && pred4535340_bottom == pred && tmp74535340_bottom == tmp7 && $result4535340_bottom == $result && item4535340_bottom == item && this4535340_bottom == this && tid4535340_bottom == tid;
   assume $recorded.state4535340_bottom == 1;                                                       
   assert phase4535340 == $pc;                                                                             // (19.9): Phase must be invariant at loop head
  }                                                                                                 
                                                                                                    
  // 34.9: tmp18 = false;                                                                           
                                                                                                    
  tmp18 := false;                                                                                   
                                                                                                    
  // 34.9: break exit$256;                                                                          
                                                                                                    
  goto exit$256_bottom;                                                                             
                                                                                                    
  // 16.54: tmp18 = false;                                                                          
                                                                                                    
  tmp18 := false;                                                                                   
                                                                                                    
  // 16.54: break exit$256;                                                                         
                                                                                                    
  goto exit$256_bottom;                                                                             
  exit$256_bottom:                                                                                  
  if (tmp18) {                                                                                      
                                                                                                    
   // 62.10: Node tmp19;                                                                            
                                                                                                    
                                                                                                    
   // 62.10: tmp19 := pred.next;                                                                    
                                                                                                    
                                                                                                    
   moverPath4535369 := ReadEval.Node.next(tid: Tid,pred: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535369 := m#moverPath(moverPath4535369);                                                   
   path4535369 := p#moverPath(moverPath4535369);                                                    
   assume Node._state4535369 == Node._state && Node.item4535369 == Node.item && Node.next4535369 == Node.next && Node._lock4535369 == Node._lock && OptimisticList._state4535369 == OptimisticList._state && OptimisticList.head4535369 == OptimisticList.head && OptimisticList._lock4535369 == OptimisticList._lock && tmp194535369 == tmp19 && tmp184535369 == tmp18 && tmp174535369 == tmp17 && tmp164535369 == tmp16 && tmp154535369 == tmp15 && tmp144535369 == tmp14 && tmp134535369 == tmp13 && tmp124535369 == tmp12 && tmp114535369 == tmp11 && tmp104535369 == tmp10 && curr4535369 == curr && pred4535369 == pred && tmp74535369 == tmp7 && $result4535369 == $result && item4535369 == item && this4535369 == this && tid4535369 == tid && $pc4535369 == $pc;
   assume $recorded.state4535369 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume pred != Node.null;                                                                       
   } else {                                                                                         
    assert pred != Node.null;                                                                              // (62.10): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535369);                                                            
   assert $pc != PhaseError;                                                                               // (62.10): Reduction failure
   tmp19 := Node.next[pred];                                                                        
                                                                                                    
   // 62.10: assert tmp19 == curr;                                                                  
                                                                                                    
   assume Node._state4535374 == Node._state && Node.item4535374 == Node.item && Node.next4535374 == Node.next && Node._lock4535374 == Node._lock && OptimisticList._state4535374 == OptimisticList._state && OptimisticList.head4535374 == OptimisticList.head && OptimisticList._lock4535374 == OptimisticList._lock && tmp194535374 == tmp19 && tmp184535374 == tmp18 && tmp174535374 == tmp17 && tmp164535374 == tmp16 && tmp154535374 == tmp15 && tmp144535374 == tmp14 && tmp134535374 == tmp13 && tmp124535374 == tmp12 && tmp114535374 == tmp11 && tmp104535374 == tmp10 && curr4535374 == curr && pred4535374 == pred && tmp74535374 == tmp7 && $result4535374 == $result && item4535374 == item && this4535374 == this && tid4535374 == tid;
   assume $recorded.state4535374 == 1;                                                              
   assert (tmp19==curr);                                                                                   // (62.10): This assertion may not hold.
                                                                                                    
   // 63.10: boolean tmp20;                                                                         
                                                                                                    
                                                                                                    
   // 63.10: int tmp21;                                                                             
                                                                                                    
                                                                                                    
   // 63.10: tmp21 := pred.item;                                                                    
                                                                                                    
                                                                                                    
   moverPath4535383 := ReadEval.Node.item(tid: Tid,pred: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535383 := m#moverPath(moverPath4535383);                                                   
   path4535383 := p#moverPath(moverPath4535383);                                                    
   assume Node._state4535383 == Node._state && Node.item4535383 == Node.item && Node.next4535383 == Node.next && Node._lock4535383 == Node._lock && OptimisticList._state4535383 == OptimisticList._state && OptimisticList.head4535383 == OptimisticList.head && OptimisticList._lock4535383 == OptimisticList._lock && tmp214535383 == tmp21 && tmp204535383 == tmp20 && tmp194535383 == tmp19 && tmp184535383 == tmp18 && tmp174535383 == tmp17 && tmp164535383 == tmp16 && tmp154535383 == tmp15 && tmp144535383 == tmp14 && tmp134535383 == tmp13 && tmp124535383 == tmp12 && tmp114535383 == tmp11 && tmp104535383 == tmp10 && curr4535383 == curr && pred4535383 == pred && tmp74535383 == tmp7 && $result4535383 == $result && item4535383 == item && this4535383 == this && tid4535383 == tid && $pc4535383 == $pc;
   assume $recorded.state4535383 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume pred != Node.null;                                                                       
   } else {                                                                                         
    assert pred != Node.null;                                                                              // (63.10): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535383);                                                            
   assert $pc != PhaseError;                                                                               // (63.10): Reduction failure
   tmp21 := Node.item[pred];                                                                        
                                                                                                    
   // 63.10: tmp20 = tmp21 < item;                                                                  
                                                                                                    
   tmp20 := (tmp21<item);                                                                           
                                                                                                    
   // 63.10: assert tmp20 /* == pred.item < item */;                                                
                                                                                                    
   assume Node._state4535397 == Node._state && Node.item4535397 == Node.item && Node.next4535397 == Node.next && Node._lock4535397 == Node._lock && OptimisticList._state4535397 == OptimisticList._state && OptimisticList.head4535397 == OptimisticList.head && OptimisticList._lock4535397 == OptimisticList._lock && tmp214535397 == tmp21 && tmp204535397 == tmp20 && tmp194535397 == tmp19 && tmp184535397 == tmp18 && tmp174535397 == tmp17 && tmp164535397 == tmp16 && tmp154535397 == tmp15 && tmp144535397 == tmp14 && tmp134535397 == tmp13 && tmp124535397 == tmp12 && tmp114535397 == tmp11 && tmp104535397 == tmp10 && curr4535397 == curr && pred4535397 == pred && tmp74535397 == tmp7 && $result4535397 == $result && item4535397 == item && this4535397 == this && tid4535397 == tid;
   assume $recorded.state4535397 == 1;                                                              
   assert tmp20 /* lowered (Node.item[pred]<item) */;                                                      // (63.10): This assertion may not hold.
                                                                                                    
   // 64.10: boolean tmp22;                                                                         
                                                                                                    
                                                                                                    
   // 64.10: int tmp23;                                                                             
                                                                                                    
                                                                                                    
   // 64.10: tmp23 := curr.item;                                                                    
                                                                                                    
                                                                                                    
   moverPath4535406 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535406 := m#moverPath(moverPath4535406);                                                   
   path4535406 := p#moverPath(moverPath4535406);                                                    
   assume Node._state4535406 == Node._state && Node.item4535406 == Node.item && Node.next4535406 == Node.next && Node._lock4535406 == Node._lock && OptimisticList._state4535406 == OptimisticList._state && OptimisticList.head4535406 == OptimisticList.head && OptimisticList._lock4535406 == OptimisticList._lock && tmp234535406 == tmp23 && tmp224535406 == tmp22 && tmp214535406 == tmp21 && tmp204535406 == tmp20 && tmp194535406 == tmp19 && tmp184535406 == tmp18 && tmp174535406 == tmp17 && tmp164535406 == tmp16 && tmp154535406 == tmp15 && tmp144535406 == tmp14 && tmp134535406 == tmp13 && tmp124535406 == tmp12 && tmp114535406 == tmp11 && tmp104535406 == tmp10 && curr4535406 == curr && pred4535406 == pred && tmp74535406 == tmp7 && $result4535406 == $result && item4535406 == item && this4535406 == this && tid4535406 == tid && $pc4535406 == $pc;
   assume $recorded.state4535406 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume curr != Node.null;                                                                       
   } else {                                                                                         
    assert curr != Node.null;                                                                              // (64.10): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535406);                                                            
   assert $pc != PhaseError;                                                                               // (64.10): Reduction failure
   tmp23 := Node.item[curr];                                                                        
                                                                                                    
   // 64.10: tmp22 = tmp23 >= item;                                                                 
                                                                                                    
   tmp22 := (tmp23>=item);                                                                          
                                                                                                    
   // 64.10: assert tmp22 /* == curr.item >= item */;                                               
                                                                                                    
   assume Node._state4535420 == Node._state && Node.item4535420 == Node.item && Node.next4535420 == Node.next && Node._lock4535420 == Node._lock && OptimisticList._state4535420 == OptimisticList._state && OptimisticList.head4535420 == OptimisticList.head && OptimisticList._lock4535420 == OptimisticList._lock && tmp234535420 == tmp23 && tmp224535420 == tmp22 && tmp214535420 == tmp21 && tmp204535420 == tmp20 && tmp194535420 == tmp19 && tmp184535420 == tmp18 && tmp174535420 == tmp17 && tmp164535420 == tmp16 && tmp154535420 == tmp15 && tmp144535420 == tmp14 && tmp134535420 == tmp13 && tmp124535420 == tmp12 && tmp114535420 == tmp11 && tmp104535420 == tmp10 && curr4535420 == curr && pred4535420 == pred && tmp74535420 == tmp7 && $result4535420 == $result && item4535420 == item && this4535420 == this && tid4535420 == tid;
   assume $recorded.state4535420 == 1;                                                              
   assert tmp22 /* lowered (Node.item[curr]>=item) */;                                                     // (64.10): This assertion may not hold.
                                                                                                    
   // 65.10: boolean tmp24;                                                                         
                                                                                                    
                                                                                                    
   // 65.10: int tmp25;                                                                             
                                                                                                    
                                                                                                    
   // 65.10: tmp25 := curr.item;                                                                    
                                                                                                    
                                                                                                    
   moverPath4535429 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535429 := m#moverPath(moverPath4535429);                                                   
   path4535429 := p#moverPath(moverPath4535429);                                                    
   assume Node._state4535429 == Node._state && Node.item4535429 == Node.item && Node.next4535429 == Node.next && Node._lock4535429 == Node._lock && OptimisticList._state4535429 == OptimisticList._state && OptimisticList.head4535429 == OptimisticList.head && OptimisticList._lock4535429 == OptimisticList._lock && tmp254535429 == tmp25 && tmp244535429 == tmp24 && tmp234535429 == tmp23 && tmp224535429 == tmp22 && tmp214535429 == tmp21 && tmp204535429 == tmp20 && tmp194535429 == tmp19 && tmp184535429 == tmp18 && tmp174535429 == tmp17 && tmp164535429 == tmp16 && tmp154535429 == tmp15 && tmp144535429 == tmp14 && tmp134535429 == tmp13 && tmp124535429 == tmp12 && tmp114535429 == tmp11 && tmp104535429 == tmp10 && curr4535429 == curr && pred4535429 == pred && tmp74535429 == tmp7 && $result4535429 == $result && item4535429 == item && this4535429 == this && tid4535429 == tid && $pc4535429 == $pc;
   assume $recorded.state4535429 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume curr != Node.null;                                                                       
   } else {                                                                                         
    assert curr != Node.null;                                                                              // (65.10): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535429);                                                            
   assert $pc != PhaseError;                                                                               // (65.10): Reduction failure
   tmp25 := Node.item[curr];                                                                        
                                                                                                    
   // 65.10: tmp24 = tmp25 == item;                                                                 
                                                                                                    
   tmp24 := (tmp25==item);                                                                          
   if (tmp24 /* lowered (Node.item[curr]==item) */) {                                               
    if ($pc == PreCommit) {                                                                         
     assume curr != Node.null;                                                                      
    } else {                                                                                        
     assert curr != Node.null;                                                                             // (66.12): Cannot have potential null deference in left-mover part.
    }                                                                                               
    assert Node._lock[curr] == tid;                                                                        // (66.12): lock not held
    $pc := transition($pc, _L);                                                                     
    assert $pc != PhaseError;                                                                              // (66.12): Reduction failure
    Node._lock[curr] := Tid.null;                                                                   
    if ($pc == PreCommit) {                                                                         
     assume pred != Node.null;                                                                      
    } else {                                                                                        
     assert pred != Node.null;                                                                             // (67.12): Cannot have potential null deference in left-mover part.
    }                                                                                               
    assert Node._lock[pred] == tid;                                                                        // (67.12): lock not held
    $pc := transition($pc, _L);                                                                     
    assert $pc != PhaseError;                                                                              // (67.12): Reduction failure
    Node._lock[pred] := Tid.null;                                                                   
                                                                                                    
    // 68.12:  return false;                                                                        
                                                                                                    
    assume Node._state4535442 == Node._state && Node.item4535442 == Node.item && Node.next4535442 == Node.next && Node._lock4535442 == Node._lock && OptimisticList._state4535442 == OptimisticList._state && OptimisticList.head4535442 == OptimisticList.head && OptimisticList._lock4535442 == OptimisticList._lock && tmp254535442 == tmp25 && tmp244535442 == tmp24 && tmp234535442 == tmp23 && tmp224535442 == tmp22 && tmp214535442 == tmp21 && tmp204535442 == tmp20 && tmp194535442 == tmp19 && tmp184535442 == tmp18 && tmp174535442 == tmp17 && tmp164535442 == tmp16 && tmp154535442 == tmp15 && tmp144535442 == tmp14 && tmp134535442 == tmp13 && tmp124535442 == tmp12 && tmp114535442 == tmp11 && tmp104535442 == tmp10 && curr4535442 == curr && pred4535442 == pred && tmp74535442 == tmp7 && $result4535442 == $result && item4535442 == item && this4535442 == this && tid4535442 == tid;
    assume $recorded.state4535442 == 1;                                                             
    $result := false;                                                                               
    assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (68.12): Object invariant may not hold.
    assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (68.12): Object invariant may not hold.
    assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (68.12): Object invariant may not hold.
    assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (68.12): Object invariant may not hold.
    return;                                                                                         
   } else {                                                                                         
                                                                                                    
    // 70.12: Node node2;                                                                           
                                                                                                    
                                                                                                    
    // 70.12: node2 = new Node();                                                                   
                                                                                                    
    havoc node2;                                                                                    
    assume node2 != Node.null && isFresh(Node._state[node2]);                                       
    Node._state[node2] := LOCAL(tid);                                                               
    assume Node.item[node2]  == 0;                                                                  
    assume Node.next[node2]  == Node.null;                                                          
    assume Node._lock[node2]  == Tid.null;                                                          
    // inlined: node2.init()}                                                                       
    exit$257_top:                                                                                   
                                                                                                    
    // 70.12: Node this$257;                                                                        
                                                                                                    
                                                                                                    
    // 70.12: this$257 = node2;                                                                     
                                                                                                    
    this$257 := node2;                                                                              
                                                                                                    
    // 2.12: assume this$257.item == 0;                                                             
                                                                                                    
    assume (Node.item[this$257]==0);                                                                
                                                                                                    
    // 2.12: assume this$257.next == Node.null;                                                     
                                                                                                    
    assume (Node.next[this$257]==Node.null);                                                        
                                                                                                    
    // 9.1: break exit$257;                                                                         
                                                                                                    
    goto exit$257_bottom;                                                                           
    exit$257_bottom:                                                                                
                                                                                                    
                                                                                                    
    // 71.12: node2.item := item;                                                                   
                                                                                                    
                                                                                                    
    moverPath4535484 := WriteEval.Node.item(tid: Tid,node2: Node,item: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
    mover4535484 := m#moverPath(moverPath4535484);                                                  
    path4535484 := p#moverPath(moverPath4535484);                                                   
    assume Node._state4535484 == Node._state && Node.item4535484 == Node.item && Node.next4535484 == Node.next && Node._lock4535484 == Node._lock && OptimisticList._state4535484 == OptimisticList._state && OptimisticList.head4535484 == OptimisticList.head && OptimisticList._lock4535484 == OptimisticList._lock && node24535484 == node2 && tmp254535484 == tmp25 && tmp244535484 == tmp24 && tmp234535484 == tmp23 && tmp224535484 == tmp22 && tmp214535484 == tmp21 && tmp204535484 == tmp20 && tmp194535484 == tmp19 && tmp184535484 == tmp18 && tmp174535484 == tmp17 && tmp164535484 == tmp16 && tmp154535484 == tmp15 && tmp144535484 == tmp14 && tmp134535484 == tmp13 && tmp124535484 == tmp12 && tmp114535484 == tmp11 && tmp104535484 == tmp10 && curr4535484 == curr && pred4535484 == pred && tmp74535484 == tmp7 && $result4535484 == $result && item4535484 == item && this4535484 == this && tid4535484 == tid && $pc4535484 == $pc;
    assume $recorded.state4535484 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume node2 != Node.null;                                                                     
    } else {                                                                                        
     assert node2 != Node.null;                                                                            // (71.12): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover4535484);                                                           
    assert $pc != PhaseError;                                                                              // (71.12): Reduction failure
    Node.item[node2] := item;                                                                       
                                                                                                    
                                                                                                    
    // 72.12: node2.next := curr;                                                                   
                                                                                                    
                                                                                                    
    moverPath4535487 := WriteEval.Node.next(tid: Tid,node2: Node,curr: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
    mover4535487 := m#moverPath(moverPath4535487);                                                  
    path4535487 := p#moverPath(moverPath4535487);                                                   
    assume Node._state4535487 == Node._state && Node.item4535487 == Node.item && Node.next4535487 == Node.next && Node._lock4535487 == Node._lock && OptimisticList._state4535487 == OptimisticList._state && OptimisticList.head4535487 == OptimisticList.head && OptimisticList._lock4535487 == OptimisticList._lock && node24535487 == node2 && tmp254535487 == tmp25 && tmp244535487 == tmp24 && tmp234535487 == tmp23 && tmp224535487 == tmp22 && tmp214535487 == tmp21 && tmp204535487 == tmp20 && tmp194535487 == tmp19 && tmp184535487 == tmp18 && tmp174535487 == tmp17 && tmp164535487 == tmp16 && tmp154535487 == tmp15 && tmp144535487 == tmp14 && tmp134535487 == tmp13 && tmp124535487 == tmp12 && tmp114535487 == tmp11 && tmp104535487 == tmp10 && curr4535487 == curr && pred4535487 == pred && tmp74535487 == tmp7 && $result4535487 == $result && item4535487 == item && this4535487 == this && tid4535487 == tid && $pc4535487 == $pc;
    assume $recorded.state4535487 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume node2 != Node.null;                                                                     
    } else {                                                                                        
     assert node2 != Node.null;                                                                            // (72.12): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover4535487);                                                           
    assert $pc != PhaseError;                                                                              // (72.12): Reduction failure
    Node.next[node2] := curr;                                                                       
    if (isLocal(Node._state[curr], tid)) {                                                          
     Node._state[curr] := SHARED();                                                                 
     assert isSharedAssignable(Node._state[Node.next[curr]]);                                              // (72.12): curr became shared, but curr.next may not be shared.
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    // 73.12: pred.next := node2;                                                                   
                                                                                                    
                                                                                                    
    moverPath4535490 := WriteEval.Node.next(tid: Tid,pred: Node,node2: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
    mover4535490 := m#moverPath(moverPath4535490);                                                  
    path4535490 := p#moverPath(moverPath4535490);                                                   
    assume Node._state4535490 == Node._state && Node.item4535490 == Node.item && Node.next4535490 == Node.next && Node._lock4535490 == Node._lock && OptimisticList._state4535490 == OptimisticList._state && OptimisticList.head4535490 == OptimisticList.head && OptimisticList._lock4535490 == OptimisticList._lock && node24535490 == node2 && tmp254535490 == tmp25 && tmp244535490 == tmp24 && tmp234535490 == tmp23 && tmp224535490 == tmp22 && tmp214535490 == tmp21 && tmp204535490 == tmp20 && tmp194535490 == tmp19 && tmp184535490 == tmp18 && tmp174535490 == tmp17 && tmp164535490 == tmp16 && tmp154535490 == tmp15 && tmp144535490 == tmp14 && tmp134535490 == tmp13 && tmp124535490 == tmp12 && tmp114535490 == tmp11 && tmp104535490 == tmp10 && curr4535490 == curr && pred4535490 == pred && tmp74535490 == tmp7 && $result4535490 == $result && item4535490 == item && this4535490 == this && tid4535490 == tid && $pc4535490 == $pc;
    assume $recorded.state4535490 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume pred != Node.null;                                                                      
    } else {                                                                                        
     assert pred != Node.null;                                                                             // (73.12): Cannot have potential null deference in left-mover part.
    }                                                                                               
    $pc := transition($pc, mover4535490);                                                           
    assert $pc != PhaseError;                                                                              // (73.12): Reduction failure
    Node.next[pred] := node2;                                                                       
    if (isLocal(Node._state[node2], tid)) {                                                         
     Node._state[node2] := SHARED();                                                                
     assert isSharedAssignable(Node._state[Node.next[node2]]);                                             // (73.12): node2 became shared, but node2.next may not be shared.
    }                                                                                               
                                                                                                    
    if ($pc == PreCommit) {                                                                         
     assume curr != Node.null;                                                                      
    } else {                                                                                        
     assert curr != Node.null;                                                                             // (74.12): Cannot have potential null deference in left-mover part.
    }                                                                                               
    assert Node._lock[curr] == tid;                                                                        // (74.12): lock not held
    $pc := transition($pc, _L);                                                                     
    assert $pc != PhaseError;                                                                              // (74.12): Reduction failure
    Node._lock[curr] := Tid.null;                                                                   
    if ($pc == PreCommit) {                                                                         
     assume pred != Node.null;                                                                      
    } else {                                                                                        
     assert pred != Node.null;                                                                             // (75.12): Cannot have potential null deference in left-mover part.
    }                                                                                               
    assert Node._lock[pred] == tid;                                                                        // (75.12): lock not held
    $pc := transition($pc, _L);                                                                     
    assert $pc != PhaseError;                                                                              // (75.12): Reduction failure
    Node._lock[pred] := Tid.null;                                                                   
                                                                                                    
    // 76.12:  return true;                                                                         
                                                                                                    
    assume Node._state4535497 == Node._state && Node.item4535497 == Node.item && Node.next4535497 == Node.next && Node._lock4535497 == Node._lock && OptimisticList._state4535497 == OptimisticList._state && OptimisticList.head4535497 == OptimisticList.head && OptimisticList._lock4535497 == OptimisticList._lock && node24535497 == node2 && tmp254535497 == tmp25 && tmp244535497 == tmp24 && tmp234535497 == tmp23 && tmp224535497 == tmp22 && tmp214535497 == tmp21 && tmp204535497 == tmp20 && tmp194535497 == tmp19 && tmp184535497 == tmp18 && tmp174535497 == tmp17 && tmp164535497 == tmp16 && tmp154535497 == tmp15 && tmp144535497 == tmp14 && tmp134535497 == tmp13 && tmp124535497 == tmp12 && tmp114535497 == tmp11 && tmp104535497 == tmp10 && curr4535497 == curr && pred4535497 == pred && tmp74535497 == tmp7 && $result4535497 == $result && item4535497 == item && this4535497 == this && tid4535497 == tid;
    assume $recorded.state4535497 == 1;                                                             
    $result := true;                                                                                
    assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (76.12): Object invariant may not hold.
    assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (76.12): Object invariant may not hold.
    assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (76.12): Object invariant may not hold.
    assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (76.12): Object invariant may not hold.
    return;                                                                                         
   }                                                                                                
  } else {                                                                                          
  }                                                                                                 
  assume Node._state4535506_bottom == Node._state && Node.item4535506_bottom == Node.item && Node.next4535506_bottom == Node.next && Node._lock4535506_bottom == Node._lock && OptimisticList._state4535506_bottom == OptimisticList._state && OptimisticList.head4535506_bottom == OptimisticList.head && OptimisticList._lock4535506_bottom == OptimisticList._lock && $result4535506_bottom == $result && item4535506_bottom == item && this4535506_bottom == this && tid4535506_bottom == tid;
  assume $recorded.state4535506_bottom == 1;                                                        
  assert phase4535506 == $pc;                                                                              // (39.7): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 38.34: // return false;                                                                         
                                                                                                    
 assume Node._state4535509 == Node._state && Node.item4535509 == Node.item && Node.next4535509 == Node.next && Node._lock4535509 == Node._lock && OptimisticList._state4535509 == OptimisticList._state && OptimisticList.head4535509 == OptimisticList.head && OptimisticList._lock4535509 == OptimisticList._lock && $result4535509 == $result && item4535509 == item && this4535509 == this && tid4535509 == tid;
 assume $recorded.state4535509 == 1;                                                                
 $result := false;                                                                                  
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (38.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (38.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (38.34): Object invariant may not hold.
 assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (38.34): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  OptimisticList.contains(tid:Tid, this : OptimisticList, item : int)                      
returns ($result : bool)                                                                            
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies OptimisticList._state;                                                                     
modifies OptimisticList.head;                                                                       
modifies OptimisticList._lock;                                                                      
                                                                                                    
requires ValidTid(tid);                                                                                    // (83.6): Bad tid
requires isShared(OptimisticList._state[this]);                                                            // (83.6): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
requires ((-(5)<item)&&(item<5));                                                                   
                                                                                                    
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (83.6): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (83.6): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (83.6): Object invariant may not hold.
requires  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (83.6): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (83.6): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (83.6): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (83.6): Object invariant may not hold.
ensures  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (83.6): Object invariant may not hold.
{                                                                                                   
 var $pc4535673: Phase;                                                                             
 var pred4535613: Node;                                                                             
 var pred4535559_post: Node;                                                                        
 var OptimisticList._lock4535674_post: [OptimisticList]Tid;                                         
 var pred4535743: Node;                                                                             
 var OptimisticList.head4535750_bottom: [OptimisticList]Node;                                       
 var pred4535566_bottom: Node;                                                                      
 var tmp30: int;                                                                                    
 var $recorded.state4535674: int;                                                                   
 var $recorded.state4535563: int;                                                                   
 var Node.next4535602: [Node]Node;                                                                  
 var tmp264535674_post: bool;                                                                       
 var Node.next4535656: [Node]Node;                                                                  
 var $result4535699: bool;                                                                          
 var OptimisticList._lock4535753: [OptimisticList]Tid;                                              
 var item4535613: int;                                                                              
 var Node.next4535562: [Node]Node;                                                                  
 var OptimisticList.head4535743: [OptimisticList]Node;                                              
 var pred4535563: Node;                                                                             
 var Node.item4535699: [Node]int;                                                                   
 var Node.next4535750_bottom: [Node]Node;                                                           
 var node$2584535656: Node;                                                                         
 var OptimisticList.head4535559: [OptimisticList]Node;                                              
 var this4535563: OptimisticList;                                                                   
 var tmp274535559_post: bool;                                                                       
 var $result4535563: bool;                                                                          
 var Node.item4535674_post: [Node]int;                                                              
 var this4535731: OptimisticList;                                                                   
 var tmp284535545: int;                                                                             
 var tmp264535619: bool;                                                                            
 var OptimisticList.head4535536_post: [OptimisticList]Node;                                         
 var Node.next4535743: [Node]Node;                                                                  
 var tmp5$258: bool;                                                                                
 var pred4535674_post: Node;                                                                        
 var tid4535602: Tid;                                                                               
 var Node.item4535619: [Node]int;                                                                   
 var tmp3$2584535673: int;                                                                          
 var tmp5$2584535656: bool;                                                                         
 var tid4535674: Tid;                                                                               
 var OptimisticList.head4535674: [OptimisticList]Node;                                              
 var OptimisticList._lock4535559: [OptimisticList]Tid;                                              
 var this4535563_post: OptimisticList;                                                              
 var item4535602_post: int;                                                                         
 var this4535601: OptimisticList;                                                                   
 var $result4535545: bool;                                                                          
 var $recorded.state4535743: int;                                                                   
 var tid4535536: Tid;                                                                               
 var item$2584535602_post: int;                                                                     
 var item4535674_post: int;                                                                         
 var tmp284535563_post: int;                                                                        
 var $result4535674_post: bool;                                                                     
 var Node.item4535699_bottom: [Node]int;                                                            
 var item$2584535619: int;                                                                          
 var $pc4535674: Phase;                                                                             
 var tmp1$258: bool;                                                                                
 var Node.item4535566_bottom: [Node]int;                                                            
 var Node._lock4535613: [Node]Tid;                                                                  
 var $recorded.state4535731: int;                                                                   
 var tid4535699_bottom: Tid;                                                                        
 var Node._lock4535563_post: [Node]Tid;                                                             
 var item4535602: int;                                                                              
 var curr4535559: Node;                                                                             
 var tmp1$2584535674: bool;                                                                         
 var pred4535656: Node;                                                                             
 var mover4535656: Mover;                                                                           
 var curr$2584535613: Node;                                                                         
 var $result4535529: bool;                                                                          
 var Node._lock4535602: [Node]Tid;                                                                  
 var Node._state4535559_post: [Node]State;                                                          
 var tmp294535699_bottom: bool;                                                                     
 var path4535673: int;                                                                              
 var Node._state4535535: [Node]State;                                                               
 var item4535601: int;                                                                              
 var tmp2$2584535674: int;                                                                          
 var moverPath4535601: MoverPath;                                                                   
 var item$2584535674: int;                                                                          
 var $pc4535602_post: Phase;                                                                        
 var OptimisticList._state4535753: [OptimisticList]State;                                           
 var tmp264535545: bool;                                                                            
 var item4535566: int;                                                                              
 var Node.item4535674: [Node]int;                                                                   
 var pred$2584535602: Node;                                                                         
 var OptimisticList._state4535536: [OptimisticList]State;                                           
 var curr4535743: Node;                                                                             
 var pred4535535: Node;                                                                             
 var Node._state4535601: [Node]State;                                                               
 var $pc4535545: Phase;                                                                             
 var tmp264535563_post: bool;                                                                       
 var Node._state4535673: [Node]State;                                                               
 var OptimisticList._state4535750_bottom: [OptimisticList]State;                                    
 var Node.item4535750_bottom: [Node]int;                                                            
 var OptimisticList.head4535602_post: [OptimisticList]Node;                                         
 var curr4535536: Node;                                                                             
 var this$2584535699: OptimisticList;                                                               
 var this4535545: OptimisticList;                                                                   
 var tmp294535656: bool;                                                                            
 var $recorded.state4535619: int;                                                                   
 var $recorded.state4535673: int;                                                                   
 var curr4535602: Node;                                                                             
 var curr4535536_post: Node;                                                                        
 var this$2584535613: OptimisticList;                                                               
 var this4535613: OptimisticList;                                                                   
 var curr4535673: Node;                                                                             
 var tmp3$2584535619: int;                                                                          
 var tmp264535674: bool;                                                                            
 var tmp294535602_post: bool;                                                                       
 var item4535536: int;                                                                              
 var curr$2584535699_bottom: Node;                                                                  
 var $result4535699_bottom: bool;                                                                   
 var pred4535529: Node;                                                                             
 var $recorded.state4535699: int;                                                                   
 var mover4535562: Mover;                                                                           
 var OptimisticList.head4535656: [OptimisticList]Node;                                              
 var tid4535750: Tid;                                                                               
 var curr$2584535602: Node;                                                                         
 var tmp284535563: int;                                                                             
 var pred$2584535601: Node;                                                                         
 var path4535613: int;                                                                              
 var Node.item4535673: [Node]int;                                                                   
 var item4535619: int;                                                                              
 var OptimisticList._lock4535731: [OptimisticList]Tid;                                              
 var Node._state4535566_bottom: [Node]State;                                                        
 var Node.item4535529: [Node]int;                                                                   
 var OptimisticList.head4535699: [OptimisticList]Node;                                              
 var tid4535753: Tid;                                                                               
 var Node._state4535536: [Node]State;                                                               
 var $recorded.state4535750: int;                                                                   
 var tmp294535731: bool;                                                                            
 var pred$2584535674: Node;                                                                         
 var Node.next4535536_post: [Node]Node;                                                             
 var tid4535731: Tid;                                                                               
 var mover4535731: Mover;                                                                           
 var tmp264535559_post: bool;                                                                       
 var Node._state4535674_post: [Node]State;                                                          
 var Node.item4535602: [Node]int;                                                                   
 var moverPath4535545: MoverPath;                                                                   
 var item4535699: int;                                                                              
 var tmp284535559: int;                                                                             
 var $result4535750: bool;                                                                          
 var tid4535601: Tid;                                                                               
 var curr4535613: Node;                                                                             
 var tmp6$2584535656: Node;                                                                         
 var node$2584535619: Node;                                                                         
 var item4535545: int;                                                                              
 var OptimisticList.head4535566_bottom: [OptimisticList]Node;                                       
 var node$2584535613: Node;                                                                         
 var node$2584535673: Node;                                                                         
 var $pc4535536: Phase;                                                                             
 var $pc4535563: Phase;                                                                             
 var Node.item4535731: [Node]int;                                                                   
 var OptimisticList._state4535559_post: [OptimisticList]State;                                      
 var Node._state4535656: [Node]State;                                                               
 var this4535566: OptimisticList;                                                                   
 var item4535656: int;                                                                              
 var tmp264535563: bool;                                                                            
 var item4535536_post: int;                                                                         
 var Node.next4535673: [Node]Node;                                                                  
 var Node.next4535529: [Node]Node;                                                                  
 var tmp284535562: int;                                                                             
 var Node.next4535619: [Node]Node;                                                                  
 var Node._lock4535743: [Node]Tid;                                                                  
 var tmp2$2584535613: int;                                                                          
 var Node.next4535699: [Node]Node;                                                                  
 var tmp294535613: bool;                                                                            
 var $pc4535753: Phase;                                                                             
 var $result4535613: bool;                                                                          
 var curr$2584535699: Node;                                                                         
 var curr4535656: Node;                                                                             
 var node$2584535699_bottom: Node;                                                                  
 var Node._state4535602_post: [Node]State;                                                          
 var item$2584535613: int;                                                                          
 var OptimisticList._lock4535536_post: [OptimisticList]Tid;                                         
 var OptimisticList._lock4535536: [OptimisticList]Tid;                                              
 var Node._state4535731: [Node]State;                                                               
 var pred$2584535619: Node;                                                                         
 var $recorded.state4535601: int;                                                                   
 var Node._state4535750_bottom: [Node]State;                                                        
 var $recorded.state4535536: int;                                                                   
 var this$2584535674_post: OptimisticList;                                                          
 var item4535731: int;                                                                              
 var item4535750_bottom: int;                                                                       
 var curr4535562: Node;                                                                             
 var pred4535699: Node;                                                                             
 var $pc4535535: Phase;                                                                             
 var item4535563_post: int;                                                                         
 var $recorded.state4535566: int;                                                                   
 var this$2584535619: OptimisticList;                                                               
 var tid4535562: Tid;                                                                               
 var item$2584535602: int;                                                                          
 var curr4535731: Node;                                                                             
 var $result4535673: bool;                                                                          
 var OptimisticList._lock4535674: [OptimisticList]Tid;                                              
 var tmp4$2584535673: bool;                                                                         
 var tmp4$2584535674: bool;                                                                         
 var tmp304535743: int;                                                                             
 var $recorded.state4535545: int;                                                                   
 var pred4535559: Node;                                                                             
 var $recorded.state4535750_bottom: int;                                                            
 var curr4535563_post: Node;                                                                        
 var pred4535566: Node;                                                                             
 var $pc4535566: Phase;                                                                             
 var OptimisticList.head4535699_bottom: [OptimisticList]Node;                                       
 var Node.next4535602_post: [Node]Node;                                                             
 var OptimisticList.head4535750: [OptimisticList]Node;                                              
 var $pc4535566_bottom: Phase;                                                                      
 var path4535601: int;                                                                              
 var OptimisticList._state4535529: [OptimisticList]State;                                           
 var $pc4535750_bottom: Phase;                                                                      
 var OptimisticList._state4535563_post: [OptimisticList]State;                                      
 var this4535673: OptimisticList;                                                                   
 var curr4535566: Node;                                                                             
 var item4535535: int;                                                                              
 var Node.item4535656: [Node]int;                                                                   
 var OptimisticList._lock4535545: [OptimisticList]Tid;                                              
 var OptimisticList._lock4535750: [OptimisticList]Tid;                                              
 var Node._lock4535536_post: [Node]Tid;                                                             
 var OptimisticList._lock4535699_bottom: [OptimisticList]Tid;                                       
 var item$2584535656: int;                                                                          
 var OptimisticList._state4535601: [OptimisticList]State;                                           
 var Node.next4535559: [Node]Node;                                                                  
 var mover4535529: Mover;                                                                           
 var Node._lock4535545: [Node]Tid;                                                                  
 var $result4535601: bool;                                                                          
 var tmp26: bool;                                                                                   
 var moverPath4535673: MoverPath;                                                                   
 var $pc4535743: Phase;                                                                             
 var item4535562: int;                                                                              
 var this$2584535601: OptimisticList;                                                               
 var pred4535619: Node;                                                                             
 var tid4535699: Tid;                                                                               
 var tid4535559: Tid;                                                                               
 var tid4535545: Tid;                                                                               
 var item$2584535699_bottom: int;                                                                   
 var Node._lock4535699_bottom: [Node]Tid;                                                           
 var OptimisticList.head4535673: [OptimisticList]Node;                                              
 var OptimisticList.head4535536: [OptimisticList]Node;                                              
 var $pc4535750: Phase;                                                                             
 var tmp2$258: int;                                                                                 
 var OptimisticList._lock4535656: [OptimisticList]Tid;                                              
 var tmp3$2584535674: int;                                                                          
 var tmp304535731: int;                                                                             
 var Node.next4535731: [Node]Node;                                                                  
 var Node.next4535674_post: [Node]Node;                                                             
 var tmp6$258: Node;                                                                                
 var tid4535743: Tid;                                                                               
 var tmp2$2584535674_post: int;                                                                     
 var $recorded.state4535559_post: int;                                                              
 var item4535750: int;                                                                              
 var tid4535673: Tid;                                                                               
 var pred4535536_post: Node;                                                                        
 var item4535674: int;                                                                              
 var $recorded.state4535562: int;                                                                   
 var path4535562: int;                                                                              
 var curr: Node;                                                                                    
 var tid4535536_post: Tid;                                                                          
 var tmp1$2584535674_post: bool;                                                                    
 var $recorded.state4535753: int;                                                                   
 var tmp28: int;                                                                                    
 var OptimisticList._lock4535535: [OptimisticList]Tid;                                              
 var OptimisticList._lock4535699: [OptimisticList]Tid;                                              
 var tid4535566_bottom: Tid;                                                                        
 var $result4535619: bool;                                                                          
 var OptimisticList._state4535602_post: [OptimisticList]State;                                      
 var $recorded.state4535613: int;                                                                   
 var OptimisticList.head4535559_post: [OptimisticList]Node;                                         
 var $pc4535601: Phase;                                                                             
 var OptimisticList.head4535601: [OptimisticList]Node;                                              
 var this4535536_post: OptimisticList;                                                              
 var tmp29: bool;                                                                                   
 var OptimisticList._lock4535750_bottom: [OptimisticList]Tid;                                       
 var this4535602_post: OptimisticList;                                                              
 var this4535562: OptimisticList;                                                                   
 var tmp264535731: bool;                                                                            
 var $recorded.state4535536_post: int;                                                              
 var Node.item4535535: [Node]int;                                                                   
 var $pc4535699_bottom: Phase;                                                                      
 var Node.next4535563: [Node]Node;                                                                  
 var Node._state4535674: [Node]State;                                                               
 var tmp294535674: bool;                                                                            
 var $result4535563_post: bool;                                                                     
 var curr$2584535674: Node;                                                                         
 var Node.item4535613: [Node]int;                                                                   
 var tmp264535743: bool;                                                                            
 var $pc4535529: Phase;                                                                             
 var tmp294535699: bool;                                                                            
 var OptimisticList.head4535613: [OptimisticList]Node;                                              
 var OptimisticList._lock4535566: [OptimisticList]Tid;                                              
 var Node._lock4535535: [Node]Tid;                                                                  
 var Node.item4535559: [Node]int;                                                                   
 var tmp2$2584535656: int;                                                                          
 var tmp2$2584535619: int;                                                                          
 var OptimisticList._lock4535566_bottom: [OptimisticList]Tid;                                       
 var path4535535: int;                                                                              
 var tmp264535562: bool;                                                                            
 var tmp294535601: bool;                                                                            
 var path4535619: int;                                                                              
 var Node._state4535613: [Node]State;                                                               
 var curr4535674_post: Node;                                                                        
 var OptimisticList._lock4535529: [OptimisticList]Tid;                                              
 var OptimisticList._state4535536_post: [OptimisticList]State;                                      
 var $pc4535619: Phase;                                                                             
 var Node.item4535743: [Node]int;                                                                   
 var curr$2584535674_post: Node;                                                                    
 var Node._state4535619: [Node]State;                                                               
 var $recorded.state4535529: int;                                                                   
 var tmp294535602: bool;                                                                            
 var tmp1$2584535673: bool;                                                                         
 var OptimisticList._state4535559: [OptimisticList]State;                                           
 var Node._lock4535674: [Node]Tid;                                                                  
 var $recorded.state4535566_bottom: int;                                                            
 var this$2584535699_bottom: OptimisticList;                                                        
 var pred$2584535673: Node;                                                                         
 var $result4535566_bottom: bool;                                                                   
 var curr$2584535619: Node;                                                                         
 var OptimisticList._state4535619: [OptimisticList]State;                                           
 var node$2584535674_post: Node;                                                                    
 var Node._state4535566: [Node]State;                                                               
 var tmp264535529: bool;                                                                            
 var Node.item4535753: [Node]int;                                                                   
 var tid4535674_post: Tid;                                                                          
 var Node._lock4535559: [Node]Tid;                                                                  
 var curr$2584535673: Node;                                                                         
 var Node._lock4535699: [Node]Tid;                                                                  
 var tid4535602_post: Tid;                                                                          
 var OptimisticList._lock4535613: [OptimisticList]Tid;                                              
 var Node._state4535559: [Node]State;                                                               
 var node$2584535602_post: Node;                                                                    
 var node$258: Node;                                                                                
 var $result4535559: bool;                                                                          
 var OptimisticList._state4535566: [OptimisticList]State;                                           
 var Node._lock4535529: [Node]Tid;                                                                  
 var Node.next4535545: [Node]Node;                                                                  
 var Node._lock4535673: [Node]Tid;                                                                  
 var Node._state4535753: [Node]State;                                                               
 var mover4535535: Mover;                                                                           
 var $pc4535613: Phase;                                                                             
 var Node._lock4535563: [Node]Tid;                                                                  
 var tid4535535: Tid;                                                                               
 var OptimisticList._state4535674_post: [OptimisticList]State;                                      
 var Node._lock4535602_post: [Node]Tid;                                                             
 var tmp3$258: int;                                                                                 
 var OptimisticList._state4535566_bottom: [OptimisticList]State;                                    
 var tmp27: bool;                                                                                   
 var $pc4535674_post: Phase;                                                                        
 var item4535559: int;                                                                              
 var Node.item4535750: [Node]int;                                                                   
 var tmp264535536_post: bool;                                                                       
 var tmp294535673: bool;                                                                            
 var tid4535559_post: Tid;                                                                          
 var OptimisticList._state4535699: [OptimisticList]State;                                           
 var OptimisticList._lock4535602_post: [OptimisticList]Tid;                                         
 var node$2584535602: Node;                                                                         
 var this$258: OptimisticList;                                                                      
 var $result4535731: bool;                                                                          
 var tmp264535656: bool;                                                                            
 var tid4535613: Tid;                                                                               
 var pred4535731: Node;                                                                             
 var curr4535535: Node;                                                                             
 var item4535566_bottom: int;                                                                       
 var tmp264535535: bool;                                                                            
 var Node.item4535563_post: [Node]int;                                                              
 var tid4535566: Tid;                                                                               
 var $result4535536: bool;                                                                          
 var Node._state4535699: [Node]State;                                                               
 var item$2584535673: int;                                                                          
 var $pc4535699: Phase;                                                                             
 var $result4535743: bool;                                                                          
 var tmp294535743: bool;                                                                            
 var OptimisticList.head4535566: [OptimisticList]Node;                                              
 var Node._state4535750: [Node]State;                                                               
 var $result4535753: bool;                                                                          
 var $result4535674: bool;                                                                          
 var curr4535545: Node;                                                                             
 var OptimisticList.head4535619: [OptimisticList]Node;                                              
 var phase4535566: Phase;                                                                           
 var tmp274535545: bool;                                                                            
 var item4535559_post: int;                                                                         
 var Node._state4535536_post: [Node]State;                                                          
 var OptimisticList._state4535602: [OptimisticList]State;                                           
 var Node._lock4535731: [Node]Tid;                                                                  
 var this4535753: OptimisticList;                                                                   
 var mover4535619: Mover;                                                                           
 var curr$2584535601: Node;                                                                         
 var curr4535699_bottom: Node;                                                                      
 var tmp2$2584535673: int;                                                                          
 var phase4535699: Phase;                                                                           
 var Node.item4535559_post: [Node]int;                                                              
 var Node._state4535563: [Node]State;                                                               
 var tmp264535559: bool;                                                                            
 var Node._lock4535674_post: [Node]Tid;                                                             
 var OptimisticList._state4535674: [OptimisticList]State;                                           
 var tmp264535699_bottom: bool;                                                                     
 var OptimisticList.head4535535: [OptimisticList]Node;                                              
 var OptimisticList._lock4535619: [OptimisticList]Tid;                                              
 var path4535731: int;                                                                              
 var curr$258: Node;                                                                                
 var tmp264535602_post: bool;                                                                       
 var Node._lock4535750_bottom: [Node]Tid;                                                           
 var $recorded.state4535559: int;                                                                   
 var OptimisticList._state4535535: [OptimisticList]State;                                           
 var Node._lock4535753: [Node]Tid;                                                                  
 var Node.next4535559_post: [Node]Node;                                                             
 var mover4535545: Mover;                                                                           
 var this4535536: OptimisticList;                                                                   
 var OptimisticList.head4535562: [OptimisticList]Node;                                              
 var tmp1$2584535613: bool;                                                                         
 var $pc4535563_post: Phase;                                                                        
 var path4535529: int;                                                                              
 var OptimisticList._state4535562: [OptimisticList]State;                                           
 var this4535674_post: OptimisticList;                                                              
 var $pc4535602: Phase;                                                                             
 var Node.next4535535: [Node]Node;                                                                  
 var $result4535602_post: bool;                                                                     
 var pred$258: Node;                                                                                
 var OptimisticList._state4535750: [OptimisticList]State;                                           
 var $recorded.state4535535: int;                                                                   
 var this$2584535673: OptimisticList;                                                               
 var item4535563: int;                                                                              
 var curr4535563: Node;                                                                             
 var tid4535656: Tid;                                                                               
 var this4535566_bottom: OptimisticList;                                                            
 var tmp274535562: bool;                                                                            
 var pred4535545: Node;                                                                             
 var OptimisticList._lock4535559_post: [OptimisticList]Tid;                                         
 var this4535674: OptimisticList;                                                                   
 var $recorded.state4535699_bottom: int;                                                            
 var tid4535563_post: Tid;                                                                          
 var pred4535563_post: Node;                                                                        
 var Node.item4535601: [Node]int;                                                                   
 var OptimisticList._lock4535673: [OptimisticList]Tid;                                              
 var path4535656: int;                                                                              
 var OptimisticList._lock4535563_post: [OptimisticList]Tid;                                         
 var tmp294535674_post: bool;                                                                       
 var item$2584535699: int;                                                                          
 var OptimisticList._state4535743: [OptimisticList]State;                                           
 var pred4535562: Node;                                                                             
 var OptimisticList._lock4535563: [OptimisticList]Tid;                                              
 var tmp1$2584535619: bool;                                                                         
 var pred4535602_post: Node;                                                                        
 var Node._lock4535656: [Node]Tid;                                                                  
 var pred$2584535613: Node;                                                                         
 var moverPath4535656: MoverPath;                                                                   
 var this$2584535602_post: OptimisticList;                                                          
 var tmp264535536: bool;                                                                            
 var item$258: int;                                                                                 
 var tmp4$258: bool;                                                                                
 var OptimisticList._lock4535743: [OptimisticList]Tid;                                              
 var this4535656: OptimisticList;                                                                   
 var tmp274535563: bool;                                                                            
 var OptimisticList._state4535699_bottom: [OptimisticList]State;                                    
 var tmp4$2584535656: bool;                                                                         
 var tid4535750_bottom: Tid;                                                                        
 var item4535753: int;                                                                              
 var $pc4535562: Phase;                                                                             
 var curr4535699: Node;                                                                             
 var $result4535562: bool;                                                                          
 var OptimisticList.head4535563: [OptimisticList]Node;                                              
 var pred$2584535699_bottom: Node;                                                                  
 var pred4535602: Node;                                                                             
 var OptimisticList.head4535563_post: [OptimisticList]Node;                                         
 var Node._state4535602: [Node]State;                                                               
 var tmp264535601: bool;                                                                            
 var tmp1$2584535656: bool;                                                                         
 var this4535602: OptimisticList;                                                                   
 var Node.next4535536: [Node]Node;                                                                  
 var curr$2584535602_post: Node;                                                                    
 var Node.next4535566: [Node]Node;                                                                  
 var tmp264535673: bool;                                                                            
 var Node.next4535674: [Node]Node;                                                                  
 var OptimisticList._state4535613: [OptimisticList]State;                                           
 var curr4535674: Node;                                                                             
 var mover4535613: Mover;                                                                           
 var pred$2584535699: Node;                                                                         
 var pred$2584535674_post: Node;                                                                    
 var pred4535673: Node;                                                                             
 var item4535743: int;                                                                              
 var pred4535536: Node;                                                                             
 var Node.item4535563: [Node]int;                                                                   
 var moverPath4535535: MoverPath;                                                                   
 var this4535750_bottom: OptimisticList;                                                            
 var Node._lock4535536: [Node]Tid;                                                                  
 var item4535673: int;                                                                              
 var OptimisticList.head4535529: [OptimisticList]Node;                                              
 var Node._state4535743: [Node]State;                                                               
 var Node.item4535536_post: [Node]int;                                                              
 var Node.next4535750: [Node]Node;                                                                  
 var $pc4535559_post: Phase;                                                                        
 var moverPath4535613: MoverPath;                                                                   
 var pred4535601: Node;                                                                             
 var Node._lock4535601: [Node]Tid;                                                                  
 var tmp3$2584535674_post: int;                                                                     
 var Node._state4535545: [Node]State;                                                               
 var tmp284535559_post: int;                                                                        
 var this4535699: OptimisticList;                                                                   
 var moverPath4535731: MoverPath;                                                                   
 var $result4535566: bool;                                                                          
 var OptimisticList._state4535673: [OptimisticList]State;                                           
 var phase4535750: Phase;                                                                           
 var $result4535602: bool;                                                                          
 var this4535559: OptimisticList;                                                                   
 var pred4535699_bottom: Node;                                                                      
 var mover4535673: Mover;                                                                           
 var item$2584535601: int;                                                                          
 var OptimisticList.head4535602: [OptimisticList]Node;                                              
 var pred: Node;                                                                                    
 var OptimisticList._lock4535601: [OptimisticList]Tid;                                              
 var node$2584535601: Node;                                                                         
 var curr4535619: Node;                                                                             
 var b4535731: bool;                                                                                
 var OptimisticList._state4535563: [OptimisticList]State;                                           
 var curr4535602_post: Node;                                                                        
 var curr4535566_bottom: Node;                                                                      
 var Node.item4535566: [Node]int;                                                                   
 var $result4535536_post: bool;                                                                     
 var pred$2584535602_post: Node;                                                                    
 var curr4535601: Node;                                                                             
 var path4535545: int;                                                                              
 var tmp264535613: bool;                                                                            
 var OptimisticList._state4535545: [OptimisticList]State;                                           
 var this4535619: OptimisticList;                                                                   
 var Node._lock4535750: [Node]Tid;                                                                  
 var Node.item4535602_post: [Node]int;                                                              
 var Node.next4535601: [Node]Node;                                                                  
 var $pc4535536_post: Phase;                                                                        
 var tmp274535559: bool;                                                                            
 var this4535529: OptimisticList;                                                                   
 var $recorded.state4535563_post: int;                                                              
 var tmp3$2584535656: int;                                                                          
 var $result4535750_bottom: bool;                                                                   
 var Node._state4535562: [Node]State;                                                               
 var pred4535674: Node;                                                                             
 var $result4535656: bool;                                                                          
 var node$2584535699: Node;                                                                         
 var this4535699_bottom: OptimisticList;                                                            
 var tmp264535566_bottom: bool;                                                                     
 var Node.next4535566_bottom: [Node]Node;                                                           
 var $pc4535731: Phase;                                                                             
 var tmp264535699: bool;                                                                            
 var this4535743: OptimisticList;                                                                   
 var tmp264535566: bool;                                                                            
 var Node._state4535699_bottom: [Node]State;                                                        
 var Node._state4535563_post: [Node]State;                                                          
 var moverPath4535562: MoverPath;                                                                   
 var this4535535: OptimisticList;                                                                   
 var Node.item4535545: [Node]int;                                                                   
 var OptimisticList.head4535674_post: [OptimisticList]Node;                                         
 var Node._lock4535619: [Node]Tid;                                                                  
 var Node.next4535613: [Node]Node;                                                                  
 var this$2584535656: OptimisticList;                                                               
 var tmp274535563_post: bool;                                                                       
 var OptimisticList.head4535545: [OptimisticList]Node;                                              
 var Node._lock4535566_bottom: [Node]Tid;                                                           
 var Node._state4535529: [Node]State;                                                               
 var $pc4535559: Phase;                                                                             
 var $recorded.state4535656: int;                                                                   
 var OptimisticList._state4535731: [OptimisticList]State;                                           
 var Node.next4535753: [Node]Node;                                                                  
 var curr4535559_post: Node;                                                                        
 var Node.item4535562: [Node]int;                                                                   
 var Node.next4535563_post: [Node]Node;                                                             
 var OptimisticList._lock4535562: [OptimisticList]Tid;                                              
 var mover4535601: Mover;                                                                           
 var $recorded.state4535602: int;                                                                   
 var moverPath4535529: MoverPath;                                                                   
 var tmp4$2584535674_post: bool;                                                                    
 var OptimisticList._state4535656: [OptimisticList]State;                                           
 var moverPath4535619: MoverPath;                                                                   
 var $result4535559_post: bool;                                                                     
 var tid4535619: Tid;                                                                               
 var $result4535535: bool;                                                                          
 var $recorded.state4535602_post: int;                                                              
 var $pc4535656: Phase;                                                                             
 var tid4535529: Tid;                                                                               
 var b4535743: bool;                                                                                
 var item4535699_bottom: int;                                                                       
 var curr$2584535656: Node;                                                                         
 var Node._lock4535562: [Node]Tid;                                                                  
 var Node._lock4535566: [Node]Tid;                                                                  
 var Node.item4535536: [Node]int;                                                                   
 var tid4535563: Tid;                                                                               
 var pred$2584535656: Node;                                                                         
 var OptimisticList.head4535753: [OptimisticList]Node;                                              
 var this4535559_post: OptimisticList;                                                              
 var this$2584535602: OptimisticList;                                                               
 var OptimisticList._lock4535602: [OptimisticList]Tid;                                              
 var b: bool;                                                                                       
 var item$2584535674_post: int;                                                                     
 var tmp294535619: bool;                                                                            
 var $recorded.state4535674_post: int;                                                              
 var tmp264535602: bool;                                                                            
 var OptimisticList.head4535731: [OptimisticList]Node;                                              
 var this4535750: OptimisticList;                                                                   
 var Node._lock4535559_post: [Node]Tid;                                                             
 var this$2584535674: OptimisticList;                                                               
 var Node.next4535699_bottom: [Node]Node;                                                           
 var node$2584535674: Node;                                                                         
 var item4535529: int;                                                                              
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true;                                                                                              // (83.25): Can only have right-mover memory accesses in requires clause
                                                                                                    
 assume Node._state4535750 == Node._state && Node.item4535750 == Node.item && Node.next4535750 == Node.next && Node._lock4535750 == Node._lock && OptimisticList._state4535750 == OptimisticList._state && OptimisticList.head4535750 == OptimisticList.head && OptimisticList._lock4535750 == OptimisticList._lock && $result4535750 == $result && item4535750 == item && this4535750 == this && tid4535750 == tid;
 assume $recorded.state4535750 == 1;                                                                
                                                                                                    
 // 85.8: while (true)   {                                                                          
                                                                                                    
 phase4535750 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (83.6): Bad tid
  invariant isShared(OptimisticList._state[this]);                                                         // (83.6): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (85.8): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (85.8): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (85.8): Object invariant may not hold.
  invariant  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (85.8): Object invariant may not hold.
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state4535750,Node.item4535750,Node.next4535750,Node._lock4535750,OptimisticList._state4535750,OptimisticList.head4535750,OptimisticList._lock4535750));       // (85.8): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state4535750,Node.item4535750,Node.next4535750,Node._lock4535750,OptimisticList._state4535750,OptimisticList.head4535750,OptimisticList._lock4535750));       // (85.8): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : OptimisticList :: Invariant.Y_OptimisticList.head(tid : Tid, _this, OptimisticList.head[_this] ,Node._state4535750,Node.item4535750,Node.next4535750,Node._lock4535750,OptimisticList._state4535750,OptimisticList.head4535750,OptimisticList._lock4535750));       // (85.8): Loop does not preserve yields_as annotation for field head
  invariant phase4535750 == $pc;                                                                           // (85.8): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (85.8): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 85.15: boolean tmp26;                                                                          
                                                                                                    
                                                                                                    
  // 85.15: tmp26 = true;                                                                           
                                                                                                    
  tmp26 := true;                                                                                    
  if (!(tmp26)) {                                                                                   
                                                                                                    
   // 85.8: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 86.10: Node pred;                                                                              
                                                                                                    
                                                                                                    
  // 86.10: pred := this.head;                                                                      
                                                                                                    
                                                                                                    
  moverPath4535529 := ReadEval.OptimisticList.head(tid: Tid,this: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
  mover4535529 := m#moverPath(moverPath4535529);                                                    
  path4535529 := p#moverPath(moverPath4535529);                                                     
  assume Node._state4535529 == Node._state && Node.item4535529 == Node.item && Node.next4535529 == Node.next && Node._lock4535529 == Node._lock && OptimisticList._state4535529 == OptimisticList._state && OptimisticList.head4535529 == OptimisticList.head && OptimisticList._lock4535529 == OptimisticList._lock && pred4535529 == pred && tmp264535529 == tmp26 && $result4535529 == $result && item4535529 == item && this4535529 == this && tid4535529 == tid && $pc4535529 == $pc;
  assume $recorded.state4535529 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != OptimisticList.null;                                                              
  } else {                                                                                          
   assert this != OptimisticList.null;                                                                     // (86.10): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4535529);                                                             
  assert $pc != PhaseError;                                                                                // (86.10): Reduction failure
  pred := OptimisticList.head[this];                                                                
                                                                                                    
  // 87.10: Node curr;                                                                              
                                                                                                    
                                                                                                    
  // 87.10: curr := pred.next;                                                                      
                                                                                                    
                                                                                                    
  moverPath4535535 := ReadEval.Node.next(tid: Tid,pred: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
  mover4535535 := m#moverPath(moverPath4535535);                                                    
  path4535535 := p#moverPath(moverPath4535535);                                                     
  assume Node._state4535535 == Node._state && Node.item4535535 == Node.item && Node.next4535535 == Node.next && Node._lock4535535 == Node._lock && OptimisticList._state4535535 == OptimisticList._state && OptimisticList.head4535535 == OptimisticList.head && OptimisticList._lock4535535 == OptimisticList._lock && curr4535535 == curr && pred4535535 == pred && tmp264535535 == tmp26 && $result4535535 == $result && item4535535 == item && this4535535 == this && tid4535535 == tid && $pc4535535 == $pc;
  assume $recorded.state4535535 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume pred != Node.null;                                                                        
  } else {                                                                                          
   assert pred != Node.null;                                                                               // (87.10): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4535535);                                                             
  assert $pc != PhaseError;                                                                                // (87.10): Reduction failure
  curr := Node.next[pred];                                                                          
                                                                                                    
  // 88.10: yield;                                                                                  
                                                                                                    
  assume Node._state4535536 == Node._state && Node.item4535536 == Node.item && Node.next4535536 == Node.next && Node._lock4535536 == Node._lock && OptimisticList._state4535536 == OptimisticList._state && OptimisticList.head4535536 == OptimisticList.head && OptimisticList._lock4535536 == OptimisticList._lock && curr4535536 == curr && pred4535536 == pred && tmp264535536 == tmp26 && $result4535536 == $result && item4535536 == item && this4535536 == this && tid4535536 == tid;
  assume $recorded.state4535536 == 1;                                                               
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (88.10): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (88.10): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (88.10): Object invariant may not hold.
  assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (88.10): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (88.10): Object invariant may not hold.
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (88.10): Object invariant may not hold.
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (88.10): Object invariant may not hold.
  assume  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (88.10): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Node._state4535536_post == Node._state && Node.item4535536_post == Node.item && Node.next4535536_post == Node.next && Node._lock4535536_post == Node._lock && OptimisticList._state4535536_post == OptimisticList._state && OptimisticList.head4535536_post == OptimisticList.head && OptimisticList._lock4535536_post == OptimisticList._lock && curr4535536_post == curr && pred4535536_post == pred && tmp264535536_post == tmp26 && $result4535536_post == $result && item4535536_post == item && this4535536_post == this && tid4535536_post == tid;
  assume $recorded.state4535536_post == 1;                                                          
  assume Node._state4535566 == Node._state && Node.item4535566 == Node.item && Node.next4535566 == Node.next && Node._lock4535566 == Node._lock && OptimisticList._state4535566 == OptimisticList._state && OptimisticList.head4535566 == OptimisticList.head && OptimisticList._lock4535566 == OptimisticList._lock && curr4535566 == curr && pred4535566 == pred && tmp264535566 == tmp26 && $result4535566 == $result && item4535566 == item && this4535566 == this && tid4535566 == tid;
  assume $recorded.state4535566 == 1;                                                               
                                                                                                    
  // 89.10: while (true)                                                                            
                                                                                                    
  phase4535566 := $pc;                                                                              
  while (true)                                                                                      
                                                                                                    
   invariant ValidTid(tid);                                                                                // (83.6): Bad tid
   invariant isShared(OptimisticList._state[this]);                                                        // (83.6): this is not global
                                                                                                    
   invariant StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
   invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (89.10): Object invariant may not hold.
   invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (89.10): Object invariant may not hold.
   invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (89.10): Object invariant may not hold.
   invariant  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (89.10): Object invariant may not hold.
   invariant isShared(Node._state[curr]);                                                           
   invariant isShared(Node._state[pred]);                                                           
   invariant (Node.item[pred]<item);                                                                
   invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state4535566,Node.item4535566,Node.next4535566,Node._lock4535566,OptimisticList._state4535566,OptimisticList.head4535566,OptimisticList._lock4535566));       // (89.10): Loop does not preserve yields_as annotation for field item
   invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state4535566,Node.item4535566,Node.next4535566,Node._lock4535566,OptimisticList._state4535566,OptimisticList.head4535566,OptimisticList._lock4535566));       // (89.10): Loop does not preserve yields_as annotation for field next
   invariant (forall _this : OptimisticList :: Invariant.Y_OptimisticList.head(tid : Tid, _this, OptimisticList.head[_this] ,Node._state4535566,Node.item4535566,Node.next4535566,Node._lock4535566,OptimisticList._state4535566,OptimisticList.head4535566,OptimisticList._lock4535566));       // (89.10): Loop does not preserve yields_as annotation for field head
   invariant phase4535566 == $pc;                                                                          // (89.10): Phase must be invariant at loop head
   invariant $pc == PreCommit;                                                                             // (89.10): Potentially infinite loop cannot be in post-commit phase.
  {                                                                                                 
                                                                                                    
   // 89.27: boolean tmp27;                                                                         
                                                                                                    
                                                                                                    
   // 89.17: int tmp28;                                                                             
                                                                                                    
                                                                                                    
   // 89.17: tmp28 := curr.item;                                                                    
                                                                                                    
                                                                                                    
   moverPath4535545 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535545 := m#moverPath(moverPath4535545);                                                   
   path4535545 := p#moverPath(moverPath4535545);                                                    
   assume Node._state4535545 == Node._state && Node.item4535545 == Node.item && Node.next4535545 == Node.next && Node._lock4535545 == Node._lock && OptimisticList._state4535545 == OptimisticList._state && OptimisticList.head4535545 == OptimisticList.head && OptimisticList._lock4535545 == OptimisticList._lock && tmp284535545 == tmp28 && tmp274535545 == tmp27 && curr4535545 == curr && pred4535545 == pred && tmp264535545 == tmp26 && $result4535545 == $result && item4535545 == item && this4535545 == this && tid4535545 == tid && $pc4535545 == $pc;
   assume $recorded.state4535545 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume curr != Node.null;                                                                       
   } else {                                                                                         
    assert curr != Node.null;                                                                              // (89.17): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535545);                                                            
   assert $pc != PhaseError;                                                                               // (89.17): Reduction failure
   tmp28 := Node.item[curr];                                                                        
                                                                                                    
   // 89.27: tmp27 = tmp28 < item;                                                                  
                                                                                                    
   tmp27 := (tmp28<item);                                                                           
   if (!(tmp27)) {                                                                                  
                                                                                                    
    // 89.10: break;                                                                                
                                                                                                    
    break;                                                                                          
   } else {                                                                                         
   }                                                                                                
                                                                                                    
   // 94.12: pred = curr;                                                                           
                                                                                                    
   pred := curr;                                                                                    
                                                                                                    
   // 95.12: yield;                                                                                 
                                                                                                    
   assume Node._state4535559 == Node._state && Node.item4535559 == Node.item && Node.next4535559 == Node.next && Node._lock4535559 == Node._lock && OptimisticList._state4535559 == OptimisticList._state && OptimisticList.head4535559 == OptimisticList.head && OptimisticList._lock4535559 == OptimisticList._lock && tmp284535559 == tmp28 && tmp274535559 == tmp27 && curr4535559 == curr && pred4535559 == pred && tmp264535559 == tmp26 && $result4535559 == $result && item4535559 == item && this4535559 == this && tid4535559 == tid;
   assume $recorded.state4535559 == 1;                                                              
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (95.12): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (95.12): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (95.12): Object invariant may not hold.
   assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (95.12): Object invariant may not hold.
   call Yield(tid);                                                                                 
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (95.12): Object invariant may not hold.
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (95.12): Object invariant may not hold.
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (95.12): Object invariant may not hold.
   assume  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (95.12): Object invariant may not hold.
   $pc := PreCommit;                                                                                
   assume Node._state4535559_post == Node._state && Node.item4535559_post == Node.item && Node.next4535559_post == Node.next && Node._lock4535559_post == Node._lock && OptimisticList._state4535559_post == OptimisticList._state && OptimisticList.head4535559_post == OptimisticList.head && OptimisticList._lock4535559_post == OptimisticList._lock && tmp284535559_post == tmp28 && tmp274535559_post == tmp27 && curr4535559_post == curr && pred4535559_post == pred && tmp264535559_post == tmp26 && $result4535559_post == $result && item4535559_post == item && this4535559_post == this && tid4535559_post == tid;
   assume $recorded.state4535559_post == 1;                                                         
                                                                                                    
   // 96.12: curr := curr.next;                                                                     
                                                                                                    
                                                                                                    
   moverPath4535562 := ReadEval.Node.next(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535562 := m#moverPath(moverPath4535562);                                                   
   path4535562 := p#moverPath(moverPath4535562);                                                    
   assume Node._state4535562 == Node._state && Node.item4535562 == Node.item && Node.next4535562 == Node.next && Node._lock4535562 == Node._lock && OptimisticList._state4535562 == OptimisticList._state && OptimisticList.head4535562 == OptimisticList.head && OptimisticList._lock4535562 == OptimisticList._lock && tmp284535562 == tmp28 && tmp274535562 == tmp27 && curr4535562 == curr && pred4535562 == pred && tmp264535562 == tmp26 && $result4535562 == $result && item4535562 == item && this4535562 == this && tid4535562 == tid && $pc4535562 == $pc;
   assume $recorded.state4535562 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume curr != Node.null;                                                                       
   } else {                                                                                         
    assert curr != Node.null;                                                                              // (96.12): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535562);                                                            
   assert $pc != PhaseError;                                                                               // (96.12): Reduction failure
   curr := Node.next[curr];                                                                         
                                                                                                    
   // 97.12: yield;                                                                                 
                                                                                                    
   assume Node._state4535563 == Node._state && Node.item4535563 == Node.item && Node.next4535563 == Node.next && Node._lock4535563 == Node._lock && OptimisticList._state4535563 == OptimisticList._state && OptimisticList.head4535563 == OptimisticList.head && OptimisticList._lock4535563 == OptimisticList._lock && tmp284535563 == tmp28 && tmp274535563 == tmp27 && curr4535563 == curr && pred4535563 == pred && tmp264535563 == tmp26 && $result4535563 == $result && item4535563 == item && this4535563 == this && tid4535563 == tid;
   assume $recorded.state4535563 == 1;                                                              
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (97.12): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (97.12): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (97.12): Object invariant may not hold.
   assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (97.12): Object invariant may not hold.
   call Yield(tid);                                                                                 
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (97.12): Object invariant may not hold.
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (97.12): Object invariant may not hold.
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (97.12): Object invariant may not hold.
   assume  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (97.12): Object invariant may not hold.
   $pc := PreCommit;                                                                                
   assume Node._state4535563_post == Node._state && Node.item4535563_post == Node.item && Node.next4535563_post == Node.next && Node._lock4535563_post == Node._lock && OptimisticList._state4535563_post == OptimisticList._state && OptimisticList.head4535563_post == OptimisticList.head && OptimisticList._lock4535563_post == OptimisticList._lock && tmp284535563_post == tmp28 && tmp274535563_post == tmp27 && curr4535563_post == curr && pred4535563_post == pred && tmp264535563_post == tmp26 && $result4535563_post == $result && item4535563_post == item && this4535563_post == this && tid4535563_post == tid;
   assume $recorded.state4535563_post == 1;                                                         
   assume Node._state4535566_bottom == Node._state && Node.item4535566_bottom == Node.item && Node.next4535566_bottom == Node.next && Node._lock4535566_bottom == Node._lock && OptimisticList._state4535566_bottom == OptimisticList._state && OptimisticList.head4535566_bottom == OptimisticList.head && OptimisticList._lock4535566_bottom == OptimisticList._lock && curr4535566_bottom == curr && pred4535566_bottom == pred && tmp264535566_bottom == tmp26 && $result4535566_bottom == $result && item4535566_bottom == item && this4535566_bottom == this && tid4535566_bottom == tid;
   assume $recorded.state4535566_bottom == 1;                                                       
   assert phase4535566 == $pc;                                                                             // (89.10): Phase must be invariant at loop head
  }                                                                                                 
  if ($pc == PreCommit) {                                                                           
   assume pred != Node.null;                                                                        
  } else {                                                                                          
   assert pred != Node.null;                                                                               // (99.10): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assume Node._lock[pred] == Tid.null;                                                              
  $pc := transition($pc, _R);                                                                       
  assert $pc != PhaseError;                                                                                // (99.10): Reduction failure
  Node._lock[pred] := tid;                                                                          
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (100.10): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assume Node._lock[curr] == Tid.null;                                                              
  $pc := transition($pc, _R);                                                                       
  assert $pc != PhaseError;                                                                                // (100.10): Reduction failure
  Node._lock[curr] := tid;                                                                          
                                                                                                    
  // 101.10: boolean tmp29;                                                                         
                                                                                                    
  // inlined: this.validate(pred,curr,item)}                                                        
  exit$258_top:                                                                                     
                                                                                                    
  // 101.10: Node pred$258;                                                                         
                                                                                                    
                                                                                                    
  // 101.10: Node curr$258;                                                                         
                                                                                                    
                                                                                                    
  // 101.10: int item$258;                                                                          
                                                                                                    
                                                                                                    
  // 101.10: OptimisticList this$258;                                                               
                                                                                                    
                                                                                                    
  // 101.10: pred$258 = pred;                                                                       
                                                                                                    
  pred$258 := pred;                                                                                 
                                                                                                    
  // 101.10: curr$258 = curr;                                                                       
                                                                                                    
  curr$258 := curr;                                                                                 
                                                                                                    
  // 101.10: item$258 = item;                                                                       
                                                                                                    
  item$258 := item;                                                                                 
                                                                                                    
  // 101.10: this$258 = this;                                                                       
                                                                                                    
  this$258 := this;                                                                                 
                                                                                                    
  // 17.9: Node node$258;                                                                           
                                                                                                    
                                                                                                    
  // 17.9: node$258 := this$258.head;                                                               
                                                                                                    
                                                                                                    
  moverPath4535601 := ReadEval.OptimisticList.head(tid: Tid,this$258: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
  mover4535601 := m#moverPath(moverPath4535601);                                                    
  path4535601 := p#moverPath(moverPath4535601);                                                     
  assume Node._state4535601 == Node._state && Node.item4535601 == Node.item && Node.next4535601 == Node.next && Node._lock4535601 == Node._lock && OptimisticList._state4535601 == OptimisticList._state && OptimisticList.head4535601 == OptimisticList.head && OptimisticList._lock4535601 == OptimisticList._lock && node$2584535601 == node$258 && this$2584535601 == this$258 && item$2584535601 == item$258 && curr$2584535601 == curr$258 && pred$2584535601 == pred$258 && tmp294535601 == tmp29 && curr4535601 == curr && pred4535601 == pred && tmp264535601 == tmp26 && $result4535601 == $result && item4535601 == item && this4535601 == this && tid4535601 == tid && $pc4535601 == $pc;
  assume $recorded.state4535601 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this$258 != OptimisticList.null;                                                          
  } else {                                                                                          
   assert this$258 != OptimisticList.null;                                                                 // (17.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover4535601);                                                             
  assert $pc != PhaseError;                                                                                // (17.9): Reduction failure
  node$258 := OptimisticList.head[this$258];                                                        
                                                                                                    
  // 18.9: yield;                                                                                   
                                                                                                    
  assume Node._state4535602 == Node._state && Node.item4535602 == Node.item && Node.next4535602 == Node.next && Node._lock4535602 == Node._lock && OptimisticList._state4535602 == OptimisticList._state && OptimisticList.head4535602 == OptimisticList.head && OptimisticList._lock4535602 == OptimisticList._lock && node$2584535602 == node$258 && this$2584535602 == this$258 && item$2584535602 == item$258 && curr$2584535602 == curr$258 && pred$2584535602 == pred$258 && tmp294535602 == tmp29 && curr4535602 == curr && pred4535602 == pred && tmp264535602 == tmp26 && $result4535602 == $result && item4535602 == item && this4535602 == this && tid4535602 == tid;
  assume $recorded.state4535602 == 1;                                                               
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  assume  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (18.9): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Node._state4535602_post == Node._state && Node.item4535602_post == Node.item && Node.next4535602_post == Node.next && Node._lock4535602_post == Node._lock && OptimisticList._state4535602_post == OptimisticList._state && OptimisticList.head4535602_post == OptimisticList.head && OptimisticList._lock4535602_post == OptimisticList._lock && node$2584535602_post == node$258 && this$2584535602_post == this$258 && item$2584535602_post == item$258 && curr$2584535602_post == curr$258 && pred$2584535602_post == pred$258 && tmp294535602_post == tmp29 && curr4535602_post == curr && pred4535602_post == pred && tmp264535602_post == tmp26 && $result4535602_post == $result && item4535602_post == item && this4535602_post == this && tid4535602_post == tid;
  assume $recorded.state4535602_post == 1;                                                          
  assume Node._state4535699 == Node._state && Node.item4535699 == Node.item && Node.next4535699 == Node.next && Node._lock4535699 == Node._lock && OptimisticList._state4535699 == OptimisticList._state && OptimisticList.head4535699 == OptimisticList.head && OptimisticList._lock4535699 == OptimisticList._lock && node$2584535699 == node$258 && this$2584535699 == this$258 && item$2584535699 == item$258 && curr$2584535699 == curr$258 && pred$2584535699 == pred$258 && tmp294535699 == tmp29 && curr4535699 == curr && pred4535699 == pred && tmp264535699 == tmp26 && $result4535699 == $result && item4535699 == item && this4535699 == this && tid4535699 == tid;
  assume $recorded.state4535699 == 1;                                                               
                                                                                                    
  // 19.9: while (true)                                                                             
                                                                                                    
  phase4535699 := $pc;                                                                              
  while (true)                                                                                      
                                                                                                    
   invariant ValidTid(tid);                                                                                // (83.6): Bad tid
   invariant isShared(OptimisticList._state[this]);                                                        // (83.6): this is not global
                                                                                                    
   invariant StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
   invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (19.9): Object invariant may not hold.
   invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (19.9): Object invariant may not hold.
   invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (19.9): Object invariant may not hold.
   invariant  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (19.9): Object invariant may not hold.
   invariant isShared(Node._state[node$258]);                                                       
   invariant isShared(Node._state[curr$258]);                                                       
   invariant isShared(Node._state[pred$258]);                                                       
   invariant (isAccessible(Node._state[curr$258], tid) && Node._lock[curr$258] == tid);             
   invariant (isAccessible(Node._state[pred$258], tid) && Node._lock[pred$258] == tid);             
   invariant (Node.item[pred$258]<item$258);                                                        
   invariant (Node.item[curr$258]>=item$258);                                                       
   invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state4535699,Node.item4535699,Node.next4535699,Node._lock4535699,OptimisticList._state4535699,OptimisticList.head4535699,OptimisticList._lock4535699));       // (19.9): Loop does not preserve yields_as annotation for field item
   invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state4535699,Node.item4535699,Node.next4535699,Node._lock4535699,OptimisticList._state4535699,OptimisticList.head4535699,OptimisticList._lock4535699));       // (19.9): Loop does not preserve yields_as annotation for field next
   invariant (forall _this : OptimisticList :: Invariant.Y_OptimisticList.head(tid : Tid, _this, OptimisticList.head[_this] ,Node._state4535699,Node.item4535699,Node.next4535699,Node._lock4535699,OptimisticList._state4535699,OptimisticList.head4535699,OptimisticList._lock4535699));       // (19.9): Loop does not preserve yields_as annotation for field head
   invariant phase4535699 == $pc;                                                                          // (19.9): Phase must be invariant at loop head
   invariant $pc == PreCommit;                                                                             // (19.9): Potentially infinite loop cannot be in post-commit phase.
  {                                                                                                 
                                                                                                    
   // 19.26: boolean tmp1$258;                                                                      
                                                                                                    
                                                                                                    
   // 19.16: int tmp2$258;                                                                          
                                                                                                    
                                                                                                    
   // 19.16: tmp2$258 := node$258.item;                                                             
                                                                                                    
                                                                                                    
   moverPath4535613 := ReadEval.Node.item(tid: Tid,node$258: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535613 := m#moverPath(moverPath4535613);                                                   
   path4535613 := p#moverPath(moverPath4535613);                                                    
   assume Node._state4535613 == Node._state && Node.item4535613 == Node.item && Node.next4535613 == Node.next && Node._lock4535613 == Node._lock && OptimisticList._state4535613 == OptimisticList._state && OptimisticList.head4535613 == OptimisticList.head && OptimisticList._lock4535613 == OptimisticList._lock && tmp2$2584535613 == tmp2$258 && tmp1$2584535613 == tmp1$258 && node$2584535613 == node$258 && this$2584535613 == this$258 && item$2584535613 == item$258 && curr$2584535613 == curr$258 && pred$2584535613 == pred$258 && tmp294535613 == tmp29 && curr4535613 == curr && pred4535613 == pred && tmp264535613 == tmp26 && $result4535613 == $result && item4535613 == item && this4535613 == this && tid4535613 == tid && $pc4535613 == $pc;
   assume $recorded.state4535613 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume node$258 != Node.null;                                                                   
   } else {                                                                                         
    assert node$258 != Node.null;                                                                          // (19.16): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535613);                                                            
   assert $pc != PhaseError;                                                                               // (19.16): Reduction failure
   tmp2$258 := Node.item[node$258];                                                                 
                                                                                                    
   // 19.29: int tmp3$258;                                                                          
                                                                                                    
                                                                                                    
   // 19.29: tmp3$258 := pred$258.item;                                                             
                                                                                                    
                                                                                                    
   moverPath4535619 := ReadEval.Node.item(tid: Tid,pred$258: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535619 := m#moverPath(moverPath4535619);                                                   
   path4535619 := p#moverPath(moverPath4535619);                                                    
   assume Node._state4535619 == Node._state && Node.item4535619 == Node.item && Node.next4535619 == Node.next && Node._lock4535619 == Node._lock && OptimisticList._state4535619 == OptimisticList._state && OptimisticList.head4535619 == OptimisticList.head && OptimisticList._lock4535619 == OptimisticList._lock && tmp3$2584535619 == tmp3$258 && tmp2$2584535619 == tmp2$258 && tmp1$2584535619 == tmp1$258 && node$2584535619 == node$258 && this$2584535619 == this$258 && item$2584535619 == item$258 && curr$2584535619 == curr$258 && pred$2584535619 == pred$258 && tmp294535619 == tmp29 && curr4535619 == curr && pred4535619 == pred && tmp264535619 == tmp26 && $result4535619 == $result && item4535619 == item && this4535619 == this && tid4535619 == tid && $pc4535619 == $pc;
   assume $recorded.state4535619 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume pred$258 != Node.null;                                                                   
   } else {                                                                                         
    assert pred$258 != Node.null;                                                                          // (19.29): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535619);                                                            
   assert $pc != PhaseError;                                                                               // (19.29): Reduction failure
   tmp3$258 := Node.item[pred$258];                                                                 
                                                                                                    
   // 19.26: tmp1$258 = tmp2$258 <= tmp3$258;                                                       
                                                                                                    
   tmp1$258 := (tmp2$258<=tmp3$258);                                                                
   if (!(tmp1$258)) {                                                                               
                                                                                                    
    // 19.9: break;                                                                                 
                                                                                                    
    break;                                                                                          
   } else {                                                                                         
   }                                                                                                
                                                                                                    
   // 28.11: boolean tmp4$258;                                                                      
                                                                                                    
                                                                                                    
   // 28.11: tmp4$258 = node$258 == pred$258;                                                       
                                                                                                    
   tmp4$258 := (node$258==pred$258);                                                                
   if (tmp4$258 /* lowered (node$258==pred$258) */) {                                               
                                                                                                    
    // 29.13: boolean tmp5$258;                                                                     
                                                                                                    
                                                                                                    
    // 29.13: Node tmp6$258;                                                                        
                                                                                                    
                                                                                                    
    // 29.13: tmp6$258 := pred$258.next;                                                            
                                                                                                    
                                                                                                    
    moverPath4535656 := ReadEval.Node.next(tid: Tid,pred$258: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
    mover4535656 := m#moverPath(moverPath4535656);                                                  
    path4535656 := p#moverPath(moverPath4535656);                                                   
    assume Node._state4535656 == Node._state && Node.item4535656 == Node.item && Node.next4535656 == Node.next && Node._lock4535656 == Node._lock && OptimisticList._state4535656 == OptimisticList._state && OptimisticList.head4535656 == OptimisticList.head && OptimisticList._lock4535656 == OptimisticList._lock && tmp6$2584535656 == tmp6$258 && tmp5$2584535656 == tmp5$258 && tmp4$2584535656 == tmp4$258 && tmp3$2584535656 == tmp3$258 && tmp2$2584535656 == tmp2$258 && tmp1$2584535656 == tmp1$258 && node$2584535656 == node$258 && this$2584535656 == this$258 && item$2584535656 == item$258 && curr$2584535656 == curr$258 && pred$2584535656 == pred$258 && tmp294535656 == tmp29 && curr4535656 == curr && pred4535656 == pred && tmp264535656 == tmp26 && $result4535656 == $result && item4535656 == item && this4535656 == this && tid4535656 == tid && $pc4535656 == $pc;
    assume $recorded.state4535656 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume pred$258 != Node.null;                                                                  
    } else {                                                                                        
     assert pred$258 != Node.null;                                                                         // (29.13): Cannot have potential null deference in left-mover part.
    }                                                                                               
                                                                                                    
    $pc := transition($pc, mover4535656);                                                           
    assert $pc != PhaseError;                                                                              // (29.13): Reduction failure
    tmp6$258 := Node.next[pred$258];                                                                
                                                                                                    
    // 29.13: tmp5$258 = tmp6$258 == curr$258;                                                      
                                                                                                    
    tmp5$258 := (tmp6$258==curr$258);                                                               
                                                                                                    
    // 29.13: tmp29 = tmp5$258;                                                                     
                                                                                                    
    tmp29 := tmp5$258;                                                                              
                                                                                                    
    // 29.13: break exit$258;                                                                       
                                                                                                    
    goto exit$258_bottom;                                                                           
   } else {                                                                                         
   }                                                                                                
                                                                                                    
   // 31.11: node$258 := node$258.next;                                                             
                                                                                                    
                                                                                                    
   moverPath4535673 := ReadEval.Node.next(tid: Tid,node$258: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535673 := m#moverPath(moverPath4535673);                                                   
   path4535673 := p#moverPath(moverPath4535673);                                                    
   assume Node._state4535673 == Node._state && Node.item4535673 == Node.item && Node.next4535673 == Node.next && Node._lock4535673 == Node._lock && OptimisticList._state4535673 == OptimisticList._state && OptimisticList.head4535673 == OptimisticList.head && OptimisticList._lock4535673 == OptimisticList._lock && tmp4$2584535673 == tmp4$258 && tmp3$2584535673 == tmp3$258 && tmp2$2584535673 == tmp2$258 && tmp1$2584535673 == tmp1$258 && node$2584535673 == node$258 && this$2584535673 == this$258 && item$2584535673 == item$258 && curr$2584535673 == curr$258 && pred$2584535673 == pred$258 && tmp294535673 == tmp29 && curr4535673 == curr && pred4535673 == pred && tmp264535673 == tmp26 && $result4535673 == $result && item4535673 == item && this4535673 == this && tid4535673 == tid && $pc4535673 == $pc;
   assume $recorded.state4535673 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume node$258 != Node.null;                                                                   
   } else {                                                                                         
    assert node$258 != Node.null;                                                                          // (31.11): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535673);                                                            
   assert $pc != PhaseError;                                                                               // (31.11): Reduction failure
   node$258 := Node.next[node$258];                                                                 
                                                                                                    
   // 32.11: yield;                                                                                 
                                                                                                    
   assume Node._state4535674 == Node._state && Node.item4535674 == Node.item && Node.next4535674 == Node.next && Node._lock4535674 == Node._lock && OptimisticList._state4535674 == OptimisticList._state && OptimisticList.head4535674 == OptimisticList.head && OptimisticList._lock4535674 == OptimisticList._lock && tmp4$2584535674 == tmp4$258 && tmp3$2584535674 == tmp3$258 && tmp2$2584535674 == tmp2$258 && tmp1$2584535674 == tmp1$258 && node$2584535674 == node$258 && this$2584535674 == this$258 && item$2584535674 == item$258 && curr$2584535674 == curr$258 && pred$2584535674 == pred$258 && tmp294535674 == tmp29 && curr4535674 == curr && pred4535674 == pred && tmp264535674 == tmp26 && $result4535674 == $result && item4535674 == item && this4535674 == this && tid4535674 == tid;
   assume $recorded.state4535674 == 1;                                                              
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   call Yield(tid);                                                                                 
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   assume  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   assume  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (32.11): Object invariant may not hold.
   $pc := PreCommit;                                                                                
   assume Node._state4535674_post == Node._state && Node.item4535674_post == Node.item && Node.next4535674_post == Node.next && Node._lock4535674_post == Node._lock && OptimisticList._state4535674_post == OptimisticList._state && OptimisticList.head4535674_post == OptimisticList.head && OptimisticList._lock4535674_post == OptimisticList._lock && tmp4$2584535674_post == tmp4$258 && tmp3$2584535674_post == tmp3$258 && tmp2$2584535674_post == tmp2$258 && tmp1$2584535674_post == tmp1$258 && node$2584535674_post == node$258 && this$2584535674_post == this$258 && item$2584535674_post == item$258 && curr$2584535674_post == curr$258 && pred$2584535674_post == pred$258 && tmp294535674_post == tmp29 && curr4535674_post == curr && pred4535674_post == pred && tmp264535674_post == tmp26 && $result4535674_post == $result && item4535674_post == item && this4535674_post == this && tid4535674_post == tid;
   assume $recorded.state4535674_post == 1;                                                         
   assume Node._state4535699_bottom == Node._state && Node.item4535699_bottom == Node.item && Node.next4535699_bottom == Node.next && Node._lock4535699_bottom == Node._lock && OptimisticList._state4535699_bottom == OptimisticList._state && OptimisticList.head4535699_bottom == OptimisticList.head && OptimisticList._lock4535699_bottom == OptimisticList._lock && node$2584535699_bottom == node$258 && this$2584535699_bottom == this$258 && item$2584535699_bottom == item$258 && curr$2584535699_bottom == curr$258 && pred$2584535699_bottom == pred$258 && tmp294535699_bottom == tmp29 && curr4535699_bottom == curr && pred4535699_bottom == pred && tmp264535699_bottom == tmp26 && $result4535699_bottom == $result && item4535699_bottom == item && this4535699_bottom == this && tid4535699_bottom == tid;
   assume $recorded.state4535699_bottom == 1;                                                       
   assert phase4535699 == $pc;                                                                             // (19.9): Phase must be invariant at loop head
  }                                                                                                 
                                                                                                    
  // 34.9: tmp29 = false;                                                                           
                                                                                                    
  tmp29 := false;                                                                                   
                                                                                                    
  // 34.9: break exit$258;                                                                          
                                                                                                    
  goto exit$258_bottom;                                                                             
                                                                                                    
  // 16.54: tmp29 = false;                                                                          
                                                                                                    
  tmp29 := false;                                                                                   
                                                                                                    
  // 16.54: break exit$258;                                                                         
                                                                                                    
  goto exit$258_bottom;                                                                             
  exit$258_bottom:                                                                                  
  if (tmp29) {                                                                                      
                                                                                                    
   // 102.12: boolean b;                                                                            
                                                                                                    
                                                                                                    
   // 102.12: int tmp30;                                                                            
                                                                                                    
                                                                                                    
   // 102.12: tmp30 := curr.item;                                                                   
                                                                                                    
                                                                                                    
   moverPath4535731 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
   mover4535731 := m#moverPath(moverPath4535731);                                                   
   path4535731 := p#moverPath(moverPath4535731);                                                    
   assume Node._state4535731 == Node._state && Node.item4535731 == Node.item && Node.next4535731 == Node.next && Node._lock4535731 == Node._lock && OptimisticList._state4535731 == OptimisticList._state && OptimisticList.head4535731 == OptimisticList.head && OptimisticList._lock4535731 == OptimisticList._lock && tmp304535731 == tmp30 && b4535731 == b && tmp294535731 == tmp29 && curr4535731 == curr && pred4535731 == pred && tmp264535731 == tmp26 && $result4535731 == $result && item4535731 == item && this4535731 == this && tid4535731 == tid && $pc4535731 == $pc;
   assume $recorded.state4535731 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume curr != Node.null;                                                                       
   } else {                                                                                         
    assert curr != Node.null;                                                                              // (102.12): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover4535731);                                                            
   assert $pc != PhaseError;                                                                               // (102.12): Reduction failure
   tmp30 := Node.item[curr];                                                                        
                                                                                                    
   // 102.12: b = tmp30 == item;                                                                    
                                                                                                    
   b := (tmp30==item);                                                                              
   if ($pc == PreCommit) {                                                                          
    assume curr != Node.null;                                                                       
   } else {                                                                                         
    assert curr != Node.null;                                                                              // (103.12): Cannot have potential null deference in left-mover part.
   }                                                                                                
   assert Node._lock[curr] == tid;                                                                         // (103.12): lock not held
   $pc := transition($pc, _L);                                                                      
   assert $pc != PhaseError;                                                                               // (103.12): Reduction failure
   Node._lock[curr] := Tid.null;                                                                    
   if ($pc == PreCommit) {                                                                          
    assume pred != Node.null;                                                                       
   } else {                                                                                         
    assert pred != Node.null;                                                                              // (104.12): Cannot have potential null deference in left-mover part.
   }                                                                                                
   assert Node._lock[pred] == tid;                                                                         // (104.12): lock not held
   $pc := transition($pc, _L);                                                                      
   assert $pc != PhaseError;                                                                               // (104.12): Reduction failure
   Node._lock[pred] := Tid.null;                                                                    
                                                                                                    
   // 105.12:  return b;                                                                            
                                                                                                    
   assume Node._state4535743 == Node._state && Node.item4535743 == Node.item && Node.next4535743 == Node.next && Node._lock4535743 == Node._lock && OptimisticList._state4535743 == OptimisticList._state && OptimisticList.head4535743 == OptimisticList.head && OptimisticList._lock4535743 == OptimisticList._lock && tmp304535743 == tmp30 && b4535743 == b && tmp294535743 == tmp29 && curr4535743 == curr && pred4535743 == pred && tmp264535743 == tmp26 && $result4535743 == $result && item4535743 == item && this4535743 == this && tid4535743 == tid;
   assume $recorded.state4535743 == 1;                                                              
   $result := b;                                                                                    
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (105.12): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (105.12): Object invariant may not hold.
   assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (105.12): Object invariant may not hold.
   assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (105.12): Object invariant may not hold.
   return;                                                                                          
  } else {                                                                                          
  }                                                                                                 
  assume Node._state4535750_bottom == Node._state && Node.item4535750_bottom == Node.item && Node.next4535750_bottom == Node.next && Node._lock4535750_bottom == Node._lock && OptimisticList._state4535750_bottom == OptimisticList._state && OptimisticList.head4535750_bottom == OptimisticList.head && OptimisticList._lock4535750_bottom == OptimisticList._lock && $result4535750_bottom == $result && item4535750_bottom == item && this4535750_bottom == this && tid4535750_bottom == tid;
  assume $recorded.state4535750_bottom == 1;                                                        
  assert phase4535750 == $pc;                                                                              // (85.8): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 84.40: // return false;                                                                         
                                                                                                    
 assume Node._state4535753 == Node._state && Node.item4535753 == Node.item && Node.next4535753 == Node.next && Node._lock4535753 == Node._lock && OptimisticList._state4535753 == OptimisticList._state && OptimisticList.head4535753 == OptimisticList.head && OptimisticList._lock4535753 == OptimisticList._lock && $result4535753 == $result && item4535753 == item && this4535753 == this && tid4535753 == tid;
 assume $recorded.state4535753 == 1;                                                                
 $result := false;                                                                                  
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (84.40): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (84.40): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (84.40): Object invariant may not hold.
 assert  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (84.40): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,OptimisticList._state: [OptimisticList]State,OptimisticList.head: [OptimisticList]Node,OptimisticList._lock: [OptimisticList]Tid) returns (bool) {
  true &&                                                                                           
  (forall _i: Node  :: _i == Node.null <==> isNull(Node._state[_i])) &&                             
  (forall _i: OptimisticList  :: _i == OptimisticList.null <==> isNull(OptimisticList._state[_i])) &&
  (forall _i: Node ::  (isShared(Node._state[_i]) ==> isSharedAssignable(Node._state[Node.next[_i]]))) &&
  (forall _i: Node ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Node._state[_i],_t) ==> isLocalAssignable(Node._state[Node.next[_i]], _t)))) &&
  (forall _i: OptimisticList ::  (isShared(OptimisticList._state[_i]) ==> isSharedAssignable(Node._state[OptimisticList.head[_i]]))) &&
  (forall _i: OptimisticList ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(OptimisticList._state[_i],_t) ==> isLocalAssignable(Node._state[OptimisticList.head[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)           
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (3.5): Node.item failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.item(u: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (3.5): Node.item failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 assume w == Node.item[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.item[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (3.5): Node.item failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)             
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 assume w == Node.item[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.item(u: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (3.5): Node.item failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)                 
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (3.5): Node.item failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)                  
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
 assume w == Node.item[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.item[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (3.5): Node.item failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)         
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (4.5): Node.next failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (4.5): Node.next failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (4.5): Node.next failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)           
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (4.5): Node.next failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)               
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (4.5): Node.next failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)                
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Node.next[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (4.5): Node.next failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, x: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(OptimisticList._state[x], u);                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 OptimisticList.head[x] := v;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.OptimisticList.head(u: Tid,x: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (13.5): OptimisticList.head failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, x: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(OptimisticList._state[x], u);                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 OptimisticList.head[x] := v;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.OptimisticList.head(u: Tid,x: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (13.5): OptimisticList.head failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, x: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(OptimisticList._state[x], u);                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == OptimisticList.head[x];                                                                
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 OptimisticList.head[x] := havocValue;                                                              
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.OptimisticList.head(u: Tid,x: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (13.5): OptimisticList.head failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, x: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(OptimisticList._state[x], u);                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == OptimisticList.head[x];                                                                
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.OptimisticList.head(u: Tid,x: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (13.5): OptimisticList.head failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, x: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(OptimisticList._state[x], u);                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.OptimisticList.head(t: Tid,x: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.OptimisticList.head(u: Tid,x: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (13.5): OptimisticList.head failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, x: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(OptimisticList._state[x], u);                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == OptimisticList.head[x];                                                                
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.OptimisticList.head(t: Tid,x: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 OptimisticList.head[x] := havocValue;                                                              
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.OptimisticList.head(u: Tid,x: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (13.5): OptimisticList.head failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.5): Node.item is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.item is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.item is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.item is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.item is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.item is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.5): Node.item is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.5): Node.next is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.item is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.item is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.item is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.5): Node.next is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.OptimisticList.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies Node.item;                                                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.item (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.OptimisticList.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies Node.item;                                                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var w0_mid: Node;                                                                                  
 var y_mid: OptimisticList;                                                                         
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 OptimisticList.head[y] := w;                                                                       
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to OptimisticList.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.OptimisticList.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies Node.item;                                                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var w0_mid: Node;                                                                                  
 var y_mid: OptimisticList;                                                                         
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 OptimisticList.head[y] := w;                                                                       
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to OptimisticList.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to OptimisticList.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.OptimisticList.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies Node.item;                                                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 OptimisticList.head[y] := w;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.item is not Read-Write Stable with respect to OptimisticList.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.item is not Read-Write Stable with respect to OptimisticList.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.item is not Read-Write Stable with respect to OptimisticList.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.OptimisticList.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies Node.item;                                                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: int;                                                                                   
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.OptimisticList.head(u: Tid,y: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.OptimisticList.head(u: Tid,y: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): OptimisticList.head is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): OptimisticList.head is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (13.5): OptimisticList.head is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.5): Node.item is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.item is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.item is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.5): Node.item is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies Node.next;                                                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies Node.next;                                                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var w0_mid: Node;                                                                                  
 var y_mid: OptimisticList;                                                                         
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 OptimisticList.head[y] := w;                                                                       
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to OptimisticList.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies Node.next;                                                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var w0_mid: Node;                                                                                  
 var y_mid: OptimisticList;                                                                         
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 OptimisticList.head[y] := w;                                                                       
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to OptimisticList.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to OptimisticList.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies Node.next;                                                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 OptimisticList.head[y] := w;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to OptimisticList.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to OptimisticList.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to OptimisticList.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies Node.next;                                                                                
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var x_pre: Node;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.OptimisticList.head(u: Tid,y: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.OptimisticList.head(u: Tid,y: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): OptimisticList.head is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): OptimisticList.head is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (13.5): OptimisticList.head is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.OptimisticList.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: OptimisticList, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(Node._state[y], u);                                                          
 modifies OptimisticList.head;                                                                      
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 OptimisticList.head[x] := v;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to OptimisticList.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.5): Node.item is not Write-Write Stable with respect to OptimisticList.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.5): Node.item is not Write-Write Stable with respect to OptimisticList.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.OptimisticList.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: OptimisticList, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(Node._state[y], u);                                                          
 modifies OptimisticList.head;                                                                      
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var x_mid: OptimisticList;                                                                         
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := OptimisticList.head[x];                                                                    
 OptimisticList.head[x] := v;                                                                       
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 OptimisticList.head[x] := tmpV;                                                                    
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.OptimisticList.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: OptimisticList, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(Node._state[y], u);                                                          
 modifies OptimisticList.head;                                                                      
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var x_mid: OptimisticList;                                                                         
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := OptimisticList.head[x];                                                                    
 OptimisticList.head[x] := v;                                                                       
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 OptimisticList.head[x] := tmpV;                                                                    
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.OptimisticList.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: OptimisticList, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(Node._state[y], u);                                                          
 modifies OptimisticList.head;                                                                      
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 _readByT := ReadEval.OptimisticList.head(t: Tid,x: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.OptimisticList.head(t: Tid,x: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Read-Write Stable with respect to Node.item (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.OptimisticList.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: OptimisticList, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(Node._state[y], u);                                                          
 modifies OptimisticList.head;                                                                      
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 OptimisticList.head[x] := v;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.item is not Write-Read Stable with respect to OptimisticList.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.item is not Write-Read Stable with respect to OptimisticList.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.5): Node.item is not Write-Read Stable with respect to OptimisticList.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.OptimisticList.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: OptimisticList, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(Node._state[y], u);                                                          
 modifies OptimisticList.head;                                                                      
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 OptimisticList.head[x] := v;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to OptimisticList.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.5): Node.next is not Write-Write Stable with respect to OptimisticList.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to OptimisticList.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.OptimisticList.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: OptimisticList, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(Node._state[y], u);                                                          
 modifies OptimisticList.head;                                                                      
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var x_mid: OptimisticList;                                                                         
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := OptimisticList.head[x];                                                                    
 OptimisticList.head[x] := v;                                                                       
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 OptimisticList.head[x] := tmpV;                                                                    
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.OptimisticList.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: OptimisticList, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(Node._state[y], u);                                                          
 modifies OptimisticList.head;                                                                      
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var x_mid: OptimisticList;                                                                         
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := OptimisticList.head[x];                                                                    
 OptimisticList.head[x] := v;                                                                       
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 OptimisticList.head[x] := tmpV;                                                                    
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.OptimisticList.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: OptimisticList, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(Node._state[y], u);                                                          
 modifies OptimisticList.head;                                                                      
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.OptimisticList.head(t: Tid,x: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.OptimisticList.head(t: Tid,x: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.OptimisticList.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: OptimisticList, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(Node._state[y], u);                                                          
 modifies OptimisticList.head;                                                                      
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 OptimisticList.head[x] := v;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to OptimisticList.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to OptimisticList.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.5): Node.next is not Write-Read Stable with respect to OptimisticList.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.OptimisticList.head.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: OptimisticList, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies OptimisticList.head;                                                                      
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 OptimisticList.head[x] := v;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to OptimisticList.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to OptimisticList.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to OptimisticList.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.OptimisticList.head.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: OptimisticList, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies OptimisticList.head;                                                                      
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var x_mid: OptimisticList;                                                                         
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var w0_mid: Node;                                                                                  
 var y_mid: OptimisticList;                                                                         
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := OptimisticList.head[x];                                                                    
 OptimisticList.head[x] := v;                                                                       
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 OptimisticList.head[x] := tmpV;                                                                    
 OptimisticList.head[y] := w;                                                                       
 _writeByTPost := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to OptimisticList.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.OptimisticList.head.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: OptimisticList, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies OptimisticList.head;                                                                      
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var OptimisticList._lock_mid: [OptimisticList]Tid;                                                 
 var x_mid: OptimisticList;                                                                         
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var v_mid: Node;                                                                                   
 var OptimisticList._state_mid: [OptimisticList]State;                                              
 var OptimisticList.head_mid: [OptimisticList]Node;                                                 
 var w0_mid: Node;                                                                                  
 var y_mid: OptimisticList;                                                                         
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := OptimisticList.head[x];                                                                    
 OptimisticList.head[x] := v;                                                                       
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && OptimisticList._state_mid == OptimisticList._state && OptimisticList.head_mid == OptimisticList.head && OptimisticList._lock_mid == OptimisticList._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 OptimisticList.head[x] := tmpV;                                                                    
 OptimisticList.head[y] := w;                                                                       
 _writeByTPost := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to OptimisticList.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Write-Write Stable with respect to OptimisticList.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.OptimisticList.head.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: OptimisticList, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies OptimisticList.head;                                                                      
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.OptimisticList.head(t: Tid,x: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.OptimisticList.head(u: Tid,y: OptimisticList,w: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 OptimisticList.head[y] := w;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.OptimisticList.head(t: Tid,x: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Read-Write Stable with respect to OptimisticList.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Read-Write Stable with respect to OptimisticList.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (13.5): OptimisticList.head is not Read-Write Stable with respect to OptimisticList.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.OptimisticList.head.OptimisticList.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: OptimisticList, y: OptimisticList)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(OptimisticList._state[x], t);                                                
 requires isAccessible(OptimisticList._state[y], u);                                                
 modifies OptimisticList.head;                                                                      
 modifies OptimisticList.head;                                                                      
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var OptimisticList._lock_pre: [OptimisticList]Tid;                                                 
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: OptimisticList;                                                                         
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var x_pre: OptimisticList;                                                                         
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var OptimisticList._state_pre: [OptimisticList]State;                                              
 var Node.item_pre: [Node]int;                                                                      
 var OptimisticList.head_pre: [OptimisticList]Node;                                                 
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var y_post: OptimisticList;                                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var OptimisticList.head_post: [OptimisticList]Node;                                                
 var OptimisticList._lock_post: [OptimisticList]Tid;                                                
 var x_post: OptimisticList;                                                                        
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var OptimisticList._state_post: [OptimisticList]State;                                             
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.OptimisticList.head(u: Tid,y: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.OptimisticList.head(t: Tid,x: OptimisticList,v: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 OptimisticList.head[x] := v;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && OptimisticList._state_post == OptimisticList._state && OptimisticList.head_post == OptimisticList.head && OptimisticList._lock_post == OptimisticList._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.OptimisticList.head(u: Tid,y: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): OptimisticList.head is not Write-Read Stable with respect to OptimisticList.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (13.5): OptimisticList.head is not Write-Read Stable with respect to OptimisticList.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (13.5): OptimisticList.head is not Write-Read Stable with respect to OptimisticList.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
requires ValidTid(tid);                                                                             
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (<undefined position>): Object invariant may not hold.
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies OptimisticList._state;                                                                     
modifies OptimisticList.head;                                                                       
modifies OptimisticList._lock;                                                                      
ensures StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
ensures Y(tid , old(Node._state), old(Node.item), old(Node.next), old(Node._lock), old(OptimisticList._state), old(OptimisticList.head), old(OptimisticList._lock) , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// Node.item:                                                                                       
                                                                                                    
function {:inline} Y_Node.item(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.item(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock)), _R)) ==> (Node.item[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.item(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var OptimisticList.head_yield: [OptimisticList]Node;                                                
var OptimisticList._state_yield: [OptimisticList]State;                                             
var $pc_yield: Phase;                                                                               
var OptimisticList._lock_yield: [OptimisticList]Tid;                                                
var newValue_yield: int;                                                                            
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.item(u: Tid,this: Node,newValue: int,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && OptimisticList._state_yield == OptimisticList._state && OptimisticList.head_yield == OptimisticList.head && OptimisticList._lock_yield == OptimisticList._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.item(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var OptimisticList.head_yield: [OptimisticList]Node;                                                
var OptimisticList._state_yield: [OptimisticList]State;                                             
var $pc_yield: Phase;                                                                               
var OptimisticList._lock_yield: [OptimisticList]Tid;                                                
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && OptimisticList._state_yield == OptimisticList._state && OptimisticList.head_yield == OptimisticList.head && OptimisticList._lock_yield == OptimisticList._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.item(tid, this, Node.item[this] , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Transitive(tid : Tid, this: Node, newValue : int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, OptimisticList._state_p: [OptimisticList]State, OptimisticList.head_p: [OptimisticList]Node, OptimisticList._lock_p: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (3.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (3.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (3.24): Object invariant may not hold.
requires  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (3.24): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var OptimisticList._lock_pre: [OptimisticList]Tid;                                                  
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var newValue_pre: int;                                                                              
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var OptimisticList._state_pre: [OptimisticList]State;                                               
var Node.item_pre: [Node]int;                                                                       
var OptimisticList.head_pre: [OptimisticList]Node;                                                  
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var newValue_post: int;                                                                             
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var OptimisticList.head_post: [OptimisticList]Node;                                                 
var this_post: Node;                                                                                
var OptimisticList._lock_post: [OptimisticList]Tid;                                                 
var OptimisticList._state_post: [OptimisticList]State;                                              
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
 assume Y_Node.item(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && OptimisticList._state_post == OptimisticList._state_p && OptimisticList.head_post == OptimisticList.head_p && OptimisticList._lock_post == OptimisticList._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.item(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
// Node.next:                                                                                       
                                                                                                    
function {:inline} Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.next(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock)), _R)) ==> (Node.next[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var OptimisticList.head_yield: [OptimisticList]Node;                                                
var OptimisticList._state_yield: [OptimisticList]State;                                             
var $pc_yield: Phase;                                                                               
var OptimisticList._lock_yield: [OptimisticList]Tid;                                                
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Node;                                                                           
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.next(u: Tid,this: Node,newValue: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && OptimisticList._state_yield == OptimisticList._state && OptimisticList.head_yield == OptimisticList.head && OptimisticList._lock_yield == OptimisticList._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var OptimisticList.head_yield: [OptimisticList]Node;                                                
var OptimisticList._state_yield: [OptimisticList]State;                                             
var $pc_yield: Phase;                                                                               
var OptimisticList._lock_yield: [OptimisticList]Tid;                                                
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && OptimisticList._state_yield == OptimisticList._state && OptimisticList.head_yield == OptimisticList.head && OptimisticList._lock_yield == OptimisticList._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, Node.next[this] , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Transitive(tid : Tid, this: Node, newValue : Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, OptimisticList._state_p: [OptimisticList]State, OptimisticList.head_p: [OptimisticList]Node, OptimisticList._lock_p: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (4.33): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (4.33): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (4.33): Object invariant may not hold.
requires  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (4.33): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var OptimisticList._lock_pre: [OptimisticList]Tid;                                                  
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var OptimisticList._state_pre: [OptimisticList]State;                                               
var Node.item_pre: [Node]int;                                                                       
var OptimisticList.head_pre: [OptimisticList]Node;                                                  
                                                                                                    
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.item_post: [Node]int;                                                                      
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var OptimisticList.head_post: [OptimisticList]Node;                                                 
var this_post: Node;                                                                                
var OptimisticList._lock_post: [OptimisticList]Tid;                                                 
var OptimisticList._state_post: [OptimisticList]State;                                              
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
 assume Y_Node.next(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && OptimisticList._state_post == OptimisticList._state_p && OptimisticList.head_post == OptimisticList.head_p && OptimisticList._lock_post == OptimisticList._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.next(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
// Node._lock:                                                                                      
                                                                                                    
function {:inline} Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock)), _R)) ==> (Node._lock[this] == newValue))
 &&(((Node._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var OptimisticList.head_yield: [OptimisticList]Node;                                                
var OptimisticList._state_yield: [OptimisticList]State;                                             
var $pc_yield: Phase;                                                                               
var OptimisticList._lock_yield: [OptimisticList]Tid;                                                
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node._lock(u: Tid,this: Node,newValue: Tid,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock)));
 assume leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock)), _N);
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && OptimisticList._state_yield == OptimisticList._state && OptimisticList.head_yield == OptimisticList.head && OptimisticList._lock_yield == OptimisticList._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var OptimisticList.head_yield: [OptimisticList]Node;                                                
var OptimisticList._state_yield: [OptimisticList]State;                                             
var $pc_yield: Phase;                                                                               
var OptimisticList._lock_yield: [OptimisticList]Tid;                                                
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && OptimisticList._state_yield == OptimisticList._state && OptimisticList.head_yield == OptimisticList.head && OptimisticList._lock_yield == OptimisticList._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, Node._lock[this] , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Transitive(tid : Tid, this: Node, newValue : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, OptimisticList._state_p: [OptimisticList]State, OptimisticList.head_p: [OptimisticList]Node, OptimisticList._lock_p: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (2.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (2.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (2.1): Object invariant may not hold.
requires  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (2.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var OptimisticList._lock_pre: [OptimisticList]Tid;                                                  
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var OptimisticList._state_pre: [OptimisticList]State;                                               
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
var OptimisticList.head_pre: [OptimisticList]Node;                                                  
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var OptimisticList.head_post: [OptimisticList]Node;                                                 
var this_post: Node;                                                                                
var newValue_post: Tid;                                                                             
var OptimisticList._lock_post: [OptimisticList]Tid;                                                 
var OptimisticList._state_post: [OptimisticList]State;                                              
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
 assume Y_Node._lock(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && OptimisticList._state_post == OptimisticList._state_p && OptimisticList.head_post == OptimisticList.head_p && OptimisticList._lock_post == OptimisticList._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
// OptimisticList.head:                                                                             
                                                                                                    
function {:inline} Y_OptimisticList.head(tid : Tid, this: OptimisticList, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid): bool
{                                                                                                   
 ((isAccessible(OptimisticList._state[this], tid) && leq(m#moverPath(ReadEval.OptimisticList.head(tid: Tid,this: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock)), _R)) ==> (OptimisticList.head[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_OptimisticList.head(tid : Tid, this: OptimisticList, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_OptimisticList.head.Subsumes.W(tid : Tid, u : Tid, this: OptimisticList, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var OptimisticList.head_yield: [OptimisticList]Node;                                                
var OptimisticList._state_yield: [OptimisticList]State;                                             
var $pc_yield: Phase;                                                                               
var OptimisticList._lock_yield: [OptimisticList]Tid;                                                
var this_yield: OptimisticList;                                                                     
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Node;                                                                           
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(OptimisticList._state[this], tid);                                             
 assume isAccessible(OptimisticList._state[this], u);                                               
 assume !isError(m#moverPath(WriteEval.OptimisticList.head(u: Tid,this: OptimisticList,newValue: Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && OptimisticList._state_yield == OptimisticList._state && OptimisticList.head_yield == OptimisticList.head && OptimisticList._lock_yield == OptimisticList._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_OptimisticList.head(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
                                                                                                    
procedure Y_OptimisticList.head.Reflexive(tid : Tid, this: OptimisticList , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var OptimisticList.head_yield: [OptimisticList]Node;                                                
var OptimisticList._state_yield: [OptimisticList]State;                                             
var $pc_yield: Phase;                                                                               
var OptimisticList._lock_yield: [OptimisticList]Tid;                                                
var this_yield: OptimisticList;                                                                     
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(OptimisticList._state[this], tid);                                             
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && OptimisticList._state_yield == OptimisticList._state && OptimisticList.head_yield == OptimisticList.head && OptimisticList._lock_yield == OptimisticList._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_OptimisticList.head(tid, this, OptimisticList.head[this] , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
                                                                                                    
procedure Y_OptimisticList.head.Transitive(tid : Tid, this: OptimisticList, newValue : Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, OptimisticList._state_p: [OptimisticList]State, OptimisticList.head_p: [OptimisticList]Node, OptimisticList._lock_p: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (13.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (13.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (13.24): Object invariant may not hold.
requires  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (13.24): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var OptimisticList._lock_pre: [OptimisticList]Tid;                                                  
var $recorded.state_pre: int;                                                                       
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var this_pre: OptimisticList;                                                                       
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var OptimisticList._state_pre: [OptimisticList]State;                                               
var Node.item_pre: [Node]int;                                                                       
var OptimisticList.head_pre: [OptimisticList]Node;                                                  
                                                                                                    
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.item_post: [Node]int;                                                                      
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var this_post: OptimisticList;                                                                      
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var OptimisticList.head_post: [OptimisticList]Node;                                                 
var OptimisticList._lock_post: [OptimisticList]Tid;                                                 
var OptimisticList._state_post: [OptimisticList]State;                                              
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(OptimisticList._state[this], tid);                                             
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
 assume Y_OptimisticList.head(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && OptimisticList._state_post == OptimisticList._state_p && OptimisticList.head_post == OptimisticList.head_p && OptimisticList._lock_post == OptimisticList._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_OptimisticList.head(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
// OptimisticList._lock:                                                                            
                                                                                                    
function {:inline} Y_OptimisticList._lock(tid : Tid, this: OptimisticList, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid): bool
{                                                                                                   
 ((isAccessible(OptimisticList._state[this], tid) && leq(m#moverPath(ReadEval.OptimisticList._lock(tid: Tid,this: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock)), _R)) ==> (OptimisticList._lock[this] == newValue))
 &&(((OptimisticList._lock[this]==tid)==(newValue==tid)))                                           
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_OptimisticList._lock(tid : Tid, this: OptimisticList, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_OptimisticList._lock.Subsumes.W(tid : Tid, u : Tid, this: OptimisticList, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var OptimisticList.head_yield: [OptimisticList]Node;                                                
var OptimisticList._state_yield: [OptimisticList]State;                                             
var $pc_yield: Phase;                                                                               
var OptimisticList._lock_yield: [OptimisticList]Tid;                                                
var this_yield: OptimisticList;                                                                     
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(OptimisticList._state[this], tid);                                             
 assume isAccessible(OptimisticList._state[this], u);                                               
 assume !isError(m#moverPath(WriteEval.OptimisticList._lock(u: Tid,this: OptimisticList,newValue: Tid,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock)));
 assume leq(m#moverPath(ReadEval.OptimisticList._lock(tid: Tid,this: OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock)), _N);
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && OptimisticList._state_yield == OptimisticList._state && OptimisticList.head_yield == OptimisticList.head && OptimisticList._lock_yield == OptimisticList._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_OptimisticList._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
                                                                                                    
procedure Y_OptimisticList._lock.Reflexive(tid : Tid, this: OptimisticList , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var OptimisticList.head_yield: [OptimisticList]Node;                                                
var OptimisticList._state_yield: [OptimisticList]State;                                             
var $pc_yield: Phase;                                                                               
var OptimisticList._lock_yield: [OptimisticList]Tid;                                                
var this_yield: OptimisticList;                                                                     
var Node._lock_yield: [Node]Tid;                                                                    
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(OptimisticList._state[this], tid);                                             
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && OptimisticList._state_yield == OptimisticList._state && OptimisticList.head_yield == OptimisticList.head && OptimisticList._lock_yield == OptimisticList._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_OptimisticList._lock(tid, this, OptimisticList._lock[this] , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
                                                                                                    
procedure Y_OptimisticList._lock.Transitive(tid : Tid, this: OptimisticList, newValue : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, OptimisticList._state_p: [OptimisticList]State, OptimisticList.head_p: [OptimisticList]Node, OptimisticList._lock_p: [OptimisticList]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527810(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (11.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527827(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (11.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.4527843(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (11.1): Object invariant may not hold.
requires  (forall _this : OptimisticList ::  { OptimisticList._state[_this] } isAccessible(OptimisticList._state[_this], tid) && true ==> Invariant.OptimisticList.4528594(tid: Tid,_this : OptimisticList,Node._state,Node.item,Node.next,Node._lock,OptimisticList._state,OptimisticList.head,OptimisticList._lock));       // (11.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var OptimisticList._lock_pre: [OptimisticList]Tid;                                                  
var $recorded.state_pre: int;                                                                       
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var this_pre: OptimisticList;                                                                       
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var OptimisticList._state_pre: [OptimisticList]State;                                               
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
var OptimisticList.head_pre: [OptimisticList]Node;                                                  
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var this_post: OptimisticList;                                                                      
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var OptimisticList.head_post: [OptimisticList]Node;                                                 
var newValue_post: Tid;                                                                             
var OptimisticList._lock_post: [OptimisticList]Tid;                                                 
var OptimisticList._state_post: [OptimisticList]State;                                              
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && OptimisticList._state_pre == OptimisticList._state && OptimisticList.head_pre == OptimisticList.head && OptimisticList._lock_pre == OptimisticList._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(OptimisticList._state[this], tid);                                             
 assume Y(tid , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
 assume Y_OptimisticList._lock(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node._lock_p, OptimisticList._state_p, OptimisticList.head_p, OptimisticList._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && OptimisticList._state_post == OptimisticList._state_p && OptimisticList.head_post == OptimisticList.head_p && OptimisticList._lock_post == OptimisticList._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_OptimisticList._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock);
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, OptimisticList._state: [OptimisticList]State, OptimisticList.head: [OptimisticList]Node, OptimisticList._lock: [OptimisticList]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, OptimisticList._state_p: [OptimisticList]State, OptimisticList.head_p: [OptimisticList]Node, OptimisticList._lock_p: [OptimisticList]Tid): bool
{                                                                                                   
 (forall this: Node :: Y_Node.item(tid : Tid, this, Node.item_p[this] , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock))
 && (forall this: Node :: Y_Node.next(tid : Tid, this, Node.next_p[this] , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock))
 && (forall this: Node :: Y_Node._lock(tid : Tid, this, Node._lock_p[this] , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock))
 && (forall this: OptimisticList :: Y_OptimisticList.head(tid : Tid, this, OptimisticList.head_p[this] , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock))
 && (forall this: OptimisticList :: Y_OptimisticList._lock(tid : Tid, this, OptimisticList._lock_p[this] , Node._state, Node.item, Node.next, Node._lock, OptimisticList._state, OptimisticList.head, OptimisticList._lock))
 && (forall _i : Node :: isShared(Node._state[_i]) ==> isShared(Node._state_p[_i]))                 
 && (forall _i : Node :: isLocal(Node._state[_i], tid) <==> isLocal(Node._state_p[_i], tid))        
 && (forall _i : OptimisticList :: isShared(OptimisticList._state[_i]) ==> isShared(OptimisticList._state_p[_i]))
 && (forall _i : OptimisticList :: isLocal(OptimisticList._state[_i], tid) <==> isLocal(OptimisticList._state_p[_i], tid))
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 1921.1-4160.2: (Method:37.5)
// 1933.1-1933.24: (37.5): Bad tid
// 1934.1-1934.48: (37.5): this is not global
// 1939.1-1939.262: (37.5): Object invariant may not hold.
// 1940.1-1940.262: (37.5): Object invariant may not hold.
// 1941.1-1941.262: (37.5): Object invariant may not hold.
// 1942.1-1942.312: (37.5): Object invariant may not hold.
// 1945.1-1945.261: (37.5): Object invariant may not hold.
// 1946.1-1946.261: (37.5): Object invariant may not hold.
// 1947.1-1947.261: (37.5): Object invariant may not hold.
// 1948.1-1948.311: (37.5): Object invariant may not hold.
// 3214.1-3214.14: (37.24): Can only have right-mover memory accesses in requires clause
// 3218.2-3222.14: (class anchor.sink.While:39.7)
// 3224.1-3224.27: (37.5): Bad tid
// 3225.1-3225.51: (37.5): this is not global
// 3228.1-3228.265: (39.7): Object invariant may not hold.
// 3229.1-3229.265: (39.7): Object invariant may not hold.
// 3230.1-3230.265: (39.7): Object invariant may not hold.
// 3231.1-3231.315: (39.7): Object invariant may not hold.
// 3232.1-3232.252: (39.7): Loop does not preserve yields_as annotation for field item
// 3233.1-3233.252: (39.7): Loop does not preserve yields_as annotation for field next
// 3234.1-3234.282: (39.7): Loop does not preserve yields_as annotation for field head
// 3235.1-3235.33: (39.7): Phase must be invariant at loop head
// 3236.1-3236.30: (39.7): Potentially infinite loop cannot be in post-commit phase.
// 3238.3-3240.3: (class anchor.sink.VarDeclStmt:39.14)
// 3241.3-3244.16: (class anchor.sink.Assign:39.14)
// 3246.4-3249.10: (class anchor.sink.Break:39.7)
// 3252.3-3254.3: (class anchor.sink.VarDeclStmt:40.9)
// 3255.3-3272.37: (class anchor.sink.Read:40.9)
// 3267.1-3267.39: (40.9): Cannot have potential null deference in left-mover part.
// 3271.1-3271.28: (40.9): Reduction failure
// 3273.3-3275.3: (class anchor.sink.VarDeclStmt:41.9)
// 3276.3-3293.27: (class anchor.sink.Read:41.9)
// 3288.1-3288.29: (41.9): Cannot have potential null deference in left-mover part.
// 3292.1-3292.28: (41.9): Reduction failure
// 3294.3-3310.43: (class anchor.sink.Yield:42.9)
// 3299.1-3299.262: (42.9): Object invariant may not hold.
// 3300.1-3300.262: (42.9): Object invariant may not hold.
// 3301.1-3301.262: (42.9): Object invariant may not hold.
// 3302.1-3302.312: (42.9): Object invariant may not hold.
// 3304.1-3304.262: (42.9): Object invariant may not hold.
// 3305.1-3305.262: (42.9): Object invariant may not hold.
// 3306.1-3306.262: (42.9): Object invariant may not hold.
// 3307.1-3307.312: (42.9): Object invariant may not hold.
// 3313.3-3317.15: (class anchor.sink.While:43.9)
// 3319.1-3319.28: (37.5): Bad tid
// 3320.1-3320.52: (37.5): this is not global
// 3323.1-3323.266: (43.9): Object invariant may not hold.
// 3324.1-3324.266: (43.9): Object invariant may not hold.
// 3325.1-3325.266: (43.9): Object invariant may not hold.
// 3326.1-3326.316: (43.9): Object invariant may not hold.
// 3326.316-3327.42: (43.9): invariant isShared(curr) may not hold
// 3327.42-3328.42: (43.9): invariant isShared(pred) may not hold
// 3328.42-3329.37: (43.9): invariant pred.item < item may not hold
// 3330.1-3330.253: (43.9): Loop does not preserve yields_as annotation for field item
// 3331.1-3331.253: (43.9): Loop does not preserve yields_as annotation for field next
// 3332.1-3332.283: (43.9): Loop does not preserve yields_as annotation for field head
// 3333.1-3333.34: (43.9): Phase must be invariant at loop head
// 3334.1-3334.31: (43.9): Potentially infinite loop cannot be in post-commit phase.
// 3336.4-3338.4: (class anchor.sink.VarDeclStmt:43.26)
// 3339.4-3341.4: (class anchor.sink.VarDeclStmt:43.16)
// 3342.4-3359.28: (class anchor.sink.Read:43.16)
// 3354.1-3354.30: (43.16): Cannot have potential null deference in left-mover part.
// 3358.1-3358.29: (43.16): Reduction failure
// 3360.4-3363.24: (class anchor.sink.Assign:43.26)
// 3365.5-3368.11: (class anchor.sink.Break:43.9)
// 3371.4-3374.17: (class anchor.sink.Assign:48.11)
// 3375.4-3391.44: (class anchor.sink.Yield:49.11)
// 3380.1-3380.263: (49.11): Object invariant may not hold.
// 3381.1-3381.263: (49.11): Object invariant may not hold.
// 3382.1-3382.263: (49.11): Object invariant may not hold.
// 3383.1-3383.313: (49.11): Object invariant may not hold.
// 3385.1-3385.263: (49.11): Object invariant may not hold.
// 3386.1-3386.263: (49.11): Object invariant may not hold.
// 3387.1-3387.263: (49.11): Object invariant may not hold.
// 3388.1-3388.313: (49.11): Object invariant may not hold.
// 3392.4-3409.28: (class anchor.sink.Read:50.11)
// 3404.1-3404.30: (50.11): Cannot have potential null deference in left-mover part.
// 3408.1-3408.29: (50.11): Reduction failure
// 3410.4-3426.44: (class anchor.sink.Yield:51.11)
// 3415.1-3415.263: (51.11): Object invariant may not hold.
// 3416.1-3416.263: (51.11): Object invariant may not hold.
// 3417.1-3417.263: (51.11): Object invariant may not hold.
// 3418.1-3418.313: (51.11): Object invariant may not hold.
// 3420.1-3420.263: (51.11): Object invariant may not hold.
// 3421.1-3421.263: (51.11): Object invariant may not hold.
// 3422.1-3422.263: (51.11): Object invariant may not hold.
// 3423.1-3423.313: (51.11): Object invariant may not hold.
// 3429.1-3429.31: (43.9): Phase must be invariant at loop head
// 3431.3-3433.3: (class anchor.sink.VarDeclStmt:53.10)
// 3434.3-3436.3: (class anchor.sink.VarDeclStmt:53.10)
// 3437.3-3454.28: (class anchor.sink.Read:53.10)
// 3449.1-3449.29: (53.10): Cannot have potential null deference in left-mover part.
// 3453.1-3453.28: (53.10): Reduction failure
// 3455.3-3458.25: (class anchor.sink.Assign:53.10)
// 3459.3-3464.53: (class anchor.sink.Assert:53.10)
// 3464.1-3464.53: (53.10): This assertion may not hold.
// 3465.3-3481.43: (class anchor.sink.Yield:54.9)
// 3470.1-3470.262: (54.9): Object invariant may not hold.
// 3471.1-3471.262: (54.9): Object invariant may not hold.
// 3472.1-3472.262: (54.9): Object invariant may not hold.
// 3473.1-3473.312: (54.9): Object invariant may not hold.
// 3475.1-3475.262: (54.9): Object invariant may not hold.
// 3476.1-3476.262: (54.9): Object invariant may not hold.
// 3477.1-3477.262: (54.9): Object invariant may not hold.
// 3478.1-3478.312: (54.9): Object invariant may not hold.
// 3482.3-3484.3: (class anchor.sink.VarDeclStmt:55.10)
// 3485.3-3487.3: (class anchor.sink.VarDeclStmt:55.10)
// 3488.3-3505.28: (class anchor.sink.Read:55.10)
// 3500.1-3500.29: (55.10): Cannot have potential null deference in left-mover part.
// 3504.1-3504.28: (55.10): Reduction failure
// 3506.3-3509.25: (class anchor.sink.Assign:55.10)
// 3510.3-3515.53: (class anchor.sink.Assert:55.10)
// 3515.1-3515.53: (55.10): This assertion may not hold.
// 3519.1-3519.29: (56.9): Cannot have potential null deference in left-mover part.
// 3523.1-3523.28: (56.9): Reduction failure
// 3528.1-3528.29: (57.9): Cannot have potential null deference in left-mover part.
// 3532.1-3532.28: (57.9): Reduction failure
// 3534.3-3536.3: (class anchor.sink.VarDeclStmt:58.10)
// 3537.3-3539.3: (class anchor.sink.VarDeclStmt:58.10)
// 3540.3-3557.28: (class anchor.sink.Read:58.10)
// 3552.1-3552.29: (58.10): Cannot have potential null deference in left-mover part.
// 3556.1-3556.28: (58.10): Reduction failure
// 3558.3-3561.25: (class anchor.sink.Assign:58.10)
// 3562.3-3567.53: (class anchor.sink.Assert:58.10)
// 3567.1-3567.53: (58.10): This assertion may not hold.
// 3568.3-3570.3: (class anchor.sink.VarDeclStmt:59.10)
// 3571.3-3573.3: (class anchor.sink.VarDeclStmt:59.10)
// 3574.3-3591.28: (class anchor.sink.Read:59.10)
// 3586.1-3586.29: (59.10): Cannot have potential null deference in left-mover part.
// 3590.1-3590.28: (59.10): Reduction failure
// 3592.3-3595.26: (class anchor.sink.Assign:59.10)
// 3596.3-3601.54: (class anchor.sink.Assert:59.10)
// 3601.1-3601.54: (59.10): This assertion may not hold.
// 3602.3-3604.3: (class anchor.sink.VarDeclStmt:61.8)
// 3607.3-3609.3: (class anchor.sink.VarDeclStmt:61.8)
// 3610.3-3612.3: (class anchor.sink.VarDeclStmt:61.8)
// 3613.3-3615.3: (class anchor.sink.VarDeclStmt:61.8)
// 3616.3-3618.3: (class anchor.sink.VarDeclStmt:61.8)
// 3619.3-3622.20: (class anchor.sink.Assign:61.8)
// 3623.3-3626.20: (class anchor.sink.Assign:61.8)
// 3627.3-3630.20: (class anchor.sink.Assign:61.8)
// 3631.3-3634.20: (class anchor.sink.Assign:61.8)
// 3635.3-3637.3: (class anchor.sink.VarDeclStmt:17.9)
// 3638.3-3655.45: (class anchor.sink.Read:17.9)
// 3650.1-3650.43: (17.9): Cannot have potential null deference in left-mover part.
// 3654.1-3654.28: (17.9): Reduction failure
// 3656.3-3672.43: (class anchor.sink.Yield:18.9)
// 3661.1-3661.262: (18.9): Object invariant may not hold.
// 3662.1-3662.262: (18.9): Object invariant may not hold.
// 3663.1-3663.262: (18.9): Object invariant may not hold.
// 3664.1-3664.312: (18.9): Object invariant may not hold.
// 3666.1-3666.262: (18.9): Object invariant may not hold.
// 3667.1-3667.262: (18.9): Object invariant may not hold.
// 3668.1-3668.262: (18.9): Object invariant may not hold.
// 3669.1-3669.312: (18.9): Object invariant may not hold.
// 3675.3-3679.15: (class anchor.sink.While:19.9)
// 3681.1-3681.28: (37.5): Bad tid
// 3682.1-3682.52: (37.5): this is not global
// 3685.1-3685.266: (19.9): Object invariant may not hold.
// 3686.1-3686.266: (19.9): Object invariant may not hold.
// 3687.1-3687.266: (19.9): Object invariant may not hold.
// 3688.1-3688.316: (19.9): Object invariant may not hold.
// 3688.316-3689.46: (19.9): invariant isShared(node$256) may not hold
// 3689.46-3690.46: (19.9): invariant isShared(curr$256) may not hold
// 3690.46-3691.46: (19.9): invariant isShared(pred$256) may not hold
// 3691.46-3692.88: (19.9): invariant holds(curr$256, tid) may not hold
// 3692.88-3693.88: (19.9): invariant holds(pred$256, tid) may not hold
// 3693.88-3694.45: (19.9): invariant pred$256.item < item$256 may not hold
// 3694.45-3695.46: (19.9): invariant curr$256.item >= item$256 may not hold
// 3696.1-3696.253: (19.9): Loop does not preserve yields_as annotation for field item
// 3697.1-3697.253: (19.9): Loop does not preserve yields_as annotation for field next
// 3698.1-3698.283: (19.9): Loop does not preserve yields_as annotation for field head
// 3699.1-3699.34: (19.9): Phase must be invariant at loop head
// 3700.1-3700.31: (19.9): Potentially infinite loop cannot be in post-commit phase.
// 3702.4-3704.4: (class anchor.sink.VarDeclStmt:19.26)
// 3705.4-3707.4: (class anchor.sink.VarDeclStmt:19.16)
// 3708.4-3725.36: (class anchor.sink.Read:19.16)
// 3720.1-3720.34: (19.16): Cannot have potential null deference in left-mover part.
// 3724.1-3724.29: (19.16): Reduction failure
// 3726.4-3728.4: (class anchor.sink.VarDeclStmt:19.29)
// 3729.4-3746.36: (class anchor.sink.Read:19.29)
// 3741.1-3741.34: (19.29): Cannot have potential null deference in left-mover part.
// 3745.1-3745.29: (19.29): Reduction failure
// 3747.4-3750.37: (class anchor.sink.Assign:19.26)
// 3752.5-3755.11: (class anchor.sink.Break:19.9)
// 3758.4-3760.4: (class anchor.sink.VarDeclStmt:28.11)
// 3761.4-3764.37: (class anchor.sink.Assign:28.11)
// 3766.5-3768.5: (class anchor.sink.VarDeclStmt:29.13)
// 3769.5-3771.5: (class anchor.sink.VarDeclStmt:29.13)
// 3772.5-3789.37: (class anchor.sink.Read:29.13)
// 3784.1-3784.35: (29.13): Cannot have potential null deference in left-mover part.
// 3788.1-3788.30: (29.13): Reduction failure
// 3790.5-3793.38: (class anchor.sink.Assign:29.13)
// 3794.5-3797.23: (class anchor.sink.Assign:29.13)
// 3798.5-3801.26: (class anchor.sink.Break:29.13)
// 3804.4-3821.36: (class anchor.sink.Read:31.11)
// 3816.1-3816.34: (31.11): Cannot have potential null deference in left-mover part.
// 3820.1-3820.29: (31.11): Reduction failure
// 3822.4-3838.44: (class anchor.sink.Yield:32.11)
// 3827.1-3827.263: (32.11): Object invariant may not hold.
// 3828.1-3828.263: (32.11): Object invariant may not hold.
// 3829.1-3829.263: (32.11): Object invariant may not hold.
// 3830.1-3830.313: (32.11): Object invariant may not hold.
// 3832.1-3832.263: (32.11): Object invariant may not hold.
// 3833.1-3833.263: (32.11): Object invariant may not hold.
// 3834.1-3834.263: (32.11): Object invariant may not hold.
// 3835.1-3835.313: (32.11): Object invariant may not hold.
// 3841.1-3841.31: (19.9): Phase must be invariant at loop head
// 3843.3-3846.18: (class anchor.sink.Assign:34.9)
// 3847.3-3850.24: (class anchor.sink.Break:34.9)
// 3851.3-3854.18: (class anchor.sink.Assign:16.54)
// 3855.3-3858.24: (class anchor.sink.Break:16.54)
// 3861.4-3863.4: (class anchor.sink.VarDeclStmt:62.10)
// 3864.4-3881.29: (class anchor.sink.Read:62.10)
// 3876.1-3876.30: (62.10): Cannot have potential null deference in left-mover part.
// 3880.1-3880.29: (62.10): Reduction failure
// 3882.4-3887.25: (class anchor.sink.Assert:62.10)
// 3887.1-3887.25: (62.10): This assertion may not hold.
// 3888.4-3890.4: (class anchor.sink.VarDeclStmt:63.10)
// 3891.4-3893.4: (class anchor.sink.VarDeclStmt:63.10)
// 3894.4-3911.29: (class anchor.sink.Read:63.10)
// 3906.1-3906.30: (63.10): Cannot have potential null deference in left-mover part.
// 3910.1-3910.29: (63.10): Reduction failure
// 3912.4-3915.26: (class anchor.sink.Assign:63.10)
// 3916.4-3921.54: (class anchor.sink.Assert:63.10)
// 3921.1-3921.54: (63.10): This assertion may not hold.
// 3922.4-3924.4: (class anchor.sink.VarDeclStmt:64.10)
// 3925.4-3927.4: (class anchor.sink.VarDeclStmt:64.10)
// 3928.4-3945.29: (class anchor.sink.Read:64.10)
// 3940.1-3940.30: (64.10): Cannot have potential null deference in left-mover part.
// 3944.1-3944.29: (64.10): Reduction failure
// 3946.4-3949.27: (class anchor.sink.Assign:64.10)
// 3950.4-3955.55: (class anchor.sink.Assert:64.10)
// 3955.1-3955.55: (64.10): This assertion may not hold.
// 3956.4-3958.4: (class anchor.sink.VarDeclStmt:65.10)
// 3959.4-3961.4: (class anchor.sink.VarDeclStmt:65.10)
// 3962.4-3979.29: (class anchor.sink.Read:65.10)
// 3974.1-3974.30: (65.10): Cannot have potential null deference in left-mover part.
// 3978.1-3978.29: (65.10): Reduction failure
// 3980.4-3983.27: (class anchor.sink.Assign:65.10)
// 3988.1-3988.31: (66.12): Cannot have potential null deference in left-mover part.
// 3990.1-3990.36: (66.12): lock not held
// 3992.1-3992.30: (66.12): Reduction failure
// 3997.1-3997.31: (67.12): Cannot have potential null deference in left-mover part.
// 3999.1-3999.36: (67.12): lock not held
// 4001.1-4001.30: (67.12): Reduction failure
// 4003.5-4013.12: (class anchor.sink.Return:68.12)
// 4009.1-4009.264: (68.12): Object invariant may not hold.
// 4010.1-4010.264: (68.12): Object invariant may not hold.
// 4011.1-4011.264: (68.12): Object invariant may not hold.
// 4012.1-4012.314: (68.12): Object invariant may not hold.
// 4015.5-4017.5: (class anchor.sink.VarDeclStmt:70.12)
// 4018.5-4026.43: (class anchor.sink.Alloc:70.12)
// 4029.5-4031.5: (class anchor.sink.VarDeclStmt:70.12)
// 4032.5-4035.23: (class anchor.sink.Assign:70.12)
// 4036.5-4039.37: (class anchor.sink.Assume:2.12)
// 4040.5-4043.45: (class anchor.sink.Assume:2.12)
// 4044.5-4047.26: (class anchor.sink.Break:9.1)
// 4050.5-4066.30: (class anchor.sink.Write:71.12)
// 4062.1-4062.32: (71.12): Cannot have potential null deference in left-mover part.
// 4065.1-4065.30: (71.12): Reduction failure
// 4068.5-4089.5: (class anchor.sink.Write:72.12)
// 4080.1-4080.32: (72.12): Cannot have potential null deference in left-mover part.
// 4083.1-4083.30: (72.12): Reduction failure
// 4087.1-4087.62: (72.12): curr became shared, but curr.next may not be shared.
// 4091.5-4112.5: (class anchor.sink.Write:73.12)
// 4103.1-4103.31: (73.12): Cannot have potential null deference in left-mover part.
// 4106.1-4106.30: (73.12): Reduction failure
// 4110.1-4110.63: (73.12): node2 became shared, but node2.next may not be shared.
// 4116.1-4116.31: (74.12): Cannot have potential null deference in left-mover part.
// 4118.1-4118.36: (74.12): lock not held
// 4120.1-4120.30: (74.12): Reduction failure
// 4125.1-4125.31: (75.12): Cannot have potential null deference in left-mover part.
// 4127.1-4127.36: (75.12): lock not held
// 4129.1-4129.30: (75.12): Reduction failure
// 4131.5-4141.12: (class anchor.sink.Return:76.12)
// 4137.1-4137.264: (76.12): Object invariant may not hold.
// 4138.1-4138.264: (76.12): Object invariant may not hold.
// 4139.1-4139.264: (76.12): Object invariant may not hold.
// 4140.1-4140.314: (76.12): Object invariant may not hold.
// 4147.1-4147.30: (39.7): Phase must be invariant at loop head
// 4149.2-4159.9: (class anchor.sink.Return:38.34)
// 4155.1-4155.261: (38.34): Object invariant may not hold.
// 4156.1-4156.261: (38.34): Object invariant may not hold.
// 4157.1-4157.261: (38.34): Object invariant may not hold.
// 4158.1-4158.311: (38.34): Object invariant may not hold.
// 4161.1-5359.2: (Method:83.6)
// 4173.1-4173.24: (83.6): Bad tid
// 4174.1-4174.48: (83.6): this is not global
// 4179.1-4179.262: (83.6): Object invariant may not hold.
// 4180.1-4180.262: (83.6): Object invariant may not hold.
// 4181.1-4181.262: (83.6): Object invariant may not hold.
// 4182.1-4182.312: (83.6): Object invariant may not hold.
// 4185.1-4185.261: (83.6): Object invariant may not hold.
// 4186.1-4186.261: (83.6): Object invariant may not hold.
// 4187.1-4187.261: (83.6): Object invariant may not hold.
// 4188.1-4188.311: (83.6): Object invariant may not hold.
// 4791.1-4791.14: (83.25): Can only have right-mover memory accesses in requires clause
// 4795.2-4799.14: (class anchor.sink.While:85.8)
// 4801.1-4801.27: (83.6): Bad tid
// 4802.1-4802.51: (83.6): this is not global
// 4805.1-4805.265: (85.8): Object invariant may not hold.
// 4806.1-4806.265: (85.8): Object invariant may not hold.
// 4807.1-4807.265: (85.8): Object invariant may not hold.
// 4808.1-4808.315: (85.8): Object invariant may not hold.
// 4809.1-4809.252: (85.8): Loop does not preserve yields_as annotation for field item
// 4810.1-4810.252: (85.8): Loop does not preserve yields_as annotation for field next
// 4811.1-4811.282: (85.8): Loop does not preserve yields_as annotation for field head
// 4812.1-4812.33: (85.8): Phase must be invariant at loop head
// 4813.1-4813.30: (85.8): Potentially infinite loop cannot be in post-commit phase.
// 4815.3-4817.3: (class anchor.sink.VarDeclStmt:85.15)
// 4818.3-4821.17: (class anchor.sink.Assign:85.15)
// 4823.4-4826.10: (class anchor.sink.Break:85.8)
// 4829.3-4831.3: (class anchor.sink.VarDeclStmt:86.10)
// 4832.3-4849.37: (class anchor.sink.Read:86.10)
// 4844.1-4844.39: (86.10): Cannot have potential null deference in left-mover part.
// 4848.1-4848.28: (86.10): Reduction failure
// 4850.3-4852.3: (class anchor.sink.VarDeclStmt:87.10)
// 4853.3-4870.27: (class anchor.sink.Read:87.10)
// 4865.1-4865.29: (87.10): Cannot have potential null deference in left-mover part.
// 4869.1-4869.28: (87.10): Reduction failure
// 4871.3-4887.43: (class anchor.sink.Yield:88.10)
// 4876.1-4876.262: (88.10): Object invariant may not hold.
// 4877.1-4877.262: (88.10): Object invariant may not hold.
// 4878.1-4878.262: (88.10): Object invariant may not hold.
// 4879.1-4879.312: (88.10): Object invariant may not hold.
// 4881.1-4881.262: (88.10): Object invariant may not hold.
// 4882.1-4882.262: (88.10): Object invariant may not hold.
// 4883.1-4883.262: (88.10): Object invariant may not hold.
// 4884.1-4884.312: (88.10): Object invariant may not hold.
// 4890.3-4894.15: (class anchor.sink.While:89.10)
// 4896.1-4896.28: (83.6): Bad tid
// 4897.1-4897.52: (83.6): this is not global
// 4900.1-4900.266: (89.10): Object invariant may not hold.
// 4901.1-4901.266: (89.10): Object invariant may not hold.
// 4902.1-4902.266: (89.10): Object invariant may not hold.
// 4903.1-4903.316: (89.10): Object invariant may not hold.
// 4903.316-4904.42: (89.10): invariant isShared(curr) may not hold
// 4904.42-4905.42: (89.10): invariant isShared(pred) may not hold
// 4905.42-4906.37: (89.10): invariant pred.item < item may not hold
// 4907.1-4907.253: (89.10): Loop does not preserve yields_as annotation for field item
// 4908.1-4908.253: (89.10): Loop does not preserve yields_as annotation for field next
// 4909.1-4909.283: (89.10): Loop does not preserve yields_as annotation for field head
// 4910.1-4910.34: (89.10): Phase must be invariant at loop head
// 4911.1-4911.31: (89.10): Potentially infinite loop cannot be in post-commit phase.
// 4913.4-4915.4: (class anchor.sink.VarDeclStmt:89.27)
// 4916.4-4918.4: (class anchor.sink.VarDeclStmt:89.17)
// 4919.4-4936.29: (class anchor.sink.Read:89.17)
// 4931.1-4931.30: (89.17): Cannot have potential null deference in left-mover part.
// 4935.1-4935.29: (89.17): Reduction failure
// 4937.4-4940.26: (class anchor.sink.Assign:89.27)
// 4942.5-4945.11: (class anchor.sink.Break:89.10)
// 4948.4-4951.17: (class anchor.sink.Assign:94.12)
// 4952.4-4968.44: (class anchor.sink.Yield:95.12)
// 4957.1-4957.263: (95.12): Object invariant may not hold.
// 4958.1-4958.263: (95.12): Object invariant may not hold.
// 4959.1-4959.263: (95.12): Object invariant may not hold.
// 4960.1-4960.313: (95.12): Object invariant may not hold.
// 4962.1-4962.263: (95.12): Object invariant may not hold.
// 4963.1-4963.263: (95.12): Object invariant may not hold.
// 4964.1-4964.263: (95.12): Object invariant may not hold.
// 4965.1-4965.313: (95.12): Object invariant may not hold.
// 4969.4-4986.28: (class anchor.sink.Read:96.12)
// 4981.1-4981.30: (96.12): Cannot have potential null deference in left-mover part.
// 4985.1-4985.29: (96.12): Reduction failure
// 4987.4-5003.44: (class anchor.sink.Yield:97.12)
// 4992.1-4992.263: (97.12): Object invariant may not hold.
// 4993.1-4993.263: (97.12): Object invariant may not hold.
// 4994.1-4994.263: (97.12): Object invariant may not hold.
// 4995.1-4995.313: (97.12): Object invariant may not hold.
// 4997.1-4997.263: (97.12): Object invariant may not hold.
// 4998.1-4998.263: (97.12): Object invariant may not hold.
// 4999.1-4999.263: (97.12): Object invariant may not hold.
// 5000.1-5000.313: (97.12): Object invariant may not hold.
// 5006.1-5006.31: (89.10): Phase must be invariant at loop head
// 5011.1-5011.29: (99.10): Cannot have potential null deference in left-mover part.
// 5015.1-5015.28: (99.10): Reduction failure
// 5020.1-5020.29: (100.10): Cannot have potential null deference in left-mover part.
// 5024.1-5024.28: (100.10): Reduction failure
// 5026.3-5028.3: (class anchor.sink.VarDeclStmt:101.10)
// 5031.3-5033.3: (class anchor.sink.VarDeclStmt:101.10)
// 5034.3-5036.3: (class anchor.sink.VarDeclStmt:101.10)
// 5037.3-5039.3: (class anchor.sink.VarDeclStmt:101.10)
// 5040.3-5042.3: (class anchor.sink.VarDeclStmt:101.10)
// 5043.3-5046.20: (class anchor.sink.Assign:101.10)
// 5047.3-5050.20: (class anchor.sink.Assign:101.10)
// 5051.3-5054.20: (class anchor.sink.Assign:101.10)
// 5055.3-5058.20: (class anchor.sink.Assign:101.10)
// 5059.3-5061.3: (class anchor.sink.VarDeclStmt:17.9)
// 5062.3-5079.45: (class anchor.sink.Read:17.9)
// 5074.1-5074.43: (17.9): Cannot have potential null deference in left-mover part.
// 5078.1-5078.28: (17.9): Reduction failure
// 5080.3-5096.43: (class anchor.sink.Yield:18.9)
// 5085.1-5085.262: (18.9): Object invariant may not hold.
// 5086.1-5086.262: (18.9): Object invariant may not hold.
// 5087.1-5087.262: (18.9): Object invariant may not hold.
// 5088.1-5088.312: (18.9): Object invariant may not hold.
// 5090.1-5090.262: (18.9): Object invariant may not hold.
// 5091.1-5091.262: (18.9): Object invariant may not hold.
// 5092.1-5092.262: (18.9): Object invariant may not hold.
// 5093.1-5093.312: (18.9): Object invariant may not hold.
// 5099.3-5103.15: (class anchor.sink.While:19.9)
// 5105.1-5105.28: (83.6): Bad tid
// 5106.1-5106.52: (83.6): this is not global
// 5109.1-5109.266: (19.9): Object invariant may not hold.
// 5110.1-5110.266: (19.9): Object invariant may not hold.
// 5111.1-5111.266: (19.9): Object invariant may not hold.
// 5112.1-5112.316: (19.9): Object invariant may not hold.
// 5112.316-5113.46: (19.9): invariant isShared(node$258) may not hold
// 5113.46-5114.46: (19.9): invariant isShared(curr$258) may not hold
// 5114.46-5115.46: (19.9): invariant isShared(pred$258) may not hold
// 5115.46-5116.88: (19.9): invariant holds(curr$258, tid) may not hold
// 5116.88-5117.88: (19.9): invariant holds(pred$258, tid) may not hold
// 5117.88-5118.45: (19.9): invariant pred$258.item < item$258 may not hold
// 5118.45-5119.46: (19.9): invariant curr$258.item >= item$258 may not hold
// 5120.1-5120.253: (19.9): Loop does not preserve yields_as annotation for field item
// 5121.1-5121.253: (19.9): Loop does not preserve yields_as annotation for field next
// 5122.1-5122.283: (19.9): Loop does not preserve yields_as annotation for field head
// 5123.1-5123.34: (19.9): Phase must be invariant at loop head
// 5124.1-5124.31: (19.9): Potentially infinite loop cannot be in post-commit phase.
// 5126.4-5128.4: (class anchor.sink.VarDeclStmt:19.26)
// 5129.4-5131.4: (class anchor.sink.VarDeclStmt:19.16)
// 5132.4-5149.36: (class anchor.sink.Read:19.16)
// 5144.1-5144.34: (19.16): Cannot have potential null deference in left-mover part.
// 5148.1-5148.29: (19.16): Reduction failure
// 5150.4-5152.4: (class anchor.sink.VarDeclStmt:19.29)
// 5153.4-5170.36: (class anchor.sink.Read:19.29)
// 5165.1-5165.34: (19.29): Cannot have potential null deference in left-mover part.
// 5169.1-5169.29: (19.29): Reduction failure
// 5171.4-5174.37: (class anchor.sink.Assign:19.26)
// 5176.5-5179.11: (class anchor.sink.Break:19.9)
// 5182.4-5184.4: (class anchor.sink.VarDeclStmt:28.11)
// 5185.4-5188.37: (class anchor.sink.Assign:28.11)
// 5190.5-5192.5: (class anchor.sink.VarDeclStmt:29.13)
// 5193.5-5195.5: (class anchor.sink.VarDeclStmt:29.13)
// 5196.5-5213.37: (class anchor.sink.Read:29.13)
// 5208.1-5208.35: (29.13): Cannot have potential null deference in left-mover part.
// 5212.1-5212.30: (29.13): Reduction failure
// 5214.5-5217.38: (class anchor.sink.Assign:29.13)
// 5218.5-5221.23: (class anchor.sink.Assign:29.13)
// 5222.5-5225.26: (class anchor.sink.Break:29.13)
// 5228.4-5245.36: (class anchor.sink.Read:31.11)
// 5240.1-5240.34: (31.11): Cannot have potential null deference in left-mover part.
// 5244.1-5244.29: (31.11): Reduction failure
// 5246.4-5262.44: (class anchor.sink.Yield:32.11)
// 5251.1-5251.263: (32.11): Object invariant may not hold.
// 5252.1-5252.263: (32.11): Object invariant may not hold.
// 5253.1-5253.263: (32.11): Object invariant may not hold.
// 5254.1-5254.313: (32.11): Object invariant may not hold.
// 5256.1-5256.263: (32.11): Object invariant may not hold.
// 5257.1-5257.263: (32.11): Object invariant may not hold.
// 5258.1-5258.263: (32.11): Object invariant may not hold.
// 5259.1-5259.313: (32.11): Object invariant may not hold.
// 5265.1-5265.31: (19.9): Phase must be invariant at loop head
// 5267.3-5270.18: (class anchor.sink.Assign:34.9)
// 5271.3-5274.24: (class anchor.sink.Break:34.9)
// 5275.3-5278.18: (class anchor.sink.Assign:16.54)
// 5279.3-5282.24: (class anchor.sink.Break:16.54)
// 5285.4-5287.4: (class anchor.sink.VarDeclStmt:102.12)
// 5288.4-5290.4: (class anchor.sink.VarDeclStmt:102.12)
// 5291.4-5308.29: (class anchor.sink.Read:102.12)
// 5303.1-5303.30: (102.12): Cannot have potential null deference in left-mover part.
// 5307.1-5307.29: (102.12): Reduction failure
// 5309.4-5312.23: (class anchor.sink.Assign:102.12)
// 5316.1-5316.30: (103.12): Cannot have potential null deference in left-mover part.
// 5318.1-5318.35: (103.12): lock not held
// 5320.1-5320.29: (103.12): Reduction failure
// 5325.1-5325.30: (104.12): Cannot have potential null deference in left-mover part.
// 5327.1-5327.35: (104.12): lock not held
// 5329.1-5329.29: (104.12): Reduction failure
// 5331.4-5341.11: (class anchor.sink.Return:105.12)
// 5337.1-5337.263: (105.12): Object invariant may not hold.
// 5338.1-5338.263: (105.12): Object invariant may not hold.
// 5339.1-5339.263: (105.12): Object invariant may not hold.
// 5340.1-5340.313: (105.12): Object invariant may not hold.
// 5346.1-5346.30: (85.8): Phase must be invariant at loop head
// 5348.2-5358.9: (class anchor.sink.Return:84.40)
// 5354.1-5354.261: (84.40): Object invariant may not hold.
// 5355.1-5355.261: (84.40): Object invariant may not hold.
// 5356.1-5356.261: (84.40): Object invariant may not hold.
// 5357.1-5357.311: (84.40): Object invariant may not hold.
// 5446.1-5446.34: (3.5): Node.item failed Write-Write Right-Mover Check
// 5511.1-5511.30: (3.5): Node.item failed Write-Read Right-Mover Check
// 5580.1-5580.34: (3.5): Node.item failed Write-Write Left-Mover Check
// 5646.1-5646.30: (3.5): Node.item failed Write-Read Left-Mover Check
// 5709.1-5709.34: (3.5): Node.item failed Read-Write Right-Mover Check
// 5775.1-5775.34: (3.5): Node.item failed Read-Write Left-Mover Check
// 5840.1-5840.34: (4.5): Node.next failed Write-Write Right-Mover Check
// 5905.1-5905.30: (4.5): Node.next failed Write-Read Right-Mover Check
// 5974.1-5974.34: (4.5): Node.next failed Write-Write Left-Mover Check
// 6040.1-6040.30: (4.5): Node.next failed Write-Read Left-Mover Check
// 6103.1-6103.34: (4.5): Node.next failed Read-Write Right-Mover Check
// 6169.1-6169.34: (4.5): Node.next failed Read-Write Left-Mover Check
// 6234.1-6234.34: (13.5): OptimisticList.head failed Write-Write Right-Mover Check
// 6299.1-6299.30: (13.5): OptimisticList.head failed Write-Read Right-Mover Check
// 6368.1-6368.34: (13.5): OptimisticList.head failed Write-Write Left-Mover Check
// 6434.1-6434.30: (13.5): OptimisticList.head failed Write-Read Left-Mover Check
// 6497.1-6497.34: (13.5): OptimisticList.head failed Read-Write Right-Mover Check
// 6563.1-6563.34: (13.5): OptimisticList.head failed Read-Write Left-Mover Check
// 6640.1-6640.140: (3.5): Node.item is not Write-Write Stable with respect to Node.item (case A.1)
// 6641.1-6641.101: (3.5): Node.item is not Write-Write Stable with respect to Node.item (case A.2)
// 6642.1-6642.158: (3.5): Node.item is not Write-Write Stable with respect to Node.item (case A.3)
// 6747.1-6747.140: (3.5): Node.item is not Write-Write Stable with respect to Node.item (case C)
// 6857.1-6857.144: (3.5): Node.item is not Write-Write Stable with respect to Node.item (case D)
// 6858.1-6858.144: (3.5): Node.item is not Write-Write Stable with respect to Node.item (case R)
// 6935.1-6935.136: (3.5): Node.item is not Read-Write Stable with respect to Node.item (case F)
// 6936.1-6936.136: (3.5): Node.item is not Read-Write Stable with respect to Node.item (case H)
// 6937.1-6937.146: (3.5): Node.item is not Read-Write Stable with respect to Node.item (case I)
// 7013.1-7013.136: (3.5): Node.item is not Write-Read Stable with respect to Node.item (case J)
// 7014.1-7014.136: (3.5): Node.item is not Write-Read Stable with respect to Node.item (case K)
// 7015.1-7015.99: (3.5): Node.item is not Write-Read Stable with respect to Node.item (case L)
// 7093.1-7093.140: (4.5): Node.next is not Write-Write Stable with respect to Node.item (case A.1)
// 7094.1-7094.101: (4.5): Node.next is not Write-Write Stable with respect to Node.item (case A.2)
// 7095.1-7095.158: (4.5): Node.next is not Write-Write Stable with respect to Node.item (case A.3)
// 7200.1-7200.140: (3.5): Node.item is not Write-Write Stable with respect to Node.next (case C)
// 7310.1-7310.144: (3.5): Node.item is not Write-Write Stable with respect to Node.next (case D)
// 7311.1-7311.144: (3.5): Node.item is not Write-Write Stable with respect to Node.next (case R)
// 7388.1-7388.136: (3.5): Node.item is not Read-Write Stable with respect to Node.next (case F)
// 7389.1-7389.136: (3.5): Node.item is not Read-Write Stable with respect to Node.next (case H)
// 7390.1-7390.146: (3.5): Node.item is not Read-Write Stable with respect to Node.next (case I)
// 7466.1-7466.136: (4.5): Node.next is not Write-Read Stable with respect to Node.item (case J)
// 7467.1-7467.136: (4.5): Node.next is not Write-Read Stable with respect to Node.item (case K)
// 7468.1-7468.99: (4.5): Node.next is not Write-Read Stable with respect to Node.item (case L)
// 7546.1-7546.140: (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.item (case A.1)
// 7547.1-7547.101: (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.item (case A.2)
// 7548.1-7548.156: (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.item (case A.3)
// 7653.1-7653.140: (3.5): Node.item is not Write-Write Stable with respect to OptimisticList.head (case C)
// 7763.1-7763.144: (3.5): Node.item is not Write-Write Stable with respect to OptimisticList.head (case D)
// 7764.1-7764.144: (3.5): Node.item is not Write-Write Stable with respect to OptimisticList.head (case R)
// 7841.1-7841.136: (3.5): Node.item is not Read-Write Stable with respect to OptimisticList.head (case F)
// 7842.1-7842.136: (3.5): Node.item is not Read-Write Stable with respect to OptimisticList.head (case H)
// 7843.1-7843.144: (3.5): Node.item is not Read-Write Stable with respect to OptimisticList.head (case I)
// 7919.1-7919.136: (13.5): OptimisticList.head is not Write-Read Stable with respect to Node.item (case J)
// 7920.1-7920.136: (13.5): OptimisticList.head is not Write-Read Stable with respect to Node.item (case K)
// 7921.1-7921.99: (13.5): OptimisticList.head is not Write-Read Stable with respect to Node.item (case L)
// 7999.1-7999.140: (3.5): Node.item is not Write-Write Stable with respect to Node.next (case A.1)
// 8000.1-8000.101: (3.5): Node.item is not Write-Write Stable with respect to Node.next (case A.2)
// 8001.1-8001.158: (3.5): Node.item is not Write-Write Stable with respect to Node.next (case A.3)
// 8106.1-8106.140: (4.5): Node.next is not Write-Write Stable with respect to Node.item (case C)
// 8216.1-8216.144: (4.5): Node.next is not Write-Write Stable with respect to Node.item (case D)
// 8217.1-8217.144: (4.5): Node.next is not Write-Write Stable with respect to Node.item (case R)
// 8294.1-8294.136: (4.5): Node.next is not Read-Write Stable with respect to Node.item (case F)
// 8295.1-8295.136: (4.5): Node.next is not Read-Write Stable with respect to Node.item (case H)
// 8296.1-8296.146: (4.5): Node.next is not Read-Write Stable with respect to Node.item (case I)
// 8372.1-8372.136: (3.5): Node.item is not Write-Read Stable with respect to Node.next (case J)
// 8373.1-8373.136: (3.5): Node.item is not Write-Read Stable with respect to Node.next (case K)
// 8374.1-8374.99: (3.5): Node.item is not Write-Read Stable with respect to Node.next (case L)
// 8452.1-8452.140: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
// 8453.1-8453.101: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
// 8454.1-8454.158: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
// 8559.1-8559.140: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
// 8669.1-8669.144: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
// 8670.1-8670.144: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
// 8747.1-8747.136: (4.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
// 8748.1-8748.136: (4.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
// 8749.1-8749.146: (4.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
// 8825.1-8825.136: (4.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
// 8826.1-8826.136: (4.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
// 8827.1-8827.99: (4.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
// 8905.1-8905.140: (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.next (case A.1)
// 8906.1-8906.101: (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.next (case A.2)
// 8907.1-8907.156: (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.next (case A.3)
// 9012.1-9012.140: (4.5): Node.next is not Write-Write Stable with respect to OptimisticList.head (case C)
// 9122.1-9122.144: (4.5): Node.next is not Write-Write Stable with respect to OptimisticList.head (case D)
// 9123.1-9123.144: (4.5): Node.next is not Write-Write Stable with respect to OptimisticList.head (case R)
// 9200.1-9200.136: (4.5): Node.next is not Read-Write Stable with respect to OptimisticList.head (case F)
// 9201.1-9201.136: (4.5): Node.next is not Read-Write Stable with respect to OptimisticList.head (case H)
// 9202.1-9202.144: (4.5): Node.next is not Read-Write Stable with respect to OptimisticList.head (case I)
// 9278.1-9278.136: (13.5): OptimisticList.head is not Write-Read Stable with respect to Node.next (case J)
// 9279.1-9279.136: (13.5): OptimisticList.head is not Write-Read Stable with respect to Node.next (case K)
// 9280.1-9280.99: (13.5): OptimisticList.head is not Write-Read Stable with respect to Node.next (case L)
// 9358.1-9358.140: (3.5): Node.item is not Write-Write Stable with respect to OptimisticList.head (case A.1)
// 9359.1-9359.101: (3.5): Node.item is not Write-Write Stable with respect to OptimisticList.head (case A.2)
// 9360.1-9360.156: (3.5): Node.item is not Write-Write Stable with respect to OptimisticList.head (case A.3)
// 9465.1-9465.140: (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.item (case C)
// 9575.1-9575.144: (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.item (case D)
// 9576.1-9576.144: (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.item (case R)
// 9653.1-9653.136: (13.5): OptimisticList.head is not Read-Write Stable with respect to Node.item (case F)
// 9654.1-9654.136: (13.5): OptimisticList.head is not Read-Write Stable with respect to Node.item (case H)
// 9655.1-9655.144: (13.5): OptimisticList.head is not Read-Write Stable with respect to Node.item (case I)
// 9731.1-9731.136: (3.5): Node.item is not Write-Read Stable with respect to OptimisticList.head (case J)
// 9732.1-9732.136: (3.5): Node.item is not Write-Read Stable with respect to OptimisticList.head (case K)
// 9733.1-9733.99: (3.5): Node.item is not Write-Read Stable with respect to OptimisticList.head (case L)
// 9811.1-9811.140: (4.5): Node.next is not Write-Write Stable with respect to OptimisticList.head (case A.1)
// 9812.1-9812.101: (4.5): Node.next is not Write-Write Stable with respect to OptimisticList.head (case A.2)
// 9813.1-9813.156: (4.5): Node.next is not Write-Write Stable with respect to OptimisticList.head (case A.3)
// 9918.1-9918.140: (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.next (case C)
// 10028.1-10028.144: (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.next (case D)
// 10029.1-10029.144: (13.5): OptimisticList.head is not Write-Write Stable with respect to Node.next (case R)
// 10106.1-10106.136: (13.5): OptimisticList.head is not Read-Write Stable with respect to Node.next (case F)
// 10107.1-10107.136: (13.5): OptimisticList.head is not Read-Write Stable with respect to Node.next (case H)
// 10108.1-10108.144: (13.5): OptimisticList.head is not Read-Write Stable with respect to Node.next (case I)
// 10184.1-10184.136: (4.5): Node.next is not Write-Read Stable with respect to OptimisticList.head (case J)
// 10185.1-10185.136: (4.5): Node.next is not Write-Read Stable with respect to OptimisticList.head (case K)
// 10186.1-10186.99: (4.5): Node.next is not Write-Read Stable with respect to OptimisticList.head (case L)
// 10264.1-10264.140: (13.5): OptimisticList.head is not Write-Write Stable with respect to OptimisticList.head (case A.1)
// 10265.1-10265.101: (13.5): OptimisticList.head is not Write-Write Stable with respect to OptimisticList.head (case A.2)
// 10266.1-10266.158: (13.5): OptimisticList.head is not Write-Write Stable with respect to OptimisticList.head (case A.3)
// 10371.1-10371.140: (13.5): OptimisticList.head is not Write-Write Stable with respect to OptimisticList.head (case C)
// 10481.1-10481.144: (13.5): OptimisticList.head is not Write-Write Stable with respect to OptimisticList.head (case D)
// 10482.1-10482.144: (13.5): OptimisticList.head is not Write-Write Stable with respect to OptimisticList.head (case R)
// 10559.1-10559.136: (13.5): OptimisticList.head is not Read-Write Stable with respect to OptimisticList.head (case F)
// 10560.1-10560.136: (13.5): OptimisticList.head is not Read-Write Stable with respect to OptimisticList.head (case H)
// 10561.1-10561.146: (13.5): OptimisticList.head is not Read-Write Stable with respect to OptimisticList.head (case I)
// 10637.1-10637.136: (13.5): OptimisticList.head is not Write-Read Stable with respect to OptimisticList.head (case J)
// 10638.1-10638.136: (13.5): OptimisticList.head is not Write-Read Stable with respect to OptimisticList.head (case K)
// 10639.1-10639.99: (13.5): OptimisticList.head is not Write-Read Stable with respect to OptimisticList.head (case L)
// 10646.1-10646.262: (<undefined position>): Object invariant may not hold.
// 10647.1-10647.262: (<undefined position>): Object invariant may not hold.
// 10648.1-10648.262: (<undefined position>): Object invariant may not hold.
// 10649.1-10649.312: (<undefined position>): Object invariant may not hold.
// 10659.1-10659.261: (<undefined position>): Object invariant may not hold.
// 10660.1-10660.261: (<undefined position>): Object invariant may not hold.
// 10661.1-10661.261: (<undefined position>): Object invariant may not hold.
// 10662.1-10662.311: (<undefined position>): Object invariant may not hold.
// 10682.1-10705.2: (3.5): yields_as clause for Node.item is not valid
// 10710.1-10728.2: (3.5): yields_as clause for Node.item is not reflexive
// 10734.1-10734.262: (3.24): Object invariant may not hold.
// 10735.1-10735.262: (3.24): Object invariant may not hold.
// 10736.1-10736.262: (3.24): Object invariant may not hold.
// 10737.1-10737.312: (3.24): Object invariant may not hold.
// 10738.1-10774.2: (3.5): yields_as clause for Node.item is not transitive
// 10793.1-10816.2: (4.5): yields_as clause for Node.next is not valid
// 10821.1-10839.2: (4.5): yields_as clause for Node.next is not reflexive
// 10845.1-10845.262: (4.33): Object invariant may not hold.
// 10846.1-10846.262: (4.33): Object invariant may not hold.
// 10847.1-10847.262: (4.33): Object invariant may not hold.
// 10848.1-10848.312: (4.33): Object invariant may not hold.
// 10849.1-10885.2: (4.5): yields_as clause for Node.next is not transitive
// 10905.1-10928.2: (7.32): yields_as clause for Node._lock is not valid
// 10933.1-10951.2: (7.32): yields_as clause for Node._lock is not reflexive
// 10957.1-10957.262: (2.1): Object invariant may not hold.
// 10958.1-10958.262: (2.1): Object invariant may not hold.
// 10959.1-10959.262: (2.1): Object invariant may not hold.
// 10960.1-10960.312: (2.1): Object invariant may not hold.
// 10961.1-10997.2: (7.32): yields_as clause for Node._lock is not transitive
// 11016.1-11039.2: (13.5): yields_as clause for OptimisticList.head is not valid
// 11044.1-11062.2: (13.5): yields_as clause for OptimisticList.head is not reflexive
// 11068.1-11068.262: (13.24): Object invariant may not hold.
// 11069.1-11069.262: (13.24): Object invariant may not hold.
// 11070.1-11070.262: (13.24): Object invariant may not hold.
// 11071.1-11071.312: (13.24): Object invariant may not hold.
// 11072.1-11108.2: (13.5): yields_as clause for OptimisticList.head is not transitive
// 11128.1-11151.2: (7.32): yields_as clause for OptimisticList._lock is not valid
// 11156.1-11174.2: (7.32): yields_as clause for OptimisticList._lock is not reflexive
// 11180.1-11180.262: (11.1): Object invariant may not hold.
// 11181.1-11181.262: (11.1): Object invariant may not hold.
// 11182.1-11182.262: (11.1): Object invariant may not hold.
// 11183.1-11183.312: (11.1): Object invariant may not hold.
// 11184.1-11220.2: (7.32): yields_as clause for OptimisticList._lock is not transitive
