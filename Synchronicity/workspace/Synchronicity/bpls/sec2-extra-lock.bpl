                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/sec2-extra-lock.anchor:                 
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Lock {                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        // return;                                                                                  
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Buffer {                                                                                  
       Lock popLock isRead ? B : E                                                                  
                                                                                                    
       Lock pushLock isRead ? B : E                                                                 
                                                                                                    
      volatile boolean full isRead                                                                  
       ? holds(this.popLock, tid)                                                                   
         ? this.full ? R : N                                                                        
         : holds(this.pushLock, tid)                                                                
           ? this.full ? N : R                                                                      
           : E                                                                                      
       : holds(this, tid) && holds(this.popLock, tid)                                               
         ? this.full && !newValue ? N : E                                                           
         : holds(this, tid) && holds(this.pushLock, tid)                                            
           ? !this.full && newValue ? N : E                                                         
           : E                                                                                      
        yields_as (holds(this.popLock, tid) && this.full ==> newValue) && (holds(this.pushLock, tid) && !this.full ==> !newValue);
                                                                                                    
                                                                                                    
      volatile int data isRead                                                                      
       ? holds(this, tid) && holds(this.popLock, tid) && this.full ? B : E                          
       : holds(this, tid) && holds(this.pushLock, tid) && !this.full ? B : E                        
                                                                                                    
      invariant  this.popLock != this.pushLock;                                                     
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.popLock == Lock.null;                                                           
        assume this.pushLock == Lock.null;                                                          
        assume this.full == false;                                                                  
        assume this.data == 0;                                                                      
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires !holds(this.popLock, tid);                                                           
                                                                                                    
      public void push(int x) {                                                                     
        Lock tmp1;                                                                                  
        tmp1 := this.pushLock;                                                                      
        synchronized (tmp1) {                                                                       
          while (true)                                                                              
            invariant holds(this.pushLock, tid);                                                    
            invariant !holds(this.popLock, tid);                                                    
            {                                                                                       
            boolean tmp2;                                                                           
            tmp2 = true;                                                                            
            if (!tmp2) break; else {                                                                
                                                                                                    
            }                                                                                       
            {                                                                                       
              boolean tmp3;                                                                         
              boolean tmp4;                                                                         
              tmp4 := this.full;                                                                    
              tmp3 = !tmp4;                                                                         
              if (tmp3 /* == !this.full */) {                                                       
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              yield;                                                                                
            }                                                                                       
          }                                                                                         
          yield;                                                                                    
          synchronized (this) {                                                                     
            this.data := x;                                                                         
            boolean tmp5;                                                                           
            tmp5 = true;                                                                            
            this.full := tmp5;                                                                      
          }                                                                                         
        }                                                                                           
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public int pop() {                                                                            
        Lock tmp6;                                                                                  
        tmp6 := this.popLock;                                                                       
        synchronized (tmp6) {                                                                       
          while (true)                                                                              
            invariant holds(this.popLock, tid);                                                     
            {                                                                                       
            boolean tmp7;                                                                           
            tmp7 = true;                                                                            
            if (!tmp7) break; else {                                                                
                                                                                                    
            }                                                                                       
            {                                                                                       
              boolean tmp8;                                                                         
              tmp8 := this.full;                                                                    
              if (tmp8 /* == this.full */) {                                                        
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              yield;                                                                                
            }                                                                                       
          }                                                                                         
          yield;                                                                                    
          synchronized (this) {                                                                     
            int result;                                                                             
            result := this.data;                                                                    
            boolean tmp9;                                                                           
            tmp9 = false;                                                                           
            this.full := tmp9;                                                                      
             return result;                                                                         
          }                                                                                         
        }                                                                                           
        // return -1;                                                                               
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Lock {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Buffer {                                                                                  
       Lock popLock isRead ? B : E                                                                  
                                                                                                    
       Lock pushLock isRead ? B : E                                                                 
                                                                                                    
      volatile boolean full isRead                                                                  
       ? holds(this.popLock, tid)                                                                   
         ? this.full ? R : N                                                                        
         : holds(this.pushLock, tid)                                                                
           ? this.full ? N : R                                                                      
           : E                                                                                      
       : holds(this, tid) && holds(this.popLock, tid)                                               
         ? this.full && !newValue ? N : E                                                           
         : holds(this, tid) && holds(this.pushLock, tid)                                            
           ? !this.full && newValue ? N : E                                                         
           : E                                                                                      
        yields_as (holds(this.popLock, tid) && this.full ==> newValue) && (holds(this.pushLock, tid) && !this.full ==> !newValue);
                                                                                                    
                                                                                                    
      volatile int data isRead                                                                      
       ? holds(this, tid) && holds(this.popLock, tid) && this.full ? B : E                          
       : holds(this, tid) && holds(this.pushLock, tid) && !this.full ? B : E                        
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.popLock != this.pushLock;                                                     
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.popLock == Lock.null;                                                           
        assume this.pushLock == Lock.null;                                                          
        assume this.full == false;                                                                  
        assume this.data == 0;                                                                      
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires !holds(this.popLock, tid);                                                           
                                                                                                    
      public void push(int x) {                                                                     
        Lock tmp1;                                                                                  
        tmp1 := this.pushLock;                                                                      
        {                                                                                           
          acquire(tmp1);                                                                            
          {                                                                                         
            while (true)                                                                            
              invariant holds(this.pushLock, tid);                                                  
              invariant !holds(this.popLock, tid);                                                  
              invariant holds(tmp1, tid);                                                           
              {                                                                                     
              boolean tmp2;                                                                         
              tmp2 = true;                                                                          
              if (!tmp2) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                boolean tmp3;                                                                       
                boolean tmp4;                                                                       
                tmp4 := this.full;                                                                  
                tmp3 = !tmp4;                                                                       
                if (tmp3 /* == !this.full */) {                                                     
                  {                                                                                 
                    break;                                                                          
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            {                                                                                       
              acquire(this);                                                                        
              {                                                                                     
                this.data := x;                                                                     
                boolean tmp5;                                                                       
                tmp5 = true;                                                                        
                this.full := tmp5;                                                                  
              }                                                                                     
              release(this);                                                                        
            }                                                                                       
          }                                                                                         
          release(tmp1);                                                                            
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public int pop() {                                                                            
        Lock tmp6;                                                                                  
        tmp6 := this.popLock;                                                                       
        {                                                                                           
          acquire(tmp6);                                                                            
          {                                                                                         
            while (true)                                                                            
              invariant holds(this.popLock, tid);                                                   
              invariant holds(tmp6, tid);                                                           
              {                                                                                     
              boolean tmp7;                                                                         
              tmp7 = true;                                                                          
              if (!tmp7) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                boolean tmp8;                                                                       
                tmp8 := this.full;                                                                  
                if (tmp8 /* == this.full */) {                                                      
                  {                                                                                 
                    break;                                                                          
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            {                                                                                       
              acquire(this);                                                                        
              {                                                                                     
                int result;                                                                         
                result := this.data;                                                                
                boolean tmp9;                                                                       
                tmp9 = false;                                                                       
                this.full := tmp9;                                                                  
                {                                                                                   
                  release(this);                                                                    
                  release(tmp6);                                                                    
                   return result;                                                                   
                }                                                                                   
              }                                                                                     
              release(this);                                                                        
            }                                                                                       
          }                                                                                         
          release(tmp6);                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Lock {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Buffer {                                                                                  
       Lock popLock isRead ? B : E                                                                  
                                                                                                    
       Lock pushLock isRead ? B : E                                                                 
                                                                                                    
      volatile boolean full isRead                                                                  
       ? holds(this.popLock, tid)                                                                   
         ? this.full ? R : N                                                                        
         : holds(this.pushLock, tid)                                                                
           ? this.full ? N : R                                                                      
           : E                                                                                      
       : holds(this, tid) && holds(this.popLock, tid)                                               
         ? this.full && !newValue ? N : E                                                           
         : holds(this, tid) && holds(this.pushLock, tid)                                            
           ? !this.full && newValue ? N : E                                                         
           : E                                                                                      
        yields_as (holds(this.popLock, tid) && this.full ==> newValue) && (holds(this.pushLock, tid) && !this.full ==> !newValue);
                                                                                                    
                                                                                                    
      volatile int data isRead                                                                      
       ? holds(this, tid) && holds(this.popLock, tid) && this.full ? B : E                          
       : holds(this, tid) && holds(this.pushLock, tid) && !this.full ? B : E                        
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.popLock != this.pushLock;                                                     
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.popLock == Lock.null;                                                           
        assume this.pushLock == Lock.null;                                                          
        assume this.full == false;                                                                  
        assume this.data == 0;                                                                      
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires !holds(this.popLock, tid);                                                           
                                                                                                    
      public void push(int x) {                                                                     
        Lock tmp1;                                                                                  
        tmp1 := this.pushLock;                                                                      
        {                                                                                           
          acquire(tmp1);                                                                            
          {                                                                                         
            while (true)                                                                            
              invariant holds(this.pushLock, tid);                                                  
              invariant !holds(this.popLock, tid);                                                  
              invariant holds(tmp1, tid);                                                           
              {                                                                                     
              boolean tmp2;                                                                         
              tmp2 = true;                                                                          
              if (!tmp2) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                boolean tmp3;                                                                       
                boolean tmp4;                                                                       
                tmp4 := this.full;                                                                  
                tmp3 = !tmp4;                                                                       
                if (tmp3 /* == !this.full */) {                                                     
                  {                                                                                 
                    break;                                                                          
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            {                                                                                       
              acquire(this);                                                                        
              {                                                                                     
                this.data := x;                                                                     
                boolean tmp5;                                                                       
                tmp5 = true;                                                                        
                this.full := tmp5;                                                                  
              }                                                                                     
              release(this);                                                                        
            }                                                                                       
          }                                                                                         
          release(tmp1);                                                                            
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public int pop() {                                                                            
        Lock tmp6;                                                                                  
        tmp6 := this.popLock;                                                                       
        {                                                                                           
          acquire(tmp6);                                                                            
          {                                                                                         
            while (true)                                                                            
              invariant holds(this.popLock, tid);                                                   
              invariant holds(tmp6, tid);                                                           
              {                                                                                     
              boolean tmp7;                                                                         
              tmp7 = true;                                                                          
              if (!tmp7) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                boolean tmp8;                                                                       
                tmp8 := this.full;                                                                  
                if (tmp8 /* == this.full */) {                                                      
                  {                                                                                 
                    break;                                                                          
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            {                                                                                       
              acquire(this);                                                                        
              {                                                                                     
                int result;                                                                         
                result := this.data;                                                                
                boolean tmp9;                                                                       
                tmp9 = false;                                                                       
                this.full := tmp9;                                                                  
                {                                                                                   
                  release(this);                                                                    
                  release(tmp6);                                                                    
                   return result;                                                                   
                }                                                                                   
              }                                                                                     
              release(this);                                                                        
            }                                                                                       
          }                                                                                         
          release(tmp6);                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Lock {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Buffer {                                                                                  
       Lock popLock isRead ? B : E                                                                  
                                                                                                    
       Lock pushLock isRead ? B : E                                                                 
                                                                                                    
      volatile boolean full isRead                                                                  
       ? holds(this.popLock, tid)                                                                   
         ? this.full ? R : N                                                                        
         : holds(this.pushLock, tid)                                                                
           ? this.full ? N : R                                                                      
           : E                                                                                      
       : holds(this, tid) && holds(this.popLock, tid)                                               
         ? this.full && !newValue ? N : E                                                           
         : holds(this, tid) && holds(this.pushLock, tid)                                            
           ? !this.full && newValue ? N : E                                                         
           : E                                                                                      
        yields_as (holds(this.popLock, tid) && this.full ==> newValue) && (holds(this.pushLock, tid) && !this.full ==> !newValue);
                                                                                                    
                                                                                                    
      volatile int data isRead                                                                      
       ? holds(this, tid) && holds(this.popLock, tid) && this.full ? B : E                          
       : holds(this, tid) && holds(this.pushLock, tid) && !this.full ? B : E                        
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.popLock != this.pushLock;                                                     
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.popLock == Lock.null;                                                           
        assume this.pushLock == Lock.null;                                                          
        assume this.full == false;                                                                  
        assume this.data == 0;                                                                      
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires !holds(this.popLock, tid);                                                           
                                                                                                    
      public void push(int x) {                                                                     
        Lock tmp1;                                                                                  
        tmp1 := this.pushLock;                                                                      
        {                                                                                           
          acquire(tmp1);                                                                            
          {                                                                                         
            while (true)                                                                            
              invariant holds(this.pushLock, tid);                                                  
              invariant !holds(this.popLock, tid);                                                  
              invariant holds(tmp1, tid);                                                           
              {                                                                                     
              boolean tmp2;                                                                         
              tmp2 = true;                                                                          
              if (!tmp2) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                boolean tmp3;                                                                       
                boolean tmp4;                                                                       
                tmp4 := this.full;                                                                  
                tmp3 = !tmp4;                                                                       
                if (tmp3 /* == !this.full */) {                                                     
                  {                                                                                 
                    break;                                                                          
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            {                                                                                       
              acquire(this);                                                                        
              {                                                                                     
                this.data := x;                                                                     
                boolean tmp5;                                                                       
                tmp5 = true;                                                                        
                this.full := tmp5;                                                                  
              }                                                                                     
              release(this);                                                                        
            }                                                                                       
          }                                                                                         
          release(tmp1);                                                                            
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public int pop() {                                                                            
        Lock tmp6;                                                                                  
        tmp6 := this.popLock;                                                                       
        {                                                                                           
          acquire(tmp6);                                                                            
          {                                                                                         
            while (true)                                                                            
              invariant holds(this.popLock, tid);                                                   
              invariant holds(tmp6, tid);                                                           
              {                                                                                     
              boolean tmp7;                                                                         
              tmp7 = true;                                                                          
              if (!tmp7) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                boolean tmp8;                                                                       
                tmp8 := this.full;                                                                  
                if (tmp8 /* == this.full */) {                                                      
                  {                                                                                 
                    break;                                                                          
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            {                                                                                       
              acquire(this);                                                                        
              {                                                                                     
                int result;                                                                         
                result := this.data;                                                                
                boolean tmp9;                                                                       
                tmp9 = false;                                                                       
                this.full := tmp9;                                                                  
                {                                                                                   
                  release(this);                                                                    
                  release(tmp6);                                                                    
                   return result;                                                                   
                }                                                                                   
              }                                                                                     
              release(this);                                                                        
            }                                                                                       
          }                                                                                         
          release(tmp6);                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Lock ***/                                                                           
                                                                                                    
type Lock;                                                                                          
const unique Lock.null: Lock;                                                                       
var Lock._state: [Lock]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Lock._lock: [Lock]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Lock._lock(tid: Tid,this : Lock,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Lock._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Lock._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Lock._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Lock._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Lock._lock(tid: Tid,this : Lock,newValue: Tid,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Lock._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Lock._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Lock._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Lock._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Buffer ***/                                                                         
                                                                                                    
type Buffer;                                                                                        
const unique Buffer.null: Buffer;                                                                   
var Buffer._state: [Buffer]State;                                                                   
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer.popLock: [Buffer]Lock;                                                                   
                                                                                                    
function {:inline} ReadEval.Buffer.popLock(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Lock.null;                                                                        
 if (isRead) then                                                                                   
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer.popLock(tid: Tid,this : Buffer,newValue: Lock,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isRead) then                                                                                   
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer.pushLock: [Buffer]Lock;                                                                  
                                                                                                    
function {:inline} ReadEval.Buffer.pushLock(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Lock.null;                                                                        
 if (isRead) then                                                                                   
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer.pushLock(tid: Tid,this : Buffer,newValue: Lock,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isRead) then                                                                                   
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer.full: [Buffer]bool;                                                                      
                                                                                                    
function {:inline} ReadEval.Buffer.full(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := false;                                                                            
 if (isRead) then                                                                                   
  if ((isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid)) then
   if (Buffer.full[this]) then                                                                      
    moverPath(_R, 7)                                                                                
   else                                                                                             
    moverPath(_N, 3)                                                                                
  else                                                                                              
   if ((isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid)) then
    if (Buffer.full[this]) then                                                                     
     moverPath(_N, 13)                                                                              
    else                                                                                            
     moverPath(_R, 5)                                                                               
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)&&(isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid))) then
   if ((Buffer.full[this]&&!(newValue))) then                                                       
    moverPath(_N, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)&&(isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid))) then
    if ((!(Buffer.full[this])&&newValue)) then                                                      
     moverPath(_N, 12)                                                                              
    else                                                                                            
     moverPath(_E, 4)                                                                               
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer.full(tid: Tid,this : Buffer,newValue: bool,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isRead) then                                                                                   
  if ((isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid)) then
   if (Buffer.full[this]) then                                                                      
    moverPath(_R, 7)                                                                                
   else                                                                                             
    moverPath(_N, 3)                                                                                
  else                                                                                              
   if ((isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid)) then
    if (Buffer.full[this]) then                                                                     
     moverPath(_N, 13)                                                                              
    else                                                                                            
     moverPath(_R, 5)                                                                               
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)&&(isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid))) then
   if ((Buffer.full[this]&&!(newValue))) then                                                       
    moverPath(_N, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)&&(isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid))) then
    if ((!(Buffer.full[this])&&newValue)) then                                                      
     moverPath(_N, 12)                                                                              
    else                                                                                            
     moverPath(_E, 4)                                                                               
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer.data: [Buffer]int;                                                                       
                                                                                                    
function {:inline} ReadEval.Buffer.data(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isRead) then                                                                                   
  if ((((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)&&(isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid))&&Buffer.full[this])) then
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)&&(isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid))&&!(Buffer.full[this]))) then
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer.data(tid: Tid,this : Buffer,newValue: int,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isRead) then                                                                                   
  if ((((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)&&(isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid))&&Buffer.full[this])) then
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)&&(isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid))&&!(Buffer.full[this]))) then
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer._lock: [Buffer]Tid;                                                                      
                                                                                                    
function {:inline} ReadEval.Buffer._lock(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Buffer._lock[this]==tid)) then                                                              
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Buffer._lock[this]==Tid.null)&&(newValue==tid))) then                                      
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Buffer._lock[this]==tid)&&(newValue==Tid.null))) then                                     
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer._lock(tid: Tid,this : Buffer,newValue: Tid,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Buffer._lock[this]==tid)) then                                                              
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Buffer._lock[this]==Tid.null)&&(newValue==tid))) then                                      
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Buffer._lock[this]==tid)&&(newValue==Tid.null))) then                                     
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.Buffer.3761691(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (bool) {
 (Buffer.popLock[this]!=Buffer.pushLock[this])                                                      
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Buffer.push(tid:Tid, this : Buffer, x : int)                                             
modifies Lock._state;                                                                               
modifies Lock._lock;                                                                                
modifies Buffer._state;                                                                             
modifies Buffer.popLock;                                                                            
modifies Buffer.pushLock;                                                                           
modifies Buffer.full;                                                                               
modifies Buffer.data;                                                                               
modifies Buffer._lock;                                                                              
                                                                                                    
requires ValidTid(tid);                                                                                    // (27.3): Bad tid
requires isShared(Buffer._state[this]);                                                                    // (27.3): this is not global
                                                                                                    
requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
requires !((isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid));
                                                                                                    
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (27.3): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
ensures  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (27.3): Object invariant may not hold.
{                                                                                                   
 var tmp13767648: Lock;                                                                             
 var $recorded.state3767644_post: int;                                                              
 var moverPath3767663: MoverPath;                                                                   
 var tid3767647: Tid;                                                                               
 var Buffer._state3767663: [Buffer]State;                                                           
 var $pc3767648_post: Phase;                                                                        
 var Buffer.data3767644: [Buffer]int;                                                               
 var tid3767633: Tid;                                                                               
 var Buffer.pushLock3767648: [Buffer]Lock;                                                          
 var this3767648_post: Buffer;                                                                      
 var Buffer._lock3767653: [Buffer]Tid;                                                              
 var Lock._lock3767633: [Lock]Tid;                                                                  
 var Buffer.pushLock3767647_bottom: [Buffer]Lock;                                                   
 var Buffer._state3767633: [Buffer]State;                                                           
 var Lock._lock3767663: [Lock]Tid;                                                                  
 var Buffer.pushLock3767648_post: [Buffer]Lock;                                                     
 var tmp43767644_post: bool;                                                                        
 var this3767644: Buffer;                                                                           
 var this3767653: Buffer;                                                                           
 var Buffer.popLock3767663: [Buffer]Lock;                                                           
 var Lock._state3767644: [Lock]State;                                                               
 var moverPath3767653: MoverPath;                                                                   
 var Buffer.data3767647: [Buffer]int;                                                               
 var Buffer.popLock3767648: [Buffer]Lock;                                                           
 var Buffer._state3767648_post: [Buffer]State;                                                      
 var x3767653: int;                                                                                 
 var Lock._lock3767611: [Lock]Tid;                                                                  
 var tmp13767647_bottom: Lock;                                                                      
 var tmp43767633: bool;                                                                             
 var Buffer.full3767648: [Buffer]bool;                                                              
 var moverPath3767633: MoverPath;                                                                   
 var tmp5: bool;                                                                                    
 var tid3767647_bottom: Tid;                                                                        
 var Buffer.data3767633: [Buffer]int;                                                               
 var tmp53767663: bool;                                                                             
 var Buffer.full3767644: [Buffer]bool;                                                              
 var Buffer.full3767633: [Buffer]bool;                                                              
 var tmp13767648_post: Lock;                                                                        
 var Buffer.full3767647: [Buffer]bool;                                                              
 var Buffer._state3767644: [Buffer]State;                                                           
 var tmp13767653: Lock;                                                                             
 var tmp23767644: bool;                                                                             
 var Buffer.full3767611: [Buffer]bool;                                                              
 var tid3767663: Tid;                                                                               
 var path3767633: int;                                                                              
 var tmp13767611: Lock;                                                                             
 var Buffer.data3767647_bottom: [Buffer]int;                                                        
 var tmp33767644_post: bool;                                                                        
 var tmp33767644: bool;                                                                             
 var Buffer._lock3767672: [Buffer]Tid;                                                              
 var Lock._lock3767648: [Lock]Tid;                                                                  
 var this3767611: Buffer;                                                                           
 var tid3767648: Tid;                                                                               
 var tmp2: bool;                                                                                    
 var Buffer._state3767653: [Buffer]State;                                                           
 var Buffer.pushLock3767644_post: [Buffer]Lock;                                                     
 var Buffer.full3767672: [Buffer]bool;                                                              
 var this3767647_bottom: Buffer;                                                                    
 var tmp13767647: Lock;                                                                             
 var this3767647: Buffer;                                                                           
 var Buffer._lock3767648: [Buffer]Tid;                                                              
 var tmp13767672: Lock;                                                                             
 var Lock._state3767672: [Lock]State;                                                               
 var $pc3767647: Phase;                                                                             
 var path3767611: int;                                                                              
 var Buffer.popLock3767653: [Buffer]Lock;                                                           
 var mover3767633: Mover;                                                                           
 var x3767611: int;                                                                                 
 var Buffer._state3767647: [Buffer]State;                                                           
 var moverPath3767611: MoverPath;                                                                   
 var $pc3767644_post: Phase;                                                                        
 var Lock._state3767663: [Lock]State;                                                               
 var Buffer._lock3767647_bottom: [Buffer]Tid;                                                       
 var Buffer.full3767653: [Buffer]bool;                                                              
 var this3767644_post: Buffer;                                                                      
 var Lock._state3767648_post: [Lock]State;                                                          
 var Buffer.popLock3767644: [Buffer]Lock;                                                           
 var Lock._lock3767647_bottom: [Lock]Tid;                                                           
 var tmp1: Lock;                                                                                    
 var this3767663: Buffer;                                                                           
 var x3767633: int;                                                                                 
 var this3767633: Buffer;                                                                           
 var Buffer.data3767648_post: [Buffer]int;                                                          
 var Buffer.pushLock3767644: [Buffer]Lock;                                                          
 var Buffer.pushLock3767653: [Buffer]Lock;                                                          
 var Buffer._lock3767663: [Buffer]Tid;                                                              
 var tmp23767633: bool;                                                                             
 var Lock._lock3767647: [Lock]Tid;                                                                  
 var Lock._state3767644_post: [Lock]State;                                                          
 var Buffer._state3767644_post: [Buffer]State;                                                      
 var tid3767653: Tid;                                                                               
 var $pc3767663: Phase;                                                                             
 var Buffer.full3767647_bottom: [Buffer]bool;                                                       
 var Buffer._state3767647_bottom: [Buffer]State;                                                    
 var $recorded.state3767647_bottom: int;                                                            
 var x3767647_bottom: int;                                                                          
 var tmp13767663: Lock;                                                                             
 var Lock._lock3767653: [Lock]Tid;                                                                  
 var Buffer.popLock3767672: [Buffer]Lock;                                                           
 var Buffer.popLock3767611: [Buffer]Lock;                                                           
 var this3767648: Buffer;                                                                           
 var Buffer.full3767663: [Buffer]bool;                                                              
 var Buffer._lock3767644: [Buffer]Tid;                                                              
 var path3767653: int;                                                                              
 var Buffer.data3767644_post: [Buffer]int;                                                          
 var $recorded.state3767648_post: int;                                                              
 var $recorded.state3767647: int;                                                                   
 var tmp13767633: Lock;                                                                             
 var $pc3767647_bottom: Phase;                                                                      
 var Lock._lock3767644: [Lock]Tid;                                                                  
 var Buffer.data3767672: [Buffer]int;                                                               
 var mover3767653: Mover;                                                                           
 var tid3767648_post: Tid;                                                                          
 var mover3767663: Mover;                                                                           
 var x3767663: int;                                                                                 
 var $pc3767672: Phase;                                                                             
 var Buffer.pushLock3767672: [Buffer]Lock;                                                          
 var tid3767611: Tid;                                                                               
 var Buffer.popLock3767647_bottom: [Buffer]Lock;                                                    
 var phase3767647: Phase;                                                                           
 var Buffer.popLock3767647: [Buffer]Lock;                                                           
 var Buffer.data3767663: [Buffer]int;                                                               
 var tid3767672: Tid;                                                                               
 var $recorded.state3767672: int;                                                                   
 var x3767647: int;                                                                                 
 var Lock._lock3767648_post: [Lock]Tid;                                                             
 var $recorded.state3767653: int;                                                                   
 var Buffer.data3767648: [Buffer]int;                                                               
 var Buffer.pushLock3767633: [Buffer]Lock;                                                          
 var $recorded.state3767663: int;                                                                   
 var Buffer.popLock3767648_post: [Buffer]Lock;                                                      
 var Buffer.full3767648_post: [Buffer]bool;                                                         
 var $recorded.state3767648: int;                                                                   
 var Lock._lock3767644_post: [Lock]Tid;                                                             
 var tmp33767633: bool;                                                                             
 var Lock._state3767633: [Lock]State;                                                               
 var Lock._state3767647: [Lock]State;                                                               
 var Buffer._lock3767648_post: [Buffer]Tid;                                                         
 var Buffer._lock3767633: [Buffer]Tid;                                                              
 var Buffer._lock3767647: [Buffer]Tid;                                                              
 var tmp3: bool;                                                                                    
 var Buffer.data3767653: [Buffer]int;                                                               
 var Buffer.pushLock3767647: [Buffer]Lock;                                                          
 var tmp4: bool;                                                                                    
 var Buffer.pushLock3767611: [Buffer]Lock;                                                          
 var $pc3767633: Phase;                                                                             
 var tid3767644_post: Tid;                                                                          
 var $recorded.state3767611: int;                                                                   
 var $recorded.state3767644: int;                                                                   
 var Lock._state3767647_bottom: [Lock]State;                                                        
 var x3767648: int;                                                                                 
 var $recorded.state3767633: int;                                                                   
 var this3767672: Buffer;                                                                           
 var Lock._state3767611: [Lock]State;                                                               
 var x3767648_post: int;                                                                            
 var tmp13767644_post: Lock;                                                                        
 var mover3767611: Mover;                                                                           
 var tmp23767644_post: bool;                                                                        
 var Lock._lock3767672: [Lock]Tid;                                                                  
 var Buffer._state3767672: [Buffer]State;                                                           
 var Buffer._lock3767611: [Buffer]Tid;                                                              
 var tmp43767644: bool;                                                                             
 var x3767644_post: int;                                                                            
 var Buffer.full3767644_post: [Buffer]bool;                                                         
 var $pc3767611: Phase;                                                                             
 var Buffer.popLock3767644_post: [Buffer]Lock;                                                      
 var tid3767644: Tid;                                                                               
 var $pc3767644: Phase;                                                                             
 var Buffer._state3767648: [Buffer]State;                                                           
 var Buffer._lock3767644_post: [Buffer]Tid;                                                         
 var tmp13767644: Lock;                                                                             
 var Buffer.data3767611: [Buffer]int;                                                               
 var path3767663: int;                                                                              
 var x3767644: int;                                                                                 
 var Lock._state3767648: [Lock]State;                                                               
 var Buffer.pushLock3767663: [Buffer]Lock;                                                          
 var Buffer.popLock3767633: [Buffer]Lock;                                                           
 var Buffer._state3767611: [Buffer]State;                                                           
 var Lock._state3767653: [Lock]State;                                                               
 var $pc3767648: Phase;                                                                             
 var x3767672: int;                                                                                 
 var $pc3767653: Phase;                                                                             
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true && leq(m#moverPath(ReadEval.Buffer.popLock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)),_R);       // (27.12): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 29.5: Lock tmp1;                                                                                
                                                                                                    
                                                                                                    
 // 29.5: tmp1 := this.pushLock;                                                                    
                                                                                                    
                                                                                                    
 moverPath3767611 := ReadEval.Buffer.pushLock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 mover3767611 := m#moverPath(moverPath3767611);                                                     
 path3767611 := p#moverPath(moverPath3767611);                                                      
 assume Lock._state3767611 == Lock._state && Lock._lock3767611 == Lock._lock && Buffer._state3767611 == Buffer._state && Buffer.popLock3767611 == Buffer.popLock && Buffer.pushLock3767611 == Buffer.pushLock && Buffer.full3767611 == Buffer.full && Buffer.data3767611 == Buffer.data && Buffer._lock3767611 == Buffer._lock && tmp13767611 == tmp1 && x3767611 == x && this3767611 == this && tid3767611 == tid && $pc3767611 == $pc;
 assume $recorded.state3767611 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (29.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover3767611);                                                              
 assert $pc != PhaseError;                                                                                 // (29.5): Reduction failure
 tmp1 := Buffer.pushLock[this];                                                                     
 if ($pc == PreCommit) {                                                                            
  assume tmp1 != Lock.null;                                                                         
 } else {                                                                                           
  assert tmp1 != Lock.null;                                                                                // (29.18): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume Lock._lock[tmp1] == Tid.null;                                                               
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (29.18): Reduction failure
 Lock._lock[tmp1] := tid;                                                                           
 assume Lock._state3767647 == Lock._state && Lock._lock3767647 == Lock._lock && Buffer._state3767647 == Buffer._state && Buffer.popLock3767647 == Buffer.popLock && Buffer.pushLock3767647 == Buffer.pushLock && Buffer.full3767647 == Buffer.full && Buffer.data3767647 == Buffer.data && Buffer._lock3767647 == Buffer._lock && tmp13767647 == tmp1 && x3767647 == x && this3767647 == this && tid3767647 == tid;
 assume $recorded.state3767647 == 1;                                                                
                                                                                                    
 // 30.9: while (true)                                                                              
                                                                                                    
 phase3767647 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (27.3): Bad tid
  invariant isShared(Buffer._state[this]);                                                                 // (27.3): this is not global
                                                                                                    
  invariant StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
  invariant  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (30.9): Object invariant may not hold.
  invariant (isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid);
  invariant !((isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid));
  invariant (isAccessible(Lock._state[tmp1], tid) && Lock._lock[tmp1] == tid);                      
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.popLock(tid : Tid, _this, Buffer.popLock[_this] ,Lock._state3767647,Lock._lock3767647,Buffer._state3767647,Buffer.popLock3767647,Buffer.pushLock3767647,Buffer.full3767647,Buffer.data3767647,Buffer._lock3767647));       // (30.9): Loop does not preserve yields_as annotation for field popLock
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.pushLock(tid : Tid, _this, Buffer.pushLock[_this] ,Lock._state3767647,Lock._lock3767647,Buffer._state3767647,Buffer.popLock3767647,Buffer.pushLock3767647,Buffer.full3767647,Buffer.data3767647,Buffer._lock3767647));       // (30.9): Loop does not preserve yields_as annotation for field pushLock
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.full(tid : Tid, _this, Buffer.full[_this] ,Lock._state3767647,Lock._lock3767647,Buffer._state3767647,Buffer.popLock3767647,Buffer.pushLock3767647,Buffer.full3767647,Buffer.data3767647,Buffer._lock3767647));       // (30.9): Loop does not preserve yields_as annotation for field full
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.data(tid : Tid, _this, Buffer.data[_this] ,Lock._state3767647,Lock._lock3767647,Buffer._state3767647,Buffer.popLock3767647,Buffer.pushLock3767647,Buffer.full3767647,Buffer.data3767647,Buffer._lock3767647));       // (30.9): Loop does not preserve yields_as annotation for field data
  invariant phase3767647 == $pc;                                                                           // (30.9): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (30.9): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 30.16: boolean tmp2;                                                                           
                                                                                                    
                                                                                                    
  // 30.16: tmp2 = true;                                                                            
                                                                                                    
  tmp2 := true;                                                                                     
  if (!(tmp2)) {                                                                                    
                                                                                                    
   // 30.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 34.11: boolean tmp3;                                                                           
                                                                                                    
                                                                                                    
  // 34.11: boolean tmp4;                                                                           
                                                                                                    
                                                                                                    
  // 34.11: tmp4 := this.full;                                                                      
                                                                                                    
                                                                                                    
  moverPath3767633 := ReadEval.Buffer.full(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
  mover3767633 := m#moverPath(moverPath3767633);                                                    
  path3767633 := p#moverPath(moverPath3767633);                                                     
  assume Lock._state3767633 == Lock._state && Lock._lock3767633 == Lock._lock && Buffer._state3767633 == Buffer._state && Buffer.popLock3767633 == Buffer.popLock && Buffer.pushLock3767633 == Buffer.pushLock && Buffer.full3767633 == Buffer.full && Buffer.data3767633 == Buffer.data && Buffer._lock3767633 == Buffer._lock && tmp43767633 == tmp4 && tmp33767633 == tmp3 && tmp23767633 == tmp2 && tmp13767633 == tmp1 && x3767633 == x && this3767633 == this && tid3767633 == tid && $pc3767633 == $pc;
  assume $recorded.state3767633 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Buffer.null;                                                                      
  } else {                                                                                          
   assert this != Buffer.null;                                                                             // (34.11): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover3767633);                                                             
  assert $pc != PhaseError;                                                                                // (34.11): Reduction failure
  tmp4 := Buffer.full[this];                                                                        
                                                                                                    
  // 34.11: tmp3 = !tmp4;                                                                           
                                                                                                    
  tmp3 := !(tmp4);                                                                                  
  if (tmp3 /* lowered !(Buffer.full[this]) */) {                                                    
                                                                                                    
   // 34.29: break;                                                                                 
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 35.11: yield;                                                                                  
                                                                                                    
  assume Lock._state3767644 == Lock._state && Lock._lock3767644 == Lock._lock && Buffer._state3767644 == Buffer._state && Buffer.popLock3767644 == Buffer.popLock && Buffer.pushLock3767644 == Buffer.pushLock && Buffer.full3767644 == Buffer.full && Buffer.data3767644 == Buffer.data && Buffer._lock3767644 == Buffer._lock && tmp43767644 == tmp4 && tmp33767644 == tmp3 && tmp23767644 == tmp2 && tmp13767644 == tmp1 && x3767644 == x && this3767644 == this && tid3767644 == tid;
  assume $recorded.state3767644 == 1;                                                               
  assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (35.11): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (35.11): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Lock._state3767644_post == Lock._state && Lock._lock3767644_post == Lock._lock && Buffer._state3767644_post == Buffer._state && Buffer.popLock3767644_post == Buffer.popLock && Buffer.pushLock3767644_post == Buffer.pushLock && Buffer.full3767644_post == Buffer.full && Buffer.data3767644_post == Buffer.data && Buffer._lock3767644_post == Buffer._lock && tmp43767644_post == tmp4 && tmp33767644_post == tmp3 && tmp23767644_post == tmp2 && tmp13767644_post == tmp1 && x3767644_post == x && this3767644_post == this && tid3767644_post == tid;
  assume $recorded.state3767644_post == 1;                                                          
  assume Lock._state3767647_bottom == Lock._state && Lock._lock3767647_bottom == Lock._lock && Buffer._state3767647_bottom == Buffer._state && Buffer.popLock3767647_bottom == Buffer.popLock && Buffer.pushLock3767647_bottom == Buffer.pushLock && Buffer.full3767647_bottom == Buffer.full && Buffer.data3767647_bottom == Buffer.data && Buffer._lock3767647_bottom == Buffer._lock && tmp13767647_bottom == tmp1 && x3767647_bottom == x && this3767647_bottom == this && tid3767647_bottom == tid;
  assume $recorded.state3767647_bottom == 1;                                                        
  assert phase3767647 == $pc;                                                                              // (30.9): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 37.9: yield;                                                                                    
                                                                                                    
 assume Lock._state3767648 == Lock._state && Lock._lock3767648 == Lock._lock && Buffer._state3767648 == Buffer._state && Buffer.popLock3767648 == Buffer.popLock && Buffer.pushLock3767648 == Buffer.pushLock && Buffer.full3767648 == Buffer.full && Buffer.data3767648 == Buffer.data && Buffer._lock3767648 == Buffer._lock && tmp13767648 == tmp1 && x3767648 == x && this3767648 == this && tid3767648 == tid;
 assume $recorded.state3767648 == 1;                                                                
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (37.9): Object invariant may not hold.
 call Yield(tid);                                                                                   
 assume  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (37.9): Object invariant may not hold.
 $pc := PreCommit;                                                                                  
 assume Lock._state3767648_post == Lock._state && Lock._lock3767648_post == Lock._lock && Buffer._state3767648_post == Buffer._state && Buffer.popLock3767648_post == Buffer.popLock && Buffer.pushLock3767648_post == Buffer.pushLock && Buffer.full3767648_post == Buffer.full && Buffer.data3767648_post == Buffer.data && Buffer._lock3767648_post == Buffer._lock && tmp13767648_post == tmp1 && x3767648_post == x && this3767648_post == this && tid3767648_post == tid;
 assume $recorded.state3767648_post == 1;                                                           
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (38.22): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume Buffer._lock[this] == Tid.null;                                                             
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (38.22): Reduction failure
 Buffer._lock[this] := tid;                                                                         
                                                                                                    
                                                                                                    
 // 39.13: this.data := x;                                                                          
                                                                                                    
                                                                                                    
 moverPath3767653 := WriteEval.Buffer.data(tid: Tid,this: Buffer,x: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 mover3767653 := m#moverPath(moverPath3767653);                                                     
 path3767653 := p#moverPath(moverPath3767653);                                                      
 assume Lock._state3767653 == Lock._state && Lock._lock3767653 == Lock._lock && Buffer._state3767653 == Buffer._state && Buffer.popLock3767653 == Buffer.popLock && Buffer.pushLock3767653 == Buffer.pushLock && Buffer.full3767653 == Buffer.full && Buffer.data3767653 == Buffer.data && Buffer._lock3767653 == Buffer._lock && tmp13767653 == tmp1 && x3767653 == x && this3767653 == this && tid3767653 == tid && $pc3767653 == $pc;
 assume $recorded.state3767653 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (39.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3767653);                                                              
 assert $pc != PhaseError;                                                                                 // (39.13): Reduction failure
 Buffer.data[this] := x;                                                                            
                                                                                                    
 // 40.13: boolean tmp5;                                                                            
                                                                                                    
                                                                                                    
 // 40.13: tmp5 = true;                                                                             
                                                                                                    
 tmp5 := true;                                                                                      
                                                                                                    
                                                                                                    
 // 40.13: this.full := tmp5;                                                                       
                                                                                                    
                                                                                                    
 moverPath3767663 := WriteEval.Buffer.full(tid: Tid,this: Buffer,tmp5: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 mover3767663 := m#moverPath(moverPath3767663);                                                     
 path3767663 := p#moverPath(moverPath3767663);                                                      
 assume Lock._state3767663 == Lock._state && Lock._lock3767663 == Lock._lock && Buffer._state3767663 == Buffer._state && Buffer.popLock3767663 == Buffer.popLock && Buffer.pushLock3767663 == Buffer.pushLock && Buffer.full3767663 == Buffer.full && Buffer.data3767663 == Buffer.data && Buffer._lock3767663 == Buffer._lock && tmp53767663 == tmp5 && tmp13767663 == tmp1 && x3767663 == x && this3767663 == this && tid3767663 == tid && $pc3767663 == $pc;
 assume $recorded.state3767663 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (40.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3767663);                                                              
 assert $pc != PhaseError;                                                                                 // (40.13): Reduction failure
 Buffer.full[this] := tmp5;                                                                         
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (41.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Buffer._lock[this] == tid;                                                                         // (41.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (41.9): Reduction failure
 Buffer._lock[this] := Tid.null;                                                                    
 if ($pc == PreCommit) {                                                                            
  assume tmp1 != Lock.null;                                                                         
 } else {                                                                                           
  assert tmp1 != Lock.null;                                                                                // (42.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Lock._lock[tmp1] == tid;                                                                           // (42.5): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (42.5): Reduction failure
 Lock._lock[tmp1] := Tid.null;                                                                      
                                                                                                    
 // 28.27: // return;                                                                               
                                                                                                    
 assume Lock._state3767672 == Lock._state && Lock._lock3767672 == Lock._lock && Buffer._state3767672 == Buffer._state && Buffer.popLock3767672 == Buffer.popLock && Buffer.pushLock3767672 == Buffer.pushLock && Buffer.full3767672 == Buffer.full && Buffer.data3767672 == Buffer.data && Buffer._lock3767672 == Buffer._lock && tmp13767672 == tmp1 && x3767672 == x && this3767672 == this && tid3767672 == tid;
 assume $recorded.state3767672 == 1;                                                                
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (28.27): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  Buffer.pop(tid:Tid, this : Buffer)                                                       
returns ($result : int)                                                                             
modifies Lock._state;                                                                               
modifies Lock._lock;                                                                                
modifies Buffer._state;                                                                             
modifies Buffer.popLock;                                                                            
modifies Buffer.pushLock;                                                                           
modifies Buffer.full;                                                                               
modifies Buffer.data;                                                                               
modifies Buffer._lock;                                                                              
                                                                                                    
requires ValidTid(tid);                                                                                    // (45.3): Bad tid
requires isShared(Buffer._state[this]);                                                                    // (45.3): this is not global
                                                                                                    
requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (45.3): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
ensures  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (45.3): Object invariant may not hold.
{                                                                                                   
 var Lock._state3767706: [Lock]State;                                                               
 var result3767728: int;                                                                            
 var tmp63767718: Lock;                                                                             
 var $pc3767709: Phase;                                                                             
 var result: int;                                                                                   
 var Buffer._lock3767734: [Buffer]Tid;                                                              
 var Buffer.pushLock3767746: [Buffer]Lock;                                                          
 var Lock._state3767709_bottom: [Lock]State;                                                        
 var Buffer._state3767728: [Buffer]State;                                                           
 var $recorded.state3767734: int;                                                                   
 var result3767718: int;                                                                            
 var $result3767734: int;                                                                           
 var Lock._lock3767728: [Lock]Tid;                                                                  
 var $result3767706: int;                                                                           
 var $pc3767710_post: Phase;                                                                        
 var Buffer.pushLock3767718: [Buffer]Lock;                                                          
 var this3767706: Buffer;                                                                           
 var Buffer.pushLock3767710: [Buffer]Lock;                                                          
 var Buffer._state3767734: [Buffer]State;                                                           
 var $pc3767728: Phase;                                                                             
 var this3767681: Buffer;                                                                           
 var Buffer.full3767700: [Buffer]bool;                                                              
 var tid3767734: Tid;                                                                               
 var tmp63767709: Lock;                                                                             
 var Buffer.pushLock3767706: [Buffer]Lock;                                                          
 var tid3767728: Tid;                                                                               
 var Buffer.popLock3767706_post: [Buffer]Lock;                                                      
 var $result3767728: int;                                                                           
 var Buffer._lock3767710_post: [Buffer]Tid;                                                         
 var Lock._lock3767710_post: [Lock]Tid;                                                             
 var Buffer.pushLock3767706_post: [Buffer]Lock;                                                     
 var tmp63767709_bottom: Lock;                                                                      
 var Lock._lock3767746: [Lock]Tid;                                                                  
 var Lock._state3767728: [Lock]State;                                                               
 var $recorded.state3767728: int;                                                                   
 var Lock._lock3767706: [Lock]Tid;                                                                  
 var Buffer._lock3767706: [Buffer]Tid;                                                              
 var $pc3767706_post: Phase;                                                                        
 var Buffer.pushLock3767709_bottom: [Buffer]Lock;                                                   
 var $result3767709_bottom: int;                                                                    
 var Buffer.data3767706: [Buffer]int;                                                               
 var Lock._lock3767734: [Lock]Tid;                                                                  
 var path3767718: int;                                                                              
 var Buffer.full3767718: [Buffer]bool;                                                              
 var Buffer.data3767710_post: [Buffer]int;                                                          
 var Buffer._state3767706_post: [Buffer]State;                                                      
 var tid3767700: Tid;                                                                               
 var Buffer.popLock3767734: [Buffer]Lock;                                                           
 var Buffer.popLock3767728: [Buffer]Lock;                                                           
 var Buffer._lock3767700: [Buffer]Tid;                                                              
 var $pc3767746: Phase;                                                                             
 var Buffer.full3767710_post: [Buffer]bool;                                                         
 var Buffer.popLock3767709_bottom: [Buffer]Lock;                                                    
 var Buffer.full3767681: [Buffer]bool;                                                              
 var tmp63767706: Lock;                                                                             
 var Buffer.data3767709: [Buffer]int;                                                               
 var Buffer.popLock3767718: [Buffer]Lock;                                                           
 var moverPath3767728: MoverPath;                                                                   
 var $recorded.state3767681: int;                                                                   
 var this3767728: Buffer;                                                                           
 var Buffer.data3767710: [Buffer]int;                                                               
 var moverPath3767700: MoverPath;                                                                   
 var tmp63767681: Lock;                                                                             
 var Buffer._lock3767709_bottom: [Buffer]Tid;                                                       
 var path3767728: int;                                                                              
 var Buffer.pushLock3767728: [Buffer]Lock;                                                          
 var $recorded.state3767746: int;                                                                   
 var Buffer.full3767734: [Buffer]bool;                                                              
 var moverPath3767718: MoverPath;                                                                   
 var Buffer.pushLock3767681: [Buffer]Lock;                                                          
 var Buffer.full3767706_post: [Buffer]bool;                                                         
 var path3767681: int;                                                                              
 var Buffer._state3767710: [Buffer]State;                                                           
 var Buffer.full3767709: [Buffer]bool;                                                              
 var $pc3767709_bottom: Phase;                                                                      
 var Buffer._lock3767728: [Buffer]Tid;                                                              
 var $recorded.state3767709: int;                                                                   
 var Lock._state3767681: [Lock]State;                                                               
 var this3767718: Buffer;                                                                           
 var $recorded.state3767706: int;                                                                   
 var tmp83767700: bool;                                                                             
 var $pc3767700: Phase;                                                                             
 var Buffer._state3767706: [Buffer]State;                                                           
 var Buffer._state3767710_post: [Buffer]State;                                                      
 var Lock._state3767706_post: [Lock]State;                                                          
 var $pc3767710: Phase;                                                                             
 var tmp83767706_post: bool;                                                                        
 var Buffer.full3767710: [Buffer]bool;                                                              
 var $recorded.state3767706_post: int;                                                              
 var path3767700: int;                                                                              
 var moverPath3767681: MoverPath;                                                                   
 var Lock._lock3767681: [Lock]Tid;                                                                  
 var Buffer.data3767728: [Buffer]int;                                                               
 var mover3767718: Mover;                                                                           
 var $result3767709: int;                                                                           
 var tmp63767710_post: Lock;                                                                        
 var tmp63767706_post: Lock;                                                                        
 var $result3767700: int;                                                                           
 var $recorded.state3767710_post: int;                                                              
 var tid3767746: Tid;                                                                               
 var Lock._state3767700: [Lock]State;                                                               
 var Buffer.popLock3767746: [Buffer]Lock;                                                           
 var tid3767681: Tid;                                                                               
 var tid3767709_bottom: Tid;                                                                        
 var Buffer._lock3767710: [Buffer]Tid;                                                              
 var tmp9: bool;                                                                                    
 var Buffer.popLock3767700: [Buffer]Lock;                                                           
 var $result3767710_post: int;                                                                      
 var Lock._state3767709: [Lock]State;                                                               
 var Buffer.pushLock3767700: [Buffer]Lock;                                                          
 var $recorded.state3767709_bottom: int;                                                            
 var $pc3767718: Phase;                                                                             
 var phase3767709: Phase;                                                                           
 var Buffer.popLock3767706: [Buffer]Lock;                                                           
 var $result3767681: int;                                                                           
 var Buffer.pushLock3767710_post: [Buffer]Lock;                                                     
 var this3767734: Buffer;                                                                           
 var tmp93767728: bool;                                                                             
 var tmp63767728: Lock;                                                                             
 var result3767734: int;                                                                            
 var tmp7: bool;                                                                                    
 var Buffer.popLock3767709: [Buffer]Lock;                                                           
 var $result3767710: int;                                                                           
 var Lock._lock3767700: [Lock]Tid;                                                                  
 var mover3767728: Mover;                                                                           
 var $pc3767706: Phase;                                                                             
 var this3767710_post: Buffer;                                                                      
 var tid3767710: Tid;                                                                               
 var tid3767718: Tid;                                                                               
 var $result3767706_post: int;                                                                      
 var Lock._state3767718: [Lock]State;                                                               
 var Buffer._state3767709: [Buffer]State;                                                           
 var Lock._lock3767709_bottom: [Lock]Tid;                                                           
 var $result3767718: int;                                                                           
 var this3767700: Buffer;                                                                           
 var Buffer.popLock3767710_post: [Buffer]Lock;                                                      
 var tid3767706_post: Tid;                                                                          
 var Buffer.data3767746: [Buffer]int;                                                               
 var Buffer.pushLock3767709: [Buffer]Lock;                                                          
 var tmp63767746: Lock;                                                                             
 var Buffer._lock3767706_post: [Buffer]Tid;                                                         
 var tmp63767700: Lock;                                                                             
 var $pc3767681: Phase;                                                                             
 var tmp73767700: bool;                                                                             
 var Buffer.full3767728: [Buffer]bool;                                                              
 var Buffer.full3767706: [Buffer]bool;                                                              
 var Lock._lock3767718: [Lock]Tid;                                                                  
 var Lock._lock3767709: [Lock]Tid;                                                                  
 var this3767709: Buffer;                                                                           
 var mover3767700: Mover;                                                                           
 var Lock._lock3767710: [Lock]Tid;                                                                  
 var Buffer.pushLock3767734: [Buffer]Lock;                                                          
 var tid3767710_post: Tid;                                                                          
 var Buffer._state3767718: [Buffer]State;                                                           
 var tmp63767734: Lock;                                                                             
 var Buffer._state3767681: [Buffer]State;                                                           
 var $pc3767734: Phase;                                                                             
 var $result3767746: int;                                                                           
 var tmp73767706_post: bool;                                                                        
 var this3767709_bottom: Buffer;                                                                    
 var Buffer.data3767718: [Buffer]int;                                                               
 var Buffer.data3767734: [Buffer]int;                                                               
 var Buffer.data3767700: [Buffer]int;                                                               
 var Lock._state3767710_post: [Lock]State;                                                          
 var Lock._state3767746: [Lock]State;                                                               
 var Buffer._lock3767746: [Buffer]Tid;                                                              
 var tid3767709: Tid;                                                                               
 var Buffer._lock3767718: [Buffer]Tid;                                                              
 var Buffer._lock3767709: [Buffer]Tid;                                                              
 var this3767746: Buffer;                                                                           
 var tmp6: Lock;                                                                                    
 var tid3767706: Tid;                                                                               
 var this3767710: Buffer;                                                                           
 var Buffer.data3767681: [Buffer]int;                                                               
 var Buffer._lock3767681: [Buffer]Tid;                                                              
 var mover3767681: Mover;                                                                           
 var Buffer.popLock3767710: [Buffer]Lock;                                                           
 var Buffer.popLock3767681: [Buffer]Lock;                                                           
 var Buffer.data3767706_post: [Buffer]int;                                                          
 var tmp8: bool;                                                                                    
 var Buffer._state3767700: [Buffer]State;                                                           
 var Buffer.data3767709_bottom: [Buffer]int;                                                        
 var this3767706_post: Buffer;                                                                      
 var Lock._state3767710: [Lock]State;                                                               
 var Buffer.full3767709_bottom: [Buffer]bool;                                                       
 var Lock._lock3767706_post: [Lock]Tid;                                                             
 var tmp63767710: Lock;                                                                             
 var Lock._state3767734: [Lock]State;                                                               
 var Buffer.full3767746: [Buffer]bool;                                                              
 var Buffer._state3767746: [Buffer]State;                                                           
 var tmp93767734: bool;                                                                             
 var tmp83767706: bool;                                                                             
 var $recorded.state3767710: int;                                                                   
 var $recorded.state3767700: int;                                                                   
 var Buffer._state3767709_bottom: [Buffer]State;                                                    
 var $recorded.state3767718: int;                                                                   
 var tmp73767706: bool;                                                                             
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 // 46.5: Lock tmp6;                                                                                
                                                                                                    
                                                                                                    
 // 46.5: tmp6 := this.popLock;                                                                     
                                                                                                    
                                                                                                    
 moverPath3767681 := ReadEval.Buffer.popLock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 mover3767681 := m#moverPath(moverPath3767681);                                                     
 path3767681 := p#moverPath(moverPath3767681);                                                      
 assume Lock._state3767681 == Lock._state && Lock._lock3767681 == Lock._lock && Buffer._state3767681 == Buffer._state && Buffer.popLock3767681 == Buffer.popLock && Buffer.pushLock3767681 == Buffer.pushLock && Buffer.full3767681 == Buffer.full && Buffer.data3767681 == Buffer.data && Buffer._lock3767681 == Buffer._lock && tmp63767681 == tmp6 && $result3767681 == $result && this3767681 == this && tid3767681 == tid && $pc3767681 == $pc;
 assume $recorded.state3767681 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (46.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover3767681);                                                              
 assert $pc != PhaseError;                                                                                 // (46.5): Reduction failure
 tmp6 := Buffer.popLock[this];                                                                      
 if ($pc == PreCommit) {                                                                            
  assume tmp6 != Lock.null;                                                                         
 } else {                                                                                           
  assert tmp6 != Lock.null;                                                                                // (46.18): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume Lock._lock[tmp6] == Tid.null;                                                               
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (46.18): Reduction failure
 Lock._lock[tmp6] := tid;                                                                           
 assume Lock._state3767709 == Lock._state && Lock._lock3767709 == Lock._lock && Buffer._state3767709 == Buffer._state && Buffer.popLock3767709 == Buffer.popLock && Buffer.pushLock3767709 == Buffer.pushLock && Buffer.full3767709 == Buffer.full && Buffer.data3767709 == Buffer.data && Buffer._lock3767709 == Buffer._lock && tmp63767709 == tmp6 && $result3767709 == $result && this3767709 == this && tid3767709 == tid;
 assume $recorded.state3767709 == 1;                                                                
                                                                                                    
 // 47.9: while (true)                                                                              
                                                                                                    
 phase3767709 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (45.3): Bad tid
  invariant isShared(Buffer._state[this]);                                                                 // (45.3): this is not global
                                                                                                    
  invariant StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
  invariant  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (47.9): Object invariant may not hold.
  invariant (isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid);
  invariant (isAccessible(Lock._state[tmp6], tid) && Lock._lock[tmp6] == tid);                      
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.popLock(tid : Tid, _this, Buffer.popLock[_this] ,Lock._state3767709,Lock._lock3767709,Buffer._state3767709,Buffer.popLock3767709,Buffer.pushLock3767709,Buffer.full3767709,Buffer.data3767709,Buffer._lock3767709));       // (47.9): Loop does not preserve yields_as annotation for field popLock
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.pushLock(tid : Tid, _this, Buffer.pushLock[_this] ,Lock._state3767709,Lock._lock3767709,Buffer._state3767709,Buffer.popLock3767709,Buffer.pushLock3767709,Buffer.full3767709,Buffer.data3767709,Buffer._lock3767709));       // (47.9): Loop does not preserve yields_as annotation for field pushLock
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.full(tid : Tid, _this, Buffer.full[_this] ,Lock._state3767709,Lock._lock3767709,Buffer._state3767709,Buffer.popLock3767709,Buffer.pushLock3767709,Buffer.full3767709,Buffer.data3767709,Buffer._lock3767709));       // (47.9): Loop does not preserve yields_as annotation for field full
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.data(tid : Tid, _this, Buffer.data[_this] ,Lock._state3767709,Lock._lock3767709,Buffer._state3767709,Buffer.popLock3767709,Buffer.pushLock3767709,Buffer.full3767709,Buffer.data3767709,Buffer._lock3767709));       // (47.9): Loop does not preserve yields_as annotation for field data
  invariant phase3767709 == $pc;                                                                           // (47.9): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (47.9): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 47.16: boolean tmp7;                                                                           
                                                                                                    
                                                                                                    
  // 47.16: tmp7 = true;                                                                            
                                                                                                    
  tmp7 := true;                                                                                     
  if (!(tmp7)) {                                                                                    
                                                                                                    
   // 47.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 50.11: boolean tmp8;                                                                           
                                                                                                    
                                                                                                    
  // 50.11: tmp8 := this.full;                                                                      
                                                                                                    
                                                                                                    
  moverPath3767700 := ReadEval.Buffer.full(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
  mover3767700 := m#moverPath(moverPath3767700);                                                    
  path3767700 := p#moverPath(moverPath3767700);                                                     
  assume Lock._state3767700 == Lock._state && Lock._lock3767700 == Lock._lock && Buffer._state3767700 == Buffer._state && Buffer.popLock3767700 == Buffer.popLock && Buffer.pushLock3767700 == Buffer.pushLock && Buffer.full3767700 == Buffer.full && Buffer.data3767700 == Buffer.data && Buffer._lock3767700 == Buffer._lock && tmp83767700 == tmp8 && tmp73767700 == tmp7 && tmp63767700 == tmp6 && $result3767700 == $result && this3767700 == this && tid3767700 == tid && $pc3767700 == $pc;
  assume $recorded.state3767700 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Buffer.null;                                                                      
  } else {                                                                                          
   assert this != Buffer.null;                                                                             // (50.11): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover3767700);                                                             
  assert $pc != PhaseError;                                                                                // (50.11): Reduction failure
  tmp8 := Buffer.full[this];                                                                        
  if (tmp8 /* lowered Buffer.full[this] */) {                                                       
                                                                                                    
   // 50.28: break;                                                                                 
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 51.11: yield;                                                                                  
                                                                                                    
  assume Lock._state3767706 == Lock._state && Lock._lock3767706 == Lock._lock && Buffer._state3767706 == Buffer._state && Buffer.popLock3767706 == Buffer.popLock && Buffer.pushLock3767706 == Buffer.pushLock && Buffer.full3767706 == Buffer.full && Buffer.data3767706 == Buffer.data && Buffer._lock3767706 == Buffer._lock && tmp83767706 == tmp8 && tmp73767706 == tmp7 && tmp63767706 == tmp6 && $result3767706 == $result && this3767706 == this && tid3767706 == tid;
  assume $recorded.state3767706 == 1;                                                               
  assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (51.11): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (51.11): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Lock._state3767706_post == Lock._state && Lock._lock3767706_post == Lock._lock && Buffer._state3767706_post == Buffer._state && Buffer.popLock3767706_post == Buffer.popLock && Buffer.pushLock3767706_post == Buffer.pushLock && Buffer.full3767706_post == Buffer.full && Buffer.data3767706_post == Buffer.data && Buffer._lock3767706_post == Buffer._lock && tmp83767706_post == tmp8 && tmp73767706_post == tmp7 && tmp63767706_post == tmp6 && $result3767706_post == $result && this3767706_post == this && tid3767706_post == tid;
  assume $recorded.state3767706_post == 1;                                                          
  assume Lock._state3767709_bottom == Lock._state && Lock._lock3767709_bottom == Lock._lock && Buffer._state3767709_bottom == Buffer._state && Buffer.popLock3767709_bottom == Buffer.popLock && Buffer.pushLock3767709_bottom == Buffer.pushLock && Buffer.full3767709_bottom == Buffer.full && Buffer.data3767709_bottom == Buffer.data && Buffer._lock3767709_bottom == Buffer._lock && tmp63767709_bottom == tmp6 && $result3767709_bottom == $result && this3767709_bottom == this && tid3767709_bottom == tid;
  assume $recorded.state3767709_bottom == 1;                                                        
  assert phase3767709 == $pc;                                                                              // (47.9): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 53.9: yield;                                                                                    
                                                                                                    
 assume Lock._state3767710 == Lock._state && Lock._lock3767710 == Lock._lock && Buffer._state3767710 == Buffer._state && Buffer.popLock3767710 == Buffer.popLock && Buffer.pushLock3767710 == Buffer.pushLock && Buffer.full3767710 == Buffer.full && Buffer.data3767710 == Buffer.data && Buffer._lock3767710 == Buffer._lock && tmp63767710 == tmp6 && $result3767710 == $result && this3767710 == this && tid3767710 == tid;
 assume $recorded.state3767710 == 1;                                                                
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (53.9): Object invariant may not hold.
 call Yield(tid);                                                                                   
 assume  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (53.9): Object invariant may not hold.
 $pc := PreCommit;                                                                                  
 assume Lock._state3767710_post == Lock._state && Lock._lock3767710_post == Lock._lock && Buffer._state3767710_post == Buffer._state && Buffer.popLock3767710_post == Buffer.popLock && Buffer.pushLock3767710_post == Buffer.pushLock && Buffer.full3767710_post == Buffer.full && Buffer.data3767710_post == Buffer.data && Buffer._lock3767710_post == Buffer._lock && tmp63767710_post == tmp6 && $result3767710_post == $result && this3767710_post == this && tid3767710_post == tid;
 assume $recorded.state3767710_post == 1;                                                           
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (54.22): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume Buffer._lock[this] == Tid.null;                                                             
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (54.22): Reduction failure
 Buffer._lock[this] := tid;                                                                         
                                                                                                    
 // 55.13: int result;                                                                              
                                                                                                    
                                                                                                    
 // 55.13: result := this.data;                                                                     
                                                                                                    
                                                                                                    
 moverPath3767718 := ReadEval.Buffer.data(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 mover3767718 := m#moverPath(moverPath3767718);                                                     
 path3767718 := p#moverPath(moverPath3767718);                                                      
 assume Lock._state3767718 == Lock._state && Lock._lock3767718 == Lock._lock && Buffer._state3767718 == Buffer._state && Buffer.popLock3767718 == Buffer.popLock && Buffer.pushLock3767718 == Buffer.pushLock && Buffer.full3767718 == Buffer.full && Buffer.data3767718 == Buffer.data && Buffer._lock3767718 == Buffer._lock && result3767718 == result && tmp63767718 == tmp6 && $result3767718 == $result && this3767718 == this && tid3767718 == tid && $pc3767718 == $pc;
 assume $recorded.state3767718 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (55.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover3767718);                                                              
 assert $pc != PhaseError;                                                                                 // (55.13): Reduction failure
 result := Buffer.data[this];                                                                       
                                                                                                    
 // 56.13: boolean tmp9;                                                                            
                                                                                                    
                                                                                                    
 // 56.13: tmp9 = false;                                                                            
                                                                                                    
 tmp9 := false;                                                                                     
                                                                                                    
                                                                                                    
 // 56.13: this.full := tmp9;                                                                       
                                                                                                    
                                                                                                    
 moverPath3767728 := WriteEval.Buffer.full(tid: Tid,this: Buffer,tmp9: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 mover3767728 := m#moverPath(moverPath3767728);                                                     
 path3767728 := p#moverPath(moverPath3767728);                                                      
 assume Lock._state3767728 == Lock._state && Lock._lock3767728 == Lock._lock && Buffer._state3767728 == Buffer._state && Buffer.popLock3767728 == Buffer.popLock && Buffer.pushLock3767728 == Buffer.pushLock && Buffer.full3767728 == Buffer.full && Buffer.data3767728 == Buffer.data && Buffer._lock3767728 == Buffer._lock && tmp93767728 == tmp9 && result3767728 == result && tmp63767728 == tmp6 && $result3767728 == $result && this3767728 == this && tid3767728 == tid && $pc3767728 == $pc;
 assume $recorded.state3767728 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (56.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3767728);                                                              
 assert $pc != PhaseError;                                                                                 // (56.13): Reduction failure
 Buffer.full[this] := tmp9;                                                                         
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (58.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Buffer._lock[this] == tid;                                                                         // (58.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (58.9): Reduction failure
 Buffer._lock[this] := Tid.null;                                                                    
 if ($pc == PreCommit) {                                                                            
  assume tmp6 != Lock.null;                                                                         
 } else {                                                                                           
  assert tmp6 != Lock.null;                                                                                // (59.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Lock._lock[tmp6] == tid;                                                                           // (59.5): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (59.5): Reduction failure
 Lock._lock[tmp6] := Tid.null;                                                                      
                                                                                                    
 // 57.13:  return result;                                                                          
                                                                                                    
 assume Lock._state3767734 == Lock._state && Lock._lock3767734 == Lock._lock && Buffer._state3767734 == Buffer._state && Buffer.popLock3767734 == Buffer.popLock && Buffer.pushLock3767734 == Buffer.pushLock && Buffer.full3767734 == Buffer.full && Buffer.data3767734 == Buffer.data && Buffer._lock3767734 == Buffer._lock && tmp93767734 == tmp9 && result3767734 == result && tmp63767734 == tmp6 && $result3767734 == $result && this3767734 == this && tid3767734 == tid;
 assume $recorded.state3767734 == 1;                                                                
 $result := result;                                                                                 
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (57.13): Object invariant may not hold.
 return;                                                                                            
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (58.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Buffer._lock[this] == tid;                                                                         // (58.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (58.9): Reduction failure
 Buffer._lock[this] := Tid.null;                                                                    
 if ($pc == PreCommit) {                                                                            
  assume tmp6 != Lock.null;                                                                         
 } else {                                                                                           
  assert tmp6 != Lock.null;                                                                                // (59.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Lock._lock[tmp6] == tid;                                                                           // (59.5): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (59.5): Reduction failure
 Lock._lock[tmp6] := Tid.null;                                                                      
                                                                                                    
 // 45.20: // return -1;                                                                            
                                                                                                    
 assume Lock._state3767746 == Lock._state && Lock._lock3767746 == Lock._lock && Buffer._state3767746 == Buffer._state && Buffer.popLock3767746 == Buffer.popLock && Buffer.pushLock3767746 == Buffer.pushLock && Buffer.full3767746 == Buffer.full && Buffer.data3767746 == Buffer.data && Buffer._lock3767746 == Buffer._lock && tmp63767746 == tmp6 && $result3767746 == $result && this3767746 == this && tid3767746 == tid;
 assume $recorded.state3767746 == 1;                                                                
 $result := -1;                                                                                     
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (45.20): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (bool) {
  true &&                                                                                           
  (forall _i: Lock  :: _i == Lock.null <==> isNull(Lock._state[_i])) &&                             
  (forall _i: Buffer  :: _i == Buffer.null <==> isNull(Buffer._state[_i])) &&                       
  (forall _i: Buffer ::  (isShared(Buffer._state[_i]) ==> isSharedAssignable(Lock._state[Buffer.popLock[_i]]))) &&
  (forall _i: Buffer ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Buffer._state[_i],_t) ==> isLocalAssignable(Lock._state[Buffer.popLock[_i]], _t)))) &&
  (forall _i: Buffer ::  (isShared(Buffer._state[_i]) ==> isSharedAssignable(Lock._state[Buffer.pushLock[_i]]))) &&
  (forall _i: Buffer ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Buffer._state[_i],_t) ==> isLocalAssignable(Lock._state[Buffer.pushLock[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)  
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.popLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.3): Buffer.popLock failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)   
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Buffer.popLock(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (7.3): Buffer.popLock failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)   
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Lock;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.popLock[x];                                                                     
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Buffer.popLock[x] := havocValue;                                                                   
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.popLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.3): Buffer.popLock failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)    
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Lock;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.popLock[x];                                                                     
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Buffer.popLock(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (7.3): Buffer.popLock failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)        
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Buffer.popLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.3): Buffer.popLock failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)         
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Lock;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Buffer.popLock[x];                                                                     
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Buffer.popLock[x] := havocValue;                                                                   
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Buffer.popLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.3): Buffer.popLock failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer) 
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (8.3): Buffer.pushLock failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)  
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Buffer.pushLock(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (8.3): Buffer.pushLock failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)  
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Lock;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.pushLock[x];                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Buffer.pushLock[x] := havocValue;                                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (8.3): Buffer.pushLock failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)   
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Lock;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.pushLock[x];                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Buffer.pushLock(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (8.3): Buffer.pushLock failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)       
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (8.3): Buffer.pushLock failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)        
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Lock;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Buffer.pushLock[x];                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Buffer.pushLock[x] := havocValue;                                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (8.3): Buffer.pushLock failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, x: Buffer)     
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.full(u: Tid,x: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (10.3): Buffer.full failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, x: Buffer)      
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Buffer.full(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (10.3): Buffer.full failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, x: Buffer)      
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.full[x];                                                                        
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Buffer.full[x] := havocValue;                                                                      
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.full(u: Tid,x: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (10.3): Buffer.full failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, x: Buffer)       
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : bool;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.full[x];                                                                        
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Buffer.full(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (10.3): Buffer.full failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, x: Buffer)           
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Buffer.full(u: Tid,x: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (10.3): Buffer.full failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, x: Buffer)            
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Buffer.full[x];                                                                        
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Buffer.full[x] := havocValue;                                                                      
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Buffer.full(u: Tid,x: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (10.3): Buffer.full failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Buffer.data(t: Tid, u: Tid, v: int, w: int, x: Buffer)       
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.data(u: Tid,x: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (20.3): Buffer.data failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Buffer.data(t: Tid, u: Tid, v: int, w: int, x: Buffer)        
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Buffer.data(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (20.3): Buffer.data failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Buffer.data(t: Tid, u: Tid, v: int, w: int, x: Buffer)        
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.data[x];                                                                        
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Buffer.data[x] := havocValue;                                                                      
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.data(u: Tid,x: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (20.3): Buffer.data failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Buffer.data(t: Tid, u: Tid, v: int, w: int, x: Buffer)         
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.data[x];                                                                        
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Buffer.data(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (20.3): Buffer.data failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Buffer.data(t: Tid, u: Tid, v: int, w: int, x: Buffer)             
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Buffer.data(u: Tid,x: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (20.3): Buffer.data failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Buffer.data(t: Tid, u: Tid, v: int, w: int, x: Buffer)              
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Buffer.data[x];                                                                        
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Buffer.data[x] := havocValue;                                                                      
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Buffer.data(u: Tid,x: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (20.3): Buffer.data failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.popLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.popLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.popLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.popLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[y] := w;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.popLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.popLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.popLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.popLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.popLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.popLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.popLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.popLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.popLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.popLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.popLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[y] := w;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.pushLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.pushLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.pushLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.popLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.popLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.popLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.popLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.popLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.popLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.popLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.popLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.full (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.full (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.full (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.popLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.popLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.popLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.popLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.popLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.popLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.popLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.popLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.data (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.data (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.data (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.popLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.popLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.popLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.popLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.pushLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.pushLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.pushLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.pushLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[y] := w;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.popLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.popLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.popLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.pushLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.pushLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.pushLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.pushLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.pushLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.pushLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.pushLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.pushLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[y] := w;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.pushLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.pushLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.pushLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.pushLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.pushLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.pushLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.pushLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.pushLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.pushLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.pushLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.pushLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.full (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.full (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.full (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.pushLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.pushLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.pushLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.pushLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.pushLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.pushLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.pushLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.pushLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.data (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.data (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.data (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.pushLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.pushLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.pushLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.pushLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.full.Buffer.popLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.full.Buffer.popLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.full.Buffer.popLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.full.Buffer.popLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[y] := w;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.popLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.popLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.popLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.full.Buffer.popLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.full (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.full (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.full (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.full.Buffer.pushLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.full.Buffer.pushLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.full.Buffer.pushLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.full.Buffer.pushLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[y] := w;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.pushLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.pushLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.pushLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.full.Buffer.pushLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.full (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.full (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.full (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.full.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.full (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.full (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.full (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.full.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.full (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.full.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.full (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.full (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.full.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.full (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.full (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.full (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.full.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.full (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.full (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.full (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.full.Buffer.data(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.full.Buffer.data(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.data (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.full.Buffer.data(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.data (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.data (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.full.Buffer.data(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.data (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.data (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.data (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.full.Buffer.data(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.full (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.full (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.full (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.data.Buffer.popLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.data.Buffer.popLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.data.Buffer.popLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.data.Buffer.popLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[y] := w;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.popLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.popLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.popLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.data.Buffer.popLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.data (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.data (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.data (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.data.Buffer.pushLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.data.Buffer.pushLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.data.Buffer.pushLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.data.Buffer.pushLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[y] := w;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.pushLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.pushLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.pushLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.data.Buffer.pushLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.data (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.data (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.data (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.data.Buffer.full(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.data (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.data (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.data (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.data.Buffer.full(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.data.Buffer.full(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.data.Buffer.full(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.full (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.full (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.full (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.data.Buffer.full(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.data (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.data (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.data (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.data.Buffer.data(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.data.Buffer.data(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.data.Buffer.data(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.data.Buffer.data(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.data (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.data (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.data (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.data.Buffer.data(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.data (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.data (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.data (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
requires ValidTid(tid);                                                                             
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (<undefined position>): Object invariant may not hold.
modifies Lock._state;                                                                               
modifies Lock._lock;                                                                                
modifies Buffer._state;                                                                             
modifies Buffer.popLock;                                                                            
modifies Buffer.pushLock;                                                                           
modifies Buffer.full;                                                                               
modifies Buffer.data;                                                                               
modifies Buffer._lock;                                                                              
ensures StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
ensures Y(tid , old(Lock._state), old(Lock._lock), old(Buffer._state), old(Buffer.popLock), old(Buffer.pushLock), old(Buffer.full), old(Buffer.data), old(Buffer._lock) , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
ensures  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// Lock._lock:                                                                                      
                                                                                                    
function {:inline} Y_Lock._lock(tid : Tid, this: Lock, newValue: Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 ((isAccessible(Lock._state[this], tid) && leq(m#moverPath(ReadEval.Lock._lock(tid: Tid,this: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _R)) ==> (Lock._lock[this] == newValue))
 &&(((Lock._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Lock._lock(tid : Tid, this: Lock, newValue: Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Lock._lock.Subsumes.W(tid : Tid, u : Tid, this: Lock, newValue: Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var newValue_yield: Tid;                                                                            
var tid_yield: Tid;                                                                                 
var this_yield: Lock;                                                                               
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var u_yield: Tid;                                                                                   
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Lock._state[this], tid);                                                       
 assume isAccessible(Lock._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Lock._lock(u: Tid,this: Lock,newValue: Tid,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)));
 assume leq(m#moverPath(ReadEval.Lock._lock(tid: Tid,this: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _N);
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Lock._lock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Lock._lock.Reflexive(tid : Tid, this: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var this_yield: Lock;                                                                               
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Lock._state[this], tid);                                                       
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Lock._lock(tid, this, Lock._lock[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Lock._lock.Transitive(tid : Tid, this: Lock, newValue : Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires StateInvariant(Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (2.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Buffer.pushLock_pre: [Buffer]Lock;                                                              
var this_pre: Lock;                                                                                 
var $recorded.state_pre: int;                                                                       
var Buffer.data_pre: [Buffer]int;                                                                   
var Buffer._state_pre: [Buffer]State;                                                               
var Lock._lock_pre: [Lock]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var Buffer.full_pre: [Buffer]bool;                                                                  
var Buffer.popLock_pre: [Buffer]Lock;                                                               
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Lock._state_pre: [Lock]State;                                                                   
var newValue_pre: Tid;                                                                              
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var Lock._lock_post: [Lock]Tid;                                                                     
var Lock._state_post: [Lock]State;                                                                  
var Buffer.popLock_post: [Buffer]Lock;                                                              
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Buffer.data_post: [Buffer]int;                                                                  
var $pc_post: Phase;                                                                                
var tid_post: Tid;                                                                                  
var this_post: Lock;                                                                                
var Buffer.full_post: [Buffer]bool;                                                                 
var newValue_post: Tid;                                                                             
var Buffer.pushLock_post: [Buffer]Lock;                                                             
                                                                                                    
assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Lock._state[this], tid);                                                       
 assume Y(tid , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 assume Y_Lock._lock(tid, this, newValue , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
assume Lock._state_post == Lock._state_p && Lock._lock_post == Lock._lock_p && Buffer._state_post == Buffer._state_p && Buffer.popLock_post == Buffer.popLock_p && Buffer.pushLock_post == Buffer.pushLock_p && Buffer.full_post == Buffer.full_p && Buffer.data_post == Buffer.data_p && Buffer._lock_post == Buffer._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Lock._lock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
// Buffer.popLock:                                                                                  
                                                                                                    
function {:inline} Y_Buffer.popLock(tid : Tid, this: Buffer, newValue: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer.popLock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _R)) ==> (Buffer.popLock[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer.popLock(tid : Tid, this: Buffer, newValue: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer.popLock.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var u_yield: Tid;                                                                                   
var Lock._state_yield: [Lock]State;                                                                 
var newValue_yield: Lock;                                                                           
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer.popLock(u: Tid,this: Buffer,newValue: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)));
                                                                                                    
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.popLock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.popLock.Reflexive(tid : Tid, this: Buffer , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.popLock(tid, this, Buffer.popLock[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.popLock.Transitive(tid : Tid, this: Buffer, newValue : Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires StateInvariant(Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (7.31): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Buffer.pushLock_pre: [Buffer]Lock;                                                              
var $recorded.state_pre: int;                                                                       
var Buffer.data_pre: [Buffer]int;                                                                   
var Buffer._state_pre: [Buffer]State;                                                               
var Lock._lock_pre: [Lock]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Buffer.full_pre: [Buffer]bool;                                                                  
var Buffer.popLock_pre: [Buffer]Lock;                                                               
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var newValue_pre: Lock;                                                                             
var Lock._state_pre: [Lock]State;                                                                   
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var Lock._lock_post: [Lock]Tid;                                                                     
var Lock._state_post: [Lock]State;                                                                  
var Buffer.popLock_post: [Buffer]Lock;                                                              
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Buffer.data_post: [Buffer]int;                                                                  
var this_post: Buffer;                                                                              
var $pc_post: Phase;                                                                                
var tid_post: Tid;                                                                                  
var Buffer.full_post: [Buffer]bool;                                                                 
var newValue_post: Lock;                                                                            
var Buffer.pushLock_post: [Buffer]Lock;                                                             
                                                                                                    
assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 assume Y_Buffer.popLock(tid, this, newValue , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
assume Lock._state_post == Lock._state_p && Lock._lock_post == Lock._lock_p && Buffer._state_post == Buffer._state_p && Buffer.popLock_post == Buffer.popLock_p && Buffer.pushLock_post == Buffer.pushLock_p && Buffer.full_post == Buffer.full_p && Buffer.data_post == Buffer.data_p && Buffer._lock_post == Buffer._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer.popLock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
// Buffer.pushLock:                                                                                 
                                                                                                    
function {:inline} Y_Buffer.pushLock(tid : Tid, this: Buffer, newValue: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer.pushLock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _R)) ==> (Buffer.pushLock[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer.pushLock(tid : Tid, this: Buffer, newValue: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer.pushLock.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var u_yield: Tid;                                                                                   
var Lock._state_yield: [Lock]State;                                                                 
var newValue_yield: Lock;                                                                           
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer.pushLock(u: Tid,this: Buffer,newValue: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)));
                                                                                                    
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.pushLock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.pushLock.Reflexive(tid : Tid, this: Buffer , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.pushLock(tid, this, Buffer.pushLock[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.pushLock.Transitive(tid : Tid, this: Buffer, newValue : Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires StateInvariant(Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (8.31): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Buffer.pushLock_pre: [Buffer]Lock;                                                              
var $recorded.state_pre: int;                                                                       
var Buffer.data_pre: [Buffer]int;                                                                   
var Buffer._state_pre: [Buffer]State;                                                               
var Lock._lock_pre: [Lock]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Buffer.full_pre: [Buffer]bool;                                                                  
var Buffer.popLock_pre: [Buffer]Lock;                                                               
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var newValue_pre: Lock;                                                                             
var Lock._state_pre: [Lock]State;                                                                   
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var Lock._lock_post: [Lock]Tid;                                                                     
var Lock._state_post: [Lock]State;                                                                  
var Buffer.popLock_post: [Buffer]Lock;                                                              
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Buffer.data_post: [Buffer]int;                                                                  
var this_post: Buffer;                                                                              
var $pc_post: Phase;                                                                                
var tid_post: Tid;                                                                                  
var Buffer.full_post: [Buffer]bool;                                                                 
var newValue_post: Lock;                                                                            
var Buffer.pushLock_post: [Buffer]Lock;                                                             
                                                                                                    
assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 assume Y_Buffer.pushLock(tid, this, newValue , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
assume Lock._state_post == Lock._state_p && Lock._lock_post == Lock._lock_p && Buffer._state_post == Buffer._state_p && Buffer.popLock_post == Buffer.popLock_p && Buffer.pushLock_post == Buffer.pushLock_p && Buffer.full_post == Buffer.full_p && Buffer.data_post == Buffer.data_p && Buffer._lock_post == Buffer._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer.pushLock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
// Buffer.full:                                                                                     
                                                                                                    
function {:inline} Y_Buffer.full(tid : Tid, this: Buffer, newValue: bool , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer.full(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _R)) ==> (Buffer.full[this] == newValue))
 &&(((((isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid)&&Buffer.full[this])==>newValue)&&(((isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid)&&!(Buffer.full[this]))==>!(newValue))))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer.full(tid : Tid, this: Buffer, newValue: bool , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer.full.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: bool , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var newValue_yield: bool;                                                                           
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var u_yield: Tid;                                                                                   
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer.full(u: Tid,this: Buffer,newValue: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)));
                                                                                                    
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.full(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.full.Reflexive(tid : Tid, this: Buffer , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.full(tid, this, Buffer.full[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.full.Transitive(tid : Tid, this: Buffer, newValue : bool , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires StateInvariant(Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (10.43): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Buffer.pushLock_pre: [Buffer]Lock;                                                              
var newValue_pre: bool;                                                                             
var $recorded.state_pre: int;                                                                       
var Buffer.data_pre: [Buffer]int;                                                                   
var Buffer._state_pre: [Buffer]State;                                                               
var Lock._lock_pre: [Lock]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Buffer.full_pre: [Buffer]bool;                                                                  
var Buffer.popLock_pre: [Buffer]Lock;                                                               
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Lock._state_pre: [Lock]State;                                                                   
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var Lock._lock_post: [Lock]Tid;                                                                     
var Lock._state_post: [Lock]State;                                                                  
var Buffer.popLock_post: [Buffer]Lock;                                                              
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Buffer.data_post: [Buffer]int;                                                                  
var this_post: Buffer;                                                                              
var $pc_post: Phase;                                                                                
var tid_post: Tid;                                                                                  
var Buffer.full_post: [Buffer]bool;                                                                 
var newValue_post: bool;                                                                            
var Buffer.pushLock_post: [Buffer]Lock;                                                             
                                                                                                    
assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 assume Y_Buffer.full(tid, this, newValue , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
assume Lock._state_post == Lock._state_p && Lock._lock_post == Lock._lock_p && Buffer._state_post == Buffer._state_p && Buffer.popLock_post == Buffer.popLock_p && Buffer.pushLock_post == Buffer.pushLock_p && Buffer.full_post == Buffer.full_p && Buffer.data_post == Buffer.data_p && Buffer._lock_post == Buffer._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer.full(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
// Buffer.data:                                                                                     
                                                                                                    
function {:inline} Y_Buffer.data(tid : Tid, this: Buffer, newValue: int , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer.data(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _R)) ==> (Buffer.data[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer.data(tid : Tid, this: Buffer, newValue: int , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer.data.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: int , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var newValue_yield: int;                                                                            
var Buffer.data_yield: [Buffer]int;                                                                 
var u_yield: Tid;                                                                                   
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer.data(u: Tid,this: Buffer,newValue: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)));
                                                                                                    
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.data(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.data.Reflexive(tid : Tid, this: Buffer , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.data(tid, this, Buffer.data[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.data.Transitive(tid : Tid, this: Buffer, newValue : int , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires StateInvariant(Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (20.40): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Buffer.pushLock_pre: [Buffer]Lock;                                                              
var $recorded.state_pre: int;                                                                       
var Buffer.data_pre: [Buffer]int;                                                                   
var Buffer._state_pre: [Buffer]State;                                                               
var newValue_pre: int;                                                                              
var Lock._lock_pre: [Lock]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Buffer.full_pre: [Buffer]bool;                                                                  
var Buffer.popLock_pre: [Buffer]Lock;                                                               
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Lock._state_pre: [Lock]State;                                                                   
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var Lock._lock_post: [Lock]Tid;                                                                     
var Lock._state_post: [Lock]State;                                                                  
var Buffer.popLock_post: [Buffer]Lock;                                                              
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Buffer.data_post: [Buffer]int;                                                                  
var this_post: Buffer;                                                                              
var newValue_post: int;                                                                             
var $pc_post: Phase;                                                                                
var tid_post: Tid;                                                                                  
var Buffer.full_post: [Buffer]bool;                                                                 
var Buffer.pushLock_post: [Buffer]Lock;                                                             
                                                                                                    
assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 assume Y_Buffer.data(tid, this, newValue , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
assume Lock._state_post == Lock._state_p && Lock._lock_post == Lock._lock_p && Buffer._state_post == Buffer._state_p && Buffer.popLock_post == Buffer.popLock_p && Buffer.pushLock_post == Buffer.pushLock_p && Buffer.full_post == Buffer.full_p && Buffer.data_post == Buffer.data_p && Buffer._lock_post == Buffer._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer.data(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
// Buffer._lock:                                                                                    
                                                                                                    
function {:inline} Y_Buffer._lock(tid : Tid, this: Buffer, newValue: Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer._lock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _R)) ==> (Buffer._lock[this] == newValue))
 &&(((Buffer._lock[this]==tid)==(newValue==tid)))                                                   
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer._lock(tid : Tid, this: Buffer, newValue: Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer._lock.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var newValue_yield: Tid;                                                                            
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var u_yield: Tid;                                                                                   
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer._lock(u: Tid,this: Buffer,newValue: Tid,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)));
 assume leq(m#moverPath(ReadEval.Buffer._lock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _N);
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer._lock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer._lock.Reflexive(tid : Tid, this: Buffer , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer._lock(tid, this, Buffer._lock[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer._lock.Transitive(tid : Tid, this: Buffer, newValue : Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires StateInvariant(Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3761691(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (4.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Buffer.pushLock_pre: [Buffer]Lock;                                                              
var $recorded.state_pre: int;                                                                       
var Buffer.data_pre: [Buffer]int;                                                                   
var Buffer._state_pre: [Buffer]State;                                                               
var Lock._lock_pre: [Lock]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Buffer.full_pre: [Buffer]bool;                                                                  
var Buffer.popLock_pre: [Buffer]Lock;                                                               
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Lock._state_pre: [Lock]State;                                                                   
var newValue_pre: Tid;                                                                              
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var Lock._lock_post: [Lock]Tid;                                                                     
var Lock._state_post: [Lock]State;                                                                  
var Buffer.popLock_post: [Buffer]Lock;                                                              
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Buffer.data_post: [Buffer]int;                                                                  
var this_post: Buffer;                                                                              
var $pc_post: Phase;                                                                                
var tid_post: Tid;                                                                                  
var Buffer.full_post: [Buffer]bool;                                                                 
var newValue_post: Tid;                                                                             
var Buffer.pushLock_post: [Buffer]Lock;                                                             
                                                                                                    
assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 assume Y_Buffer._lock(tid, this, newValue , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
assume Lock._state_post == Lock._state_p && Lock._lock_post == Lock._lock_p && Buffer._state_post == Buffer._state_p && Buffer.popLock_post == Buffer.popLock_p && Buffer.pushLock_post == Buffer.pushLock_p && Buffer.full_post == Buffer.full_p && Buffer.data_post == Buffer.data_p && Buffer._lock_post == Buffer._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer._lock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid): bool
{                                                                                                   
 (forall this: Lock :: Y_Lock._lock(tid : Tid, this, Lock._lock_p[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock))
 && (forall this: Buffer :: Y_Buffer.popLock(tid : Tid, this, Buffer.popLock_p[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock))
 && (forall this: Buffer :: Y_Buffer.pushLock(tid : Tid, this, Buffer.pushLock_p[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock))
 && (forall this: Buffer :: Y_Buffer.full(tid : Tid, this, Buffer.full_p[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock))
 && (forall this: Buffer :: Y_Buffer.data(tid : Tid, this, Buffer.data_p[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock))
 && (forall this: Buffer :: Y_Buffer._lock(tid : Tid, this, Buffer._lock_p[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock))
 && (forall _i : Lock :: isShared(Lock._state[_i]) ==> isShared(Lock._state_p[_i]))                 
 && (forall _i : Lock :: isLocal(Lock._state[_i], tid) <==> isLocal(Lock._state_p[_i], tid))        
 && (forall _i : Buffer :: isShared(Buffer._state[_i]) ==> isShared(Buffer._state_p[_i]))           
 && (forall _i : Buffer :: isLocal(Buffer._state[_i], tid) <==> isLocal(Buffer._state_p[_i], tid))  
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 1183.1-1599.2: (Method:27.3)
// 1195.1-1195.24: (27.3): Bad tid
// 1196.1-1196.40: (27.3): this is not global
// 1201.1-1201.271: (27.3): Object invariant may not hold.
// 1204.1-1204.270: (27.3): Object invariant may not hold.
// 1392.1-1392.190: (27.12): Can only have right-mover memory accesses in requires clause
// 1394.2-1396.2: (class anchor.sink.VarDeclStmt:29.5)
// 1397.2-1414.32: (class anchor.sink.Read:29.5)
// 1409.1-1409.30: (29.5): Cannot have potential null deference in left-mover part.
// 1413.1-1413.27: (29.5): Reduction failure
// 1418.1-1418.28: (29.18): Cannot have potential null deference in left-mover part.
// 1422.1-1422.27: (29.18): Reduction failure
// 1426.2-1430.14: (class anchor.sink.While:30.9)
// 1432.1-1432.27: (27.3): Bad tid
// 1433.1-1433.43: (27.3): this is not global
// 1436.1-1436.274: (30.9): Object invariant may not hold.
// 1436.274-1437.113: (30.9): invariant holds(this.pushLock, tid) may not hold
// 1437.113-1438.114: (30.9): invariant !holds(this.popLock, tid) may not hold
// 1438.114-1439.79: (30.9): invariant holds(tmp1, tid) may not hold
// 1440.1-1440.270: (30.9): Loop does not preserve yields_as annotation for field popLock
// 1441.1-1441.272: (30.9): Loop does not preserve yields_as annotation for field pushLock
// 1442.1-1442.264: (30.9): Loop does not preserve yields_as annotation for field full
// 1443.1-1443.264: (30.9): Loop does not preserve yields_as annotation for field data
// 1444.1-1444.33: (30.9): Phase must be invariant at loop head
// 1445.1-1445.30: (30.9): Potentially infinite loop cannot be in post-commit phase.
// 1447.3-1449.3: (class anchor.sink.VarDeclStmt:30.16)
// 1450.3-1453.16: (class anchor.sink.Assign:30.16)
// 1455.4-1458.10: (class anchor.sink.Break:30.9)
// 1461.3-1463.3: (class anchor.sink.VarDeclStmt:34.11)
// 1464.3-1466.3: (class anchor.sink.VarDeclStmt:34.11)
// 1467.3-1484.29: (class anchor.sink.Read:34.11)
// 1479.1-1479.31: (34.11): Cannot have potential null deference in left-mover part.
// 1483.1-1483.28: (34.11): Reduction failure
// 1485.3-1488.19: (class anchor.sink.Assign:34.11)
// 1490.4-1493.10: (class anchor.sink.Break:34.29)
// 1496.3-1506.43: (class anchor.sink.Yield:35.11)
// 1501.1-1501.271: (35.11): Object invariant may not hold.
// 1503.1-1503.271: (35.11): Object invariant may not hold.
// 1509.1-1509.30: (30.9): Phase must be invariant at loop head
// 1511.2-1521.42: (class anchor.sink.Yield:37.9)
// 1516.1-1516.270: (37.9): Object invariant may not hold.
// 1518.1-1518.270: (37.9): Object invariant may not hold.
// 1525.1-1525.30: (38.22): Cannot have potential null deference in left-mover part.
// 1529.1-1529.27: (38.22): Reduction failure
// 1532.2-1548.25: (class anchor.sink.Write:39.13)
// 1544.1-1544.30: (39.13): Cannot have potential null deference in left-mover part.
// 1547.1-1547.27: (39.13): Reduction failure
// 1549.2-1551.2: (class anchor.sink.VarDeclStmt:40.13)
// 1552.2-1555.15: (class anchor.sink.Assign:40.13)
// 1557.2-1573.28: (class anchor.sink.Write:40.13)
// 1569.1-1569.30: (40.13): Cannot have potential null deference in left-mover part.
// 1572.1-1572.27: (40.13): Reduction failure
// 1577.1-1577.30: (41.9): Cannot have potential null deference in left-mover part.
// 1579.1-1579.35: (41.9): lock not held
// 1581.1-1581.27: (41.9): Reduction failure
// 1586.1-1586.28: (42.5): Cannot have potential null deference in left-mover part.
// 1588.1-1588.33: (42.5): lock not held
// 1590.1-1590.27: (42.5): Reduction failure
// 1592.2-1598.9: (class anchor.sink.Return:28.27)
// 1597.1-1597.270: (28.27): Object invariant may not hold.
// 1600.1-2051.2: (Method:45.3)
// 1613.1-1613.24: (45.3): Bad tid
// 1614.1-1614.40: (45.3): this is not global
// 1617.1-1617.271: (45.3): Object invariant may not hold.
// 1620.1-1620.270: (45.3): Object invariant may not hold.
// 1824.2-1826.2: (class anchor.sink.VarDeclStmt:46.5)
// 1827.2-1844.31: (class anchor.sink.Read:46.5)
// 1839.1-1839.30: (46.5): Cannot have potential null deference in left-mover part.
// 1843.1-1843.27: (46.5): Reduction failure
// 1848.1-1848.28: (46.18): Cannot have potential null deference in left-mover part.
// 1852.1-1852.27: (46.18): Reduction failure
// 1856.2-1860.14: (class anchor.sink.While:47.9)
// 1862.1-1862.27: (45.3): Bad tid
// 1863.1-1863.43: (45.3): this is not global
// 1866.1-1866.274: (47.9): Object invariant may not hold.
// 1866.274-1867.111: (47.9): invariant holds(this.popLock, tid) may not hold
// 1867.111-1868.79: (47.9): invariant holds(tmp6, tid) may not hold
// 1869.1-1869.270: (47.9): Loop does not preserve yields_as annotation for field popLock
// 1870.1-1870.272: (47.9): Loop does not preserve yields_as annotation for field pushLock
// 1871.1-1871.264: (47.9): Loop does not preserve yields_as annotation for field full
// 1872.1-1872.264: (47.9): Loop does not preserve yields_as annotation for field data
// 1873.1-1873.33: (47.9): Phase must be invariant at loop head
// 1874.1-1874.30: (47.9): Potentially infinite loop cannot be in post-commit phase.
// 1876.3-1878.3: (class anchor.sink.VarDeclStmt:47.16)
// 1879.3-1882.16: (class anchor.sink.Assign:47.16)
// 1884.4-1887.10: (class anchor.sink.Break:47.9)
// 1890.3-1892.3: (class anchor.sink.VarDeclStmt:50.11)
// 1893.3-1910.29: (class anchor.sink.Read:50.11)
// 1905.1-1905.31: (50.11): Cannot have potential null deference in left-mover part.
// 1909.1-1909.28: (50.11): Reduction failure
// 1912.4-1915.10: (class anchor.sink.Break:50.28)
// 1918.3-1928.43: (class anchor.sink.Yield:51.11)
// 1923.1-1923.271: (51.11): Object invariant may not hold.
// 1925.1-1925.271: (51.11): Object invariant may not hold.
// 1931.1-1931.30: (47.9): Phase must be invariant at loop head
// 1933.2-1943.42: (class anchor.sink.Yield:53.9)
// 1938.1-1938.270: (53.9): Object invariant may not hold.
// 1940.1-1940.270: (53.9): Object invariant may not hold.
// 1947.1-1947.30: (54.22): Cannot have potential null deference in left-mover part.
// 1951.1-1951.27: (54.22): Reduction failure
// 1953.2-1955.2: (class anchor.sink.VarDeclStmt:55.13)
// 1956.2-1973.30: (class anchor.sink.Read:55.13)
// 1968.1-1968.30: (55.13): Cannot have potential null deference in left-mover part.
// 1972.1-1972.27: (55.13): Reduction failure
// 1974.2-1976.2: (class anchor.sink.VarDeclStmt:56.13)
// 1977.2-1980.16: (class anchor.sink.Assign:56.13)
// 1982.2-1998.28: (class anchor.sink.Write:56.13)
// 1994.1-1994.30: (56.13): Cannot have potential null deference in left-mover part.
// 1997.1-1997.27: (56.13): Reduction failure
// 2002.1-2002.30: (58.9): Cannot have potential null deference in left-mover part.
// 2004.1-2004.35: (58.9): lock not held
// 2006.1-2006.27: (58.9): Reduction failure
// 2011.1-2011.28: (59.5): Cannot have potential null deference in left-mover part.
// 2013.1-2013.33: (59.5): lock not held
// 2015.1-2015.27: (59.5): Reduction failure
// 2017.2-2024.9: (class anchor.sink.Return:57.13)
// 2023.1-2023.270: (57.13): Object invariant may not hold.
// 2028.1-2028.30: (58.9): Cannot have potential null deference in left-mover part.
// 2030.1-2030.35: (58.9): lock not held
// 2032.1-2032.27: (58.9): Reduction failure
// 2037.1-2037.28: (59.5): Cannot have potential null deference in left-mover part.
// 2039.1-2039.33: (59.5): lock not held
// 2041.1-2041.27: (59.5): Reduction failure
// 2043.2-2050.9: (class anchor.sink.Return:45.20)
// 2049.1-2049.270: (45.20): Object invariant may not hold.
// 2140.1-2140.34: (7.3): Buffer.popLock failed Write-Write Right-Mover Check
// 2207.1-2207.30: (7.3): Buffer.popLock failed Write-Read Right-Mover Check
// 2278.1-2278.34: (7.3): Buffer.popLock failed Write-Write Left-Mover Check
// 2346.1-2346.30: (7.3): Buffer.popLock failed Write-Read Left-Mover Check
// 2411.1-2411.34: (7.3): Buffer.popLock failed Read-Write Right-Mover Check
// 2479.1-2479.34: (7.3): Buffer.popLock failed Read-Write Left-Mover Check
// 2546.1-2546.34: (8.3): Buffer.pushLock failed Write-Write Right-Mover Check
// 2613.1-2613.30: (8.3): Buffer.pushLock failed Write-Read Right-Mover Check
// 2684.1-2684.34: (8.3): Buffer.pushLock failed Write-Write Left-Mover Check
// 2752.1-2752.30: (8.3): Buffer.pushLock failed Write-Read Left-Mover Check
// 2817.1-2817.34: (8.3): Buffer.pushLock failed Read-Write Right-Mover Check
// 2885.1-2885.34: (8.3): Buffer.pushLock failed Read-Write Left-Mover Check
// 2952.1-2952.34: (10.3): Buffer.full failed Write-Write Right-Mover Check
// 3019.1-3019.30: (10.3): Buffer.full failed Write-Read Right-Mover Check
// 3090.1-3090.34: (10.3): Buffer.full failed Write-Write Left-Mover Check
// 3158.1-3158.30: (10.3): Buffer.full failed Write-Read Left-Mover Check
// 3223.1-3223.34: (10.3): Buffer.full failed Read-Write Right-Mover Check
// 3291.1-3291.34: (10.3): Buffer.full failed Read-Write Left-Mover Check
// 3358.1-3358.34: (20.3): Buffer.data failed Write-Write Right-Mover Check
// 3425.1-3425.30: (20.3): Buffer.data failed Write-Read Right-Mover Check
// 3496.1-3496.34: (20.3): Buffer.data failed Write-Write Left-Mover Check
// 3564.1-3564.30: (20.3): Buffer.data failed Write-Read Left-Mover Check
// 3629.1-3629.34: (20.3): Buffer.data failed Read-Write Right-Mover Check
// 3697.1-3697.34: (20.3): Buffer.data failed Read-Write Left-Mover Check
// 3776.1-3776.140: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case A.1)
// 3777.1-3777.101: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case A.2)
// 3778.1-3778.158: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case A.3)
// 3886.1-3886.140: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case C)
// 3999.1-3999.144: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case D)
// 4000.1-4000.144: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case R)
// 4079.1-4079.136: (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.popLock (case F)
// 4080.1-4080.136: (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.popLock (case H)
// 4081.1-4081.146: (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.popLock (case I)
// 4159.1-4159.136: (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.popLock (case J)
// 4160.1-4160.136: (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.popLock (case K)
// 4161.1-4161.99: (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.popLock (case L)
// 4241.1-4241.140: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case A.1)
// 4242.1-4242.101: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case A.2)
// 4243.1-4243.158: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case A.3)
// 4351.1-4351.140: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case C)
// 4464.1-4464.144: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case D)
// 4465.1-4465.144: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case R)
// 4544.1-4544.136: (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.pushLock (case F)
// 4545.1-4545.136: (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.pushLock (case H)
// 4546.1-4546.146: (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.pushLock (case I)
// 4624.1-4624.136: (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.popLock (case J)
// 4625.1-4625.136: (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.popLock (case K)
// 4626.1-4626.99: (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.popLock (case L)
// 4706.1-4706.140: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case A.1)
// 4707.1-4707.101: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case A.2)
// 4708.1-4708.158: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case A.3)
// 4816.1-4816.140: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case C)
// 4929.1-4929.144: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case D)
// 4930.1-4930.144: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case R)
// 5009.1-5009.136: (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.full (case F)
// 5010.1-5010.136: (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.full (case H)
// 5011.1-5011.146: (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.full (case I)
// 5089.1-5089.136: (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.popLock (case J)
// 5090.1-5090.136: (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.popLock (case K)
// 5091.1-5091.99: (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.popLock (case L)
// 5171.1-5171.140: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case A.1)
// 5172.1-5172.101: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case A.2)
// 5173.1-5173.158: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case A.3)
// 5281.1-5281.140: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case C)
// 5394.1-5394.144: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case D)
// 5395.1-5395.144: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case R)
// 5474.1-5474.136: (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.data (case F)
// 5475.1-5475.136: (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.data (case H)
// 5476.1-5476.146: (7.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.data (case I)
// 5554.1-5554.136: (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.popLock (case J)
// 5555.1-5555.136: (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.popLock (case K)
// 5556.1-5556.99: (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.popLock (case L)
// 5636.1-5636.140: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
// 5637.1-5637.101: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
// 5638.1-5638.158: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
// 5746.1-5746.140: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case C)
// 5859.1-5859.144: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case D)
// 5860.1-5860.144: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case R)
// 5939.1-5939.136: (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.popLock (case F)
// 5940.1-5940.136: (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.popLock (case H)
// 5941.1-5941.146: (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.popLock (case I)
// 6019.1-6019.136: (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.pushLock (case J)
// 6020.1-6020.136: (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.pushLock (case K)
// 6021.1-6021.99: (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.pushLock (case L)
// 6101.1-6101.140: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
// 6102.1-6102.101: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
// 6103.1-6103.158: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
// 6211.1-6211.140: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case C)
// 6324.1-6324.144: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case D)
// 6325.1-6325.144: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case R)
// 6404.1-6404.136: (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.pushLock (case F)
// 6405.1-6405.136: (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.pushLock (case H)
// 6406.1-6406.146: (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.pushLock (case I)
// 6484.1-6484.136: (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.pushLock (case J)
// 6485.1-6485.136: (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.pushLock (case K)
// 6486.1-6486.99: (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.pushLock (case L)
// 6566.1-6566.140: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
// 6567.1-6567.101: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
// 6568.1-6568.158: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
// 6676.1-6676.140: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case C)
// 6789.1-6789.144: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case D)
// 6790.1-6790.144: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case R)
// 6869.1-6869.136: (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.full (case F)
// 6870.1-6870.136: (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.full (case H)
// 6871.1-6871.146: (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.full (case I)
// 6949.1-6949.136: (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.pushLock (case J)
// 6950.1-6950.136: (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.pushLock (case K)
// 6951.1-6951.99: (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.pushLock (case L)
// 7031.1-7031.140: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
// 7032.1-7032.101: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
// 7033.1-7033.158: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
// 7141.1-7141.140: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case C)
// 7254.1-7254.144: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case D)
// 7255.1-7255.144: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case R)
// 7334.1-7334.136: (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.data (case F)
// 7335.1-7335.136: (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.data (case H)
// 7336.1-7336.146: (8.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.data (case I)
// 7414.1-7414.136: (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.pushLock (case J)
// 7415.1-7415.136: (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.pushLock (case K)
// 7416.1-7416.99: (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.pushLock (case L)
// 7496.1-7496.140: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case A.1)
// 7497.1-7497.101: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case A.2)
// 7498.1-7498.158: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case A.3)
// 7606.1-7606.140: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case C)
// 7719.1-7719.144: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case D)
// 7720.1-7720.144: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case R)
// 7799.1-7799.136: (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.popLock (case F)
// 7800.1-7800.136: (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.popLock (case H)
// 7801.1-7801.146: (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.popLock (case I)
// 7879.1-7879.136: (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.full (case J)
// 7880.1-7880.136: (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.full (case K)
// 7881.1-7881.99: (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.full (case L)
// 7961.1-7961.140: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case A.1)
// 7962.1-7962.101: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case A.2)
// 7963.1-7963.158: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case A.3)
// 8071.1-8071.140: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case C)
// 8184.1-8184.144: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case D)
// 8185.1-8185.144: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case R)
// 8264.1-8264.136: (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.pushLock (case F)
// 8265.1-8265.136: (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.pushLock (case H)
// 8266.1-8266.146: (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.pushLock (case I)
// 8344.1-8344.136: (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.full (case J)
// 8345.1-8345.136: (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.full (case K)
// 8346.1-8346.99: (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.full (case L)
// 8426.1-8426.140: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.full (case A.1)
// 8427.1-8427.101: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.full (case A.2)
// 8428.1-8428.158: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.full (case A.3)
// 8536.1-8536.140: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.full (case C)
// 8649.1-8649.144: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.full (case D)
// 8650.1-8650.144: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.full (case R)
// 8729.1-8729.136: (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.full (case F)
// 8730.1-8730.136: (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.full (case H)
// 8731.1-8731.146: (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.full (case I)
// 8809.1-8809.136: (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.full (case J)
// 8810.1-8810.136: (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.full (case K)
// 8811.1-8811.99: (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.full (case L)
// 8891.1-8891.140: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case A.1)
// 8892.1-8892.101: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case A.2)
// 8893.1-8893.158: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case A.3)
// 9001.1-9001.140: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.data (case C)
// 9114.1-9114.144: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.data (case D)
// 9115.1-9115.144: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.data (case R)
// 9194.1-9194.136: (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.data (case F)
// 9195.1-9195.136: (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.data (case H)
// 9196.1-9196.146: (10.3): Buffer.full is not Read-Write Stable with respect to Buffer.data (case I)
// 9274.1-9274.136: (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.full (case J)
// 9275.1-9275.136: (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.full (case K)
// 9276.1-9276.99: (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.full (case L)
// 9356.1-9356.140: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case A.1)
// 9357.1-9357.101: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case A.2)
// 9358.1-9358.158: (7.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case A.3)
// 9466.1-9466.140: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case C)
// 9579.1-9579.144: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case D)
// 9580.1-9580.144: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case R)
// 9659.1-9659.136: (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.popLock (case F)
// 9660.1-9660.136: (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.popLock (case H)
// 9661.1-9661.146: (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.popLock (case I)
// 9739.1-9739.136: (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.data (case J)
// 9740.1-9740.136: (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.data (case K)
// 9741.1-9741.99: (7.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.data (case L)
// 9821.1-9821.140: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case A.1)
// 9822.1-9822.101: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case A.2)
// 9823.1-9823.158: (8.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case A.3)
// 9931.1-9931.140: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case C)
// 10044.1-10044.144: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case D)
// 10045.1-10045.144: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case R)
// 10124.1-10124.136: (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.pushLock (case F)
// 10125.1-10125.136: (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.pushLock (case H)
// 10126.1-10126.146: (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.pushLock (case I)
// 10204.1-10204.136: (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.data (case J)
// 10205.1-10205.136: (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.data (case K)
// 10206.1-10206.99: (8.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.data (case L)
// 10286.1-10286.140: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.data (case A.1)
// 10287.1-10287.101: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.data (case A.2)
// 10288.1-10288.158: (10.3): Buffer.full is not Write-Write Stable with respect to Buffer.data (case A.3)
// 10396.1-10396.140: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case C)
// 10509.1-10509.144: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case D)
// 10510.1-10510.144: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case R)
// 10589.1-10589.136: (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.full (case F)
// 10590.1-10590.136: (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.full (case H)
// 10591.1-10591.146: (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.full (case I)
// 10669.1-10669.136: (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.data (case J)
// 10670.1-10670.136: (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.data (case K)
// 10671.1-10671.99: (10.3): Buffer.full is not Write-Read Stable with respect to Buffer.data (case L)
// 10751.1-10751.140: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case A.1)
// 10752.1-10752.101: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case A.2)
// 10753.1-10753.158: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case A.3)
// 10861.1-10861.140: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case C)
// 10974.1-10974.144: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case D)
// 10975.1-10975.144: (20.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case R)
// 11054.1-11054.136: (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.data (case F)
// 11055.1-11055.136: (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.data (case H)
// 11056.1-11056.146: (20.3): Buffer.data is not Read-Write Stable with respect to Buffer.data (case I)
// 11134.1-11134.136: (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.data (case J)
// 11135.1-11135.136: (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.data (case K)
// 11136.1-11136.99: (20.3): Buffer.data is not Write-Read Stable with respect to Buffer.data (case L)
// 11143.1-11143.271: (<undefined position>): Object invariant may not hold.
// 11154.1-11154.270: (<undefined position>): Object invariant may not hold.
// 11175.1-11199.2: (7.32): yields_as clause for Lock._lock is not valid
// 11204.1-11223.2: (7.32): yields_as clause for Lock._lock is not reflexive
// 11229.1-11229.271: (2.1): Object invariant may not hold.
// 11230.1-11268.2: (7.32): yields_as clause for Lock._lock is not transitive
// 11287.1-11311.2: (7.3): yields_as clause for Buffer.popLock is not valid
// 11316.1-11335.2: (7.3): yields_as clause for Buffer.popLock is not reflexive
// 11341.1-11341.271: (7.31): Object invariant may not hold.
// 11342.1-11380.2: (7.3): yields_as clause for Buffer.popLock is not transitive
// 11399.1-11423.2: (8.3): yields_as clause for Buffer.pushLock is not valid
// 11428.1-11447.2: (8.3): yields_as clause for Buffer.pushLock is not reflexive
// 11453.1-11453.271: (8.31): Object invariant may not hold.
// 11454.1-11492.2: (8.3): yields_as clause for Buffer.pushLock is not transitive
// 11512.1-11536.2: (17.27): yields_as clause for Buffer.full is not valid
// 11541.1-11560.2: (17.27): yields_as clause for Buffer.full is not reflexive
// 11566.1-11566.271: (10.43): Object invariant may not hold.
// 11567.1-11605.2: (17.27): yields_as clause for Buffer.full is not transitive
// 11624.1-11648.2: (20.3): yields_as clause for Buffer.data is not valid
// 11653.1-11672.2: (20.3): yields_as clause for Buffer.data is not reflexive
// 11678.1-11678.271: (20.40): Object invariant may not hold.
// 11679.1-11717.2: (20.3): yields_as clause for Buffer.data is not transitive
// 11737.1-11761.2: (7.32): yields_as clause for Buffer._lock is not valid
// 11766.1-11785.2: (7.32): yields_as clause for Buffer._lock is not reflexive
// 11791.1-11791.271: (4.1): Object invariant may not hold.
// 11792.1-11830.2: (7.32): yields_as clause for Buffer._lock is not transitive
