                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/queue-cas.anchor:                       
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int value isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      volatile Node next isLocal(this, tid)                                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? this.next != Node.null ? R : N                                                           
         : this.next == Node.null && newValue != Node.null && isLocal(newValue, tid) ? N : E        
        yields_as this.next != newValue ==> !isShared(newValue);                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int value,Node next) {                                                              
        assume this.value == 0;                                                                     
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.value := value;                                                                      
          this.next := next;                                                                        
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Queue {                                                                                   
      volatile Node head isLocal(this, tid)                                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
      volatile Node tail isLocal(this, tid)                                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
      invariant  this.head != Node.null;                                                            
      invariant  this.tail != Node.null;                                                            
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        assume this.tail == Node.null;                                                              
        {                                                                                           
          Node sentinel;                                                                            
          sentinel = new Node();                                                                    
          sentinel.init(0,Node.null)                                                                
          this.head := sentinel;                                                                    
          this.tail := sentinel;                                                                    
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void enqueue(int value) {                                                              
        Node n;                                                                                     
        n = new Node();                                                                             
        n.init(value,Node.null)                                                                     
        while (true)                                                                                
          invariant isLocal(n, tid);                                                                
          invariant n.next == Node.null;                                                            
          {                                                                                         
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) break; else {                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node last;                                                                              
            last := this.tail;                                                                      
            yield;                                                                                  
            Node next;                                                                              
            next := last.next;                                                                      
            boolean tmp2;                                                                           
            tmp2 = next == Node.null;                                                               
            if (tmp2 /* == next == Node.null */) {                                                  
              yield;                                                                                
              boolean tmp3;                                                                         
              tmp3 = last.next@next :~ n;                                                           
              if (tmp3) {                                                                           
                yield;                                                                              
                boolean tmp4;                                                                       
                tmp4 = this.tail@last :~ n;                                                         
                 return;                                                                            
              } else {                                                                              
                                                                                                    
              }                                                                                     
            } else {                                                                                
              boolean tmp5;                                                                         
              tmp5 = this.tail@last :~ next;                                                        
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public int dequeue() {                                                                        
        while (true)   {                                                                            
          boolean tmp6;                                                                             
          tmp6 = true;                                                                              
          if (!tmp6) break; else {                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node first;                                                                             
            first := this.head;                                                                     
            yield;                                                                                  
            Node next;                                                                              
            next := first.next;                                                                     
            yield;                                                                                  
            Node last;                                                                              
            last := this.tail;                                                                      
            boolean tmp7;                                                                           
            tmp7 = first == last;                                                                   
            if (tmp7 /* == first == last */) {                                                      
              boolean tmp8;                                                                         
              tmp8 = next == Node.null;                                                             
              if (tmp8 /* == next == Node.null */) {                                                
                int tmp9;                                                                           
                tmp9 = -1;                                                                          
                 return tmp9;                                                                       
              } else {                                                                              
                yield;                                                                              
                boolean tmp10;                                                                      
                tmp10 = this.tail@last :~ next;                                                     
              }                                                                                     
            } else {                                                                                
              boolean tmp11;                                                                        
              tmp11 = next != Node.null;                                                            
              if (tmp11 /* == next != Node.null */) {                                               
                int value;                                                                          
                value := next.value;                                                                
                yield;                                                                              
                boolean tmp12;                                                                      
                tmp12 = this.head@first :~ next;                                                    
                if (tmp12) {                                                                        
                   return value;                                                                    
                } else {                                                                            
                                                                                                    
                }                                                                                   
              } else {                                                                              
                                                                                                    
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        // return -1;                                                                               
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int value isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      hasCASOperation volatile Node next isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? this.next != Node.null ? R : N                                                           
         : this.next == Node.null && newValue != Node.null && isLocal(newValue, tid) ? N : E        
        yields_as this.next != newValue ==> !isShared(newValue);                                    
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid next_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.next_nextThread == tid ? N : E                                                        
        yields_as this.next_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node next_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.next_nextThread == tid ? N : E                                                        
        yields_as this.next_nextThread == tid ==> newValue == this.next_nextValue;                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int value,Node next) {                                                              
        assume this.value == 0;                                                                     
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.value := value;                                                                      
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.next_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.next := next;                                                                      
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Queue {                                                                                   
      hasCASOperation volatile Node head isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
      hasCASOperation volatile Node tail isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid head_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node head_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == this.head_nextValue;                  
                                                                                                    
                                                                                                    
      updatesViaCAS Tid tail_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.tail_nextThread == tid ? N : E                                                        
        yields_as this.tail_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node tail_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.tail_nextThread == tid ? N : E                                                        
        yields_as this.tail_nextThread == tid ==> newValue == this.tail_nextValue;                  
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null;                                                            
      invariant  this.tail != Node.null;                                                            
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        assume this.tail == Node.null;                                                              
        {                                                                                           
          Node sentinel;                                                                            
          sentinel = new Node();                                                                    
          sentinel.init(0,Node.null)                                                                
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.head_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.head := sentinel;                                                                  
          }                                                                                         
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.tail_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.tail := sentinel;                                                                  
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void enqueue(int value) {                                                              
        Node n;                                                                                     
        n = new Node();                                                                             
        n.init(value,Node.null)                                                                     
        while (true)                                                                                
          invariant isLocal(n, tid);                                                                
          invariant n.next == Node.null;                                                            
          {                                                                                         
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node last;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.tail_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.tail_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.tail  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.tail);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                last := this.tail  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                last := this.tail;                                                                  
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            Node next;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := last.next_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := last.next_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := last.next  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(last.next);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                next := last.next  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                next := last.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp2;                                                                           
            tmp2 = next == Node.null;                                                               
            if (tmp2 /* == next == Node.null */) {                                                  
              yield;                                                                                
              boolean tmp3;                                                                         
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp3519962;                                                                
                ctmp3519962 = *;                                                                    
                if (ctmp3519962) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp3 = false;                                                                     
                } else {                                                                            
                  ctmp3519962 = *;                                                                  
                  if (ctmp3519962) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(last.next, n);                                             
                    assume last.next == next;                                                       
                    assume !goesWrong(_m);                                                          
                    assume last.next_nextThread == tid;                                             
                    assume last.next_nextValue == next;                                             
                    last.next_nextThread := tmpTid as B;                                            
                    last.next_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    last.next := n;                                                                 
                    tmp3 = true;                                                                    
                  } else {                                                                          
                    assume last.next_nextThread == tid;                                             
                    assume last.next_nextValue == next;                                             
                    Node _currentValue;                                                             
                    _currentValue := last.next  as B;                                               
                    last.next := next as B;                                                         
                    Mover _m;                                                                       
                    _m = writePermission(last.next, n);                                             
                    last.next := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    last.next := n;                                                                 
                    tmp3 = false;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              if (tmp3) {                                                                           
                yield;                                                                              
                boolean tmp4;                                                                       
                {                                                                                   
                  noop(TraceOff);                                                                   
                  boolean ctmp3519972;                                                              
                  ctmp3519972 = *;                                                                  
                  if (ctmp3519972) {                                                                
                    noop(TraceOn);                                                                  
                    tmp4 = false;                                                                   
                  } else {                                                                          
                    ctmp3519972 = *;                                                                
                    if (ctmp3519972) {                                                              
                      Tid tmpTid;                                                                   
                      Node tmpValue;                                                                
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, n);                                           
                      assume this.tail == last;                                                     
                      assume !goesWrong(_m);                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      this.tail_nextThread := tmpTid as B;                                          
                      this.tail_nextValue := tmpValue as B;                                         
                      noop(TraceOn);                                                                
                      this.tail := n;                                                               
                      tmp4 = true;                                                                  
                    } else {                                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      Node _currentValue;                                                           
                      _currentValue := this.tail  as B;                                             
                      this.tail := last as B;                                                       
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, n);                                           
                      this.tail := _currentValue as B;                                              
                      assume goesWrong(_m);                                                         
                      noop(TraceOn);                                                                
                      this.tail := n;                                                               
                      tmp4 = false;                                                                 
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                {                                                                                   
                   return;                                                                          
                }                                                                                   
              } else {                                                                              
                                                                                                    
              }                                                                                     
            } else {                                                                                
              boolean tmp5;                                                                         
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp3519986;                                                                
                ctmp3519986 = *;                                                                    
                if (ctmp3519986) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp5 = false;                                                                     
                } else {                                                                            
                  ctmp3519986 = *;                                                                  
                  if (ctmp3519986) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(this.tail, next);                                          
                    assume this.tail == last;                                                       
                    assume !goesWrong(_m);                                                          
                    assume this.tail_nextThread == tid;                                             
                    assume this.tail_nextValue == last;                                             
                    this.tail_nextThread := tmpTid as B;                                            
                    this.tail_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    this.tail := next;                                                              
                    tmp5 = true;                                                                    
                  } else {                                                                          
                    assume this.tail_nextThread == tid;                                             
                    assume this.tail_nextValue == last;                                             
                    Node _currentValue;                                                             
                    _currentValue := this.tail  as B;                                               
                    this.tail := last as B;                                                         
                    Mover _m;                                                                       
                    _m = writePermission(this.tail, next);                                          
                    this.tail := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    this.tail := next;                                                              
                    tmp5 = false;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public int dequeue() {                                                                        
        while (true)   {                                                                            
          boolean tmp6;                                                                             
          tmp6 = true;                                                                              
          if (!tmp6) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node first;                                                                             
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                first := this.head  as R;                                                           
              } else {                                                                              
                noop(TraceOn);                                                                      
                first := this.head;                                                                 
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            Node next;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := first.next_nextThread  as B;                                                  
              Node _C_v;                                                                            
              _C_v := first.next_nextValue  as B;                                                   
              Node _currentValue;                                                                   
              _currentValue := first.next  as B;                                                    
              Mover _R_t;                                                                           
              _R_t = readPermission(first.next);                                                    
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                next := first.next  as R;                                                           
              } else {                                                                              
                noop(TraceOn);                                                                      
                next := first.next;                                                                 
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            Node last;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.tail_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.tail_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.tail  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.tail);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                last := this.tail  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                last := this.tail;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp7;                                                                           
            tmp7 = first == last;                                                                   
            if (tmp7 /* == first == last */) {                                                      
              boolean tmp8;                                                                         
              tmp8 = next == Node.null;                                                             
              if (tmp8 /* == next == Node.null */) {                                                
                int tmp9;                                                                           
                tmp9 = -1;                                                                          
                {                                                                                   
                   return tmp9;                                                                     
                }                                                                                   
              } else {                                                                              
                yield;                                                                              
                boolean tmp10;                                                                      
                {                                                                                   
                  noop(TraceOff);                                                                   
                  boolean ctmp3520094;                                                              
                  ctmp3520094 = *;                                                                  
                  if (ctmp3520094) {                                                                
                    noop(TraceOn);                                                                  
                    tmp10 = false;                                                                  
                  } else {                                                                          
                    ctmp3520094 = *;                                                                
                    if (ctmp3520094) {                                                              
                      Tid tmpTid;                                                                   
                      Node tmpValue;                                                                
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, next);                                        
                      assume this.tail == last;                                                     
                      assume !goesWrong(_m);                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      this.tail_nextThread := tmpTid as B;                                          
                      this.tail_nextValue := tmpValue as B;                                         
                      noop(TraceOn);                                                                
                      this.tail := next;                                                            
                      tmp10 = true;                                                                 
                    } else {                                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      Node _currentValue;                                                           
                      _currentValue := this.tail  as B;                                             
                      this.tail := last as B;                                                       
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, next);                                        
                      this.tail := _currentValue as B;                                              
                      assume goesWrong(_m);                                                         
                      noop(TraceOn);                                                                
                      this.tail := next;                                                            
                      tmp10 = false;                                                                
                    }                                                                               
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            } else {                                                                                
              boolean tmp11;                                                                        
              tmp11 = next != Node.null;                                                            
              if (tmp11 /* == next != Node.null */) {                                               
                int value;                                                                          
                value := next.value;                                                                
                yield;                                                                              
                boolean tmp12;                                                                      
                {                                                                                   
                  noop(TraceOff);                                                                   
                  boolean ctmp3520129;                                                              
                  ctmp3520129 = *;                                                                  
                  if (ctmp3520129) {                                                                
                    noop(TraceOn);                                                                  
                    tmp12 = false;                                                                  
                  } else {                                                                          
                    ctmp3520129 = *;                                                                
                    if (ctmp3520129) {                                                              
                      Tid tmpTid;                                                                   
                      Node tmpValue;                                                                
                      Mover _m;                                                                     
                      _m = writePermission(this.head, next);                                        
                      assume this.head == first;                                                    
                      assume !goesWrong(_m);                                                        
                      assume this.head_nextThread == tid;                                           
                      assume this.head_nextValue == first;                                          
                      this.head_nextThread := tmpTid as B;                                          
                      this.head_nextValue := tmpValue as B;                                         
                      noop(TraceOn);                                                                
                      this.head := next;                                                            
                      tmp12 = true;                                                                 
                    } else {                                                                        
                      assume this.head_nextThread == tid;                                           
                      assume this.head_nextValue == first;                                          
                      Node _currentValue;                                                           
                      _currentValue := this.head  as B;                                             
                      this.head := first as B;                                                      
                      Mover _m;                                                                     
                      _m = writePermission(this.head, next);                                        
                      this.head := _currentValue as B;                                              
                      assume goesWrong(_m);                                                         
                      noop(TraceOn);                                                                
                      this.head := next;                                                            
                      tmp12 = false;                                                                
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                if (tmp12) {                                                                        
                  {                                                                                 
                     return value;                                                                  
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
              } else {                                                                              
                                                                                                    
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int value isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      hasCASOperation volatile Node next isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? this.next != Node.null ? R : N                                                           
         : this.next == Node.null && newValue != Node.null && isLocal(newValue, tid) ? N : E        
        yields_as this.next != newValue ==> !isShared(newValue);                                    
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid next_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.next_nextThread == tid ? N : E                                                        
        yields_as this.next_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node next_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.next_nextThread == tid ? N : E                                                        
        yields_as this.next_nextThread == tid ==> newValue == this.next_nextValue;                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int value,Node next) {                                                              
        assume this.value == 0;                                                                     
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.value := value;                                                                      
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.next_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.next := next;                                                                      
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Queue {                                                                                   
      hasCASOperation volatile Node head isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
      hasCASOperation volatile Node tail isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid head_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node head_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == this.head_nextValue;                  
                                                                                                    
                                                                                                    
      updatesViaCAS Tid tail_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.tail_nextThread == tid ? N : E                                                        
        yields_as this.tail_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node tail_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.tail_nextThread == tid ? N : E                                                        
        yields_as this.tail_nextThread == tid ==> newValue == this.tail_nextValue;                  
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null;                                                            
      invariant  this.tail != Node.null;                                                            
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        assume this.tail == Node.null;                                                              
        {                                                                                           
          Node sentinel;                                                                            
          sentinel = new Node();                                                                    
          sentinel.init(0,Node.null)                                                                
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.head_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.head := sentinel;                                                                  
          }                                                                                         
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.tail_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.tail := sentinel;                                                                  
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void enqueue(int value) {                                                              
        Node n;                                                                                     
        n = new Node();                                                                             
        {                                                                                           
          inlined n.init(value,Node.null);                                                          
          exit$230: {                                                                               
            int value$230;                                                                          
            Node next$230;                                                                          
            Node this$230;                                                                          
            value$230 = value;                                                                      
            next$230 = Node.null;                                                                   
            this$230 = n;                                                                           
            {                                                                                       
              assume this$230.value == 0;                                                           
              assume this$230.next == Node.null;                                                    
              {                                                                                     
                this$230.value := value$230;                                                        
                {                                                                                   
                  noop(TraceOff);                                                                   
                  assume this$230.next_nextThread == tid;                                           
                  noop(TraceOn);                                                                    
                  this$230.next := next$230;                                                        
                }                                                                                   
                {                                                                                   
                  break exit$230;                                                                   
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        while (true)                                                                                
          invariant isLocal(n, tid);                                                                
          invariant n.next == Node.null;                                                            
          {                                                                                         
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node last;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.tail_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.tail_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.tail  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.tail);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                last := this.tail  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                last := this.tail;                                                                  
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            Node next;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := last.next_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := last.next_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := last.next  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(last.next);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                next := last.next  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                next := last.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp2;                                                                           
            tmp2 = next == Node.null;                                                               
            if (tmp2 /* == next == Node.null */) {                                                  
              yield;                                                                                
              boolean tmp3;                                                                         
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp3519962;                                                                
                ctmp3519962 = *;                                                                    
                if (ctmp3519962) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp3 = false;                                                                     
                } else {                                                                            
                  ctmp3519962 = *;                                                                  
                  if (ctmp3519962) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(last.next, n);                                             
                    assume last.next == next;                                                       
                    assume !goesWrong(_m);                                                          
                    assume last.next_nextThread == tid;                                             
                    assume last.next_nextValue == next;                                             
                    last.next_nextThread := tmpTid as B;                                            
                    last.next_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    last.next := n;                                                                 
                    tmp3 = true;                                                                    
                  } else {                                                                          
                    assume last.next_nextThread == tid;                                             
                    assume last.next_nextValue == next;                                             
                    Node _currentValue;                                                             
                    _currentValue := last.next  as B;                                               
                    last.next := next as B;                                                         
                    Mover _m;                                                                       
                    _m = writePermission(last.next, n);                                             
                    last.next := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    last.next := n;                                                                 
                    tmp3 = false;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              if (tmp3) {                                                                           
                yield;                                                                              
                boolean tmp4;                                                                       
                {                                                                                   
                  noop(TraceOff);                                                                   
                  boolean ctmp3519972;                                                              
                  ctmp3519972 = *;                                                                  
                  if (ctmp3519972) {                                                                
                    noop(TraceOn);                                                                  
                    tmp4 = false;                                                                   
                  } else {                                                                          
                    ctmp3519972 = *;                                                                
                    if (ctmp3519972) {                                                              
                      Tid tmpTid;                                                                   
                      Node tmpValue;                                                                
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, n);                                           
                      assume this.tail == last;                                                     
                      assume !goesWrong(_m);                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      this.tail_nextThread := tmpTid as B;                                          
                      this.tail_nextValue := tmpValue as B;                                         
                      noop(TraceOn);                                                                
                      this.tail := n;                                                               
                      tmp4 = true;                                                                  
                    } else {                                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      Node _currentValue;                                                           
                      _currentValue := this.tail  as B;                                             
                      this.tail := last as B;                                                       
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, n);                                           
                      this.tail := _currentValue as B;                                              
                      assume goesWrong(_m);                                                         
                      noop(TraceOn);                                                                
                      this.tail := n;                                                               
                      tmp4 = false;                                                                 
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                {                                                                                   
                   return;                                                                          
                }                                                                                   
              } else {                                                                              
                                                                                                    
              }                                                                                     
            } else {                                                                                
              boolean tmp5;                                                                         
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp3519986;                                                                
                ctmp3519986 = *;                                                                    
                if (ctmp3519986) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp5 = false;                                                                     
                } else {                                                                            
                  ctmp3519986 = *;                                                                  
                  if (ctmp3519986) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(this.tail, next);                                          
                    assume this.tail == last;                                                       
                    assume !goesWrong(_m);                                                          
                    assume this.tail_nextThread == tid;                                             
                    assume this.tail_nextValue == last;                                             
                    this.tail_nextThread := tmpTid as B;                                            
                    this.tail_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    this.tail := next;                                                              
                    tmp5 = true;                                                                    
                  } else {                                                                          
                    assume this.tail_nextThread == tid;                                             
                    assume this.tail_nextValue == last;                                             
                    Node _currentValue;                                                             
                    _currentValue := this.tail  as B;                                               
                    this.tail := last as B;                                                         
                    Mover _m;                                                                       
                    _m = writePermission(this.tail, next);                                          
                    this.tail := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    this.tail := next;                                                              
                    tmp5 = false;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public int dequeue() {                                                                        
        while (true)   {                                                                            
          boolean tmp6;                                                                             
          tmp6 = true;                                                                              
          if (!tmp6) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node first;                                                                             
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                first := this.head  as R;                                                           
              } else {                                                                              
                noop(TraceOn);                                                                      
                first := this.head;                                                                 
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            Node next;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := first.next_nextThread  as B;                                                  
              Node _C_v;                                                                            
              _C_v := first.next_nextValue  as B;                                                   
              Node _currentValue;                                                                   
              _currentValue := first.next  as B;                                                    
              Mover _R_t;                                                                           
              _R_t = readPermission(first.next);                                                    
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                next := first.next  as R;                                                           
              } else {                                                                              
                noop(TraceOn);                                                                      
                next := first.next;                                                                 
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            Node last;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.tail_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.tail_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.tail  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.tail);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                last := this.tail  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                last := this.tail;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp7;                                                                           
            tmp7 = first == last;                                                                   
            if (tmp7 /* == first == last */) {                                                      
              boolean tmp8;                                                                         
              tmp8 = next == Node.null;                                                             
              if (tmp8 /* == next == Node.null */) {                                                
                int tmp9;                                                                           
                tmp9 = -1;                                                                          
                {                                                                                   
                   return tmp9;                                                                     
                }                                                                                   
              } else {                                                                              
                yield;                                                                              
                boolean tmp10;                                                                      
                {                                                                                   
                  noop(TraceOff);                                                                   
                  boolean ctmp3520094;                                                              
                  ctmp3520094 = *;                                                                  
                  if (ctmp3520094) {                                                                
                    noop(TraceOn);                                                                  
                    tmp10 = false;                                                                  
                  } else {                                                                          
                    ctmp3520094 = *;                                                                
                    if (ctmp3520094) {                                                              
                      Tid tmpTid;                                                                   
                      Node tmpValue;                                                                
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, next);                                        
                      assume this.tail == last;                                                     
                      assume !goesWrong(_m);                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      this.tail_nextThread := tmpTid as B;                                          
                      this.tail_nextValue := tmpValue as B;                                         
                      noop(TraceOn);                                                                
                      this.tail := next;                                                            
                      tmp10 = true;                                                                 
                    } else {                                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      Node _currentValue;                                                           
                      _currentValue := this.tail  as B;                                             
                      this.tail := last as B;                                                       
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, next);                                        
                      this.tail := _currentValue as B;                                              
                      assume goesWrong(_m);                                                         
                      noop(TraceOn);                                                                
                      this.tail := next;                                                            
                      tmp10 = false;                                                                
                    }                                                                               
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            } else {                                                                                
              boolean tmp11;                                                                        
              tmp11 = next != Node.null;                                                            
              if (tmp11 /* == next != Node.null */) {                                               
                int value;                                                                          
                value := next.value;                                                                
                yield;                                                                              
                boolean tmp12;                                                                      
                {                                                                                   
                  noop(TraceOff);                                                                   
                  boolean ctmp3520129;                                                              
                  ctmp3520129 = *;                                                                  
                  if (ctmp3520129) {                                                                
                    noop(TraceOn);                                                                  
                    tmp12 = false;                                                                  
                  } else {                                                                          
                    ctmp3520129 = *;                                                                
                    if (ctmp3520129) {                                                              
                      Tid tmpTid;                                                                   
                      Node tmpValue;                                                                
                      Mover _m;                                                                     
                      _m = writePermission(this.head, next);                                        
                      assume this.head == first;                                                    
                      assume !goesWrong(_m);                                                        
                      assume this.head_nextThread == tid;                                           
                      assume this.head_nextValue == first;                                          
                      this.head_nextThread := tmpTid as B;                                          
                      this.head_nextValue := tmpValue as B;                                         
                      noop(TraceOn);                                                                
                      this.head := next;                                                            
                      tmp12 = true;                                                                 
                    } else {                                                                        
                      assume this.head_nextThread == tid;                                           
                      assume this.head_nextValue == first;                                          
                      Node _currentValue;                                                           
                      _currentValue := this.head  as B;                                             
                      this.head := first as B;                                                      
                      Mover _m;                                                                     
                      _m = writePermission(this.head, next);                                        
                      this.head := _currentValue as B;                                              
                      assume goesWrong(_m);                                                         
                      noop(TraceOn);                                                                
                      this.head := next;                                                            
                      tmp12 = false;                                                                
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                if (tmp12) {                                                                        
                  {                                                                                 
                     return value;                                                                  
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
              } else {                                                                              
                                                                                                    
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int value isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      hasCASOperation volatile Node next isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? this.next != Node.null ? R : N                                                           
         : this.next == Node.null && newValue != Node.null && isLocal(newValue, tid) ? N : E        
        yields_as this.next != newValue ==> !isShared(newValue);                                    
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid next_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.next_nextThread == tid ? N : E                                                        
        yields_as this.next_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node next_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.next_nextThread == tid ? N : E                                                        
        yields_as this.next_nextThread == tid ==> newValue == this.next_nextValue;                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int value,Node next) {                                                              
        assume this.value == 0;                                                                     
        assume this.next == Node.null;                                                              
        {                                                                                           
          this.value := value;                                                                      
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.next_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.next := next;                                                                      
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Queue {                                                                                   
      hasCASOperation volatile Node head isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
      hasCASOperation volatile Node tail isLocal(this, tid)                                         
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      updatesViaCAS Tid head_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node head_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.head_nextThread == tid ? N : E                                                        
        yields_as this.head_nextThread == tid ==> newValue == this.head_nextValue;                  
                                                                                                    
                                                                                                    
      updatesViaCAS Tid tail_nextThread isLocal(this, tid)                                          
       ? B                                                                                          
       : this.tail_nextThread == tid ? N : E                                                        
        yields_as this.tail_nextThread == tid ==> newValue == tid;                                  
                                                                                                    
                                                                                                    
      updatesViaCAS Node tail_nextValue isLocal(this, tid)                                          
       ? B                                                                                          
       : this.tail_nextThread == tid ? N : E                                                        
        yields_as this.tail_nextThread == tid ==> newValue == this.tail_nextValue;                  
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null;                                                            
      invariant  this.tail != Node.null;                                                            
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        assume this.tail == Node.null;                                                              
        {                                                                                           
          Node sentinel;                                                                            
          sentinel = new Node();                                                                    
          sentinel.init(0,Node.null)                                                                
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.head_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.head := sentinel;                                                                  
          }                                                                                         
          {                                                                                         
            noop(TraceOff);                                                                         
            assume this.tail_nextThread == tid;                                                     
            noop(TraceOn);                                                                          
            this.tail := sentinel;                                                                  
          }                                                                                         
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void enqueue(int value) {                                                              
        Node n;                                                                                     
        n = new Node();                                                                             
        {                                                                                           
          inlined n.init(value,Node.null);                                                          
          exit$230: {                                                                               
            int value$230;                                                                          
            Node next$230;                                                                          
            Node this$230;                                                                          
            value$230 = value;                                                                      
            next$230 = Node.null;                                                                   
            this$230 = n;                                                                           
            {                                                                                       
              assume this$230.value == 0;                                                           
              assume this$230.next == Node.null;                                                    
              {                                                                                     
                this$230.value := value$230;                                                        
                {                                                                                   
                  noop(TraceOff);                                                                   
                  assume this$230.next_nextThread == tid;                                           
                  noop(TraceOn);                                                                    
                  this$230.next := next$230;                                                        
                }                                                                                   
                {                                                                                   
                  break exit$230;                                                                   
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        while (true)                                                                                
          invariant isLocal(n, tid);                                                                
          invariant n.next == Node.null;                                                            
          {                                                                                         
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node last;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.tail_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.tail_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.tail  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.tail);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                last := this.tail  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                last := this.tail;                                                                  
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            Node next;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := last.next_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := last.next_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := last.next  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(last.next);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                next := last.next  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                next := last.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp2;                                                                           
            tmp2 = next == Node.null;                                                               
            if (tmp2 /* == next == Node.null */) {                                                  
              yield;                                                                                
              boolean tmp3;                                                                         
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp3519962;                                                                
                ctmp3519962 = *;                                                                    
                if (ctmp3519962) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp3 = false;                                                                     
                } else {                                                                            
                  ctmp3519962 = *;                                                                  
                  if (ctmp3519962) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(last.next, n);                                             
                    assume last.next == next;                                                       
                    assume !goesWrong(_m);                                                          
                    assume last.next_nextThread == tid;                                             
                    assume last.next_nextValue == next;                                             
                    last.next_nextThread := tmpTid as B;                                            
                    last.next_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    last.next := n;                                                                 
                    tmp3 = true;                                                                    
                  } else {                                                                          
                    assume last.next_nextThread == tid;                                             
                    assume last.next_nextValue == next;                                             
                    Node _currentValue;                                                             
                    _currentValue := last.next  as B;                                               
                    last.next := next as B;                                                         
                    Mover _m;                                                                       
                    _m = writePermission(last.next, n);                                             
                    last.next := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    last.next := n;                                                                 
                    tmp3 = false;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              if (tmp3) {                                                                           
                yield;                                                                              
                boolean tmp4;                                                                       
                {                                                                                   
                  noop(TraceOff);                                                                   
                  boolean ctmp3519972;                                                              
                  ctmp3519972 = *;                                                                  
                  if (ctmp3519972) {                                                                
                    noop(TraceOn);                                                                  
                    tmp4 = false;                                                                   
                  } else {                                                                          
                    ctmp3519972 = *;                                                                
                    if (ctmp3519972) {                                                              
                      Tid tmpTid;                                                                   
                      Node tmpValue;                                                                
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, n);                                           
                      assume this.tail == last;                                                     
                      assume !goesWrong(_m);                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      this.tail_nextThread := tmpTid as B;                                          
                      this.tail_nextValue := tmpValue as B;                                         
                      noop(TraceOn);                                                                
                      this.tail := n;                                                               
                      tmp4 = true;                                                                  
                    } else {                                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      Node _currentValue;                                                           
                      _currentValue := this.tail  as B;                                             
                      this.tail := last as B;                                                       
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, n);                                           
                      this.tail := _currentValue as B;                                              
                      assume goesWrong(_m);                                                         
                      noop(TraceOn);                                                                
                      this.tail := n;                                                               
                      tmp4 = false;                                                                 
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                {                                                                                   
                   return;                                                                          
                }                                                                                   
              } else {                                                                              
                                                                                                    
              }                                                                                     
            } else {                                                                                
              boolean tmp5;                                                                         
              {                                                                                     
                noop(TraceOff);                                                                     
                boolean ctmp3519986;                                                                
                ctmp3519986 = *;                                                                    
                if (ctmp3519986) {                                                                  
                  noop(TraceOn);                                                                    
                  tmp5 = false;                                                                     
                } else {                                                                            
                  ctmp3519986 = *;                                                                  
                  if (ctmp3519986) {                                                                
                    Tid tmpTid;                                                                     
                    Node tmpValue;                                                                  
                    Mover _m;                                                                       
                    _m = writePermission(this.tail, next);                                          
                    assume this.tail == last;                                                       
                    assume !goesWrong(_m);                                                          
                    assume this.tail_nextThread == tid;                                             
                    assume this.tail_nextValue == last;                                             
                    this.tail_nextThread := tmpTid as B;                                            
                    this.tail_nextValue := tmpValue as B;                                           
                    noop(TraceOn);                                                                  
                    this.tail := next;                                                              
                    tmp5 = true;                                                                    
                  } else {                                                                          
                    assume this.tail_nextThread == tid;                                             
                    assume this.tail_nextValue == last;                                             
                    Node _currentValue;                                                             
                    _currentValue := this.tail  as B;                                               
                    this.tail := last as B;                                                         
                    Mover _m;                                                                       
                    _m = writePermission(this.tail, next);                                          
                    this.tail := _currentValue as B;                                                
                    assume goesWrong(_m);                                                           
                    noop(TraceOn);                                                                  
                    this.tail := next;                                                              
                    tmp5 = false;                                                                   
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public int dequeue() {                                                                        
        while (true)   {                                                                            
          boolean tmp6;                                                                             
          tmp6 = true;                                                                              
          if (!tmp6) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            Node first;                                                                             
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.head_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.head_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.head  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.head);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                first := this.head  as R;                                                           
              } else {                                                                              
                noop(TraceOn);                                                                      
                first := this.head;                                                                 
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            Node next;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := first.next_nextThread  as B;                                                  
              Node _C_v;                                                                            
              _C_v := first.next_nextValue  as B;                                                   
              Node _currentValue;                                                                   
              _currentValue := first.next  as B;                                                    
              Mover _R_t;                                                                           
              _R_t = readPermission(first.next);                                                    
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                next := first.next  as R;                                                           
              } else {                                                                              
                noop(TraceOn);                                                                      
                next := first.next;                                                                 
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
            Node last;                                                                              
            {                                                                                       
              noop(TraceOff);                                                                       
              Tid _C_t;                                                                             
              _C_t := this.tail_nextThread  as B;                                                   
              Node _C_v;                                                                            
              _C_v := this.tail_nextValue  as B;                                                    
              Node _currentValue;                                                                   
              _currentValue := this.tail  as B;                                                     
              Mover _R_t;                                                                           
              _R_t = readPermission(this.tail);                                                     
              boolean _casable;                                                                     
              _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                
              if (_casable) {                                                                       
                noop(TraceOn);                                                                      
                last := this.tail  as R;                                                            
              } else {                                                                              
                noop(TraceOn);                                                                      
                last := this.tail;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp7;                                                                           
            tmp7 = first == last;                                                                   
            if (tmp7 /* == first == last */) {                                                      
              boolean tmp8;                                                                         
              tmp8 = next == Node.null;                                                             
              if (tmp8 /* == next == Node.null */) {                                                
                int tmp9;                                                                           
                tmp9 = -1;                                                                          
                {                                                                                   
                   return tmp9;                                                                     
                }                                                                                   
              } else {                                                                              
                yield;                                                                              
                boolean tmp10;                                                                      
                {                                                                                   
                  noop(TraceOff);                                                                   
                  boolean ctmp3520094;                                                              
                  ctmp3520094 = *;                                                                  
                  if (ctmp3520094) {                                                                
                    noop(TraceOn);                                                                  
                    tmp10 = false;                                                                  
                  } else {                                                                          
                    ctmp3520094 = *;                                                                
                    if (ctmp3520094) {                                                              
                      Tid tmpTid;                                                                   
                      Node tmpValue;                                                                
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, next);                                        
                      assume this.tail == last;                                                     
                      assume !goesWrong(_m);                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      this.tail_nextThread := tmpTid as B;                                          
                      this.tail_nextValue := tmpValue as B;                                         
                      noop(TraceOn);                                                                
                      this.tail := next;                                                            
                      tmp10 = true;                                                                 
                    } else {                                                                        
                      assume this.tail_nextThread == tid;                                           
                      assume this.tail_nextValue == last;                                           
                      Node _currentValue;                                                           
                      _currentValue := this.tail  as B;                                             
                      this.tail := last as B;                                                       
                      Mover _m;                                                                     
                      _m = writePermission(this.tail, next);                                        
                      this.tail := _currentValue as B;                                              
                      assume goesWrong(_m);                                                         
                      noop(TraceOn);                                                                
                      this.tail := next;                                                            
                      tmp10 = false;                                                                
                    }                                                                               
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            } else {                                                                                
              boolean tmp11;                                                                        
              tmp11 = next != Node.null;                                                            
              if (tmp11 /* == next != Node.null */) {                                               
                int value;                                                                          
                value := next.value;                                                                
                yield;                                                                              
                boolean tmp12;                                                                      
                {                                                                                   
                  noop(TraceOff);                                                                   
                  boolean ctmp3520129;                                                              
                  ctmp3520129 = *;                                                                  
                  if (ctmp3520129) {                                                                
                    noop(TraceOn);                                                                  
                    tmp12 = false;                                                                  
                  } else {                                                                          
                    ctmp3520129 = *;                                                                
                    if (ctmp3520129) {                                                              
                      Tid tmpTid;                                                                   
                      Node tmpValue;                                                                
                      Mover _m;                                                                     
                      _m = writePermission(this.head, next);                                        
                      assume this.head == first;                                                    
                      assume !goesWrong(_m);                                                        
                      assume this.head_nextThread == tid;                                           
                      assume this.head_nextValue == first;                                          
                      this.head_nextThread := tmpTid as B;                                          
                      this.head_nextValue := tmpValue as B;                                         
                      noop(TraceOn);                                                                
                      this.head := next;                                                            
                      tmp12 = true;                                                                 
                    } else {                                                                        
                      assume this.head_nextThread == tid;                                           
                      assume this.head_nextValue == first;                                          
                      Node _currentValue;                                                           
                      _currentValue := this.head  as B;                                             
                      this.head := first as B;                                                      
                      Mover _m;                                                                     
                      _m = writePermission(this.head, next);                                        
                      this.head := _currentValue as B;                                              
                      assume goesWrong(_m);                                                         
                      noop(TraceOn);                                                                
                      this.head := next;                                                            
                      tmp12 = false;                                                                
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                if (tmp12) {                                                                        
                  {                                                                                 
                     return value;                                                                  
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
              } else {                                                                              
                                                                                                    
              }                                                                                     
            }                                                                                       
            yield;                                                                                  
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Node ***/                                                                           
                                                                                                    
type Node;                                                                                          
const unique Node.null: Node;                                                                       
var Node._state: [Node]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.value: [Node]int;                                                                          
                                                                                                    
function {:inline} ReadEval.Node.value(tid: Tid,this : Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.value(tid: Tid,this : Node,newValue: int,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.next: [Node]Node;                                                                          
                                                                                                    
function {:inline} ReadEval.Node.next(tid: Tid,this : Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node.next[this]!=Node.null)) then                                                           
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_N, 2)                                                                                
  else                                                                                              
   if ((((Node.next[this]==Node.null)&&(newValue!=Node.null))&&isLocal(Node._state[newValue], tid))) then
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.next(tid: Tid,this : Node,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node.next[this]!=Node.null)) then                                                           
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_N, 2)                                                                                
  else                                                                                              
   if ((((Node.next[this]==Node.null)&&(newValue!=Node.null))&&isLocal(Node._state[newValue], tid))) then
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node._lock: [Node]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Node._lock(tid: Tid,this : Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node._lock(tid: Tid,this : Node,newValue: Tid,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.next_nextThread: [Node]Tid;                                                                
                                                                                                    
function {:inline} ReadEval.Node.next_nextThread(tid: Tid,this : Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Node._state[this], tid)) then                                                          
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Node.next_nextThread[this]==tid)) then                                                       
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.next_nextThread(tid: Tid,this : Node,newValue: Tid,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Node.next_nextThread[this]==tid)) then                                                       
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.next_nextValue: [Node]Node;                                                                
                                                                                                    
function {:inline} ReadEval.Node.next_nextValue(tid: Tid,this : Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Node._state[this], tid)) then                                                          
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Node.next_nextThread[this]==tid)) then                                                       
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.next_nextValue(tid: Tid,this : Node,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Node.next_nextThread[this]==tid)) then                                                       
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Queue ***/                                                                          
                                                                                                    
type Queue;                                                                                         
const unique Queue.null: Queue;                                                                     
var Queue._state: [Queue]State;                                                                     
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.head: [Queue]Node;                                                                        
                                                                                                    
function {:inline} ReadEval.Queue.head(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.head(tid: Tid,this : Queue,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.tail: [Queue]Node;                                                                        
                                                                                                    
function {:inline} ReadEval.Queue.tail(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.tail(tid: Tid,this : Queue,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue._lock: [Queue]Tid;                                                                        
                                                                                                    
function {:inline} ReadEval.Queue._lock(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Queue._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Queue._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Queue._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue._lock(tid: Tid,this : Queue,newValue: Tid,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Queue._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Queue._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Queue._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.head_nextThread: [Queue]Tid;                                                              
                                                                                                    
function {:inline} ReadEval.Queue.head_nextThread(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Queue._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Queue.head_nextThread[this]==tid)) then                                                      
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.head_nextThread(tid: Tid,this : Queue,newValue: Tid,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Queue.head_nextThread[this]==tid)) then                                                      
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.head_nextValue: [Queue]Node;                                                              
                                                                                                    
function {:inline} ReadEval.Queue.head_nextValue(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Queue._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Queue.head_nextThread[this]==tid)) then                                                      
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.head_nextValue(tid: Tid,this : Queue,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Queue.head_nextThread[this]==tid)) then                                                      
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.tail_nextThread: [Queue]Tid;                                                              
                                                                                                    
function {:inline} ReadEval.Queue.tail_nextThread(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Queue._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Queue.tail_nextThread[this]==tid)) then                                                      
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.tail_nextThread(tid: Tid,this : Queue,newValue: Tid,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Queue.tail_nextThread[this]==tid)) then                                                      
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.tail_nextValue: [Queue]Node;                                                              
                                                                                                    
function {:inline} ReadEval.Queue.tail_nextValue(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Queue._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Queue.tail_nextThread[this]==tid)) then                                                      
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.tail_nextValue(tid: Tid,this : Queue,newValue: Node,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  if ((Queue.tail_nextThread[this]==tid)) then                                                      
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.Queue.3537828(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (bool) {
 (Queue.head[this]!=Node.null)                                                                      
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Queue.3537836(tid: Tid,this : Queue,Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (bool) {
 (Queue.tail[this]!=Node.null)                                                                      
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Queue.enqueue(tid:Tid, this : Queue, value : int)                                        
modifies Node._state;                                                                               
modifies Node.value;                                                                                
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Node.next_nextThread;                                                                      
modifies Node.next_nextValue;                                                                       
modifies Queue._state;                                                                              
modifies Queue.head;                                                                                
modifies Queue.tail;                                                                                
modifies Queue._lock;                                                                               
modifies Queue.head_nextThread;                                                                     
modifies Queue.head_nextValue;                                                                      
modifies Queue.tail_nextThread;                                                                     
modifies Queue.tail_nextValue;                                                                      
                                                                                                    
requires ValidTid(tid);                                                                                    // (31.5): Bad tid
requires isShared(Queue._state[this]);                                                                     // (31.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (31.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (31.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (31.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (31.5): Object invariant may not hold.
{                                                                                                   
 var Queue.tail3545595: [Queue]Node;                                                                
 var Queue.tail_nextThread3545280: [Queue]Tid;                                                      
 var last3545752: Node;                                                                             
 var value3545595: int;                                                                             
 var Queue.tail_nextValue3545774: [Queue]Node;                                                      
 var Node._lock3545506: [Node]Tid;                                                                  
 var n3545725: Node;                                                                                
 var this3545628: Queue;                                                                            
 var ctmp35199723545628: bool;                                                                      
 var Node.next_nextValue3545535_post: [Node]Node;                                                   
 var tid3545506: Tid;                                                                               
 var $recorded.state3545722: int;                                                                   
 var ctmp35199723545598: bool;                                                                      
 var Queue.head_nextThread3545413: [Queue]Tid;                                                      
 var Queue.tail3545647: [Queue]Node;                                                                
 var mover3545647: Mover;                                                                           
 var Queue.tail_nextValue3545786_post: [Queue]Node;                                                 
 var n3545333_post: Node;                                                                           
 var Queue.tail_nextThread3545333_post: [Queue]Tid;                                                 
 var value3545729: int;                                                                             
 var Queue.head_nextValue3545598: [Queue]Node;                                                      
 var _C_v3545355: Node;                                                                             
 var Node.value3545503: [Node]int;                                                                  
 var tid3545333: Tid;                                                                               
 var Queue.head_nextValue3545518: [Queue]Node;                                                      
 var Node.next_nextValue3545280: [Node]Node;                                                        
 var Queue.head_nextValue3545274: [Queue]Node;                                                      
 var moverPath3545286: MoverPath;                                                                   
 var tmp23545657: bool;                                                                             
 var Queue._state3545535: [Queue]State;                                                             
 var mover3545324: Mover;                                                                           
 var Queue.tail3545329: [Queue]Node;                                                                
 var Node._state3545503: [Node]State;                                                               
 var Node._lock3545398: [Node]Tid;                                                                  
 var path3545274: int;                                                                              
 var n3545722: Node;                                                                                
 var moverPath3545752: MoverPath;                                                                   
 var Queue.head_nextValue3545789_bottom: [Queue]Node;                                               
 var Queue.head3545506: [Queue]Node;                                                                
 var $recorded.state3545725: int;                                                                   
 var Node.next_nextThread3545227: [Node]Tid;                                                        
 var Node.value3545349: [Node]int;                                                                  
 var last3545324: Node;                                                                             
 var Queue.head3545333_post: [Queue]Node;                                                           
 var Node._lock3545238: [Node]Tid;                                                                  
 var Node._state3545640: [Node]State;                                                               
 var Queue._lock3545535: [Queue]Tid;                                                                
 var Node._state3545752: [Node]State;                                                               
 var Node.value3545595: [Node]int;                                                                  
 var tmp13545786_post: bool;                                                                        
 var $recorded.state3545343: int;                                                                   
 var ctmp35199863545755: bool;                                                                      
 var tmpValue3545473: Node;                                                                         
 var ctmp35199623545525: bool;                                                                      
 var tmp13545324: bool;                                                                             
 var Queue.tail_nextValue3545227: [Queue]Node;                                                      
 var Queue.tail3545602: [Queue]Node;                                                                
 var Node._state3545525: [Node]State;                                                               
 var Queue.head_nextValue3545525: [Queue]Node;                                                      
 var Queue.tail3545657: [Queue]Node;                                                                
 var Node.next3545393: [Node]Node;                                                                  
 var value3545725: int;                                                                             
 var Queue.head_nextThread3545525: [Queue]Tid;                                                      
 var moverPath3545755: MoverPath;                                                                   
 var Node._lock3545767: [Node]Tid;                                                                  
 var Node.next3545480: [Node]Node;                                                                  
 var tmp33545625: bool;                                                                             
 var value3545625: int;                                                                             
 var Queue.head3545789_bottom: [Queue]Node;                                                         
 var Queue.tail3545280: [Queue]Node;                                                                
 var n3545355: Node;                                                                                
 var Queue.head3545657: [Queue]Node;                                                                
 var Queue._lock3545602: [Queue]Tid;                                                                
 var n3545647: Node;                                                                                
 var next3545506: Node;                                                                             
 var Queue.tail_nextValue3545722: [Queue]Node;                                                      
 var tid3545398: Tid;                                                                               
 var $recorded.state3545525: int;                                                                   
 var Queue.tail_nextValue3545535: [Queue]Node;                                                      
 var mover3545774: Mover;                                                                           
 var Queue.head_nextThread3545752: [Queue]Tid;                                                      
 var Queue.tail_nextThread3545333: [Queue]Tid;                                                      
 var Queue.tail3545790: [Queue]Node;                                                                
 var Queue._state3545640: [Queue]State;                                                             
 var tmp23545535: bool;                                                                             
 var Node.value3545786_post: [Node]int;                                                             
 var next: Node;                                                                                    
 var Node.next3545535_post: [Node]Node;                                                             
 var Queue.head3545480: [Queue]Node;                                                                
 var moverPath3545725: MoverPath;                                                                   
 var mover3545628: Mover;                                                                           
 var Node.next_nextValue3545789_bottom: [Node]Node;                                                 
 var _currentValue3545640: Node;                                                                    
 var _C_t: Tid;                                                                                     
 var _C_t3545349: Tid;                                                                              
 var Queue.tail3545625: [Queue]Node;                                                                
 var path3545755: int;                                                                              
 var Queue.tail_nextThread3545398: [Queue]Tid;                                                      
 var tid3545640: Tid;                                                                               
 var $pc3545480: Phase;                                                                             
 var tmp13545333: bool;                                                                             
 var moverPath3545647: MoverPath;                                                                   
 var Queue.head3545473: [Queue]Node;                                                                
 var value3545238: int;                                                                             
 var Queue._state3545413_post: [Queue]State;                                                        
 var path3545722: int;                                                                              
 var tmp53545725: bool;                                                                             
 var Queue._state3545480: [Queue]State;                                                             
 var Node.next_nextValue3545647: [Node]Node;                                                        
 var mover3545518: Mover;                                                                           
 var Node._state3545413: [Node]State;                                                               
 var Node.value3545324: [Node]int;                                                                  
 var Node._lock3545355: [Node]Tid;                                                                  
 var $pc3545535: Phase;                                                                             
 var Node.value3545729: [Node]int;                                                                  
 var Queue.head_nextValue3545333_post: [Queue]Node;                                                 
 var $recorded.state3545657: int;                                                                   
 var tmp33545476: bool;                                                                             
 var Node._state3545755: [Node]State;                                                               
 var Queue.head_nextValue3545329: [Queue]Node;                                                      
 var _currentValue3545625: Node;                                                                    
 var Node.next_nextThread3545349: [Node]Tid;                                                        
 var Queue.tail_nextValue3545480: [Queue]Node;                                                      
 var Queue.head3545595: [Queue]Node;                                                                
 var tid3545725: Tid;                                                                               
 var Queue.head_nextValue3545789: [Queue]Node;                                                      
 var _m3545767: Mover;                                                                              
 var $pc3545657: Phase;                                                                             
 var Queue.tail_nextThread3545413_post: [Queue]Tid;                                                 
 var Node._lock3545640: [Node]Tid;                                                                  
 var tid3545647: Tid;                                                                               
 var tmpTid3545598: Tid;                                                                            
 var _currentValue3545393: Node;                                                                    
 var $pc3545595: Phase;                                                                             
 var moverPath3545525: MoverPath;                                                                   
 var Node.next_nextThread3545602: [Node]Tid;                                                        
 var Node.next_nextValue3545355: [Node]Node;                                                        
 var tid3545657: Tid;                                                                               
 var Node.value3545227: [Node]int;                                                                  
 var Queue.head3545752: [Queue]Node;                                                                
 var ctmp35199623545480: bool;                                                                      
 var Node.next_nextValue3545790: [Node]Node;                                                        
 var tmp13545602: bool;                                                                             
 var Node.value3545657: [Node]int;                                                                  
 var next3545786_post: Node;                                                                        
 var ctmp35199723545625: bool;                                                                      
 var path3545625: int;                                                                              
 var Queue.tail_nextThread3545789_bottom: [Queue]Tid;                                               
 var Node._state3545535: [Node]State;                                                               
 var this3545518: Queue;                                                                            
 var this3545329: Queue;                                                                            
 var _C_v3545329: Node;                                                                             
 var Queue.head_nextValue3545503: [Queue]Node;                                                      
 var $recorded.state3545595: int;                                                                   
 var Node.next3545238: [Node]Node;                                                                  
 var moverPath3545729: MoverPath;                                                                   
 var Node.next_nextThread3545786: [Node]Tid;                                                        
 var this3545398: Queue;                                                                            
 var Queue.head3545476: [Queue]Node;                                                                
 var Node.next_nextValue3545473: [Node]Node;                                                        
 var Queue.tail3545518: [Queue]Node;                                                                
 var last3545725: Node;                                                                             
 var _m3545476: Mover;                                                                              
 var tmp33545518: bool;                                                                             
 var Queue.tail3545722: [Queue]Node;                                                                
 var Node.next3545280: [Node]Node;                                                                  
 var value3545349: int;                                                                             
 var Queue.tail_nextValue3545657: [Queue]Node;                                                      
 var last3545480: Node;                                                                             
 var path3545774: int;                                                                              
 var Node.next_nextThread3545473: [Node]Tid;                                                        
 var Queue.tail_nextValue3545789_bottom: [Queue]Node;                                               
 var tid3545473: Tid;                                                                               
 var tmp23545503: bool;                                                                             
 var $pc3545473: Phase;                                                                             
 var Queue.tail3545343: [Queue]Node;                                                                
 var Queue.head3545274: [Queue]Node;                                                                
 var Node.next_nextThread3545722: [Node]Tid;                                                        
 var Queue._state3545789_bottom: [Queue]State;                                                      
 var $pc3545628: Phase;                                                                             
 var last3545595: Node;                                                                             
 var n3545398: Node;                                                                                
 var Queue.tail_nextValue3545506: [Queue]Node;                                                      
 var Queue.tail_nextValue3545274: [Queue]Node;                                                      
 var tid3545602: Tid;                                                                               
 var Queue.tail_nextThread3545274: [Queue]Tid;                                                      
 var mover3545227: Mover;                                                                           
 var Queue.head_nextValue3545602: [Queue]Node;                                                      
 var Queue.head_nextValue3545786: [Queue]Node;                                                      
 var Queue.tail_nextValue3545598: [Queue]Node;                                                      
 var path3545398: int;                                                                              
 var Queue.tail_nextThread3545238: [Queue]Tid;                                                      
 var Queue.head_nextValue3545349: [Queue]Node;                                                      
 var tmpValue: Node;                                                                                
 var Queue.tail_nextThread3545657: [Queue]Tid;                                                      
 var tmp5: bool;                                                                                    
 var this3545349: Queue;                                                                            
 var Queue.tail_nextValue3545238: [Queue]Node;                                                      
 var moverPath3545595: MoverPath;                                                                   
 var _casable: bool;                                                                                
 var Queue._state3545647: [Queue]State;                                                             
 var Node.next3545525: [Node]Node;                                                                  
 var ctmp35199723545602: bool;                                                                      
 var $pc3545286: Phase;                                                                             
 var _C_v3545280: Node;                                                                             
 var tid3545349: Tid;                                                                               
 var Queue._lock3545480: [Queue]Tid;                                                                
 var Queue._state3545413: [Queue]State;                                                             
 var tid3545755: Tid;                                                                               
 var last3545598: Node;                                                                             
 var Queue.tail_nextValue3545628: [Queue]Node;                                                      
 var _m3545774: Mover;                                                                              
 var moverPath3545343: MoverPath;                                                                   
 var Node.next_nextValue3545476: [Node]Node;                                                        
 var Node.next3545506: [Node]Node;                                                                  
 var Queue.head_nextThread3545398: [Queue]Tid;                                                      
 var Queue.head_nextValue3545535_post: [Queue]Node;                                                 
 var Queue.head_nextValue3545767: [Queue]Node;                                                      
 var Queue.tail_nextValue3545790: [Queue]Node;                                                      
 var Node.value3545473: [Node]int;                                                                  
 var _C_t3545398: Tid;                                                                              
 var Node.next_nextThread3545413: [Node]Tid;                                                        
 var tid3545525: Tid;                                                                               
 var Queue.tail_nextThread3545729: [Queue]Tid;                                                      
 var this3545355: Queue;                                                                            
 var Node.value3545598: [Node]int;                                                                  
 var tmp43545625: bool;                                                                             
 var Node.next3545598: [Node]Node;                                                                  
 var this3545227: Queue;                                                                            
 var this3545476: Queue;                                                                            
 var Node.next_nextThread3545480: [Node]Tid;                                                        
 var last3545657: Node;                                                                             
 var Queue.tail_nextThread3545476: [Queue]Tid;                                                      
 var Queue.tail3545789: [Queue]Node;                                                                
 var Queue.head3545725: [Queue]Node;                                                                
 var n3545413_post: Node;                                                                           
 var this3545786: Queue;                                                                            
 var tmp53545774: bool;                                                                             
 var $recorded.state3545349: int;                                                                   
 var Queue.head_nextThread3545355: [Queue]Tid;                                                      
 var n3545393: Node;                                                                                
 var Node._lock3545324: [Node]Tid;                                                                  
 var tid3545329: Tid;                                                                               
 var Queue._lock3545274: [Queue]Tid;                                                                
 var Queue.head_nextValue3545476: [Queue]Node;                                                      
 var Node.next_nextThread3545786_post: [Node]Tid;                                                   
 var Queue.head_nextThread3545595: [Queue]Tid;                                                      
 var value3545473: int;                                                                             
 var Queue.head_nextValue3545480: [Queue]Node;                                                      
 var Node.next3545729: [Node]Node;                                                                  
 var Node.next_nextValue3545729: [Node]Node;                                                        
 var Queue.head_nextValue3545625: [Queue]Node;                                                      
 var Node._state3545598: [Node]State;                                                               
 var $pc3545525: Phase;                                                                             
 var tmpTid3545473: Tid;                                                                            
 var Node._lock3545535_post: [Node]Tid;                                                             
 var Node._state3545349: [Node]State;                                                               
 var next3545525: Node;                                                                             
 var last3545535_post: Node;                                                                        
 var Node._lock3545755: [Node]Tid;                                                                  
 var $pc3545725: Phase;                                                                             
 var Node.next3545752: [Node]Node;                                                                  
 var Queue.head3545518: [Queue]Node;                                                                
 var Queue.head_nextThread3545657: [Queue]Tid;                                                      
 var moverPath3545476: MoverPath;                                                                   
 var $pc3545343: Phase;                                                                             
 var Node.next_nextValue3545628: [Node]Node;                                                        
 var tmp13545480: bool;                                                                             
 var n: Node;                                                                                       
 var Queue.head3545398: [Queue]Node;                                                                
 var Node.next3545789_bottom: [Node]Node;                                                           
 var _R_t3545393: Mover;                                                                            
 var Queue.tail_nextThread3545343: [Queue]Tid;                                                      
 var last3545333: Node;                                                                             
 var next3545774: Node;                                                                             
 var Node._lock3545333_post: [Node]Tid;                                                             
 var Queue.tail3545506: [Queue]Node;                                                                
 var last3545393: Node;                                                                             
 var $recorded.state3545598: int;                                                                   
 var value3545525: int;                                                                             
 var n3545413: Node;                                                                                
 var this3545238: Queue;                                                                            
 var n3545333: Node;                                                                                
 var path3545480: int;                                                                              
 var tmpTid3545602: Tid;                                                                            
 var next3545535: Node;                                                                             
 var $recorded.state3545535: int;                                                                   
 var Node.next_nextValue3545333: [Node]Node;                                                        
 var Queue.head_nextThread3545393: [Queue]Tid;                                                      
 var mover3545343: Mover;                                                                           
 var value3545227: int;                                                                             
 var this$2303545238: Node;                                                                         
 var last3545476: Node;                                                                             
 var Node.next3545503: [Node]Node;                                                                  
 var n3545767: Node;                                                                                
 var _currentValue3545767: Node;                                                                    
 var Queue.tail_nextValue3545640: [Queue]Node;                                                      
 var tmp1: bool;                                                                                    
 var Queue.tail_nextValue3545755: [Queue]Node;                                                      
 var mover3545398: Mover;                                                                           
 var _currentValue3545525: Node;                                                                    
 var Queue._state3545786: [Queue]State;                                                             
 var ctmp35199723545647: bool;                                                                      
 var next3545503: Node;                                                                             
 var Node.next_nextValue3545286: [Node]Node;                                                        
 var Node._state3545535_post: [Node]State;                                                          
 var tmp23545602: bool;                                                                             
 var Node.next_nextValue3545480: [Node]Node;                                                        
 var _C_t3545280: Tid;                                                                              
 var path3545286: int;                                                                              
 var Queue.tail_nextThread3545725: [Queue]Tid;                                                      
 var ctmp3519986: bool;                                                                             
 var Node._lock3545329: [Node]Tid;                                                                  
 var mover3545625: Mover;                                                                           
 var Node.next_nextThread3545393: [Node]Tid;                                                        
 var moverPath3545602: MoverPath;                                                                   
 var Queue._state3545790: [Queue]State;                                                             
 var Queue.head3545755: [Queue]Node;                                                                
 var tid3545333_post: Tid;                                                                          
 var path3545518: int;                                                                              
 var mover3545393: Mover;                                                                           
 var moverPath3545280: MoverPath;                                                                   
 var ctmp3519962: bool;                                                                             
 var $recorded.state3545413: int;                                                                   
 var mover3545473: Mover;                                                                           
 var Queue.tail3545286: [Queue]Node;                                                                
 var Queue._lock3545786_post: [Queue]Tid;                                                           
 var Queue._lock3545329: [Queue]Tid;                                                                
 var Queue._lock3545789_bottom: [Queue]Tid;                                                         
 var Queue.head_nextThread3545786_post: [Queue]Tid;                                                 
 var next3545535_post: Node;                                                                        
 var tmp53545729: bool;                                                                             
 var Queue.head3545535_post: [Queue]Node;                                                           
 var $pc3545729: Phase;                                                                             
 var Node.next_nextValue3545238: [Node]Node;                                                        
 var _casable3545329: bool;                                                                         
 var tid3545722: Tid;                                                                               
 var tmpValue3545602: Node;                                                                         
 var n3545506: Node;                                                                                
 var Queue._lock3545476: [Queue]Tid;                                                                
 var Queue._state3545506: [Queue]State;                                                             
 var moverPath3545473: MoverPath;                                                                   
 var next3545413_post: Node;                                                                        
 var Node._lock3545473: [Node]Tid;                                                                  
 var moverPath3545518: MoverPath;                                                                   
 var tmp23545722: bool;                                                                             
 var Queue.head3545227: [Queue]Node;                                                                
 var Queue.head_nextThread3545473: [Queue]Tid;                                                      
 var Queue.head_nextThread3545647: [Queue]Tid;                                                      
 var Queue._lock3545722: [Queue]Tid;                                                                
 var Node.next_nextThread3545789_bottom: [Node]Tid;                                                 
 var Node.next3545274: [Node]Node;                                                                  
 var this3545598: Queue;                                                                            
 var Queue.tail3545324: [Queue]Node;                                                                
 var Node.value3545647: [Node]int;                                                                  
 var this$230: Node;                                                                                
 var Queue.tail_nextThread3545227: [Queue]Tid;                                                      
 var Queue._lock3545625: [Queue]Tid;                                                                
 var Queue.head3545324: [Queue]Node;                                                                
 var this3545280: Queue;                                                                            
 var ctmp35199863545729: bool;                                                                      
 var $recorded.state3545789: int;                                                                   
 var _casable3545393: bool;                                                                         
 var Queue.head_nextValue3545324: [Queue]Node;                                                      
 var Node.next_nextThread3545343: [Node]Tid;                                                        
 var tid3545752: Tid;                                                                               
 var Queue.tail_nextValue3545476: [Queue]Node;                                                      
 var Queue._state3545355: [Queue]State;                                                             
 var _currentValue3545647: Node;                                                                    
 var tmp2: bool;                                                                                    
 var this3545343: Queue;                                                                            
 var tmp13545628: bool;                                                                             
 var Queue.tail_nextThread3545602: [Queue]Tid;                                                      
 var Node.next_nextValue3545774: [Node]Node;                                                        
 var Queue.tail3545789_bottom: [Queue]Node;                                                         
 var Queue.head_nextThread3545324: [Queue]Tid;                                                      
 var Queue._lock3545628: [Queue]Tid;                                                                
 var _R_t3545398: Mover;                                                                            
 var Node.value3545786: [Node]int;                                                                  
 var Node._state3545789: [Node]State;                                                               
 var Queue._lock3545755: [Queue]Tid;                                                                
 var Node.value3545274: [Node]int;                                                                  
 var Queue.tail3545274: [Queue]Node;                                                                
 var value3545774: int;                                                                             
 var this3545413_post: Queue;                                                                       
 var Node.next_nextValue3545506: [Node]Node;                                                        
 var mover3545506: Mover;                                                                           
 var moverPath3545767: MoverPath;                                                                   
 var last3545722: Node;                                                                             
 var Node._state3545506: [Node]State;                                                               
 var _casable3545398: bool;                                                                         
 var this3545722: Queue;                                                                            
 var Node.next3545333_post: [Node]Node;                                                             
 var Node.next3545774: [Node]Node;                                                                  
 var tmp43545595: bool;                                                                             
 var value3545755: int;                                                                             
 var Queue.tail_nextThread3545324: [Queue]Tid;                                                      
 var path3545598: int;                                                                              
 var moverPath3545349: MoverPath;                                                                   
 var Queue.head3545349: [Queue]Node;                                                                
 var value3545786_post: int;                                                                        
 var Node.next3545789: [Node]Node;                                                                  
 var tmp13545398: bool;                                                                             
 var Queue.tail_nextThread3545722: [Queue]Tid;                                                      
 var value3545480: int;                                                                             
 var Queue.head3545329: [Queue]Node;                                                                
 var Node.value3545602: [Node]int;                                                                  
 var Queue._lock3545355: [Queue]Tid;                                                                
 var moverPath3545480: MoverPath;                                                                   
 var ctmp35199623545518: bool;                                                                      
 var tmp23545535_post: bool;                                                                        
 var path3545329: int;                                                                              
 var Node.next_nextValue3545725: [Node]Node;                                                        
 var Queue.tail3545598: [Queue]Node;                                                                
 var last3545525: Node;                                                                             
 var value3545535_post: int;                                                                        
 var Queue.head3545413: [Queue]Node;                                                                
 var path3545506: int;                                                                              
 var ctmp35199863545767: bool;                                                                      
 var tid3545790: Tid;                                                                               
 var moverPath3545393: MoverPath;                                                                   
 var value3545280: int;                                                                             
 var Queue.head_nextValue3545393: [Queue]Node;                                                      
 var mover3545755: Mover;                                                                           
 var Queue.head3545280: [Queue]Node;                                                                
 var next3545398: Node;                                                                             
 var Node.value3545625: [Node]int;                                                                  
 var path3545525: int;                                                                              
 var value$230: int;                                                                                
 var _currentValue3545752: Node;                                                                    
 var next3545625: Node;                                                                             
 var Queue.head_nextThread3545535_post: [Queue]Tid;                                                 
 var mover3545729: Mover;                                                                           
 var Node.next_nextValue3545598: [Node]Node;                                                        
 var tmp43545602: bool;                                                                             
 var Queue.tail3545503: [Queue]Node;                                                                
 var tmp13545722: bool;                                                                             
 var Node._lock3545752: [Node]Tid;                                                                  
 var Queue._state3545722: [Queue]State;                                                             
 var n3545518: Node;                                                                                
 var Queue.head_nextThread3545480: [Queue]Tid;                                                      
 var $pc3545506: Phase;                                                                             
 var Node.next_nextThread3545725: [Node]Tid;                                                        
 var tmp13545286: bool;                                                                             
 var Node._state3545647: [Node]State;                                                               
 var Node.next_nextThread3545525: [Node]Tid;                                                        
 var Node.next3545628: [Node]Node;                                                                  
 var mover3545752: Mover;                                                                           
 var $pc3545333: Phase;                                                                             
 var ctmp35199623545476: bool;                                                                      
 var $recorded.state3545535_post: int;                                                              
 var tmp13545355: bool;                                                                             
 var $recorded.state3545640: int;                                                                   
 var Node._state3545480: [Node]State;                                                               
 var _m3545722: Mover;                                                                              
 var Node._state3545725: [Node]State;                                                               
 var n3545602: Node;                                                                                
 var Node.value3545238: [Node]int;                                                                  
 var next3545786: Node;                                                                             
 var tid3545628: Tid;                                                                               
 var n3545786: Node;                                                                                
 var Queue.head3545238: [Queue]Node;                                                                
 var path3545752: int;                                                                              
 var _m3545480: Mover;                                                                              
 var $pc3545755: Phase;                                                                             
 var n3545774: Node;                                                                                
 var last3545786: Node;                                                                             
 var Queue.tail3545774: [Queue]Node;                                                                
 var $pc3545535_post: Phase;                                                                        
 var phase3545789: Phase;                                                                           
 var n3545476: Node;                                                                                
 var Queue.head3545525: [Queue]Node;                                                                
 var tid3545786: Tid;                                                                               
 var Queue.tail_nextThread3545286: [Queue]Tid;                                                      
 var last3545398: Node;                                                                             
 var tmp13545274: bool;                                                                             
 var n3545329: Node;                                                                                
 var last3545473: Node;                                                                             
 var Queue.head_nextThread3545625: [Queue]Tid;                                                      
 var Queue.head_nextValue3545647: [Queue]Node;                                                      
 var _C_v3545349: Node;                                                                             
 var next$2303545238: Node;                                                                         
 var Queue.head_nextThread3545274: [Queue]Tid;                                                      
 var Node._state3545628: [Node]State;                                                               
 var _currentValue3545503: Node;                                                                    
 var Queue.head3545767: [Queue]Node;                                                                
 var next3545393: Node;                                                                             
 var value3545767: int;                                                                             
 var Queue.head_nextThread3545598: [Queue]Tid;                                                      
 var tmp13545755: bool;                                                                             
 var tmp23545729: bool;                                                                             
 var Node.next_nextThread3545595: [Node]Tid;                                                        
 var next3545473: Node;                                                                             
 var Node._state3545343: [Node]State;                                                               
 var Node.next_nextValue3545329: [Node]Node;                                                        
 var this3545535_post: Queue;                                                                       
 var Queue.head_nextValue3545722: [Queue]Node;                                                      
 var Queue._lock3545393: [Queue]Tid;                                                                
 var _C_v3545398: Node;                                                                             
 var path3545393: int;                                                                              
 var this3545393: Queue;                                                                            
 var last3545786_post: Node;                                                                        
 var Queue.tail_nextValue3545333_post: [Queue]Node;                                                 
 var Queue.head_nextValue3545355: [Queue]Node;                                                      
 var $recorded.state3545355: int;                                                                   
 var tmp53545722: bool;                                                                             
 var Queue.tail_nextValue3545767: [Queue]Node;                                                      
 var last3545280: Node;                                                                             
 var _C_t3545324: Tid;                                                                              
 var Node.value3545752: [Node]int;                                                                  
 var Queue.tail_nextValue3545280: [Queue]Node;                                                      
 var Node.next3545333: [Node]Node;                                                                  
 var Queue.head3545625: [Queue]Node;                                                                
 var tmp23545506: bool;                                                                             
 var ctmp35199723545640: bool;                                                                      
 var Queue.tail_nextValue3545413_post: [Queue]Node;                                                 
 var Queue.tail_nextThread3545480: [Queue]Tid;                                                      
 var Node._lock3545343: [Node]Tid;                                                                  
 var _currentValue3545324: Node;                                                                    
 var last3545503: Node;                                                                             
 var _C_v: Node;                                                                                    
 var tid3545355: Tid;                                                                               
 var _m3545640: Mover;                                                                              
 var Node.value3545628: [Node]int;                                                                  
 var Node._lock3545722: [Node]Tid;                                                                  
 var path3545349: int;                                                                              
 var Queue.head_nextValue3545640: [Queue]Node;                                                      
 var tid3545518: Tid;                                                                               
 var value3545647: int;                                                                             
 var n3545480: Node;                                                                                
 var Queue.head_nextValue3545774: [Queue]Node;                                                      
 var Queue.head3545628: [Queue]Node;                                                                
 var value3545640: int;                                                                             
 var $recorded.state3545274: int;                                                                   
 var tid3545343: Tid;                                                                               
 var Node.next3545640: [Node]Node;                                                                  
 var Queue.head_nextThread3545535: [Queue]Tid;                                                      
 var tmp13545393: bool;                                                                             
 var _C_v3545286: Node;                                                                             
 var Node._lock3545274: [Node]Tid;                                                                  
 var value3545535: int;                                                                             
 var last3545647: Node;                                                                             
 var Node.value3545398: [Node]int;                                                                  
 var $recorded.state3545324: int;                                                                   
 var tid3545789: Tid;                                                                               
 var Node._lock3545598: [Node]Tid;                                                                  
 var Queue._lock3545398: [Queue]Tid;                                                                
 var Queue.head_nextThread3545628: [Queue]Tid;                                                      
 var Queue._lock3545413: [Queue]Tid;                                                                
 var Node._lock3545625: [Node]Tid;                                                                  
 var ctmp35199623545506: bool;                                                                      
 var Node.next3545755: [Node]Node;                                                                  
 var value3545333_post: int;                                                                        
 var Node.value3545393: [Node]int;                                                                  
 var $pc3545602: Phase;                                                                             
 var Queue.head_nextValue3545535: [Queue]Node;                                                      
 var tmp33545628: bool;                                                                             
 var tmp13545413_post: bool;                                                                        
 var tmp23545518: bool;                                                                             
 var value3545752: int;                                                                             
 var moverPath3545329: MoverPath;                                                                   
 var mover3545286: Mover;                                                                           
 var last3545286: Node;                                                                             
 var Queue._lock3545413_post: [Queue]Tid;                                                           
 var $recorded.state3545602: int;                                                                   
 var tid3545286: Tid;                                                                               
 var next3545355: Node;                                                                             
 var Node.value3545506: [Node]int;                                                                  
 var Queue.tail_nextThread3545535: [Queue]Tid;                                                      
 var path3545767: int;                                                                              
 var tid3545227: Tid;                                                                               
 var tmp43545657: bool;                                                                             
 var Node._state3545602: [Node]State;                                                               
 var tmp13545349: bool;                                                                             
 var _currentValue3545755: Node;                                                                    
 var Queue.tail_nextThread3545774: [Queue]Tid;                                                      
 var Node._lock3545725: [Node]Tid;                                                                  
 var this3545790: Queue;                                                                            
 var Node.next_nextValue3545595: [Node]Node;                                                        
 var tmp13545729: bool;                                                                             
 var next3545755: Node;                                                                             
 var path3545595: int;                                                                              
 var $recorded.state3545329: int;                                                                   
 var Node._lock3545413_post: [Node]Tid;                                                             
 var next3545518: Node;                                                                             
 var path3545640: int;                                                                              
 var tmpValue3545480: Node;                                                                         
 var Node._state3545393: [Node]State;                                                               
 var tmp13545786: bool;                                                                             
 var Node.next3545595: [Node]Node;                                                                  
 var $pc3545598: Phase;                                                                             
 var Node.next_nextThread3545286: [Node]Tid;                                                        
 var Queue.tail_nextThread3545640: [Queue]Tid;                                                      
 var tid3545413: Tid;                                                                               
 var Queue.head_nextValue3545238: [Queue]Node;                                                      
 var value3545274: int;                                                                             
 var tid3545767: Tid;                                                                               
 var Node.value3545767: [Node]int;                                                                  
 var $pc3545786: Phase;                                                                             
 var Queue.tail3545355: [Queue]Node;                                                                
 var Queue.head_nextValue3545343: [Queue]Node;                                                      
 var _C_t3545329: Tid;                                                                              
 var Queue.tail3545413: [Queue]Node;                                                                
 var last3545343: Node;                                                                             
 var tmp23545725: bool;                                                                             
 var Queue.head_nextValue3545473: [Queue]Node;                                                      
 var n3545657: Node;                                                                                
 var Queue._state3545625: [Queue]State;                                                             
 var Queue.tail3545535_post: [Queue]Node;                                                           
 var Node.next_nextThread3545329: [Node]Tid;                                                        
 var _currentValue3545518: Node;                                                                    
 var last3545729: Node;                                                                             
 var Queue._state3545774: [Queue]State;                                                             
 var Queue._state3545238: [Queue]State;                                                             
 var tid3545535: Tid;                                                                               
 var n3545789: Node;                                                                                
 var Node.value3545640: [Node]int;                                                                  
 var Queue.tail_nextThread3545625: [Queue]Tid;                                                      
 var Node.next_nextThread3545280: [Node]Tid;                                                        
 var last3545625: Node;                                                                             
 var Queue.tail3545393: [Queue]Node;                                                                
 var last3545506: Node;                                                                             
 var _C_t3545393: Tid;                                                                              
 var Queue.tail3545398: [Queue]Node;                                                                
 var Queue._lock3545640: [Queue]Tid;                                                                
 var Node.next_nextValue3545752: [Node]Node;                                                        
 var value3545503: int;                                                                             
 var Queue.tail_nextThread3545595: [Queue]Tid;                                                      
 var Queue.tail3545729: [Queue]Node;                                                                
 var Node.value3545535: [Node]int;                                                                  
 var Queue.head3545786: [Queue]Node;                                                                
 var Queue._state3545476: [Queue]State;                                                             
 var tmp23545476: bool;                                                                             
 var Queue.head_nextValue3545729: [Queue]Node;                                                      
 var Node.next_nextValue3545343: [Node]Node;                                                        
 var Node._lock3545786_post: [Node]Tid;                                                             
 var ctmp35199863545722: bool;                                                                      
 var Queue.tail3545752: [Queue]Node;                                                                
 var $recorded.state3545227: int;                                                                   
 var Node.value3545535_post: [Node]int;                                                             
 var Node._state3545786: [Node]State;                                                               
 var Node.next_nextThread3545506: [Node]Tid;                                                        
 var Queue._lock3545647: [Queue]Tid;                                                                
 var Node._lock3545503: [Node]Tid;                                                                  
 var last3545640: Node;                                                                             
 var _m3545595: Mover;                                                                              
 var tmp13545657: bool;                                                                             
 var mover3545349: Mover;                                                                           
 var this3545602: Queue;                                                                            
 var Node.next_nextThread3545657: [Node]Tid;                                                        
 var Queue.head3545503: [Queue]Node;                                                                
 var Queue.head_nextValue3545752: [Queue]Node;                                                      
 var Queue.head_nextThread3545333: [Queue]Tid;                                                      
 var Queue._state3545343: [Queue]State;                                                             
 var Node._state3545625: [Node]State;                                                               
 var Queue.head_nextThread3545518: [Queue]Tid;                                                      
 var Queue._state3545525: [Queue]State;                                                             
 var ctmp35199623545473: bool;                                                                      
 var $recorded.state3545238: int;                                                                   
 var Queue.tail_nextThread3545525: [Queue]Tid;                                                      
 var Node.next_nextValue3545349: [Node]Node;                                                        
 var last: Node;                                                                                    
 var mover3545280: Mover;                                                                           
 var Queue.tail_nextThread3545506: [Queue]Tid;                                                      
 var $recorded.state3545789_bottom: int;                                                            
 var this3545755: Queue;                                                                            
 var Queue._state3545349: [Queue]State;                                                             
 var value3545789_bottom: int;                                                                      
 var Queue._state3545333: [Queue]State;                                                             
 var ctmp35199623545503: bool;                                                                      
 var tid3545595: Tid;                                                                               
 var tmp23545595: bool;                                                                             
 var Node.next3545647: [Node]Node;                                                                  
 var next3545767: Node;                                                                             
 var Node.next_nextValue3545413: [Node]Node;                                                        
 var Node.value3545413_post: [Node]int;                                                             
 var tmpValue3545476: Node;                                                                         
 var Node.value3545355: [Node]int;                                                                  
 var Queue.head_nextThread3545329: [Queue]Tid;                                                      
 var Node.next3545535: [Node]Node;                                                                  
 var Node._state3545413_post: [Node]State;                                                          
 var Queue.tail_nextValue3545503: [Queue]Node;                                                      
 var Queue.tail_nextValue3545535_post: [Queue]Node;                                                 
 var Queue.head_nextValue3545657: [Queue]Node;                                                      
 var Node.next_nextThread3545774: [Node]Tid;                                                        
 var Node._lock3545333: [Node]Tid;                                                                  
 var Queue.head_nextThread3545286: [Queue]Tid;                                                      
 var this3545625: Queue;                                                                            
 var n3545535: Node;                                                                                
 var Node._state3545789_bottom: [Node]State;                                                        
 var tmp13545473: bool;                                                                             
 var n3545286: Node;                                                                                
 var Node.next_nextThread3545518: [Node]Tid;                                                        
 var Queue.head_nextThread3545786: [Queue]Tid;                                                      
 var tmpValue3545725: Node;                                                                         
 var this3545752: Queue;                                                                            
 var $recorded.state3545280: int;                                                                   
 var Node._lock3545647: [Node]Tid;                                                                  
 var mover3545525: Mover;                                                                           
 var Queue.tail3545525: [Queue]Node;                                                                
 var Queue.tail3545480: [Queue]Node;                                                                
 var Queue.tail_nextThread3545355: [Queue]Tid;                                                      
 var $pc3545280: Phase;                                                                             
 var mover3545274: Mover;                                                                           
 var moverPath3545238: MoverPath;                                                                   
 var Node._state3545324: [Node]State;                                                               
 var Node._lock3545786: [Node]Tid;                                                                  
 var $pc3545355: Phase;                                                                             
 var Queue._state3545628: [Queue]State;                                                             
 var tmpTid3545595: Tid;                                                                            
 var next3545657: Node;                                                                             
 var next3545729: Node;                                                                             
 var Queue._lock3545506: [Queue]Tid;                                                                
 var mover3545725: Mover;                                                                           
 var Queue._state3545518: [Queue]State;                                                             
 var Node.value3545413: [Node]int;                                                                  
 var Queue._state3545729: [Queue]State;                                                             
 var $pc3545625: Phase;                                                                             
 var Queue.tail3545333: [Queue]Node;                                                                
 var this3545503: Queue;                                                                            
 var tmp33545647: bool;                                                                             
 var Node._lock3545349: [Node]Tid;                                                                  
 var Queue._lock3545790: [Queue]Tid;                                                                
 var next3545752: Node;                                                                             
 var n3545628: Node;                                                                                
 var Node._state3545333: [Node]State;                                                               
 var tmp23545752: bool;                                                                             
 var tid3545535_post: Tid;                                                                          
 var path3545227: int;                                                                              
 var this3545480: Queue;                                                                            
 var value3545333: int;                                                                             
 var tmp13545343: bool;                                                                             
 var this$2303545227: Node;                                                                         
 var n3545238: Node;                                                                                
 var Queue.head_nextThread3545774: [Queue]Tid;                                                      
 var moverPath3545640: MoverPath;                                                                   
 var tmp13545506: bool;                                                                             
 var Node.value3545725: [Node]int;                                                                  
 var mover3545598: Mover;                                                                           
 var Queue.tail3545640: [Queue]Node;                                                                
 var last3545767: Node;                                                                             
 var Node.next_nextThread3545535: [Node]Tid;                                                        
 var n3545280: Node;                                                                                
 var Queue._state3545786_post: [Queue]State;                                                        
 var _C_v3545324: Node;                                                                             
 var path3545238: int;                                                                              
 var tmp33545640: bool;                                                                             
 var Queue._state3545755: [Queue]State;                                                             
 var Node._state3545476: [Node]State;                                                               
 var Queue.head_nextValue3545280: [Queue]Node;                                                      
 var tmp23545767: bool;                                                                             
 var _C_t3545274: Tid;                                                                              
 var $pc3545274: Phase;                                                                             
 var $pc3545722: Phase;                                                                             
 var Node.next_nextThread3545790: [Node]Tid;                                                        
 var Queue.tail_nextValue3545789: [Queue]Node;                                                      
 var tmp23545786_post: bool;                                                                        
 var Node.next_nextThread3545413_post: [Node]Tid;                                                   
 var Queue.head_nextValue3545786_post: [Queue]Node;                                                 
 var Node.next3545476: [Node]Node;                                                                  
 var Node.next_nextValue3545333_post: [Node]Node;                                                   
 var tmp23545647: bool;                                                                             
 var tmp23545755: bool;                                                                             
 var $recorded.state3545333: int;                                                                   
 var Queue.tail_nextThread3545789: [Queue]Tid;                                                      
 var tmpValue3545595: Node;                                                                         
 var Node.next_nextThread3545755: [Node]Tid;                                                        
 var Node.next_nextThread3545503: [Node]Tid;                                                        
 var $pc3545333_post: Phase;                                                                        
 var next3545476: Node;                                                                             
 var value3545598: int;                                                                             
 var Queue.head_nextThread3545722: [Queue]Tid;                                                      
 var Node.next_nextValue3545767: [Node]Node;                                                        
 var n3545349: Node;                                                                                
 var _currentValue: Node;                                                                           
 var Queue.head_nextThread3545506: [Queue]Tid;                                                      
 var this3545647: Queue;                                                                            
 var Queue._lock3545518: [Queue]Tid;                                                                
 var mover3545238: Mover;                                                                           
 var Queue.tail_nextValue3545473: [Queue]Node;                                                      
 var Queue.head_nextValue3545755: [Queue]Node;                                                      
 var path3545324: int;                                                                              
 var _currentValue3545398: Node;                                                                    
 var Node._state3545722: [Node]State;                                                               
 var _casable3545324: bool;                                                                         
 var Node.next3545625: [Node]Node;                                                                  
 var Node.value3545790: [Node]int;                                                                  
 var Queue.head_nextThread3545755: [Queue]Tid;                                                      
 var tmp33545535_post: bool;                                                                        
 var tmp23545413_post: bool;                                                                        
 var this3545333: Queue;                                                                            
 var Queue.head_nextThread3545503: [Queue]Tid;                                                      
 var path3545602: int;                                                                              
 var Queue.head3545413_post: [Queue]Node;                                                           
 var Node._state3545786_post: [Node]State;                                                          
 var Node.value3545333: [Node]int;                                                                  
 var Queue.head_nextThread3545729: [Queue]Tid;                                                      
 var Node._state3545227: [Node]State;                                                               
 var tmp33545525: bool;                                                                             
 var moverPath3545506: MoverPath;                                                                   
 var tmp23545413: bool;                                                                             
 var path3545355: int;                                                                              
 var _R_t: Mover;                                                                                   
 var mover3545767: Mover;                                                                           
 var this3545789: Queue;                                                                            
 var $recorded.state3545413_post: int;                                                              
 var Node._state3545333_post: [Node]State;                                                          
 var Queue._lock3545349: [Queue]Tid;                                                                
 var Queue._state3545725: [Queue]State;                                                             
 var next3545413: Node;                                                                             
 var tmpValue3545722: Node;                                                                         
 var Node.next_nextValue3545503: [Node]Node;                                                        
 var tmp13545595: bool;                                                                             
 var Node._lock3545227: [Node]Tid;                                                                  
 var Queue.head_nextThread3545476: [Queue]Tid;                                                      
 var Queue.head_nextThread3545640: [Queue]Tid;                                                      
 var $recorded.state3545786_post: int;                                                              
 var Node.next3545324: [Node]Node;                                                                  
 var last3545413_post: Node;                                                                        
 var _currentValue3545506: Node;                                                                    
 var Queue._state3545789: [Queue]State;                                                             
 var Node._lock3545480: [Node]Tid;                                                                  
 var this3545413: Queue;                                                                            
 var $recorded.state3545625: int;                                                                   
 var path3545729: int;                                                                              
 var Node.next3545343: [Node]Node;                                                                  
 var Node.next_nextThread3545274: [Node]Tid;                                                        
 var $pc3545518: Phase;                                                                             
 var n3545324: Node;                                                                                
 var Queue.tail_nextThread3545786_post: [Queue]Tid;                                                 
 var tmp23545473: bool;                                                                             
 var _m: Mover;                                                                                     
 var path3545476: int;                                                                              
 var tmp23545628: bool;                                                                             
 var $pc3545398: Phase;                                                                             
 var _R_t3545324: Mover;                                                                            
 var next3545640: Node;                                                                             
 var path3545343: int;                                                                              
 var tmp53545752: bool;                                                                             
 var _currentValue3545329: Node;                                                                    
 var this3545786_post: Queue;                                                                       
 var Queue.head_nextValue3545595: [Queue]Node;                                                      
 var mover3545602: Mover;                                                                           
 var Node.value3545722: [Node]int;                                                                  
 var Node._lock3545595: [Node]Tid;                                                                  
 var tid3545789_bottom: Tid;                                                                        
 var next3545628: Node;                                                                             
 var last3545329: Node;                                                                             
 var value3545657: int;                                                                             
 var this3545789_bottom: Queue;                                                                     
 var $pc3545349: Phase;                                                                             
 var _R_t3545329: Mover;                                                                            
 var Queue.head_nextThread3545789_bottom: [Queue]Tid;                                               
 var Node._lock3545657: [Node]Tid;                                                                  
 var n3545343: Node;                                                                                
 var Queue.head_nextThread3545333_post: [Queue]Tid;                                                 
 var last3545518: Node;                                                                             
 var tmp33545602: bool;                                                                             
 var Node.value3545329: [Node]int;                                                                  
 var tmp23545640: bool;                                                                             
 var Queue.head_nextThread3545413_post: [Queue]Tid;                                                 
 var Queue.tail_nextValue3545355: [Queue]Node;                                                      
 var $pc3545329: Phase;                                                                             
 var Queue.head3545286: [Queue]Node;                                                                
 var value3545286: int;                                                                             
 var n3545227: Node;                                                                                
 var tmp13545725: bool;                                                                             
 var Queue.head3545333: [Queue]Node;                                                                
 var tmp43545647: bool;                                                                             
 var Queue.tail3545473: [Queue]Node;                                                                
 var Queue.tail_nextThread3545767: [Queue]Tid;                                                      
 var _m3545473: Mover;                                                                              
 var _m3545598: Mover;                                                                              
 var Queue.head3545343: [Queue]Node;                                                                
 var $pc3545238: Phase;                                                                             
 var Node.next_nextValue3545786: [Node]Node;                                                        
 var Node._state3545473: [Node]State;                                                               
 var value$2303545238: int;                                                                         
 var Queue.tail_nextThread3545503: [Queue]Tid;                                                      
 var Node.next3545473: [Node]Node;                                                                  
 var Queue._lock3545729: [Queue]Tid;                                                                
 var Node._state3545286: [Node]State;                                                               
 var value3545324: int;                                                                             
 var Node._state3545238: [Node]State;                                                               
 var Queue.head3545790: [Queue]Node;                                                                
 var ctmp35199863545774: bool;                                                                      
 var Node._lock3545790: [Node]Tid;                                                                  
 var tmpValue3545598: Node;                                                                         
 var this3545333_post: Queue;                                                                       
 var Node.next_nextValue3545393: [Node]Node;                                                        
 var Node.next3545767: [Node]Node;                                                                  
 var $pc3545767: Phase;                                                                             
 var Node.next3545602: [Node]Node;                                                                  
 var Queue.tail_nextValue3545725: [Queue]Node;                                                      
 var Queue._lock3545789: [Queue]Tid;                                                                
 var Node.next_nextValue3545722: [Node]Node;                                                        
 var Node.next_nextValue3545274: [Node]Node;                                                        
 var value3545343: int;                                                                             
 var tmp23545480: bool;                                                                             
 var Queue._lock3545473: [Queue]Tid;                                                                
 var tid3545625: Tid;                                                                               
 var Node._state3545767: [Node]State;                                                               
 var Queue.head_nextThread3545343: [Queue]Tid;                                                      
 var Queue._state3545324: [Queue]State;                                                             
 var Queue._state3545280: [Queue]State;                                                             
 var $recorded.state3545503: int;                                                                   
 var n3545790: Node;                                                                                
 var Queue.head_nextValue3545227: [Queue]Node;                                                      
 var tmp13545329: bool;                                                                             
 var $pc3545786_post: Phase;                                                                        
 var moverPath3545227: MoverPath;                                                                   
 var ctmp35199863545752: bool;                                                                      
 var n3545755: Node;                                                                                
 var Node._lock3545789_bottom: [Node]Tid;                                                           
 var _m3545725: Mover;                                                                              
 var this3545595: Queue;                                                                            
 var $recorded.state3545393: int;                                                                   
 var Queue.head_nextValue3545628: [Queue]Node;                                                      
 var _C_t3545343: Tid;                                                                              
 var Queue.tail_nextValue3545625: [Queue]Node;                                                      
 var Queue.head_nextThread3545238: [Queue]Tid;                                                      
 var tid3545598: Tid;                                                                               
 var Queue._lock3545525: [Queue]Tid;                                                                
 var Node.next_nextThread3545333_post: [Node]Tid;                                                   
 var Queue._state3545227: [Queue]State;                                                             
 var Node._lock3545729: [Node]Tid;                                                                  
 var _C_t3545286: Tid;                                                                              
 var value$2303545227: int;                                                                         
 var Node.next3545790: [Node]Node;                                                                  
 var $pc3545476: Phase;                                                                             
 var this3545324: Queue;                                                                            
 var Queue.head3545786_post: [Queue]Node;                                                           
 var $recorded.state3545398: int;                                                                   
 var mover3545640: Mover;                                                                           
 var tmp23545774: bool;                                                                             
 var Node.next_nextValue3545640: [Node]Node;                                                        
 var value3545602: int;                                                                             
 var tmp43545640: bool;                                                                             
 var Queue._lock3545598: [Queue]Tid;                                                                
 var tmpTid3545476: Tid;                                                                            
 var Node.next_nextValue3545755: [Node]Node;                                                        
 var tmp13545503: bool;                                                                             
 var tid3545324: Tid;                                                                               
 var Node.next_nextThread3545333: [Node]Tid;                                                        
 var mover3545503: Mover;                                                                           
 var Node.next_nextThread3545355: [Node]Tid;                                                        
 var $recorded.state3545333_post: int;                                                              
 var Node.next_nextThread3545628: [Node]Tid;                                                        
 var $recorded.state3545786: int;                                                                   
 var Queue.tail_nextValue3545286: [Queue]Node;                                                      
 var next3545343: Node;                                                                             
 var moverPath3545628: MoverPath;                                                                   
 var last3545274: Node;                                                                             
 var Queue.head_nextThread3545767: [Queue]Tid;                                                      
 var next3545602: Node;                                                                             
 var tmp13545625: bool;                                                                             
 var tmp43545598: bool;                                                                             
 var tmp13545535: bool;                                                                             
 var Node.next3545398: [Node]Node;                                                                  
 var n3545473: Node;                                                                                
 var _C_t3545355: Tid;                                                                              
 var Queue.tail_nextValue3545398: [Queue]Node;                                                      
 var this3545640: Queue;                                                                            
 var Node.next3545349: [Node]Node;                                                                  
 var Queue.head_nextThread3545349: [Queue]Tid;                                                      
 var $pc3545324: Phase;                                                                             
 var last3545349: Node;                                                                             
 var Queue._lock3545333: [Queue]Tid;                                                                
 var _m3545729: Mover;                                                                              
 var next3545722: Node;                                                                             
 var Node.next_nextThread3545238: [Node]Tid;                                                        
 var Node.next3545786: [Node]Node;                                                                  
 var tid3545280: Tid;                                                                               
 var n3545789_bottom: Node;                                                                         
 var tmpTid3545480: Tid;                                                                            
 var path3545503: int;                                                                              
 var value3545413: int;                                                                             
 var Node.next_nextThread3545398: [Node]Tid;                                                        
 var Node._lock3545789: [Node]Tid;                                                                  
 var last3545535: Node;                                                                             
 var Queue._state3545503: [Queue]State;                                                             
 var tmp13545647: bool;                                                                             
 var Queue.tail_nextThread3545518: [Queue]Tid;                                                      
 var Node.next_nextValue3545786_post: [Node]Node;                                                   
 var n3545640: Node;                                                                                
 var next3545598: Node;                                                                             
 var Node.next_nextValue3545413_post: [Node]Node;                                                   
 var Queue.tail3545767: [Queue]Node;                                                                
 var Node.next_nextValue3545398: [Node]Node;                                                        
 var Queue.head_nextThread3545790: [Queue]Tid;                                                      
 var Queue._state3545595: [Queue]State;                                                             
 var value3545355: int;                                                                             
 var Queue._lock3545286: [Queue]Tid;                                                                
 var tmp13545774: bool;                                                                             
 var Node.value3545789_bottom: [Node]int;                                                           
 var mover3545355: Mover;                                                                           
 var value3545398: int;                                                                             
 var Node.next_nextThread3545535_post: [Node]Tid;                                                   
 var Node._lock3545774: [Node]Tid;                                                                  
 var $recorded.state3545518: int;                                                                   
 var Queue.tail3545413_post: [Queue]Node;                                                           
 var Queue._lock3545786: [Queue]Tid;                                                                
 var Queue.head_nextThread3545725: [Queue]Tid;                                                      
 var Queue._lock3545657: [Queue]Tid;                                                                
 var last3545355: Node;                                                                             
 var tmp3: bool;                                                                                    
 var Node.next_nextValue3545525: [Node]Node;                                                        
 var tmp23545786: bool;                                                                             
 var tid3545786_post: Tid;                                                                          
 var Queue.head3545640: [Queue]Node;                                                                
 var Node.next_nextThread3545324: [Node]Tid;                                                        
 var Node.next_nextThread3545729: [Node]Tid;                                                        
 var _C_v3545393: Node;                                                                             
 var Node._state3545729: [Node]State;                                                               
 var Node.value3545476: [Node]int;                                                                  
 var tmpTid: Tid;                                                                                   
 var Queue.head3545393: [Queue]Node;                                                                
 var moverPath3545274: MoverPath;                                                                   
 var tmp13545752: bool;                                                                             
 var Node.next3545413: [Node]Node;                                                                  
 var Queue.tail_nextValue3545413: [Queue]Node;                                                      
 var Node.value3545755: [Node]int;                                                                  
 var Node.next3545286: [Node]Node;                                                                  
 var ctmp3519972: bool;                                                                             
 var Queue.tail3545725: [Queue]Node;                                                                
 var $pc3545393: Phase;                                                                             
 var Queue._state3545752: [Queue]State;                                                             
 var Queue.tail3545227: [Queue]Node;                                                                
 var Queue.tail_nextValue3545324: [Queue]Node;                                                      
 var value3545518: int;                                                                             
 var Queue.head_nextValue3545790: [Queue]Node;                                                      
 var Node.next3545518: [Node]Node;                                                                  
 var Queue._state3545393: [Queue]State;                                                             
 var Queue.head3545789: [Queue]Node;                                                                
 var this3545535: Queue;                                                                            
 var tmp53545767: bool;                                                                             
 var tmp4: bool;                                                                                    
 var Queue.tail_nextValue3545343: [Queue]Node;                                                      
 var $recorded.state3545286: int;                                                                   
 var $recorded.state3545767: int;                                                                   
 var $recorded.state3545473: int;                                                                   
 var Queue.head_nextThread3545227: [Queue]Tid;                                                      
 var tid3545393: Tid;                                                                               
 var this3545767: Queue;                                                                            
 var tid3545476: Tid;                                                                               
 var Queue.tail_nextThread3545413: [Queue]Tid;                                                      
 var Node.next3545657: [Node]Node;                                                                  
 var Queue._state3545598: [Queue]State;                                                             
 var Queue.head_nextValue3545413_post: [Queue]Node;                                                 
 var tid3545413_post: Tid;                                                                          
 var _m3545602: Mover;                                                                              
 var Queue.head_nextThread3545789: [Queue]Tid;                                                      
 var tmp33545595: bool;                                                                             
 var Queue.tail_nextThread3545349: [Queue]Tid;                                                      
 var Queue.tail_nextValue3545329: [Queue]Node;                                                      
 var moverPath3545503: MoverPath;                                                                   
 var n3545525: Node;                                                                                
 var Queue.tail_nextThread3545786: [Queue]Tid;                                                      
 var tmp33545598: bool;                                                                             
 var value3545506: int;                                                                             
 var Queue.tail_nextValue3545518: [Queue]Node;                                                      
 var tmp13545640: bool;                                                                             
 var tmp33545473: bool;                                                                             
 var tmpTid3545729: Tid;                                                                            
 var Node.next3545227: [Node]Node;                                                                  
 var this3545506: Queue;                                                                            
 var value3545628: int;                                                                             
 var Queue.head3545602: [Queue]Node;                                                                
 var tmp23545625: bool;                                                                             
 var _currentValue3545286: Node;                                                                    
 var Queue._state3545657: [Queue]State;                                                             
 var Node.next_nextValue3545657: [Node]Node;                                                        
 var tmp53545755: bool;                                                                             
 var path3545280: int;                                                                              
 var $recorded.state3545480: int;                                                                   
 var Queue.head_nextValue3545725: [Queue]Node;                                                      
 var Queue._lock3545595: [Queue]Tid;                                                                
 var tmp13545525: bool;                                                                             
 var Node._state3545518: [Node]State;                                                               
 var Node.next3545413_post: [Node]Node;                                                             
 var Queue.head3545535: [Queue]Node;                                                                
 var moverPath3545722: MoverPath;                                                                   
 var value3545413_post: int;                                                                        
 var path3545473: int;                                                                              
 var $recorded.state3545647: int;                                                                   
 var Node._state3545657: [Node]State;                                                               
 var last3545774: Node;                                                                             
 var Queue.tail3545628: [Queue]Node;                                                                
 var _m3545647: Mover;                                                                              
 var n3545625: Node;                                                                                
 var tmp13545767: bool;                                                                             
 var Node._state3545398: [Node]State;                                                               
 var this3545774: Queue;                                                                            
 var Queue.head3545774: [Queue]Node;                                                                
 var Queue._lock3545238: [Queue]Tid;                                                                
 var Queue.tail3545755: [Queue]Node;                                                                
 var Node.value3545525: [Node]int;                                                                  
 var Queue.head3545729: [Queue]Node;                                                                
 var tmp13545280: bool;                                                                             
 var Node.next3545329: [Node]Node;                                                                  
 var tmp13545535_post: bool;                                                                        
 var Node.next_nextValue3545324: [Node]Node;                                                        
 var Queue.tail3545333_post: [Queue]Node;                                                           
 var this3545725: Queue;                                                                            
 var last3545755: Node;                                                                             
 var $pc3545752: Phase;                                                                             
 var value3545786: int;                                                                             
 var Node._state3545329: [Node]State;                                                               
 var Node._state3545274: [Node]State;                                                               
 var Node._lock3545280: [Node]Tid;                                                                  
 var $pc3545227: Phase;                                                                             
 var Queue.tail_nextValue3545729: [Queue]Node;                                                      
 var Node.next_nextValue3545602: [Node]Node;                                                        
 var $pc3545647: Phase;                                                                             
 var Node._lock3545286: [Node]Tid;                                                                  
 var value3545790: int;                                                                             
 var Node.value3545280: [Node]int;                                                                  
 var Queue.head_nextValue3545398: [Queue]Node;                                                      
 var $pc3545413: Phase;                                                                             
 var Node.next_nextValue3545227: [Node]Node;                                                        
 var Node.next3545355: [Node]Node;                                                                  
 var $recorded.state3545774: int;                                                                   
 var tmpTid3545725: Tid;                                                                            
 var moverPath3545398: MoverPath;                                                                   
 var Node.next_nextThread3545598: [Node]Tid;                                                        
 var $pc3545503: Phase;                                                                             
 var Node._lock3545413: [Node]Tid;                                                                  
 var Node.next3545725: [Node]Node;                                                                  
 var mover3545595: Mover;                                                                           
 var Queue.tail_nextThread3545628: [Queue]Tid;                                                      
 var n3545503: Node;                                                                                
 var $recorded.state3545755: int;                                                                   
 var Node.next_nextThread3545752: [Node]Tid;                                                        
 var Queue.tail3545786: [Queue]Node;                                                                
 var Queue._lock3545227: [Queue]Tid;                                                                
 var last3545413: Node;                                                                             
 var mover3545722: Mover;                                                                           
 var Node.value3545343: [Node]int;                                                                  
 var Queue.head3545647: [Queue]Node;                                                                
 var Node.next_nextValue3545625: [Node]Node;                                                        
 var Queue.head_nextValue3545506: [Queue]Node;                                                      
 var Node._lock3545518: [Node]Tid;                                                                  
 var Node.next_nextValue3545789: [Node]Node;                                                        
 var value3545329: int;                                                                             
 var _m3545525: Mover;                                                                              
 var Node._lock3545535: [Node]Tid;                                                                  
 var Queue.tail_nextThread3545393: [Queue]Tid;                                                      
 var moverPath3545625: MoverPath;                                                                   
 var Queue.head3545355: [Queue]Node;                                                                
 var Queue.tail_nextValue3545752: [Queue]Node;                                                      
 var Queue._state3545274: [Queue]State;                                                             
 var Node.next_nextThread3545625: [Node]Tid;                                                        
 var Queue.tail_nextThread3545473: [Queue]Tid;                                                      
 var Queue.tail3545535: [Queue]Node;                                                                
 var moverPath3545774: MoverPath;                                                                   
 var this3545473: Queue;                                                                            
 var _currentValue3545355: Node;                                                                    
 var Node.next_nextThread3545767: [Node]Tid;                                                        
 var this3545525: Queue;                                                                            
 var Node._lock3545476: [Node]Tid;                                                                  
 var n3545535_post: Node;                                                                           
 var Queue.head_nextValue3545286: [Queue]Node;                                                      
 var Queue.tail_nextValue3545333: [Queue]Node;                                                      
 var next$230: Node;                                                                                
 var last3545628: Node;                                                                             
 var path3545628: int;                                                                              
 var n3545598: Node;                                                                                
 var ctmp35199863545725: bool;                                                                      
 var Queue._state3545535_post: [Queue]State;                                                        
 var Node.value3545333_post: [Node]int;                                                             
 var Queue.tail3545238: [Queue]Node;                                                                
 var Node.next_nextValue3545518: [Node]Node;                                                        
 var value3545722: int;                                                                             
 var this3545286: Queue;                                                                            
 var Queue.tail3545786_post: [Queue]Node;                                                           
 var Queue._lock3545343: [Queue]Tid;                                                                
 var Queue.head3545598: [Queue]Node;                                                                
 var Queue._lock3545725: [Queue]Tid;                                                                
 var Queue._lock3545503: [Queue]Tid;                                                                
 var tid3545274: Tid;                                                                               
 var value3545789: int;                                                                             
 var Queue.head_nextValue3545413: [Queue]Node;                                                      
 var path3545725: int;                                                                              
 var tid3545480: Tid;                                                                               
 var mover3545480: Mover;                                                                           
 var $recorded.state3545790: int;                                                                   
 var tid3545729: Tid;                                                                               
 var Queue.tail_nextValue3545647: [Queue]Node;                                                      
 var moverPath3545355: MoverPath;                                                                   
 var Node.next3545722: [Node]Node;                                                                  
 var $pc3545790: Phase;                                                                             
 var n3545729: Node;                                                                                
 var Queue.tail_nextThread3545329: [Queue]Tid;                                                      
 var this3545729: Queue;                                                                            
 var Queue._lock3545774: [Queue]Tid;                                                                
 var Queue._state3545602: [Queue]State;                                                             
 var this3545657: Queue;                                                                            
 var next3545725: Node;                                                                             
 var next3545647: Node;                                                                             
 var Node._lock3545525: [Node]Tid;                                                                  
 var n3545595: Node;                                                                                
 var Node.next_nextThread3545647: [Node]Tid;                                                        
 var tmp33545657: bool;                                                                             
 var Queue._state3545767: [Queue]State;                                                             
 var Queue._lock3545535_post: [Queue]Tid;                                                           
 var moverPath3545324: MoverPath;                                                                   
 var Node._lock3545602: [Node]Tid;                                                                  
 var Node._state3545790: [Node]State;                                                               
 var Queue.head_nextThread3545602: [Queue]Tid;                                                      
 var n3545786_post: Node;                                                                           
 var _m3545518: Mover;                                                                              
 var tmp33545503: bool;                                                                             
 var tid3545238: Tid;                                                                               
 var value3545393: int;                                                                             
 var Node.value3545774: [Node]int;                                                                  
 var next$2303545227: Node;                                                                         
 var mover3545476: Mover;                                                                           
 var Queue._state3545333_post: [Queue]State;                                                        
 var tmp13545333_post: bool;                                                                        
 var Queue.tail_nextValue3545393: [Queue]Node;                                                      
 var last3545602: Node;                                                                             
 var Node.value3545286: [Node]int;                                                                  
 var Queue.tail3545476: [Queue]Node;                                                                
 var mover3545329: Mover;                                                                           
 var Node.next_nextThread3545640: [Node]Tid;                                                        
 var Node.next_nextThread3545789: [Node]Tid;                                                        
 var _currentValue3545628: Node;                                                                    
 var $pc3545640: Phase;                                                                             
 var Queue.tail_nextThread3545598: [Queue]Tid;                                                      
 var Queue.tail_nextValue3545525: [Queue]Node;                                                      
 var $recorded.state3545506: int;                                                                   
 var next3545349: Node;                                                                             
 var Queue.tail_nextValue3545595: [Queue]Node;                                                      
 var $recorded.state3545628: int;                                                                   
 var Queue.tail_nextValue3545602: [Queue]Node;                                                      
 var Node.next_nextValue3545535: [Node]Node;                                                        
 var Node._state3545355: [Node]State;                                                               
 var Queue._state3545286: [Queue]State;                                                             
 var tmp13545476: bool;                                                                             
 var Queue.tail_nextThread3545752: [Queue]Tid;                                                      
 var path3545647: int;                                                                              
 var last3545333_post: Node;                                                                        
 var $pc3545774: Phase;                                                                             
 var tid3545503: Tid;                                                                               
 var tmp23545525: bool;                                                                             
 var Node._state3545595: [Node]State;                                                               
 var moverPath3545598: MoverPath;                                                                   
 var Queue.tail_nextThread3545755: [Queue]Tid;                                                      
 var Queue._state3545398: [Queue]State;                                                             
 var Queue._lock3545752: [Queue]Tid;                                                                
 var Node.next_nextThread3545476: [Node]Tid;                                                        
 var next3545595: Node;                                                                             
 var _currentValue3545774: Node;                                                                    
 var Queue.head3545722: [Queue]Node;                                                                
 var tmp23545598: bool;                                                                             
 var $pc3545413_post: Phase;                                                                        
 var next3545480: Node;                                                                             
 var Node._lock3545393: [Node]Tid;                                                                  
 var Queue._lock3545280: [Queue]Tid;                                                                
 var Node.next3545786_post: [Node]Node;                                                             
 var tmp33545535: bool;                                                                             
 var Queue.tail_nextThread3545647: [Queue]Tid;                                                      
 var Queue._lock3545333_post: [Queue]Tid;                                                           
 var Queue._state3545473: [Queue]State;                                                             
 var Node._state3545280: [Node]State;                                                               
 var tmp13545518: bool;                                                                             
 var $recorded.state3545729: int;                                                                   
 var Queue._state3545329: [Queue]State;                                                             
 var Queue.tail_nextValue3545786: [Queue]Node;                                                      
 var tid3545774: Tid;                                                                               
 var $pc3545789_bottom: Phase;                                                                      
 var Node.value3545518: [Node]int;                                                                  
 var Node.value3545789: [Node]int;                                                                  
 var Node._state3545774: [Node]State;                                                               
 var Node._lock3545628: [Node]Tid;                                                                  
 var tmp13545598: bool;                                                                             
 var Queue._lock3545767: [Queue]Tid;                                                                
 var tmp33545506: bool;                                                                             
 var Queue._lock3545324: [Queue]Tid;                                                                
 var Node.value3545480: [Node]int;                                                                  
 var $recorded.state3545752: int;                                                                   
 var $recorded.state3545476: int;                                                                   
 var Queue.tail3545349: [Queue]Node;                                                                
 var tmpValue3545729: Node;                                                                         
 var ctmp35199723545595: bool;                                                                      
 var Queue.head_nextValue3545333: [Queue]Node;                                                      
 var Queue.tail_nextValue3545349: [Queue]Node;                                                      
 var $pc3545789: Phase;                                                                             
 var n3545752: Node;                                                                                
 var Queue.head_nextThread3545280: [Queue]Tid;                                                      
 var tmp33545480: bool;                                                                             
 var Queue.tail_nextThread3545535_post: [Queue]Tid;                                                 
 var Queue.tail_nextThread3545790: [Queue]Tid;                                                      
 var this3545274: Queue;                                                                            
 var value3545476: int;                                                                             
 var n3545274: Node;                                                                                
 var tmpTid3545722: Tid;                                                                            
 var tmp43545628: bool;                                                                             
 var tmp13545413: bool;                                                                             
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 // 32.9: Node n;                                                                                   
                                                                                                    
                                                                                                    
 // 32.9: n = new Node();                                                                           
                                                                                                    
 havoc n;                                                                                           
 assume n != Node.null && isFresh(Node._state[n]);                                                  
 Node._state[n] := LOCAL(tid);                                                                      
 assume Node.value[n]  == 0;                                                                        
 assume Node.next[n]  == Node.null;                                                                 
 assume Node._lock[n]  == Tid.null;                                                                 
 // inlined: n.init(value,Node.null)}                                                               
 exit$230_top:                                                                                      
                                                                                                    
 // 32.9: int value$230;                                                                            
                                                                                                    
                                                                                                    
 // 32.9: Node next$230;                                                                            
                                                                                                    
                                                                                                    
 // 32.9: Node this$230;                                                                            
                                                                                                    
                                                                                                    
 // 32.9: value$230 = value;                                                                        
                                                                                                    
 value$230 := value;                                                                                
                                                                                                    
 // 32.9: next$230 = Node.null;                                                                     
                                                                                                    
 next$230 := Node.null;                                                                             
                                                                                                    
 // 32.9: this$230 = n;                                                                             
                                                                                                    
 this$230 := n;                                                                                     
                                                                                                    
 // 10.5: assume this$230.value == 0;                                                               
                                                                                                    
 assume (Node.value[this$230]==0);                                                                  
                                                                                                    
 // 10.5: assume this$230.next == Node.null;                                                        
                                                                                                    
 assume (Node.next[this$230]==Node.null);                                                           
                                                                                                    
                                                                                                    
 // 11.7: this$230.value := value$230;                                                              
                                                                                                    
                                                                                                    
 moverPath3545227 := WriteEval.Node.value(tid: Tid,this$230: Node,value$230: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 mover3545227 := m#moverPath(moverPath3545227);                                                     
 path3545227 := p#moverPath(moverPath3545227);                                                      
 assume Node._state3545227 == Node._state && Node.value3545227 == Node.value && Node.next3545227 == Node.next && Node._lock3545227 == Node._lock && Node.next_nextThread3545227 == Node.next_nextThread && Node.next_nextValue3545227 == Node.next_nextValue && Queue._state3545227 == Queue._state && Queue.head3545227 == Queue.head && Queue.tail3545227 == Queue.tail && Queue._lock3545227 == Queue._lock && Queue.head_nextThread3545227 == Queue.head_nextThread && Queue.head_nextValue3545227 == Queue.head_nextValue && Queue.tail_nextThread3545227 == Queue.tail_nextThread && Queue.tail_nextValue3545227 == Queue.tail_nextValue && this$2303545227 == this$230 && next$2303545227 == next$230 && value$2303545227 == value$230 && n3545227 == n && value3545227 == value && this3545227 == this && tid3545227 == tid && $pc3545227 == $pc;
 assume $recorded.state3545227 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$230 != Node.null;                                                                     
 } else {                                                                                           
  assert this$230 != Node.null;                                                                            // (11.7): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3545227);                                                              
 assert $pc != PhaseError;                                                                                 // (11.7): Reduction failure
 Node.value[this$230] := value$230;                                                                 
 // NoOp: 'TraceOff'                                                                                
                                                                                                    
 // 12.7: assume this$230.next_nextThread == tid;                                                   
                                                                                                    
 assume (Node.next_nextThread[this$230]==tid);                                                      
 // NoOp: 'TraceOn'                                                                                 
                                                                                                    
                                                                                                    
 // 12.7: this$230.next := next$230;                                                                
                                                                                                    
                                                                                                    
 moverPath3545238 := WriteEval.Node.next(tid: Tid,this$230: Node,next$230: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 mover3545238 := m#moverPath(moverPath3545238);                                                     
 path3545238 := p#moverPath(moverPath3545238);                                                      
 assume Node._state3545238 == Node._state && Node.value3545238 == Node.value && Node.next3545238 == Node.next && Node._lock3545238 == Node._lock && Node.next_nextThread3545238 == Node.next_nextThread && Node.next_nextValue3545238 == Node.next_nextValue && Queue._state3545238 == Queue._state && Queue.head3545238 == Queue.head && Queue.tail3545238 == Queue.tail && Queue._lock3545238 == Queue._lock && Queue.head_nextThread3545238 == Queue.head_nextThread && Queue.head_nextValue3545238 == Queue.head_nextValue && Queue.tail_nextThread3545238 == Queue.tail_nextThread && Queue.tail_nextValue3545238 == Queue.tail_nextValue && this$2303545238 == this$230 && next$2303545238 == next$230 && value$2303545238 == value$230 && n3545238 == n && value3545238 == value && this3545238 == this && tid3545238 == tid && $pc3545238 == $pc;
 assume $recorded.state3545238 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$230 != Node.null;                                                                     
 } else {                                                                                           
  assert this$230 != Node.null;                                                                            // (12.7): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3545238);                                                              
 assert $pc != PhaseError;                                                                                 // (12.7): Reduction failure
 Node.next[this$230] := next$230;                                                                   
 if (isLocal(Node._state[next$230], tid)) {                                                         
  Node._state[next$230] := SHARED();                                                                
  assert isSharedAssignable(Node._state[Node.next[next$230]]);                                             // (12.7): next$230 became shared, but next$230.next may not be shared.
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 10.32: break exit$230;                                                                          
                                                                                                    
 goto exit$230_bottom;                                                                              
 exit$230_bottom:                                                                                   
 assume Node._state3545789 == Node._state && Node.value3545789 == Node.value && Node.next3545789 == Node.next && Node._lock3545789 == Node._lock && Node.next_nextThread3545789 == Node.next_nextThread && Node.next_nextValue3545789 == Node.next_nextValue && Queue._state3545789 == Queue._state && Queue.head3545789 == Queue.head && Queue.tail3545789 == Queue.tail && Queue._lock3545789 == Queue._lock && Queue.head_nextThread3545789 == Queue.head_nextThread && Queue.head_nextValue3545789 == Queue.head_nextValue && Queue.tail_nextThread3545789 == Queue.tail_nextThread && Queue.tail_nextValue3545789 == Queue.tail_nextValue && n3545789 == n && value3545789 == value && this3545789 == this && tid3545789 == tid;
 assume $recorded.state3545789 == 1;                                                                
                                                                                                    
 // 33.9: while (true)                                                                              
                                                                                                    
 phase3545789 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (31.5): Bad tid
  invariant isShared(Queue._state[this]);                                                                  // (31.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
  invariant  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (33.9): Object invariant may not hold.
  invariant  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (33.9): Object invariant may not hold.
  invariant isLocal(Node._state[n], tid);                                                           
  invariant (Node.next[n]==Node.null);                                                              
  invariant (forall _this : Node :: Invariant.Y_Node.value(tid : Tid, _this, Node.value[_this] ,Node._state3545789,Node.value3545789,Node.next3545789,Node._lock3545789,Node.next_nextThread3545789,Node.next_nextValue3545789,Queue._state3545789,Queue.head3545789,Queue.tail3545789,Queue._lock3545789,Queue.head_nextThread3545789,Queue.head_nextValue3545789,Queue.tail_nextThread3545789,Queue.tail_nextValue3545789));       // (33.9): Loop does not preserve yields_as annotation for field value
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state3545789,Node.value3545789,Node.next3545789,Node._lock3545789,Node.next_nextThread3545789,Node.next_nextValue3545789,Queue._state3545789,Queue.head3545789,Queue.tail3545789,Queue._lock3545789,Queue.head_nextThread3545789,Queue.head_nextValue3545789,Queue.tail_nextThread3545789,Queue.tail_nextValue3545789));       // (33.9): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Queue :: Invariant.Y_Queue.head(tid : Tid, _this, Queue.head[_this] ,Node._state3545789,Node.value3545789,Node.next3545789,Node._lock3545789,Node.next_nextThread3545789,Node.next_nextValue3545789,Queue._state3545789,Queue.head3545789,Queue.tail3545789,Queue._lock3545789,Queue.head_nextThread3545789,Queue.head_nextValue3545789,Queue.tail_nextThread3545789,Queue.tail_nextValue3545789));       // (33.9): Loop does not preserve yields_as annotation for field head
  invariant (forall _this : Queue :: Invariant.Y_Queue.tail(tid : Tid, _this, Queue.tail[_this] ,Node._state3545789,Node.value3545789,Node.next3545789,Node._lock3545789,Node.next_nextThread3545789,Node.next_nextValue3545789,Queue._state3545789,Queue.head3545789,Queue.tail3545789,Queue._lock3545789,Queue.head_nextThread3545789,Queue.head_nextValue3545789,Queue.tail_nextThread3545789,Queue.tail_nextValue3545789));       // (33.9): Loop does not preserve yields_as annotation for field tail
  invariant phase3545789 == $pc;                                                                           // (33.9): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (33.9): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 33.15: boolean tmp1;                                                                           
                                                                                                    
                                                                                                    
  // 33.15: tmp1 = true;                                                                            
                                                                                                    
  tmp1 := true;                                                                                     
  if (!(tmp1)) {                                                                                    
                                                                                                    
   // 33.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 37.13: Node last;                                                                              
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 37.13: Tid _C_t;                                                                               
                                                                                                    
                                                                                                    
  // 37.13: _C_t := this.tail_nextThread  as B;                                                     
                                                                                                    
                                                                                                    
  moverPath3545274 := ReadEval.Queue.tail_nextThread(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545274 := m#moverPath(moverPath3545274);                                                    
  path3545274 := p#moverPath(moverPath3545274);                                                     
  assume Node._state3545274 == Node._state && Node.value3545274 == Node.value && Node.next3545274 == Node.next && Node._lock3545274 == Node._lock && Node.next_nextThread3545274 == Node.next_nextThread && Node.next_nextValue3545274 == Node.next_nextValue && Queue._state3545274 == Queue._state && Queue.head3545274 == Queue.head && Queue.tail3545274 == Queue.tail && Queue._lock3545274 == Queue._lock && Queue.head_nextThread3545274 == Queue.head_nextThread && Queue.head_nextValue3545274 == Queue.head_nextValue && Queue.tail_nextThread3545274 == Queue.tail_nextThread && Queue.tail_nextValue3545274 == Queue.tail_nextValue && _C_t3545274 == _C_t && last3545274 == last && tmp13545274 == tmp1 && n3545274 == n && value3545274 == value && this3545274 == this && tid3545274 == tid && $pc3545274 == $pc;
  assume $recorded.state3545274 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (37.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (37.13): Reduction failure
  _C_t := Queue.tail_nextThread[this];                                                              
                                                                                                    
  // 37.13: Node _C_v;                                                                              
                                                                                                    
                                                                                                    
  // 37.13: _C_v := this.tail_nextValue  as B;                                                      
                                                                                                    
                                                                                                    
  moverPath3545280 := ReadEval.Queue.tail_nextValue(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545280 := m#moverPath(moverPath3545280);                                                    
  path3545280 := p#moverPath(moverPath3545280);                                                     
  assume Node._state3545280 == Node._state && Node.value3545280 == Node.value && Node.next3545280 == Node.next && Node._lock3545280 == Node._lock && Node.next_nextThread3545280 == Node.next_nextThread && Node.next_nextValue3545280 == Node.next_nextValue && Queue._state3545280 == Queue._state && Queue.head3545280 == Queue.head && Queue.tail3545280 == Queue.tail && Queue._lock3545280 == Queue._lock && Queue.head_nextThread3545280 == Queue.head_nextThread && Queue.head_nextValue3545280 == Queue.head_nextValue && Queue.tail_nextThread3545280 == Queue.tail_nextThread && Queue.tail_nextValue3545280 == Queue.tail_nextValue && _C_v3545280 == _C_v && _C_t3545280 == _C_t && last3545280 == last && tmp13545280 == tmp1 && n3545280 == n && value3545280 == value && this3545280 == this && tid3545280 == tid && $pc3545280 == $pc;
  assume $recorded.state3545280 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (37.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (37.13): Reduction failure
  _C_v := Queue.tail_nextValue[this];                                                               
                                                                                                    
  // 37.13: Node _currentValue;                                                                     
                                                                                                    
                                                                                                    
  // 37.13: _currentValue := this.tail  as B;                                                       
                                                                                                    
                                                                                                    
  moverPath3545286 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545286 := m#moverPath(moverPath3545286);                                                    
  path3545286 := p#moverPath(moverPath3545286);                                                     
  assume Node._state3545286 == Node._state && Node.value3545286 == Node.value && Node.next3545286 == Node.next && Node._lock3545286 == Node._lock && Node.next_nextThread3545286 == Node.next_nextThread && Node.next_nextValue3545286 == Node.next_nextValue && Queue._state3545286 == Queue._state && Queue.head3545286 == Queue.head && Queue.tail3545286 == Queue.tail && Queue._lock3545286 == Queue._lock && Queue.head_nextThread3545286 == Queue.head_nextThread && Queue.head_nextValue3545286 == Queue.head_nextValue && Queue.tail_nextThread3545286 == Queue.tail_nextThread && Queue.tail_nextValue3545286 == Queue.tail_nextValue && _currentValue3545286 == _currentValue && _C_v3545286 == _C_v && _C_t3545286 == _C_t && last3545286 == last && tmp13545286 == tmp1 && n3545286 == n && value3545286 == value && this3545286 == this && tid3545286 == tid && $pc3545286 == $pc;
  assume $recorded.state3545286 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (37.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (37.13): Reduction failure
  _currentValue := Queue.tail[this];                                                                
                                                                                                    
  // 37.13: Mover _R_t;                                                                             
                                                                                                    
                                                                                                    
  // 37.13: _R_t = readPermission(this.tail);                                                       
                                                                                                    
  _R_t := m#moverPath(ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
  // 37.13: boolean _casable;                                                                       
                                                                                                    
                                                                                                    
  // 37.13: _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
                                                                                                    
  _casable := ((((_R_t!=_E)&&false)&&(_C_t==tid))&&(_C_v==_currentValue));                          
  if (_casable) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 37.13: last := this.tail  as R;                                                               
                                                                                                    
                                                                                                    
   moverPath3545324 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
   mover3545324 := m#moverPath(moverPath3545324);                                                   
   path3545324 := p#moverPath(moverPath3545324);                                                    
   assume Node._state3545324 == Node._state && Node.value3545324 == Node.value && Node.next3545324 == Node.next && Node._lock3545324 == Node._lock && Node.next_nextThread3545324 == Node.next_nextThread && Node.next_nextValue3545324 == Node.next_nextValue && Queue._state3545324 == Queue._state && Queue.head3545324 == Queue.head && Queue.tail3545324 == Queue.tail && Queue._lock3545324 == Queue._lock && Queue.head_nextThread3545324 == Queue.head_nextThread && Queue.head_nextValue3545324 == Queue.head_nextValue && Queue.tail_nextThread3545324 == Queue.tail_nextThread && Queue.tail_nextValue3545324 == Queue.tail_nextValue && _casable3545324 == _casable && _R_t3545324 == _R_t && _currentValue3545324 == _currentValue && _C_v3545324 == _C_v && _C_t3545324 == _C_t && last3545324 == last && tmp13545324 == tmp1 && n3545324 == n && value3545324 == value && this3545324 == this && tid3545324 == tid && $pc3545324 == $pc;
   assume $recorded.state3545324 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Queue.null;                                                                      
   } else {                                                                                         
    assert this != Queue.null;                                                                             // (37.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, _R);                                                                      
   assert $pc != PhaseError;                                                                               // (37.13): Reduction failure
   last := Queue.tail[this];                                                                        
  } else {                                                                                          
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 37.13: last := this.tail;                                                                     
                                                                                                    
                                                                                                    
   moverPath3545329 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
   mover3545329 := m#moverPath(moverPath3545329);                                                   
   path3545329 := p#moverPath(moverPath3545329);                                                    
   assume Node._state3545329 == Node._state && Node.value3545329 == Node.value && Node.next3545329 == Node.next && Node._lock3545329 == Node._lock && Node.next_nextThread3545329 == Node.next_nextThread && Node.next_nextValue3545329 == Node.next_nextValue && Queue._state3545329 == Queue._state && Queue.head3545329 == Queue.head && Queue.tail3545329 == Queue.tail && Queue._lock3545329 == Queue._lock && Queue.head_nextThread3545329 == Queue.head_nextThread && Queue.head_nextValue3545329 == Queue.head_nextValue && Queue.tail_nextThread3545329 == Queue.tail_nextThread && Queue.tail_nextValue3545329 == Queue.tail_nextValue && _casable3545329 == _casable && _R_t3545329 == _R_t && _currentValue3545329 == _currentValue && _C_v3545329 == _C_v && _C_t3545329 == _C_t && last3545329 == last && tmp13545329 == tmp1 && n3545329 == n && value3545329 == value && this3545329 == this && tid3545329 == tid && $pc3545329 == $pc;
   assume $recorded.state3545329 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Queue.null;                                                                      
   } else {                                                                                         
    assert this != Queue.null;                                                                             // (37.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover3545329);                                                            
   assert $pc != PhaseError;                                                                               // (37.13): Reduction failure
   last := Queue.tail[this];                                                                        
  }                                                                                                 
                                                                                                    
  // 38.13: yield;                                                                                  
                                                                                                    
  assume Node._state3545333 == Node._state && Node.value3545333 == Node.value && Node.next3545333 == Node.next && Node._lock3545333 == Node._lock && Node.next_nextThread3545333 == Node.next_nextThread && Node.next_nextValue3545333 == Node.next_nextValue && Queue._state3545333 == Queue._state && Queue.head3545333 == Queue.head && Queue.tail3545333 == Queue.tail && Queue._lock3545333 == Queue._lock && Queue.head_nextThread3545333 == Queue.head_nextThread && Queue.head_nextValue3545333 == Queue.head_nextValue && Queue.tail_nextThread3545333 == Queue.tail_nextThread && Queue.tail_nextValue3545333 == Queue.tail_nextValue && last3545333 == last && tmp13545333 == tmp1 && n3545333 == n && value3545333 == value && this3545333 == this && tid3545333 == tid;
  assume $recorded.state3545333 == 1;                                                               
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (38.13): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (38.13): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (38.13): Object invariant may not hold.
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (38.13): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Node._state3545333_post == Node._state && Node.value3545333_post == Node.value && Node.next3545333_post == Node.next && Node._lock3545333_post == Node._lock && Node.next_nextThread3545333_post == Node.next_nextThread && Node.next_nextValue3545333_post == Node.next_nextValue && Queue._state3545333_post == Queue._state && Queue.head3545333_post == Queue.head && Queue.tail3545333_post == Queue.tail && Queue._lock3545333_post == Queue._lock && Queue.head_nextThread3545333_post == Queue.head_nextThread && Queue.head_nextValue3545333_post == Queue.head_nextValue && Queue.tail_nextThread3545333_post == Queue.tail_nextThread && Queue.tail_nextValue3545333_post == Queue.tail_nextValue && last3545333_post == last && tmp13545333_post == tmp1 && n3545333_post == n && value3545333_post == value && this3545333_post == this && tid3545333_post == tid;
  assume $recorded.state3545333_post == 1;                                                          
                                                                                                    
  // 39.13: Node next;                                                                              
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 39.13: Tid _C_t;                                                                               
                                                                                                    
                                                                                                    
  // 39.13: _C_t := last.next_nextThread  as B;                                                     
                                                                                                    
                                                                                                    
  moverPath3545343 := ReadEval.Node.next_nextThread(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545343 := m#moverPath(moverPath3545343);                                                    
  path3545343 := p#moverPath(moverPath3545343);                                                     
  assume Node._state3545343 == Node._state && Node.value3545343 == Node.value && Node.next3545343 == Node.next && Node._lock3545343 == Node._lock && Node.next_nextThread3545343 == Node.next_nextThread && Node.next_nextValue3545343 == Node.next_nextValue && Queue._state3545343 == Queue._state && Queue.head3545343 == Queue.head && Queue.tail3545343 == Queue.tail && Queue._lock3545343 == Queue._lock && Queue.head_nextThread3545343 == Queue.head_nextThread && Queue.head_nextValue3545343 == Queue.head_nextValue && Queue.tail_nextThread3545343 == Queue.tail_nextThread && Queue.tail_nextValue3545343 == Queue.tail_nextValue && _C_t3545343 == _C_t && next3545343 == next && last3545343 == last && tmp13545343 == tmp1 && n3545343 == n && value3545343 == value && this3545343 == this && tid3545343 == tid && $pc3545343 == $pc;
  assume $recorded.state3545343 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume last != Node.null;                                                                        
  } else {                                                                                          
   assert last != Node.null;                                                                               // (39.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (39.13): Reduction failure
  _C_t := Node.next_nextThread[last];                                                               
                                                                                                    
  // 39.13: Node _C_v;                                                                              
                                                                                                    
                                                                                                    
  // 39.13: _C_v := last.next_nextValue  as B;                                                      
                                                                                                    
                                                                                                    
  moverPath3545349 := ReadEval.Node.next_nextValue(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545349 := m#moverPath(moverPath3545349);                                                    
  path3545349 := p#moverPath(moverPath3545349);                                                     
  assume Node._state3545349 == Node._state && Node.value3545349 == Node.value && Node.next3545349 == Node.next && Node._lock3545349 == Node._lock && Node.next_nextThread3545349 == Node.next_nextThread && Node.next_nextValue3545349 == Node.next_nextValue && Queue._state3545349 == Queue._state && Queue.head3545349 == Queue.head && Queue.tail3545349 == Queue.tail && Queue._lock3545349 == Queue._lock && Queue.head_nextThread3545349 == Queue.head_nextThread && Queue.head_nextValue3545349 == Queue.head_nextValue && Queue.tail_nextThread3545349 == Queue.tail_nextThread && Queue.tail_nextValue3545349 == Queue.tail_nextValue && _C_v3545349 == _C_v && _C_t3545349 == _C_t && next3545349 == next && last3545349 == last && tmp13545349 == tmp1 && n3545349 == n && value3545349 == value && this3545349 == this && tid3545349 == tid && $pc3545349 == $pc;
  assume $recorded.state3545349 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume last != Node.null;                                                                        
  } else {                                                                                          
   assert last != Node.null;                                                                               // (39.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (39.13): Reduction failure
  _C_v := Node.next_nextValue[last];                                                                
                                                                                                    
  // 39.13: Node _currentValue;                                                                     
                                                                                                    
                                                                                                    
  // 39.13: _currentValue := last.next  as B;                                                       
                                                                                                    
                                                                                                    
  moverPath3545355 := ReadEval.Node.next(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545355 := m#moverPath(moverPath3545355);                                                    
  path3545355 := p#moverPath(moverPath3545355);                                                     
  assume Node._state3545355 == Node._state && Node.value3545355 == Node.value && Node.next3545355 == Node.next && Node._lock3545355 == Node._lock && Node.next_nextThread3545355 == Node.next_nextThread && Node.next_nextValue3545355 == Node.next_nextValue && Queue._state3545355 == Queue._state && Queue.head3545355 == Queue.head && Queue.tail3545355 == Queue.tail && Queue._lock3545355 == Queue._lock && Queue.head_nextThread3545355 == Queue.head_nextThread && Queue.head_nextValue3545355 == Queue.head_nextValue && Queue.tail_nextThread3545355 == Queue.tail_nextThread && Queue.tail_nextValue3545355 == Queue.tail_nextValue && _currentValue3545355 == _currentValue && _C_v3545355 == _C_v && _C_t3545355 == _C_t && next3545355 == next && last3545355 == last && tmp13545355 == tmp1 && n3545355 == n && value3545355 == value && this3545355 == this && tid3545355 == tid && $pc3545355 == $pc;
  assume $recorded.state3545355 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume last != Node.null;                                                                        
  } else {                                                                                          
   assert last != Node.null;                                                                               // (39.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (39.13): Reduction failure
  _currentValue := Node.next[last];                                                                 
                                                                                                    
  // 39.13: Mover _R_t;                                                                             
                                                                                                    
                                                                                                    
  // 39.13: _R_t = readPermission(last.next);                                                       
                                                                                                    
  _R_t := m#moverPath(ReadEval.Node.next(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
  // 39.13: boolean _casable;                                                                       
                                                                                                    
                                                                                                    
  // 39.13: _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
                                                                                                    
  _casable := ((((_R_t!=_E)&&false)&&(_C_t==tid))&&(_C_v==_currentValue));                          
  if (_casable) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 39.13: next := last.next  as R;                                                               
                                                                                                    
                                                                                                    
   moverPath3545393 := ReadEval.Node.next(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
   mover3545393 := m#moverPath(moverPath3545393);                                                   
   path3545393 := p#moverPath(moverPath3545393);                                                    
   assume Node._state3545393 == Node._state && Node.value3545393 == Node.value && Node.next3545393 == Node.next && Node._lock3545393 == Node._lock && Node.next_nextThread3545393 == Node.next_nextThread && Node.next_nextValue3545393 == Node.next_nextValue && Queue._state3545393 == Queue._state && Queue.head3545393 == Queue.head && Queue.tail3545393 == Queue.tail && Queue._lock3545393 == Queue._lock && Queue.head_nextThread3545393 == Queue.head_nextThread && Queue.head_nextValue3545393 == Queue.head_nextValue && Queue.tail_nextThread3545393 == Queue.tail_nextThread && Queue.tail_nextValue3545393 == Queue.tail_nextValue && _casable3545393 == _casable && _R_t3545393 == _R_t && _currentValue3545393 == _currentValue && _C_v3545393 == _C_v && _C_t3545393 == _C_t && next3545393 == next && last3545393 == last && tmp13545393 == tmp1 && n3545393 == n && value3545393 == value && this3545393 == this && tid3545393 == tid && $pc3545393 == $pc;
   assume $recorded.state3545393 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume last != Node.null;                                                                       
   } else {                                                                                         
    assert last != Node.null;                                                                              // (39.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, _R);                                                                      
   assert $pc != PhaseError;                                                                               // (39.13): Reduction failure
   next := Node.next[last];                                                                         
  } else {                                                                                          
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 39.13: next := last.next;                                                                     
                                                                                                    
                                                                                                    
   moverPath3545398 := ReadEval.Node.next(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
   mover3545398 := m#moverPath(moverPath3545398);                                                   
   path3545398 := p#moverPath(moverPath3545398);                                                    
   assume Node._state3545398 == Node._state && Node.value3545398 == Node.value && Node.next3545398 == Node.next && Node._lock3545398 == Node._lock && Node.next_nextThread3545398 == Node.next_nextThread && Node.next_nextValue3545398 == Node.next_nextValue && Queue._state3545398 == Queue._state && Queue.head3545398 == Queue.head && Queue.tail3545398 == Queue.tail && Queue._lock3545398 == Queue._lock && Queue.head_nextThread3545398 == Queue.head_nextThread && Queue.head_nextValue3545398 == Queue.head_nextValue && Queue.tail_nextThread3545398 == Queue.tail_nextThread && Queue.tail_nextValue3545398 == Queue.tail_nextValue && _casable3545398 == _casable && _R_t3545398 == _R_t && _currentValue3545398 == _currentValue && _C_v3545398 == _C_v && _C_t3545398 == _C_t && next3545398 == next && last3545398 == last && tmp13545398 == tmp1 && n3545398 == n && value3545398 == value && this3545398 == this && tid3545398 == tid && $pc3545398 == $pc;
   assume $recorded.state3545398 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume last != Node.null;                                                                       
   } else {                                                                                         
    assert last != Node.null;                                                                              // (39.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover3545398);                                                            
   assert $pc != PhaseError;                                                                               // (39.13): Reduction failure
   next := Node.next[last];                                                                         
  }                                                                                                 
                                                                                                    
  // 40.13: boolean tmp2;                                                                           
                                                                                                    
                                                                                                    
  // 40.13: tmp2 = next == Node.null;                                                               
                                                                                                    
  tmp2 := (next==Node.null);                                                                        
  if (tmp2 /* lowered (next==Node.null) */) {                                                       
                                                                                                    
   // 41.17: yield;                                                                                 
                                                                                                    
   assume Node._state3545413 == Node._state && Node.value3545413 == Node.value && Node.next3545413 == Node.next && Node._lock3545413 == Node._lock && Node.next_nextThread3545413 == Node.next_nextThread && Node.next_nextValue3545413 == Node.next_nextValue && Queue._state3545413 == Queue._state && Queue.head3545413 == Queue.head && Queue.tail3545413 == Queue.tail && Queue._lock3545413 == Queue._lock && Queue.head_nextThread3545413 == Queue.head_nextThread && Queue.head_nextValue3545413 == Queue.head_nextValue && Queue.tail_nextThread3545413 == Queue.tail_nextThread && Queue.tail_nextValue3545413 == Queue.tail_nextValue && tmp23545413 == tmp2 && next3545413 == next && last3545413 == last && tmp13545413 == tmp1 && n3545413 == n && value3545413 == value && this3545413 == this && tid3545413 == tid;
   assume $recorded.state3545413 == 1;                                                              
   assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (41.17): Object invariant may not hold.
   assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (41.17): Object invariant may not hold.
   call Yield(tid);                                                                                 
   assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (41.17): Object invariant may not hold.
   assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (41.17): Object invariant may not hold.
   $pc := PreCommit;                                                                                
   assume Node._state3545413_post == Node._state && Node.value3545413_post == Node.value && Node.next3545413_post == Node.next && Node._lock3545413_post == Node._lock && Node.next_nextThread3545413_post == Node.next_nextThread && Node.next_nextValue3545413_post == Node.next_nextValue && Queue._state3545413_post == Queue._state && Queue.head3545413_post == Queue.head && Queue.tail3545413_post == Queue.tail && Queue._lock3545413_post == Queue._lock && Queue.head_nextThread3545413_post == Queue.head_nextThread && Queue.head_nextValue3545413_post == Queue.head_nextValue && Queue.tail_nextThread3545413_post == Queue.tail_nextThread && Queue.tail_nextValue3545413_post == Queue.tail_nextValue && tmp23545413_post == tmp2 && next3545413_post == next && last3545413_post == last && tmp13545413_post == tmp1 && n3545413_post == n && value3545413_post == value && this3545413_post == this && tid3545413_post == tid;
   assume $recorded.state3545413_post == 1;                                                         
                                                                                                    
   // 42.17: boolean tmp3;                                                                          
                                                                                                    
   // NoOp: 'TraceOff'                                                                              
                                                                                                    
   // 42.17: boolean ctmp3519962;                                                                   
                                                                                                    
                                                                                                    
   // 42.17: ctmp3519962 = *;                                                                       
                                                                                                    
   havoc ctmp3519962;                                                                               
   if (ctmp3519962) {                                                                               
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
    // 42.17: tmp3 = false;                                                                         
                                                                                                    
    tmp3 := false;                                                                                  
   } else {                                                                                         
                                                                                                    
    // 42.17: ctmp3519962 = *;                                                                      
                                                                                                    
    havoc ctmp3519962;                                                                              
    if (ctmp3519962) {                                                                              
                                                                                                    
     // 42.17: Tid tmpTid;                                                                          
                                                                                                    
                                                                                                    
     // 42.17: Node tmpValue;                                                                       
                                                                                                    
                                                                                                    
     // 42.17: Mover _m;                                                                            
                                                                                                    
                                                                                                    
     // 42.17: _m = writePermission(last.next, n);                                                  
                                                                                                    
     _m := m#moverPath(WriteEval.Node.next(tid: Tid,last: Node,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
     // 42.17: assume last.next == next;                                                            
                                                                                                    
     assume (Node.next[last]==next);                                                                
                                                                                                    
     // 42.17: assume !goesWrong(_m);                                                               
                                                                                                    
     assume !(transition($pc, _m) == PhaseError);                                                   
                                                                                                    
     // 42.17: assume last.next_nextThread == tid;                                                  
                                                                                                    
     assume (Node.next_nextThread[last]==tid);                                                      
                                                                                                    
     // 42.17: assume last.next_nextValue == next;                                                  
                                                                                                    
     assume (Node.next_nextValue[last]==next);                                                      
                                                                                                    
                                                                                                    
     // 42.17: last.next_nextThread := tmpTid as B;                                                 
                                                                                                    
                                                                                                    
     moverPath3545473 := WriteEval.Node.next_nextThread(tid: Tid,last: Node,tmpTid: Tid,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545473 := m#moverPath(moverPath3545473);                                                 
     path3545473 := p#moverPath(moverPath3545473);                                                  
     assume Node._state3545473 == Node._state && Node.value3545473 == Node.value && Node.next3545473 == Node.next && Node._lock3545473 == Node._lock && Node.next_nextThread3545473 == Node.next_nextThread && Node.next_nextValue3545473 == Node.next_nextValue && Queue._state3545473 == Queue._state && Queue.head3545473 == Queue.head && Queue.tail3545473 == Queue.tail && Queue._lock3545473 == Queue._lock && Queue.head_nextThread3545473 == Queue.head_nextThread && Queue.head_nextValue3545473 == Queue.head_nextValue && Queue.tail_nextThread3545473 == Queue.tail_nextThread && Queue.tail_nextValue3545473 == Queue.tail_nextValue && _m3545473 == _m && tmpValue3545473 == tmpValue && tmpTid3545473 == tmpTid && ctmp35199623545473 == ctmp3519962 && tmp33545473 == tmp3 && tmp23545473 == tmp2 && next3545473 == next && last3545473 == last && tmp13545473 == tmp1 && n3545473 == n && value3545473 == value && this3545473 == this && tid3545473 == tid && $pc3545473 == $pc;
     assume $recorded.state3545473 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (42.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (42.17): Reduction failure
     Node.next_nextThread[last] := tmpTid;                                                          
                                                                                                    
                                                                                                    
     // 42.17: last.next_nextValue := tmpValue as B;                                                
                                                                                                    
                                                                                                    
     moverPath3545476 := WriteEval.Node.next_nextValue(tid: Tid,last: Node,tmpValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545476 := m#moverPath(moverPath3545476);                                                 
     path3545476 := p#moverPath(moverPath3545476);                                                  
     assume Node._state3545476 == Node._state && Node.value3545476 == Node.value && Node.next3545476 == Node.next && Node._lock3545476 == Node._lock && Node.next_nextThread3545476 == Node.next_nextThread && Node.next_nextValue3545476 == Node.next_nextValue && Queue._state3545476 == Queue._state && Queue.head3545476 == Queue.head && Queue.tail3545476 == Queue.tail && Queue._lock3545476 == Queue._lock && Queue.head_nextThread3545476 == Queue.head_nextThread && Queue.head_nextValue3545476 == Queue.head_nextValue && Queue.tail_nextThread3545476 == Queue.tail_nextThread && Queue.tail_nextValue3545476 == Queue.tail_nextValue && _m3545476 == _m && tmpValue3545476 == tmpValue && tmpTid3545476 == tmpTid && ctmp35199623545476 == ctmp3519962 && tmp33545476 == tmp3 && tmp23545476 == tmp2 && next3545476 == next && last3545476 == last && tmp13545476 == tmp1 && n3545476 == n && value3545476 == value && this3545476 == this && tid3545476 == tid && $pc3545476 == $pc;
     assume $recorded.state3545476 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (42.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (42.17): Reduction failure
     Node.next_nextValue[last] := tmpValue;                                                         
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
                                                                                                    
     // 42.17: last.next := n;                                                                      
                                                                                                    
                                                                                                    
     moverPath3545480 := WriteEval.Node.next(tid: Tid,last: Node,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545480 := m#moverPath(moverPath3545480);                                                 
     path3545480 := p#moverPath(moverPath3545480);                                                  
     assume Node._state3545480 == Node._state && Node.value3545480 == Node.value && Node.next3545480 == Node.next && Node._lock3545480 == Node._lock && Node.next_nextThread3545480 == Node.next_nextThread && Node.next_nextValue3545480 == Node.next_nextValue && Queue._state3545480 == Queue._state && Queue.head3545480 == Queue.head && Queue.tail3545480 == Queue.tail && Queue._lock3545480 == Queue._lock && Queue.head_nextThread3545480 == Queue.head_nextThread && Queue.head_nextValue3545480 == Queue.head_nextValue && Queue.tail_nextThread3545480 == Queue.tail_nextThread && Queue.tail_nextValue3545480 == Queue.tail_nextValue && _m3545480 == _m && tmpValue3545480 == tmpValue && tmpTid3545480 == tmpTid && ctmp35199623545480 == ctmp3519962 && tmp33545480 == tmp3 && tmp23545480 == tmp2 && next3545480 == next && last3545480 == last && tmp13545480 == tmp1 && n3545480 == n && value3545480 == value && this3545480 == this && tid3545480 == tid && $pc3545480 == $pc;
     assume $recorded.state3545480 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (42.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, mover3545480);                                                          
     assert $pc != PhaseError;                                                                             // (42.17): Reduction failure
     Node.next[last] := n;                                                                          
     if (isLocal(Node._state[n], tid)) {                                                            
      Node._state[n] := SHARED();                                                                   
      assert isSharedAssignable(Node._state[Node.next[n]]);                                                // (42.17): n became shared, but n.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 42.17: tmp3 = true;                                                                         
                                                                                                    
     tmp3 := true;                                                                                  
    } else {                                                                                        
                                                                                                    
     // 42.17: assume last.next_nextThread == tid;                                                  
                                                                                                    
     assume (Node.next_nextThread[last]==tid);                                                      
                                                                                                    
     // 42.17: assume last.next_nextValue == next;                                                  
                                                                                                    
     assume (Node.next_nextValue[last]==next);                                                      
                                                                                                    
     // 42.17: Node _currentValue;                                                                  
                                                                                                    
                                                                                                    
     // 42.17: _currentValue := last.next  as B;                                                    
                                                                                                    
                                                                                                    
     moverPath3545503 := ReadEval.Node.next(tid: Tid,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545503 := m#moverPath(moverPath3545503);                                                 
     path3545503 := p#moverPath(moverPath3545503);                                                  
     assume Node._state3545503 == Node._state && Node.value3545503 == Node.value && Node.next3545503 == Node.next && Node._lock3545503 == Node._lock && Node.next_nextThread3545503 == Node.next_nextThread && Node.next_nextValue3545503 == Node.next_nextValue && Queue._state3545503 == Queue._state && Queue.head3545503 == Queue.head && Queue.tail3545503 == Queue.tail && Queue._lock3545503 == Queue._lock && Queue.head_nextThread3545503 == Queue.head_nextThread && Queue.head_nextValue3545503 == Queue.head_nextValue && Queue.tail_nextThread3545503 == Queue.tail_nextThread && Queue.tail_nextValue3545503 == Queue.tail_nextValue && _currentValue3545503 == _currentValue && ctmp35199623545503 == ctmp3519962 && tmp33545503 == tmp3 && tmp23545503 == tmp2 && next3545503 == next && last3545503 == last && tmp13545503 == tmp1 && n3545503 == n && value3545503 == value && this3545503 == this && tid3545503 == tid && $pc3545503 == $pc;
     assume $recorded.state3545503 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (42.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
                                                                                                    
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (42.17): Reduction failure
     _currentValue := Node.next[last];                                                              
                                                                                                    
                                                                                                    
     // 42.17: last.next := next as B;                                                              
                                                                                                    
                                                                                                    
     moverPath3545506 := WriteEval.Node.next(tid: Tid,last: Node,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545506 := m#moverPath(moverPath3545506);                                                 
     path3545506 := p#moverPath(moverPath3545506);                                                  
     assume Node._state3545506 == Node._state && Node.value3545506 == Node.value && Node.next3545506 == Node.next && Node._lock3545506 == Node._lock && Node.next_nextThread3545506 == Node.next_nextThread && Node.next_nextValue3545506 == Node.next_nextValue && Queue._state3545506 == Queue._state && Queue.head3545506 == Queue.head && Queue.tail3545506 == Queue.tail && Queue._lock3545506 == Queue._lock && Queue.head_nextThread3545506 == Queue.head_nextThread && Queue.head_nextValue3545506 == Queue.head_nextValue && Queue.tail_nextThread3545506 == Queue.tail_nextThread && Queue.tail_nextValue3545506 == Queue.tail_nextValue && _currentValue3545506 == _currentValue && ctmp35199623545506 == ctmp3519962 && tmp33545506 == tmp3 && tmp23545506 == tmp2 && next3545506 == next && last3545506 == last && tmp13545506 == tmp1 && n3545506 == n && value3545506 == value && this3545506 == this && tid3545506 == tid && $pc3545506 == $pc;
     assume $recorded.state3545506 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (42.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (42.17): Reduction failure
     Node.next[last] := next;                                                                       
     if (isLocal(Node._state[next], tid)) {                                                         
      Node._state[next] := SHARED();                                                                
      assert isSharedAssignable(Node._state[Node.next[next]]);                                             // (42.17): next became shared, but next.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 42.17: Mover _m;                                                                            
                                                                                                    
                                                                                                    
     // 42.17: _m = writePermission(last.next, n);                                                  
                                                                                                    
     _m := m#moverPath(WriteEval.Node.next(tid: Tid,last: Node,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
                                                                                                    
     // 42.17: last.next := _currentValue as B;                                                     
                                                                                                    
                                                                                                    
     moverPath3545518 := WriteEval.Node.next(tid: Tid,last: Node,_currentValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545518 := m#moverPath(moverPath3545518);                                                 
     path3545518 := p#moverPath(moverPath3545518);                                                  
     assume Node._state3545518 == Node._state && Node.value3545518 == Node.value && Node.next3545518 == Node.next && Node._lock3545518 == Node._lock && Node.next_nextThread3545518 == Node.next_nextThread && Node.next_nextValue3545518 == Node.next_nextValue && Queue._state3545518 == Queue._state && Queue.head3545518 == Queue.head && Queue.tail3545518 == Queue.tail && Queue._lock3545518 == Queue._lock && Queue.head_nextThread3545518 == Queue.head_nextThread && Queue.head_nextValue3545518 == Queue.head_nextValue && Queue.tail_nextThread3545518 == Queue.tail_nextThread && Queue.tail_nextValue3545518 == Queue.tail_nextValue && _m3545518 == _m && _currentValue3545518 == _currentValue && ctmp35199623545518 == ctmp3519962 && tmp33545518 == tmp3 && tmp23545518 == tmp2 && next3545518 == next && last3545518 == last && tmp13545518 == tmp1 && n3545518 == n && value3545518 == value && this3545518 == this && tid3545518 == tid && $pc3545518 == $pc;
     assume $recorded.state3545518 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (42.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (42.17): Reduction failure
     Node.next[last] := _currentValue;                                                              
     if (isLocal(Node._state[_currentValue], tid)) {                                                
      Node._state[_currentValue] := SHARED();                                                       
      assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                    // (42.17): _currentValue became shared, but _currentValue.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 42.17: assume goesWrong(_m);                                                                
                                                                                                    
     assume transition($pc, _m) == PhaseError;                                                      
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
                                                                                                    
     // 42.17: last.next := n;                                                                      
                                                                                                    
                                                                                                    
     moverPath3545525 := WriteEval.Node.next(tid: Tid,last: Node,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545525 := m#moverPath(moverPath3545525);                                                 
     path3545525 := p#moverPath(moverPath3545525);                                                  
     assume Node._state3545525 == Node._state && Node.value3545525 == Node.value && Node.next3545525 == Node.next && Node._lock3545525 == Node._lock && Node.next_nextThread3545525 == Node.next_nextThread && Node.next_nextValue3545525 == Node.next_nextValue && Queue._state3545525 == Queue._state && Queue.head3545525 == Queue.head && Queue.tail3545525 == Queue.tail && Queue._lock3545525 == Queue._lock && Queue.head_nextThread3545525 == Queue.head_nextThread && Queue.head_nextValue3545525 == Queue.head_nextValue && Queue.tail_nextThread3545525 == Queue.tail_nextThread && Queue.tail_nextValue3545525 == Queue.tail_nextValue && _m3545525 == _m && _currentValue3545525 == _currentValue && ctmp35199623545525 == ctmp3519962 && tmp33545525 == tmp3 && tmp23545525 == tmp2 && next3545525 == next && last3545525 == last && tmp13545525 == tmp1 && n3545525 == n && value3545525 == value && this3545525 == this && tid3545525 == tid && $pc3545525 == $pc;
     assume $recorded.state3545525 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume last != Node.null;                                                                     
     } else {                                                                                       
      assert last != Node.null;                                                                            // (42.17): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, mover3545525);                                                          
     assert $pc != PhaseError;                                                                             // (42.17): Reduction failure
     Node.next[last] := n;                                                                          
     if (isLocal(Node._state[n], tid)) {                                                            
      Node._state[n] := SHARED();                                                                   
      assert isSharedAssignable(Node._state[Node.next[n]]);                                                // (42.17): n became shared, but n.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 42.17: tmp3 = false;                                                                        
                                                                                                    
     tmp3 := false;                                                                                 
    }                                                                                               
   }                                                                                                
   if (tmp3) {                                                                                      
                                                                                                    
    // 43.21: yield;                                                                                
                                                                                                    
    assume Node._state3545535 == Node._state && Node.value3545535 == Node.value && Node.next3545535 == Node.next && Node._lock3545535 == Node._lock && Node.next_nextThread3545535 == Node.next_nextThread && Node.next_nextValue3545535 == Node.next_nextValue && Queue._state3545535 == Queue._state && Queue.head3545535 == Queue.head && Queue.tail3545535 == Queue.tail && Queue._lock3545535 == Queue._lock && Queue.head_nextThread3545535 == Queue.head_nextThread && Queue.head_nextValue3545535 == Queue.head_nextValue && Queue.tail_nextThread3545535 == Queue.tail_nextThread && Queue.tail_nextValue3545535 == Queue.tail_nextValue && tmp33545535 == tmp3 && tmp23545535 == tmp2 && next3545535 == next && last3545535 == last && tmp13545535 == tmp1 && n3545535 == n && value3545535 == value && this3545535 == this && tid3545535 == tid;
    assume $recorded.state3545535 == 1;                                                             
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (43.21): Object invariant may not hold.
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (43.21): Object invariant may not hold.
    call Yield(tid);                                                                                
    assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (43.21): Object invariant may not hold.
    assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (43.21): Object invariant may not hold.
    $pc := PreCommit;                                                                               
    assume Node._state3545535_post == Node._state && Node.value3545535_post == Node.value && Node.next3545535_post == Node.next && Node._lock3545535_post == Node._lock && Node.next_nextThread3545535_post == Node.next_nextThread && Node.next_nextValue3545535_post == Node.next_nextValue && Queue._state3545535_post == Queue._state && Queue.head3545535_post == Queue.head && Queue.tail3545535_post == Queue.tail && Queue._lock3545535_post == Queue._lock && Queue.head_nextThread3545535_post == Queue.head_nextThread && Queue.head_nextValue3545535_post == Queue.head_nextValue && Queue.tail_nextThread3545535_post == Queue.tail_nextThread && Queue.tail_nextValue3545535_post == Queue.tail_nextValue && tmp33545535_post == tmp3 && tmp23545535_post == tmp2 && next3545535_post == next && last3545535_post == last && tmp13545535_post == tmp1 && n3545535_post == n && value3545535_post == value && this3545535_post == this && tid3545535_post == tid;
    assume $recorded.state3545535_post == 1;                                                        
                                                                                                    
    // 44.21: boolean tmp4;                                                                         
                                                                                                    
    // NoOp: 'TraceOff'                                                                             
                                                                                                    
    // 44.21: boolean ctmp3519972;                                                                  
                                                                                                    
                                                                                                    
    // 44.21: ctmp3519972 = *;                                                                      
                                                                                                    
    havoc ctmp3519972;                                                                              
    if (ctmp3519972) {                                                                              
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
     // 44.21: tmp4 = false;                                                                        
                                                                                                    
     tmp4 := false;                                                                                 
    } else {                                                                                        
                                                                                                    
     // 44.21: ctmp3519972 = *;                                                                     
                                                                                                    
     havoc ctmp3519972;                                                                             
     if (ctmp3519972) {                                                                             
                                                                                                    
      // 44.21: Tid tmpTid;                                                                         
                                                                                                    
                                                                                                    
      // 44.21: Node tmpValue;                                                                      
                                                                                                    
                                                                                                    
      // 44.21: Mover _m;                                                                           
                                                                                                    
                                                                                                    
      // 44.21: _m = writePermission(this.tail, n);                                                 
                                                                                                    
      _m := m#moverPath(WriteEval.Queue.tail(tid: Tid,this: Queue,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
      // 44.21: assume this.tail == last;                                                           
                                                                                                    
      assume (Queue.tail[this]==last);                                                              
                                                                                                    
      // 44.21: assume !goesWrong(_m);                                                              
                                                                                                    
      assume !(transition($pc, _m) == PhaseError);                                                  
                                                                                                    
      // 44.21: assume this.tail_nextThread == tid;                                                 
                                                                                                    
      assume (Queue.tail_nextThread[this]==tid);                                                    
                                                                                                    
      // 44.21: assume this.tail_nextValue == last;                                                 
                                                                                                    
      assume (Queue.tail_nextValue[this]==last);                                                    
                                                                                                    
                                                                                                    
      // 44.21: this.tail_nextThread := tmpTid as B;                                                
                                                                                                    
                                                                                                    
      moverPath3545595 := WriteEval.Queue.tail_nextThread(tid: Tid,this: Queue,tmpTid: Tid,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3545595 := m#moverPath(moverPath3545595);                                                
      path3545595 := p#moverPath(moverPath3545595);                                                 
      assume Node._state3545595 == Node._state && Node.value3545595 == Node.value && Node.next3545595 == Node.next && Node._lock3545595 == Node._lock && Node.next_nextThread3545595 == Node.next_nextThread && Node.next_nextValue3545595 == Node.next_nextValue && Queue._state3545595 == Queue._state && Queue.head3545595 == Queue.head && Queue.tail3545595 == Queue.tail && Queue._lock3545595 == Queue._lock && Queue.head_nextThread3545595 == Queue.head_nextThread && Queue.head_nextValue3545595 == Queue.head_nextValue && Queue.tail_nextThread3545595 == Queue.tail_nextThread && Queue.tail_nextValue3545595 == Queue.tail_nextValue && _m3545595 == _m && tmpValue3545595 == tmpValue && tmpTid3545595 == tmpTid && ctmp35199723545595 == ctmp3519972 && tmp43545595 == tmp4 && tmp33545595 == tmp3 && tmp23545595 == tmp2 && next3545595 == next && last3545595 == last && tmp13545595 == tmp1 && n3545595 == n && value3545595 == value && this3545595 == this && tid3545595 == tid && $pc3545595 == $pc;
      assume $recorded.state3545595 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (44.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (44.21): Reduction failure
      Queue.tail_nextThread[this] := tmpTid;                                                        
                                                                                                    
                                                                                                    
      // 44.21: this.tail_nextValue := tmpValue as B;                                               
                                                                                                    
                                                                                                    
      moverPath3545598 := WriteEval.Queue.tail_nextValue(tid: Tid,this: Queue,tmpValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3545598 := m#moverPath(moverPath3545598);                                                
      path3545598 := p#moverPath(moverPath3545598);                                                 
      assume Node._state3545598 == Node._state && Node.value3545598 == Node.value && Node.next3545598 == Node.next && Node._lock3545598 == Node._lock && Node.next_nextThread3545598 == Node.next_nextThread && Node.next_nextValue3545598 == Node.next_nextValue && Queue._state3545598 == Queue._state && Queue.head3545598 == Queue.head && Queue.tail3545598 == Queue.tail && Queue._lock3545598 == Queue._lock && Queue.head_nextThread3545598 == Queue.head_nextThread && Queue.head_nextValue3545598 == Queue.head_nextValue && Queue.tail_nextThread3545598 == Queue.tail_nextThread && Queue.tail_nextValue3545598 == Queue.tail_nextValue && _m3545598 == _m && tmpValue3545598 == tmpValue && tmpTid3545598 == tmpTid && ctmp35199723545598 == ctmp3519972 && tmp43545598 == tmp4 && tmp33545598 == tmp3 && tmp23545598 == tmp2 && next3545598 == next && last3545598 == last && tmp13545598 == tmp1 && n3545598 == n && value3545598 == value && this3545598 == this && tid3545598 == tid && $pc3545598 == $pc;
      assume $recorded.state3545598 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (44.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (44.21): Reduction failure
      Queue.tail_nextValue[this] := tmpValue;                                                       
      // NoOp: 'TraceOn'                                                                            
                                                                                                    
                                                                                                    
      // 44.21: this.tail := n;                                                                     
                                                                                                    
                                                                                                    
      moverPath3545602 := WriteEval.Queue.tail(tid: Tid,this: Queue,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3545602 := m#moverPath(moverPath3545602);                                                
      path3545602 := p#moverPath(moverPath3545602);                                                 
      assume Node._state3545602 == Node._state && Node.value3545602 == Node.value && Node.next3545602 == Node.next && Node._lock3545602 == Node._lock && Node.next_nextThread3545602 == Node.next_nextThread && Node.next_nextValue3545602 == Node.next_nextValue && Queue._state3545602 == Queue._state && Queue.head3545602 == Queue.head && Queue.tail3545602 == Queue.tail && Queue._lock3545602 == Queue._lock && Queue.head_nextThread3545602 == Queue.head_nextThread && Queue.head_nextValue3545602 == Queue.head_nextValue && Queue.tail_nextThread3545602 == Queue.tail_nextThread && Queue.tail_nextValue3545602 == Queue.tail_nextValue && _m3545602 == _m && tmpValue3545602 == tmpValue && tmpTid3545602 == tmpTid && ctmp35199723545602 == ctmp3519972 && tmp43545602 == tmp4 && tmp33545602 == tmp3 && tmp23545602 == tmp2 && next3545602 == next && last3545602 == last && tmp13545602 == tmp1 && n3545602 == n && value3545602 == value && this3545602 == this && tid3545602 == tid && $pc3545602 == $pc;
      assume $recorded.state3545602 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (44.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, mover3545602);                                                         
      assert $pc != PhaseError;                                                                            // (44.21): Reduction failure
      Queue.tail[this] := n;                                                                        
      if (isLocal(Node._state[n], tid)) {                                                           
       Node._state[n] := SHARED();                                                                  
       assert isSharedAssignable(Node._state[Node.next[n]]);                                               // (44.21): n became shared, but n.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 44.21: tmp4 = true;                                                                        
                                                                                                    
      tmp4 := true;                                                                                 
     } else {                                                                                       
                                                                                                    
      // 44.21: assume this.tail_nextThread == tid;                                                 
                                                                                                    
      assume (Queue.tail_nextThread[this]==tid);                                                    
                                                                                                    
      // 44.21: assume this.tail_nextValue == last;                                                 
                                                                                                    
      assume (Queue.tail_nextValue[this]==last);                                                    
                                                                                                    
      // 44.21: Node _currentValue;                                                                 
                                                                                                    
                                                                                                    
      // 44.21: _currentValue := this.tail  as B;                                                   
                                                                                                    
                                                                                                    
      moverPath3545625 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3545625 := m#moverPath(moverPath3545625);                                                
      path3545625 := p#moverPath(moverPath3545625);                                                 
      assume Node._state3545625 == Node._state && Node.value3545625 == Node.value && Node.next3545625 == Node.next && Node._lock3545625 == Node._lock && Node.next_nextThread3545625 == Node.next_nextThread && Node.next_nextValue3545625 == Node.next_nextValue && Queue._state3545625 == Queue._state && Queue.head3545625 == Queue.head && Queue.tail3545625 == Queue.tail && Queue._lock3545625 == Queue._lock && Queue.head_nextThread3545625 == Queue.head_nextThread && Queue.head_nextValue3545625 == Queue.head_nextValue && Queue.tail_nextThread3545625 == Queue.tail_nextThread && Queue.tail_nextValue3545625 == Queue.tail_nextValue && _currentValue3545625 == _currentValue && ctmp35199723545625 == ctmp3519972 && tmp43545625 == tmp4 && tmp33545625 == tmp3 && tmp23545625 == tmp2 && next3545625 == next && last3545625 == last && tmp13545625 == tmp1 && n3545625 == n && value3545625 == value && this3545625 == this && tid3545625 == tid && $pc3545625 == $pc;
      assume $recorded.state3545625 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (44.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
                                                                                                    
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (44.21): Reduction failure
      _currentValue := Queue.tail[this];                                                            
                                                                                                    
                                                                                                    
      // 44.21: this.tail := last as B;                                                             
                                                                                                    
                                                                                                    
      moverPath3545628 := WriteEval.Queue.tail(tid: Tid,this: Queue,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3545628 := m#moverPath(moverPath3545628);                                                
      path3545628 := p#moverPath(moverPath3545628);                                                 
      assume Node._state3545628 == Node._state && Node.value3545628 == Node.value && Node.next3545628 == Node.next && Node._lock3545628 == Node._lock && Node.next_nextThread3545628 == Node.next_nextThread && Node.next_nextValue3545628 == Node.next_nextValue && Queue._state3545628 == Queue._state && Queue.head3545628 == Queue.head && Queue.tail3545628 == Queue.tail && Queue._lock3545628 == Queue._lock && Queue.head_nextThread3545628 == Queue.head_nextThread && Queue.head_nextValue3545628 == Queue.head_nextValue && Queue.tail_nextThread3545628 == Queue.tail_nextThread && Queue.tail_nextValue3545628 == Queue.tail_nextValue && _currentValue3545628 == _currentValue && ctmp35199723545628 == ctmp3519972 && tmp43545628 == tmp4 && tmp33545628 == tmp3 && tmp23545628 == tmp2 && next3545628 == next && last3545628 == last && tmp13545628 == tmp1 && n3545628 == n && value3545628 == value && this3545628 == this && tid3545628 == tid && $pc3545628 == $pc;
      assume $recorded.state3545628 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (44.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (44.21): Reduction failure
      Queue.tail[this] := last;                                                                     
      if (isLocal(Node._state[last], tid)) {                                                        
       Node._state[last] := SHARED();                                                               
       assert isSharedAssignable(Node._state[Node.next[last]]);                                            // (44.21): last became shared, but last.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 44.21: Mover _m;                                                                           
                                                                                                    
                                                                                                    
      // 44.21: _m = writePermission(this.tail, n);                                                 
                                                                                                    
      _m := m#moverPath(WriteEval.Queue.tail(tid: Tid,this: Queue,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
                                                                                                    
      // 44.21: this.tail := _currentValue as B;                                                    
                                                                                                    
                                                                                                    
      moverPath3545640 := WriteEval.Queue.tail(tid: Tid,this: Queue,_currentValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3545640 := m#moverPath(moverPath3545640);                                                
      path3545640 := p#moverPath(moverPath3545640);                                                 
      assume Node._state3545640 == Node._state && Node.value3545640 == Node.value && Node.next3545640 == Node.next && Node._lock3545640 == Node._lock && Node.next_nextThread3545640 == Node.next_nextThread && Node.next_nextValue3545640 == Node.next_nextValue && Queue._state3545640 == Queue._state && Queue.head3545640 == Queue.head && Queue.tail3545640 == Queue.tail && Queue._lock3545640 == Queue._lock && Queue.head_nextThread3545640 == Queue.head_nextThread && Queue.head_nextValue3545640 == Queue.head_nextValue && Queue.tail_nextThread3545640 == Queue.tail_nextThread && Queue.tail_nextValue3545640 == Queue.tail_nextValue && _m3545640 == _m && _currentValue3545640 == _currentValue && ctmp35199723545640 == ctmp3519972 && tmp43545640 == tmp4 && tmp33545640 == tmp3 && tmp23545640 == tmp2 && next3545640 == next && last3545640 == last && tmp13545640 == tmp1 && n3545640 == n && value3545640 == value && this3545640 == this && tid3545640 == tid && $pc3545640 == $pc;
      assume $recorded.state3545640 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (44.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (44.21): Reduction failure
      Queue.tail[this] := _currentValue;                                                            
      if (isLocal(Node._state[_currentValue], tid)) {                                               
       Node._state[_currentValue] := SHARED();                                                      
       assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                   // (44.21): _currentValue became shared, but _currentValue.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 44.21: assume goesWrong(_m);                                                               
                                                                                                    
      assume transition($pc, _m) == PhaseError;                                                     
      // NoOp: 'TraceOn'                                                                            
                                                                                                    
                                                                                                    
      // 44.21: this.tail := n;                                                                     
                                                                                                    
                                                                                                    
      moverPath3545647 := WriteEval.Queue.tail(tid: Tid,this: Queue,n: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3545647 := m#moverPath(moverPath3545647);                                                
      path3545647 := p#moverPath(moverPath3545647);                                                 
      assume Node._state3545647 == Node._state && Node.value3545647 == Node.value && Node.next3545647 == Node.next && Node._lock3545647 == Node._lock && Node.next_nextThread3545647 == Node.next_nextThread && Node.next_nextValue3545647 == Node.next_nextValue && Queue._state3545647 == Queue._state && Queue.head3545647 == Queue.head && Queue.tail3545647 == Queue.tail && Queue._lock3545647 == Queue._lock && Queue.head_nextThread3545647 == Queue.head_nextThread && Queue.head_nextValue3545647 == Queue.head_nextValue && Queue.tail_nextThread3545647 == Queue.tail_nextThread && Queue.tail_nextValue3545647 == Queue.tail_nextValue && _m3545647 == _m && _currentValue3545647 == _currentValue && ctmp35199723545647 == ctmp3519972 && tmp43545647 == tmp4 && tmp33545647 == tmp3 && tmp23545647 == tmp2 && next3545647 == next && last3545647 == last && tmp13545647 == tmp1 && n3545647 == n && value3545647 == value && this3545647 == this && tid3545647 == tid && $pc3545647 == $pc;
      assume $recorded.state3545647 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (44.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, mover3545647);                                                         
      assert $pc != PhaseError;                                                                            // (44.21): Reduction failure
      Queue.tail[this] := n;                                                                        
      if (isLocal(Node._state[n], tid)) {                                                           
       Node._state[n] := SHARED();                                                                  
       assert isSharedAssignable(Node._state[Node.next[n]]);                                               // (44.21): n became shared, but n.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 44.21: tmp4 = false;                                                                       
                                                                                                    
      tmp4 := false;                                                                                
     }                                                                                              
    }                                                                                               
                                                                                                    
    // 45.21:  return;                                                                              
                                                                                                    
    assume Node._state3545657 == Node._state && Node.value3545657 == Node.value && Node.next3545657 == Node.next && Node._lock3545657 == Node._lock && Node.next_nextThread3545657 == Node.next_nextThread && Node.next_nextValue3545657 == Node.next_nextValue && Queue._state3545657 == Queue._state && Queue.head3545657 == Queue.head && Queue.tail3545657 == Queue.tail && Queue._lock3545657 == Queue._lock && Queue.head_nextThread3545657 == Queue.head_nextThread && Queue.head_nextValue3545657 == Queue.head_nextValue && Queue.tail_nextThread3545657 == Queue.tail_nextThread && Queue.tail_nextValue3545657 == Queue.tail_nextValue && tmp43545657 == tmp4 && tmp33545657 == tmp3 && tmp23545657 == tmp2 && next3545657 == next && last3545657 == last && tmp13545657 == tmp1 && n3545657 == n && value3545657 == value && this3545657 == this && tid3545657 == tid;
    assume $recorded.state3545657 == 1;                                                             
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (45.21): Object invariant may not hold.
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (45.21): Object invariant may not hold.
    return;                                                                                         
   } else {                                                                                         
   }                                                                                                
  } else {                                                                                          
                                                                                                    
   // 48.18: boolean tmp5;                                                                          
                                                                                                    
   // NoOp: 'TraceOff'                                                                              
                                                                                                    
   // 48.18: boolean ctmp3519986;                                                                   
                                                                                                    
                                                                                                    
   // 48.18: ctmp3519986 = *;                                                                       
                                                                                                    
   havoc ctmp3519986;                                                                               
   if (ctmp3519986) {                                                                               
    // NoOp: 'TraceOn'                                                                              
                                                                                                    
    // 48.18: tmp5 = false;                                                                         
                                                                                                    
    tmp5 := false;                                                                                  
   } else {                                                                                         
                                                                                                    
    // 48.18: ctmp3519986 = *;                                                                      
                                                                                                    
    havoc ctmp3519986;                                                                              
    if (ctmp3519986) {                                                                              
                                                                                                    
     // 48.18: Tid tmpTid;                                                                          
                                                                                                    
                                                                                                    
     // 48.18: Node tmpValue;                                                                       
                                                                                                    
                                                                                                    
     // 48.18: Mover _m;                                                                            
                                                                                                    
                                                                                                    
     // 48.18: _m = writePermission(this.tail, next);                                               
                                                                                                    
     _m := m#moverPath(WriteEval.Queue.tail(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
     // 48.18: assume this.tail == last;                                                            
                                                                                                    
     assume (Queue.tail[this]==last);                                                               
                                                                                                    
     // 48.18: assume !goesWrong(_m);                                                               
                                                                                                    
     assume !(transition($pc, _m) == PhaseError);                                                   
                                                                                                    
     // 48.18: assume this.tail_nextThread == tid;                                                  
                                                                                                    
     assume (Queue.tail_nextThread[this]==tid);                                                     
                                                                                                    
     // 48.18: assume this.tail_nextValue == last;                                                  
                                                                                                    
     assume (Queue.tail_nextValue[this]==last);                                                     
                                                                                                    
                                                                                                    
     // 48.18: this.tail_nextThread := tmpTid as B;                                                 
                                                                                                    
                                                                                                    
     moverPath3545722 := WriteEval.Queue.tail_nextThread(tid: Tid,this: Queue,tmpTid: Tid,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545722 := m#moverPath(moverPath3545722);                                                 
     path3545722 := p#moverPath(moverPath3545722);                                                  
     assume Node._state3545722 == Node._state && Node.value3545722 == Node.value && Node.next3545722 == Node.next && Node._lock3545722 == Node._lock && Node.next_nextThread3545722 == Node.next_nextThread && Node.next_nextValue3545722 == Node.next_nextValue && Queue._state3545722 == Queue._state && Queue.head3545722 == Queue.head && Queue.tail3545722 == Queue.tail && Queue._lock3545722 == Queue._lock && Queue.head_nextThread3545722 == Queue.head_nextThread && Queue.head_nextValue3545722 == Queue.head_nextValue && Queue.tail_nextThread3545722 == Queue.tail_nextThread && Queue.tail_nextValue3545722 == Queue.tail_nextValue && _m3545722 == _m && tmpValue3545722 == tmpValue && tmpTid3545722 == tmpTid && ctmp35199863545722 == ctmp3519986 && tmp53545722 == tmp5 && tmp23545722 == tmp2 && next3545722 == next && last3545722 == last && tmp13545722 == tmp1 && n3545722 == n && value3545722 == value && this3545722 == this && tid3545722 == tid && $pc3545722 == $pc;
     assume $recorded.state3545722 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (48.18): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (48.18): Reduction failure
     Queue.tail_nextThread[this] := tmpTid;                                                         
                                                                                                    
                                                                                                    
     // 48.18: this.tail_nextValue := tmpValue as B;                                                
                                                                                                    
                                                                                                    
     moverPath3545725 := WriteEval.Queue.tail_nextValue(tid: Tid,this: Queue,tmpValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545725 := m#moverPath(moverPath3545725);                                                 
     path3545725 := p#moverPath(moverPath3545725);                                                  
     assume Node._state3545725 == Node._state && Node.value3545725 == Node.value && Node.next3545725 == Node.next && Node._lock3545725 == Node._lock && Node.next_nextThread3545725 == Node.next_nextThread && Node.next_nextValue3545725 == Node.next_nextValue && Queue._state3545725 == Queue._state && Queue.head3545725 == Queue.head && Queue.tail3545725 == Queue.tail && Queue._lock3545725 == Queue._lock && Queue.head_nextThread3545725 == Queue.head_nextThread && Queue.head_nextValue3545725 == Queue.head_nextValue && Queue.tail_nextThread3545725 == Queue.tail_nextThread && Queue.tail_nextValue3545725 == Queue.tail_nextValue && _m3545725 == _m && tmpValue3545725 == tmpValue && tmpTid3545725 == tmpTid && ctmp35199863545725 == ctmp3519986 && tmp53545725 == tmp5 && tmp23545725 == tmp2 && next3545725 == next && last3545725 == last && tmp13545725 == tmp1 && n3545725 == n && value3545725 == value && this3545725 == this && tid3545725 == tid && $pc3545725 == $pc;
     assume $recorded.state3545725 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (48.18): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (48.18): Reduction failure
     Queue.tail_nextValue[this] := tmpValue;                                                        
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
                                                                                                    
     // 48.18: this.tail := next;                                                                   
                                                                                                    
                                                                                                    
     moverPath3545729 := WriteEval.Queue.tail(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545729 := m#moverPath(moverPath3545729);                                                 
     path3545729 := p#moverPath(moverPath3545729);                                                  
     assume Node._state3545729 == Node._state && Node.value3545729 == Node.value && Node.next3545729 == Node.next && Node._lock3545729 == Node._lock && Node.next_nextThread3545729 == Node.next_nextThread && Node.next_nextValue3545729 == Node.next_nextValue && Queue._state3545729 == Queue._state && Queue.head3545729 == Queue.head && Queue.tail3545729 == Queue.tail && Queue._lock3545729 == Queue._lock && Queue.head_nextThread3545729 == Queue.head_nextThread && Queue.head_nextValue3545729 == Queue.head_nextValue && Queue.tail_nextThread3545729 == Queue.tail_nextThread && Queue.tail_nextValue3545729 == Queue.tail_nextValue && _m3545729 == _m && tmpValue3545729 == tmpValue && tmpTid3545729 == tmpTid && ctmp35199863545729 == ctmp3519986 && tmp53545729 == tmp5 && tmp23545729 == tmp2 && next3545729 == next && last3545729 == last && tmp13545729 == tmp1 && n3545729 == n && value3545729 == value && this3545729 == this && tid3545729 == tid && $pc3545729 == $pc;
     assume $recorded.state3545729 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (48.18): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, mover3545729);                                                          
     assert $pc != PhaseError;                                                                             // (48.18): Reduction failure
     Queue.tail[this] := next;                                                                      
     if (isLocal(Node._state[next], tid)) {                                                         
      Node._state[next] := SHARED();                                                                
      assert isSharedAssignable(Node._state[Node.next[next]]);                                             // (48.18): next became shared, but next.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 48.18: tmp5 = true;                                                                         
                                                                                                    
     tmp5 := true;                                                                                  
    } else {                                                                                        
                                                                                                    
     // 48.18: assume this.tail_nextThread == tid;                                                  
                                                                                                    
     assume (Queue.tail_nextThread[this]==tid);                                                     
                                                                                                    
     // 48.18: assume this.tail_nextValue == last;                                                  
                                                                                                    
     assume (Queue.tail_nextValue[this]==last);                                                     
                                                                                                    
     // 48.18: Node _currentValue;                                                                  
                                                                                                    
                                                                                                    
     // 48.18: _currentValue := this.tail  as B;                                                    
                                                                                                    
                                                                                                    
     moverPath3545752 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545752 := m#moverPath(moverPath3545752);                                                 
     path3545752 := p#moverPath(moverPath3545752);                                                  
     assume Node._state3545752 == Node._state && Node.value3545752 == Node.value && Node.next3545752 == Node.next && Node._lock3545752 == Node._lock && Node.next_nextThread3545752 == Node.next_nextThread && Node.next_nextValue3545752 == Node.next_nextValue && Queue._state3545752 == Queue._state && Queue.head3545752 == Queue.head && Queue.tail3545752 == Queue.tail && Queue._lock3545752 == Queue._lock && Queue.head_nextThread3545752 == Queue.head_nextThread && Queue.head_nextValue3545752 == Queue.head_nextValue && Queue.tail_nextThread3545752 == Queue.tail_nextThread && Queue.tail_nextValue3545752 == Queue.tail_nextValue && _currentValue3545752 == _currentValue && ctmp35199863545752 == ctmp3519986 && tmp53545752 == tmp5 && tmp23545752 == tmp2 && next3545752 == next && last3545752 == last && tmp13545752 == tmp1 && n3545752 == n && value3545752 == value && this3545752 == this && tid3545752 == tid && $pc3545752 == $pc;
     assume $recorded.state3545752 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (48.18): Cannot have potential null deference in left-mover part.
     }                                                                                              
                                                                                                    
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (48.18): Reduction failure
     _currentValue := Queue.tail[this];                                                             
                                                                                                    
                                                                                                    
     // 48.18: this.tail := last as B;                                                              
                                                                                                    
                                                                                                    
     moverPath3545755 := WriteEval.Queue.tail(tid: Tid,this: Queue,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545755 := m#moverPath(moverPath3545755);                                                 
     path3545755 := p#moverPath(moverPath3545755);                                                  
     assume Node._state3545755 == Node._state && Node.value3545755 == Node.value && Node.next3545755 == Node.next && Node._lock3545755 == Node._lock && Node.next_nextThread3545755 == Node.next_nextThread && Node.next_nextValue3545755 == Node.next_nextValue && Queue._state3545755 == Queue._state && Queue.head3545755 == Queue.head && Queue.tail3545755 == Queue.tail && Queue._lock3545755 == Queue._lock && Queue.head_nextThread3545755 == Queue.head_nextThread && Queue.head_nextValue3545755 == Queue.head_nextValue && Queue.tail_nextThread3545755 == Queue.tail_nextThread && Queue.tail_nextValue3545755 == Queue.tail_nextValue && _currentValue3545755 == _currentValue && ctmp35199863545755 == ctmp3519986 && tmp53545755 == tmp5 && tmp23545755 == tmp2 && next3545755 == next && last3545755 == last && tmp13545755 == tmp1 && n3545755 == n && value3545755 == value && this3545755 == this && tid3545755 == tid && $pc3545755 == $pc;
     assume $recorded.state3545755 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (48.18): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (48.18): Reduction failure
     Queue.tail[this] := last;                                                                      
     if (isLocal(Node._state[last], tid)) {                                                         
      Node._state[last] := SHARED();                                                                
      assert isSharedAssignable(Node._state[Node.next[last]]);                                             // (48.18): last became shared, but last.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 48.18: Mover _m;                                                                            
                                                                                                    
                                                                                                    
     // 48.18: _m = writePermission(this.tail, next);                                               
                                                                                                    
     _m := m#moverPath(WriteEval.Queue.tail(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
                                                                                                    
     // 48.18: this.tail := _currentValue as B;                                                     
                                                                                                    
                                                                                                    
     moverPath3545767 := WriteEval.Queue.tail(tid: Tid,this: Queue,_currentValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545767 := m#moverPath(moverPath3545767);                                                 
     path3545767 := p#moverPath(moverPath3545767);                                                  
     assume Node._state3545767 == Node._state && Node.value3545767 == Node.value && Node.next3545767 == Node.next && Node._lock3545767 == Node._lock && Node.next_nextThread3545767 == Node.next_nextThread && Node.next_nextValue3545767 == Node.next_nextValue && Queue._state3545767 == Queue._state && Queue.head3545767 == Queue.head && Queue.tail3545767 == Queue.tail && Queue._lock3545767 == Queue._lock && Queue.head_nextThread3545767 == Queue.head_nextThread && Queue.head_nextValue3545767 == Queue.head_nextValue && Queue.tail_nextThread3545767 == Queue.tail_nextThread && Queue.tail_nextValue3545767 == Queue.tail_nextValue && _m3545767 == _m && _currentValue3545767 == _currentValue && ctmp35199863545767 == ctmp3519986 && tmp53545767 == tmp5 && tmp23545767 == tmp2 && next3545767 == next && last3545767 == last && tmp13545767 == tmp1 && n3545767 == n && value3545767 == value && this3545767 == this && tid3545767 == tid && $pc3545767 == $pc;
     assume $recorded.state3545767 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (48.18): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, _B);                                                                    
     assert $pc != PhaseError;                                                                             // (48.18): Reduction failure
     Queue.tail[this] := _currentValue;                                                             
     if (isLocal(Node._state[_currentValue], tid)) {                                                
      Node._state[_currentValue] := SHARED();                                                       
      assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                    // (48.18): _currentValue became shared, but _currentValue.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 48.18: assume goesWrong(_m);                                                                
                                                                                                    
     assume transition($pc, _m) == PhaseError;                                                      
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
                                                                                                    
     // 48.18: this.tail := next;                                                                   
                                                                                                    
                                                                                                    
     moverPath3545774 := WriteEval.Queue.tail(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
     mover3545774 := m#moverPath(moverPath3545774);                                                 
     path3545774 := p#moverPath(moverPath3545774);                                                  
     assume Node._state3545774 == Node._state && Node.value3545774 == Node.value && Node.next3545774 == Node.next && Node._lock3545774 == Node._lock && Node.next_nextThread3545774 == Node.next_nextThread && Node.next_nextValue3545774 == Node.next_nextValue && Queue._state3545774 == Queue._state && Queue.head3545774 == Queue.head && Queue.tail3545774 == Queue.tail && Queue._lock3545774 == Queue._lock && Queue.head_nextThread3545774 == Queue.head_nextThread && Queue.head_nextValue3545774 == Queue.head_nextValue && Queue.tail_nextThread3545774 == Queue.tail_nextThread && Queue.tail_nextValue3545774 == Queue.tail_nextValue && _m3545774 == _m && _currentValue3545774 == _currentValue && ctmp35199863545774 == ctmp3519986 && tmp53545774 == tmp5 && tmp23545774 == tmp2 && next3545774 == next && last3545774 == last && tmp13545774 == tmp1 && n3545774 == n && value3545774 == value && this3545774 == this && tid3545774 == tid && $pc3545774 == $pc;
     assume $recorded.state3545774 == 1;                                                            
     if ($pc == PreCommit) {                                                                        
      assume this != Queue.null;                                                                    
     } else {                                                                                       
      assert this != Queue.null;                                                                           // (48.18): Cannot have potential null deference in left-mover part.
     }                                                                                              
     $pc := transition($pc, mover3545774);                                                          
     assert $pc != PhaseError;                                                                             // (48.18): Reduction failure
     Queue.tail[this] := next;                                                                      
     if (isLocal(Node._state[next], tid)) {                                                         
      Node._state[next] := SHARED();                                                                
      assert isSharedAssignable(Node._state[Node.next[next]]);                                             // (48.18): next became shared, but next.next may not be shared.
     }                                                                                              
                                                                                                    
                                                                                                    
     // 48.18: tmp5 = false;                                                                        
                                                                                                    
     tmp5 := false;                                                                                 
    }                                                                                               
   }                                                                                                
  }                                                                                                 
                                                                                                    
  // 50.13: yield;                                                                                  
                                                                                                    
  assume Node._state3545786 == Node._state && Node.value3545786 == Node.value && Node.next3545786 == Node.next && Node._lock3545786 == Node._lock && Node.next_nextThread3545786 == Node.next_nextThread && Node.next_nextValue3545786 == Node.next_nextValue && Queue._state3545786 == Queue._state && Queue.head3545786 == Queue.head && Queue.tail3545786 == Queue.tail && Queue._lock3545786 == Queue._lock && Queue.head_nextThread3545786 == Queue.head_nextThread && Queue.head_nextValue3545786 == Queue.head_nextValue && Queue.tail_nextThread3545786 == Queue.tail_nextThread && Queue.tail_nextValue3545786 == Queue.tail_nextValue && tmp23545786 == tmp2 && next3545786 == next && last3545786 == last && tmp13545786 == tmp1 && n3545786 == n && value3545786 == value && this3545786 == this && tid3545786 == tid;
  assume $recorded.state3545786 == 1;                                                               
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (50.13): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (50.13): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (50.13): Object invariant may not hold.
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (50.13): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Node._state3545786_post == Node._state && Node.value3545786_post == Node.value && Node.next3545786_post == Node.next && Node._lock3545786_post == Node._lock && Node.next_nextThread3545786_post == Node.next_nextThread && Node.next_nextValue3545786_post == Node.next_nextValue && Queue._state3545786_post == Queue._state && Queue.head3545786_post == Queue.head && Queue.tail3545786_post == Queue.tail && Queue._lock3545786_post == Queue._lock && Queue.head_nextThread3545786_post == Queue.head_nextThread && Queue.head_nextValue3545786_post == Queue.head_nextValue && Queue.tail_nextThread3545786_post == Queue.tail_nextThread && Queue.tail_nextValue3545786_post == Queue.tail_nextValue && tmp23545786_post == tmp2 && next3545786_post == next && last3545786_post == last && tmp13545786_post == tmp1 && n3545786_post == n && value3545786_post == value && this3545786_post == this && tid3545786_post == tid;
  assume $recorded.state3545786_post == 1;                                                          
  assume Node._state3545789_bottom == Node._state && Node.value3545789_bottom == Node.value && Node.next3545789_bottom == Node.next && Node._lock3545789_bottom == Node._lock && Node.next_nextThread3545789_bottom == Node.next_nextThread && Node.next_nextValue3545789_bottom == Node.next_nextValue && Queue._state3545789_bottom == Queue._state && Queue.head3545789_bottom == Queue.head && Queue.tail3545789_bottom == Queue.tail && Queue._lock3545789_bottom == Queue._lock && Queue.head_nextThread3545789_bottom == Queue.head_nextThread && Queue.head_nextValue3545789_bottom == Queue.head_nextValue && Queue.tail_nextThread3545789_bottom == Queue.tail_nextThread && Queue.tail_nextValue3545789_bottom == Queue.tail_nextValue && n3545789_bottom == n && value3545789_bottom == value && this3545789_bottom == this && tid3545789_bottom == tid;
  assume $recorded.state3545789_bottom == 1;                                                        
  assert phase3545789 == $pc;                                                                              // (33.9): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 31.36: // return;                                                                               
                                                                                                    
 assume Node._state3545790 == Node._state && Node.value3545790 == Node.value && Node.next3545790 == Node.next && Node._lock3545790 == Node._lock && Node.next_nextThread3545790 == Node.next_nextThread && Node.next_nextValue3545790 == Node.next_nextValue && Queue._state3545790 == Queue._state && Queue.head3545790 == Queue.head && Queue.tail3545790 == Queue.tail && Queue._lock3545790 == Queue._lock && Queue.head_nextThread3545790 == Queue.head_nextThread && Queue.head_nextValue3545790 == Queue.head_nextValue && Queue.tail_nextThread3545790 == Queue.tail_nextThread && Queue.tail_nextValue3545790 == Queue.tail_nextValue && n3545790 == n && value3545790 == value && this3545790 == this && tid3545790 == tid;
 assume $recorded.state3545790 == 1;                                                                
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (31.36): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (31.36): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  Queue.dequeue(tid:Tid, this : Queue)                                                     
returns ($result : int)                                                                             
modifies Node._state;                                                                               
modifies Node.value;                                                                                
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Node.next_nextThread;                                                                      
modifies Node.next_nextValue;                                                                       
modifies Queue._state;                                                                              
modifies Queue.head;                                                                                
modifies Queue.tail;                                                                                
modifies Queue._lock;                                                                               
modifies Queue.head_nextThread;                                                                     
modifies Queue.head_nextValue;                                                                      
modifies Queue.tail_nextThread;                                                                     
modifies Queue.tail_nextValue;                                                                      
                                                                                                    
requires ValidTid(tid);                                                                                    // (54.5): Bad tid
requires isShared(Queue._state[this]);                                                                     // (54.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (54.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (54.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (54.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (54.5): Object invariant may not hold.
{                                                                                                   
 var this3545820: Queue;                                                                            
 var tmp63545820: bool;                                                                             
 var this3545964: Queue;                                                                            
 var Node.next_nextValue3545873_post: [Node]Node;                                                   
 var _currentValue3546002: Node;                                                                    
 var $result3545864: int;                                                                           
 var tmp103546134: bool;                                                                            
 var Queue.tail_nextThread3545964: [Queue]Tid;                                                      
 var Queue._state3546246: [Queue]State;                                                             
 var Node.next3545964: [Node]Node;                                                                  
 var $recorded.state3546007: int;                                                                   
 var path3546298: int;                                                                              
 var Node.next_nextThread3546253: [Node]Tid;                                                        
 var Node.next_nextThread3546279: [Node]Tid;                                                        
 var _R_t3546007: Mover;                                                                            
 var moverPath3546249: MoverPath;                                                                   
 var Node.value3545869: [Node]int;                                                                  
 var Queue._state3545933: [Queue]State;                                                             
 var Queue._lock3546186_post: [Queue]Tid;                                                           
 var Node.next3545864: [Node]Node;                                                                  
 var tid3545952: Tid;                                                                               
 var Queue._state3546044: [Queue]State;                                                             
 var tmp73546291: bool;                                                                             
 var Queue.tail3545933: [Queue]Node;                                                                
 var $recorded.state3545814: int;                                                                   
 var Queue._state3546186_post: [Queue]State;                                                        
 var Queue.head_nextValue3546149: [Queue]Node;                                                      
 var Node.value3546044: [Node]int;                                                                  
 var _m3546249: Mover;                                                                              
 var Node.value3545958: [Node]int;                                                                  
 var $recorded.state3546044: int;                                                                   
 var next3546319_post: Node;                                                                        
 var _C_v3545889: Node;                                                                             
 var Queue._lock3545820: [Queue]Tid;                                                                
 var tmp73546107: bool;                                                                             
 var Queue._lock3546111: [Queue]Tid;                                                                
 var first3546041: Node;                                                                            
 var Queue.head_nextThread3545889: [Queue]Tid;                                                      
 var $recorded.state3546186_post: int;                                                              
 var this3545826: Queue;                                                                            
 var tmp63545873: bool;                                                                             
 var Node._lock3545942_post: [Node]Tid;                                                             
 var Queue.tail_nextValue3546111: [Queue]Node;                                                      
 var Node.value3545873: [Node]int;                                                                  
 var Node.next_nextThread3545826: [Node]Tid;                                                        
 var Node.value3545895: [Node]int;                                                                  
 var Queue._state3545820: [Queue]State;                                                             
 var $result3545889: int;                                                                           
 var $result3545942: int;                                                                           
 var Queue._state3546156: [Queue]State;                                                             
 var Queue.head_nextValue3545964: [Queue]Node;                                                      
 var Node.next3545869: [Node]Node;                                                                  
 var ctmp35200943546137: bool;                                                                      
 var $recorded.state3546134: int;                                                                   
 var next3546041: Node;                                                                             
 var Queue.tail3546137: [Queue]Node;                                                                
 var Queue.head3545942_post: [Queue]Node;                                                           
 var Node.next_nextThread3546249: [Node]Tid;                                                        
 var Node._state3545952: [Node]State;                                                               
 var $pc3545895: Phase;                                                                             
 var Queue._lock3546246: [Queue]Tid;                                                                
 var Node.next3545883: [Node]Node;                                                                  
 var path3546249: int;                                                                              
 var tmp63545958: bool;                                                                             
 var Node.next_nextValue3546104: [Node]Node;                                                        
 var tmp113546279: bool;                                                                            
 var Queue.head_nextValue3546134: [Queue]Node;                                                      
 var tid3545826: Tid;                                                                               
 var path3546156: int;                                                                              
 var Queue.head_nextValue3546322_bottom: [Queue]Node;                                               
 var Queue.head_nextValue3546186_post: [Queue]Node;                                                 
 var path3546253: int;                                                                              
 var Queue._state3545814: [Queue]State;                                                             
 var Node.next_nextThread3545952: [Node]Tid;                                                        
 var tmp63546249: bool;                                                                             
 var tid3545958: Tid;                                                                               
 var next: Node;                                                                                    
 var Node.value3546137: [Node]int;                                                                  
 var Node.next3545938: [Node]Node;                                                                  
 var _C_t: Tid;                                                                                     
 var Node.value3546291: [Node]int;                                                                  
 var Queue.head3546186_post: [Queue]Node;                                                           
 var Queue._lock3546249: [Queue]Tid;                                                                
 var first3545964: Node;                                                                            
 var Queue._state3546322_bottom: [Queue]State;                                                      
 var tmp83546156: bool;                                                                             
 var Queue.head3546322_bottom: [Queue]Node;                                                         
 var Queue._state3545883: [Queue]State;                                                             
 var first3546319_post: Node;                                                                       
 var tmp63546279: bool;                                                                             
 var Node.next_nextValue3545883: [Node]Node;                                                        
 var Queue.head_nextValue3546322: [Queue]Node;                                                      
 var Node.next3546007: [Node]Node;                                                                  
 var $recorded.state3546246: int;                                                                   
 var $result3546156: int;                                                                           
 var $pc3546044_post: Phase;                                                                        
 var last3546149: Node;                                                                             
 var Queue.tail3546186: [Queue]Node;                                                                
 var last3546186: Node;                                                                             
 var Node.value3545942_post: [Node]int;                                                             
 var Node._state3546137: [Node]State;                                                               
 var Node.next_nextThread3545895: [Node]Tid;                                                        
 var tmp63545895: bool;                                                                             
 var $recorded.state3546104: int;                                                                   
 var Queue._lock3545895: [Queue]Tid;                                                                
 var $result3545958: int;                                                                           
 var Queue.tail_nextThread3545895: [Queue]Tid;                                                      
 var $result3545826: int;                                                                           
 var Queue.tail_nextThread3545820: [Queue]Tid;                                                      
 var Queue.head3546137: [Queue]Node;                                                                
 var _C_t3545826: Tid;                                                                              
 var Queue._state3546002: [Queue]State;                                                             
 var Queue.tail_nextThread3546002: [Queue]Tid;                                                      
 var first3545869: Node;                                                                            
 var _R_t3545864: Mover;                                                                            
 var tid3545942_post: Tid;                                                                          
 var Node.next_nextValue3546044_post: [Node]Node;                                                   
 var next3545964: Node;                                                                             
 var Queue.tail3545814: [Queue]Node;                                                                
 var Queue.head3545820: [Queue]Node;                                                                
 var next3545895: Node;                                                                             
 var Queue.head_nextThread3545864: [Queue]Tid;                                                      
 var Node.next_nextValue3546246: [Node]Node;                                                        
 var tid3545933: Tid;                                                                               
 var first3546279: Node;                                                                            
 var Node.value3546319: [Node]int;                                                                  
 var $recorded.state3546107: int;                                                                   
 var Node._state3546134: [Node]State;                                                               
 var Queue._lock3545938: [Queue]Tid;                                                                
 var Queue._state3546325: [Queue]State;                                                             
 var $recorded.state3545942: int;                                                                   
 var Node._lock3546002: [Node]Tid;                                                                  
 var value3546249: int;                                                                             
 var Node.next_nextValue3546002: [Node]Node;                                                        
 var Node.next3546002: [Node]Node;                                                                  
 var Queue.head_nextThread3546322_bottom: [Queue]Tid;                                               
 var Node._lock3546134: [Node]Tid;                                                                  
 var $pc3545873_post: Phase;                                                                        
 var tmp63546309: bool;                                                                             
 var Node.next_nextThread3545864: [Node]Tid;                                                        
 var $pc3546322: Phase;                                                                             
 var $recorded.state3545883: int;                                                                   
 var Queue.tail_nextValue3545826: [Queue]Node;                                                      
 var Queue.tail_nextThread3546291: [Queue]Tid;                                                      
 var Node.next_nextValue3545958: [Node]Node;                                                        
 var tmp63546186_post: bool;                                                                        
 var Node.next_nextThread3545958: [Node]Tid;                                                        
 var Node.next_nextThread3546319: [Node]Tid;                                                        
 var tid3546007: Tid;                                                                               
 var _C_v3545964: Node;                                                                             
 var _m3546111: Mover;                                                                              
 var Queue._lock3546041: [Queue]Tid;                                                                
 var Node.next_nextThread3545814: [Node]Tid;                                                        
 var Queue.tail_nextValue3546007: [Queue]Node;                                                      
 var this3546186: Queue;                                                                            
 var Queue._lock3545864: [Queue]Tid;                                                                
 var Queue.tail3546246: [Queue]Node;                                                                
 var Queue.tail3545889: [Queue]Node;                                                                
 var Node.value3546107: [Node]int;                                                                  
 var Queue.tail_nextValue3545889: [Queue]Node;                                                      
 var Queue.head3545826: [Queue]Node;                                                                
 var Queue.tail3546044_post: [Queue]Node;                                                           
 var $result3546137: int;                                                                           
 var tmpValue: Node;                                                                                
 var $result3545883: int;                                                                           
 var Queue.tail3545873: [Queue]Node;                                                                
 var _casable: bool;                                                                                
 var Node._lock3546291: [Node]Tid;                                                                  
 var Queue.head3545864: [Queue]Node;                                                                
 var $recorded.state3545938: int;                                                                   
 var Queue.tail_nextValue3546298: [Queue]Node;                                                      
 var _C_t3545820: Tid;                                                                              
 var tmp63545883: bool;                                                                             
 var Node.value3545889: [Node]int;                                                                  
 var Queue.head_nextThread3546249: [Queue]Tid;                                                      
 var Queue.head_nextValue3546041: [Queue]Node;                                                      
 var $result3546149: int;                                                                           
 var path3545895: int;                                                                              
 var tid3546041: Tid;                                                                               
 var Node.next_nextValue3545964: [Node]Node;                                                        
 var Queue._state3546111: [Queue]State;                                                             
 var Node._lock3546279: [Node]Tid;                                                                  
 var tmp73546276: bool;                                                                             
 var value3546185: int;                                                                             
 var Queue._lock3546319_post: [Queue]Tid;                                                           
 var Node.next3545895: [Node]Node;                                                                  
 var Node.next3545942: [Node]Node;                                                                  
 var Node.next3546291: [Node]Node;                                                                  
 var mover3546253: Mover;                                                                           
 var Queue.tail3546319_post: [Queue]Node;                                                           
 var next3546107: Node;                                                                             
 var _R_t3546002: Mover;                                                                            
 var _C_v3546007: Node;                                                                             
 var Node._lock3545895: [Node]Tid;                                                                  
 var moverPath3546149: MoverPath;                                                                   
 var moverPath3546134: MoverPath;                                                                   
 var tid3545942: Tid;                                                                               
 var Node._state3545933: [Node]State;                                                               
 var next3546276: Node;                                                                             
 var mover3546007: Mover;                                                                           
 var Node.value3546322: [Node]int;                                                                  
 var last3546137: Node;                                                                             
 var Node._state3546298: [Node]State;                                                               
 var Queue._state3545873_post: [Queue]State;                                                        
 var Queue.head_nextValue3546156: [Queue]Node;                                                      
 var tmp63546185: bool;                                                                             
 var mover3546134: Mover;                                                                           
 var $recorded.state3545873: int;                                                                   
 var Queue.tail3545958: [Queue]Node;                                                                
 var Queue._lock3546276: [Queue]Tid;                                                                
 var moverPath3545958: MoverPath;                                                                   
 var _currentValue3546156: Node;                                                                    
 var Node._state3546246: [Node]State;                                                               
 var Node.next_nextValue3545873: [Node]Node;                                                        
 var $result3546104: int;                                                                           
 var Queue._state3546137: [Queue]State;                                                             
 var tmp63546298: bool;                                                                             
 var $result3546319_post: int;                                                                      
 var Queue.tail_nextThread3545873: [Queue]Tid;                                                      
 var Queue._state3546249: [Queue]State;                                                             
 var Queue.head_nextThread3546298: [Queue]Tid;                                                      
 var Node.next_nextValue3545826: [Node]Node;                                                        
 var path3545820: int;                                                                              
 var $pc3545938: Phase;                                                                             
 var first3546107: Node;                                                                            
 var Node.value3545873_post: [Node]int;                                                             
 var $pc3546186_post: Phase;                                                                        
 var _C_v3546002: Node;                                                                             
 var Node.next_nextValue3546322: [Node]Node;                                                        
 var Node._state3546322: [Node]State;                                                               
 var Node.next_nextValue3546298: [Node]Node;                                                        
 var Queue._lock3546309: [Queue]Tid;                                                                
 var Queue.head3545958: [Queue]Node;                                                                
 var first3545826: Node;                                                                            
 var Node._state3545889: [Node]State;                                                               
 var tid3546044_post: Tid;                                                                          
 var first3546186: Node;                                                                            
 var Node._state3546309: [Node]State;                                                               
 var Node.next3546249: [Node]Node;                                                                  
 var tid3546319_post: Tid;                                                                          
 var Queue.tail_nextValue3546325: [Queue]Node;                                                      
 var Node.next3546322_bottom: [Node]Node;                                                           
 var mover3545826: Mover;                                                                           
 var first3545873_post: Node;                                                                       
 var $recorded.state3546298: int;                                                                   
 var Queue.tail_nextValue3546041: [Queue]Node;                                                      
 var Queue.head3546309: [Queue]Node;                                                                
 var path3546134: int;                                                                              
 var $recorded.state3546322_bottom: int;                                                            
 var Node.next_nextThread3546044_post: [Node]Tid;                                                   
 var tid3546322_bottom: Tid;                                                                        
 var _C_t3545814: Tid;                                                                              
 var _C_v3545895: Node;                                                                             
 var next3546149: Node;                                                                             
 var Queue.tail_nextValue3546291: [Queue]Node;                                                      
 var ctmp35201293546249: bool;                                                                      
 var $pc3546309: Phase;                                                                             
 var _m3546156: Mover;                                                                              
 var $recorded.state3546309: int;                                                                   
 var tid3546186_post: Tid;                                                                          
 var _C_v3545869: Node;                                                                             
 var tmp113546291: bool;                                                                            
 var Queue.tail3546104: [Queue]Node;                                                                
 var last3546253: Node;                                                                             
 var Queue._state3546319_post: [Queue]State;                                                        
 var _currentValue3546298: Node;                                                                    
 var tmp63546044_post: bool;                                                                        
 var Node._lock3545826: [Node]Tid;                                                                  
 var Node.next3545820: [Node]Node;                                                                  
 var path3545958: int;                                                                              
 var next3546002: Node;                                                                             
 var _casable3545869: bool;                                                                         
 var Node._state3546149: [Node]State;                                                               
 var _currentValue3545933: Node;                                                                    
 var tid3546104: Tid;                                                                               
 var Node._state3546111: [Node]State;                                                               
 var last3546104: Node;                                                                             
 var $result3546309: int;                                                                           
 var $pc3546291: Phase;                                                                             
 var Queue.head3546319: [Queue]Node;                                                                
 var Queue.tail_nextThread3546253: [Queue]Tid;                                                      
 var Queue._lock3545826: [Queue]Tid;                                                                
 var mover3546185: Mover;                                                                           
 var this3546249: Queue;                                                                            
 var Queue.tail_nextThread3545814: [Queue]Tid;                                                      
 var Queue.tail_nextThread3545883: [Queue]Tid;                                                      
 var tmp83546137: bool;                                                                             
 var $pc3545952: Phase;                                                                             
 var mover3545964: Mover;                                                                           
 var _C_t3545952: Tid;                                                                              
 var Queue._lock3546253: [Queue]Tid;                                                                
 var tmp73546279: bool;                                                                             
 var Queue.head_nextValue3545873_post: [Queue]Node;                                                 
 var first3545889: Node;                                                                            
 var Node.next_nextThread3546007: [Node]Tid;                                                        
 var this3546185: Queue;                                                                            
 var _currentValue3546279: Node;                                                                    
 var Queue.head_nextThread3546007: [Queue]Tid;                                                      
 var tmp73546111: bool;                                                                             
 var this3546291: Queue;                                                                            
 var tmp63545938: bool;                                                                             
 var Node.next_nextThread3545873: [Node]Tid;                                                        
 var $recorded.state3545895: int;                                                                   
 var Queue.tail_nextValue3545864: [Queue]Node;                                                      
 var value3546253: int;                                                                             
 var Queue.tail_nextThread3545826: [Queue]Tid;                                                      
 var _m3546298: Mover;                                                                              
 var this3545958: Queue;                                                                            
 var next3546246: Node;                                                                             
 var tmp63546186: bool;                                                                             
 var Queue.head_nextThread3546325: [Queue]Tid;                                                      
 var _m3546149: Mover;                                                                              
 var last3546279: Node;                                                                             
 var ctmp35200943546149: bool;                                                                      
 var Queue._state3545889: [Queue]State;                                                             
 var Queue.tail3546185: [Queue]Node;                                                                
 var Node._lock3545864: [Node]Tid;                                                                  
 var Queue.head_nextValue3546002: [Queue]Node;                                                      
 var Node.next3546149: [Node]Node;                                                                  
 var Queue.tail_nextThread3546246: [Queue]Tid;                                                      
 var Queue._state3546104: [Queue]State;                                                             
 var tmp63546291: bool;                                                                             
 var tmp83546134: bool;                                                                             
 var next3545942: Node;                                                                             
 var Queue._lock3546186: [Queue]Tid;                                                                
 var moverPath3546111: MoverPath;                                                                   
 var Queue.head_nextValue3546246: [Queue]Node;                                                      
 var Queue._lock3545883: [Queue]Tid;                                                                
 var Queue.tail_nextThread3545933: [Queue]Tid;                                                      
 var tid3545873: Tid;                                                                               
 var tmp123546279: bool;                                                                            
 var Node.next3546107: [Node]Node;                                                                  
 var _C_v3545826: Node;                                                                             
 var _C_t3545938: Tid;                                                                              
 var Queue.tail3545864: [Queue]Node;                                                                
 var _C_t3545895: Tid;                                                                              
 var Queue.head_nextValue3545820: [Queue]Node;                                                      
 var $pc3546325: Phase;                                                                             
 var Queue.head3546044: [Queue]Node;                                                                
 var moverPath3545952: MoverPath;                                                                   
 var this3546104: Queue;                                                                            
 var Node._lock3546325: [Node]Tid;                                                                  
 var Node._lock3545820: [Node]Tid;                                                                  
 var tmp113546186_post: bool;                                                                       
 var Queue.tail_nextValue3546137: [Queue]Node;                                                      
 var Queue.head_nextThread3545814: [Queue]Tid;                                                      
 var _currentValue3545938: Node;                                                                    
 var Node.next_nextValue3545869: [Node]Node;                                                        
 var Queue.head_nextThread3546134: [Queue]Tid;                                                      
 var $result3545938: int;                                                                           
 var Queue.head_nextThread3546002: [Queue]Tid;                                                      
 var tmpValue3546253: Node;                                                                         
 var _currentValue3546007: Node;                                                                    
 var Node._lock3545814: [Node]Tid;                                                                  
 var Node._state3546322_bottom: [Node]State;                                                        
 var _currentValue3545826: Node;                                                                    
 var moverPath3546185: MoverPath;                                                                   
 var tmpTid3546104: Tid;                                                                            
 var tmpTid3546249: Tid;                                                                            
 var Node.next_nextValue3546111: [Node]Node;                                                        
 var Node._state3546044: [Node]State;                                                               
 var Queue.head_nextThread3546111: [Queue]Tid;                                                      
 var $result3546044: int;                                                                           
 var Queue.head_nextThread3546137: [Queue]Tid;                                                      
 var tmpValue3546111: Node;                                                                         
 var $recorded.state3546279: int;                                                                   
 var Queue.tail3546044: [Queue]Node;                                                                
 var Node.next_nextThread3546107: [Node]Tid;                                                        
 var Queue.tail_nextThread3545952: [Queue]Tid;                                                      
 var last3545958: Node;                                                                             
 var tmp123546291: bool;                                                                            
 var tid3546107: Tid;                                                                               
 var Node.next_nextValue3546137: [Node]Node;                                                        
 var Queue.head3546111: [Queue]Node;                                                                
 var tmp83546149: bool;                                                                             
 var ctmp3520094: bool;                                                                             
 var _currentValue3546134: Node;                                                                    
 var mover3545864: Mover;                                                                           
 var moverPath3546253: MoverPath;                                                                   
 var next3546291: Node;                                                                             
 var Queue.head_nextThread3546291: [Queue]Tid;                                                      
 var Queue.head_nextThread3546156: [Queue]Tid;                                                      
 var tid3545895: Tid;                                                                               
 var $result3545814: int;                                                                           
 var Queue.tail_nextValue3546185: [Queue]Node;                                                      
 var first3546044: Node;                                                                            
 var next3545942_post: Node;                                                                        
 var Queue.head3546249: [Queue]Node;                                                                
 var Queue._state3545964: [Queue]State;                                                             
 var path3545964: int;                                                                              
 var Node.next3545933: [Node]Node;                                                                  
 var Queue.head_nextValue3546319: [Queue]Node;                                                      
 var Queue._lock3546322_bottom: [Queue]Tid;                                                         
 var Queue.tail3546276: [Queue]Node;                                                                
 var Queue.tail3546007: [Queue]Node;                                                                
 var Node.next_nextThread3546104: [Node]Tid;                                                        
 var first3546186_post: Node;                                                                       
 var $pc3545873: Phase;                                                                             
 var this3546276: Queue;                                                                            
 var Node._state3545942: [Node]State;                                                               
 var Node._lock3545938: [Node]Tid;                                                                  
 var Queue.tail_nextValue3545958: [Queue]Node;                                                      
 var Node._state3546185: [Node]State;                                                               
 var last3546044: Node;                                                                             
 var value3546291: int;                                                                             
 var $pc3546137: Phase;                                                                             
 var tmp113546249: bool;                                                                            
 var Queue.tail_nextThread3545942_post: [Queue]Tid;                                                 
 var first3546253: Node;                                                                            
 var tmp73546249: bool;                                                                             
 var first3546185: Node;                                                                            
 var Queue.head_nextThread3546319_post: [Queue]Tid;                                                 
 var Node.next_nextValue3546134: [Node]Node;                                                        
 var Queue.tail_nextThread3546107: [Queue]Tid;                                                      
 var Node.next_nextValue3546309: [Node]Node;                                                        
 var mover3545938: Mover;                                                                           
 var _currentValue3546137: Node;                                                                    
 var Node._state3546002: [Node]State;                                                               
 var tmp9: int;                                                                                     
 var Node._state3545814: [Node]State;                                                               
 var ctmp35201293546298: bool;                                                                      
 var tmp83546044: bool;                                                                             
 var Queue.tail_nextThread3546309: [Queue]Tid;                                                      
 var Queue.tail_nextThread3545889: [Queue]Tid;                                                      
 var Node.value3546325: [Node]int;                                                                  
 var tmp123546253: bool;                                                                            
 var Node.next_nextThread3545820: [Node]Tid;                                                        
 var $recorded.state3545942_post: int;                                                              
 var $pc3545864: Phase;                                                                             
 var Queue.head_nextValue3546276: [Queue]Node;                                                      
 var value: int;                                                                                    
 var Queue.tail_nextValue3545883: [Queue]Node;                                                      
 var Queue.head_nextThread3545883: [Queue]Tid;                                                      
 var Queue.head_nextThread3546246: [Queue]Tid;                                                      
 var Node._state3545958: [Node]State;                                                               
 var Queue.tail_nextValue3546249: [Queue]Node;                                                      
 var Node.next_nextValue3546007: [Node]Node;                                                        
 var Node._state3546104: [Node]State;                                                               
 var Queue.head_nextValue3546298: [Queue]Node;                                                      
 var path3546246: int;                                                                              
 var Queue.tail3545952: [Queue]Node;                                                                
 var tid3546185: Tid;                                                                               
 var path3546002: int;                                                                              
 var moverPath3546104: MoverPath;                                                                   
 var $pc3545942_post: Phase;                                                                        
 var Queue.tail3545873_post: [Queue]Node;                                                           
 var $pc3546107: Phase;                                                                             
 var Node.next3546322: [Node]Node;                                                                  
 var _casable3545938: bool;                                                                         
 var this3546156: Queue;                                                                            
 var first3545864: Node;                                                                            
 var Node.next_nextValue3545942_post: [Node]Node;                                                   
 var Queue.head3546185: [Queue]Node;                                                                
 var $pc3546156: Phase;                                                                             
 var this3546002: Queue;                                                                            
 var tmpTid3546111: Tid;                                                                            
 var Queue.head3545933: [Queue]Node;                                                                
 var _C_v3545933: Node;                                                                             
 var tmpTid3546107: Tid;                                                                            
 var Queue.head3546298: [Queue]Node;                                                                
 var tid3546111: Tid;                                                                               
 var Queue.head_nextThread3546319: [Queue]Tid;                                                      
 var Node._state3546044_post: [Node]State;                                                          
 var Queue.tail_nextValue3546104: [Queue]Node;                                                      
 var moverPath3545883: MoverPath;                                                                   
 var last3546298: Node;                                                                             
 var ctmp35201293546246: bool;                                                                      
 var Queue._lock3545889: [Queue]Tid;                                                                
 var Node.next_nextValue3546044: [Node]Node;                                                        
 var _R_t3545933: Mover;                                                                            
 var $recorded.state3545933: int;                                                                   
 var tmp73546156: bool;                                                                             
 var Queue.head_nextValue3546325: [Queue]Node;                                                      
 var Queue.tail3545883: [Queue]Node;                                                                
 var Node.next3546044_post: [Node]Node;                                                             
 var Node.next_nextThread3546325: [Node]Tid;                                                        
 var tmp11: bool;                                                                                   
 var value3546276: int;                                                                             
 var Queue.tail_nextValue3546322: [Queue]Node;                                                      
 var moverPath3545933: MoverPath;                                                                   
 var $result3545942_post: int;                                                                      
 var $pc3546186: Phase;                                                                             
 var Queue.head3545895: [Queue]Node;                                                                
 var Queue.tail3545820: [Queue]Node;                                                                
 var next3546104: Node;                                                                             
 var Queue.tail_nextThread3546156: [Queue]Tid;                                                      
 var Node.value3545820: [Node]int;                                                                  
 var Node.next_nextThread3546309: [Node]Tid;                                                        
 var tmp103546104: bool;                                                                            
 var _C_t3545889: Tid;                                                                              
 var Queue.tail_nextThread3546104: [Queue]Tid;                                                      
 var Queue._state3546279: [Queue]State;                                                             
 var Queue._state3546007: [Queue]State;                                                             
 var path3545952: int;                                                                              
 var this3546309: Queue;                                                                            
 var Node._lock3546044_post: [Node]Tid;                                                             
 var tid3546309: Tid;                                                                               
 var this3545933: Queue;                                                                            
 var Queue.head3546291: [Queue]Node;                                                                
 var tid3546249: Tid;                                                                               
 var Node.next3546044: [Node]Node;                                                                  
 var Queue._state3546149: [Queue]State;                                                             
 var Node._lock3546319: [Node]Tid;                                                                  
 var Queue.tail_nextValue3545873: [Queue]Node;                                                      
 var next3546186: Node;                                                                             
 var tid3546291: Tid;                                                                               
 var $result3546185: int;                                                                           
 var Node._lock3545883: [Node]Tid;                                                                  
 var _C_v: Node;                                                                                    
 var Queue._state3545864: [Queue]State;                                                             
 var Node._lock3546137: [Node]Tid;                                                                  
 var moverPath3545826: MoverPath;                                                                   
 var mover3546279: Mover;                                                                           
 var _R_t3545869: Mover;                                                                            
 var Queue.head3545942: [Queue]Node;                                                                
 var last3546007: Node;                                                                             
 var Queue.head_nextThread3545942: [Queue]Tid;                                                      
 var Node.next_nextValue3546249: [Node]Node;                                                        
 var Node.next3546134: [Node]Node;                                                                  
 var $pc3546298: Phase;                                                                             
 var Node.next_nextThread3546276: [Node]Tid;                                                        
 var this3546186_post: Queue;                                                                       
 var Queue.tail_nextThread3546279: [Queue]Tid;                                                      
 var $result3546107: int;                                                                           
 var _C_t3545933: Tid;                                                                              
 var Node._state3546325: [Node]State;                                                               
 var tmp123546246: bool;                                                                            
 var Node.next3545942_post: [Node]Node;                                                             
 var mover3545958: Mover;                                                                           
 var Queue.head_nextThread3545873_post: [Queue]Tid;                                                 
 var Queue._state3546134: [Queue]State;                                                             
 var mover3546149: Mover;                                                                           
 var this3545889: Queue;                                                                            
 var last3546186_post: Node;                                                                        
 var Queue.tail3546156: [Queue]Node;                                                                
 var $result3545952: int;                                                                           
 var mover3545820: Mover;                                                                           
 var _m3546246: Mover;                                                                              
 var tid3546322: Tid;                                                                               
 var tmp63546134: bool;                                                                             
 var next3545952: Node;                                                                             
 var $recorded.state3546002: int;                                                                   
 var Queue.tail_nextThread3546185: [Queue]Tid;                                                      
 var Queue._state3545952: [Queue]State;                                                             
 var Node.value3546298: [Node]int;                                                                  
 var $recorded.state3545826: int;                                                                   
 var Queue.tail3546041: [Queue]Node;                                                                
 var Node._lock3545889: [Node]Tid;                                                                  
 var Node._lock3546107: [Node]Tid;                                                                  
 var tmpValue3546249: Node;                                                                         
 var Queue.tail_nextValue3546309: [Queue]Node;                                                      
 var Queue.head3545938: [Queue]Node;                                                                
 var tmpTid3546246: Tid;                                                                            
 var first3545952: Node;                                                                            
 var Queue._lock3545964: [Queue]Tid;                                                                
 var path3546104: int;                                                                              
 var tid3546134: Tid;                                                                               
 var Node.next_nextValue3546319: [Node]Node;                                                        
 var $result3546044_post: int;                                                                      
 var Queue.head_nextThread3546041: [Queue]Tid;                                                      
 var tmp123546249: bool;                                                                            
 var Node.value3546279: [Node]int;                                                                  
 var _C_v3545820: Node;                                                                             
 var _m3546104: Mover;                                                                              
 var Queue.head3546007: [Queue]Node;                                                                
 var Queue.tail_nextThread3546149: [Queue]Tid;                                                      
 var tmp63545864: bool;                                                                             
 var $recorded.state3546319_post: int;                                                              
 var this3546107: Queue;                                                                            
 var tmp73546149: bool;                                                                             
 var Queue.tail_nextValue3546156: [Queue]Node;                                                      
 var moverPath3545889: MoverPath;                                                                   
 var mover3546104: Mover;                                                                           
 var Node.value3545964: [Node]int;                                                                  
 var Node.next_nextThread3545942: [Node]Tid;                                                        
 var Queue._lock3546156: [Queue]Tid;                                                                
 var this3546149: Queue;                                                                            
 var Node._state3546041: [Node]State;                                                               
 var Queue.head_nextValue3545814: [Queue]Node;                                                      
 var Node.next_nextValue3546107: [Node]Node;                                                        
 var Queue.head_nextThread3545933: [Queue]Tid;                                                      
 var Queue._lock3545942_post: [Queue]Tid;                                                           
 var Node._lock3546298: [Node]Tid;                                                                  
 var Node.next3546104: [Node]Node;                                                                  
 var tid3546186: Tid;                                                                               
 var next3546298: Node;                                                                             
 var $result3546322: int;                                                                           
 var Queue.tail_nextValue3545820: [Queue]Node;                                                      
 var $pc3546044: Phase;                                                                             
 var Queue.tail3545869: [Queue]Node;                                                                
 var first3546044_post: Node;                                                                       
 var Queue.tail3546325: [Queue]Node;                                                                
 var Node.value3545933: [Node]int;                                                                  
 var first3546002: Node;                                                                            
 var this3545895: Queue;                                                                            
 var Node.next_nextThread3546246: [Node]Tid;                                                        
 var Queue.head_nextValue3546137: [Queue]Node;                                                      
 var tmp73546319: bool;                                                                             
 var Queue.head3546134: [Queue]Node;                                                                
 var first3546309: Node;                                                                            
 var Queue.head_nextValue3546319_post: [Queue]Node;                                                 
 var next3546319: Node;                                                                             
 var Queue.tail_nextThread3546325: [Queue]Tid;                                                      
 var _C_t3545883: Tid;                                                                              
 var $result3546298: int;                                                                           
 var Node.value3546249: [Node]int;                                                                  
 var _currentValue3545864: Node;                                                                    
 var tmp83546111: bool;                                                                             
 var Queue.head_nextValue3545942_post: [Queue]Node;                                                 
 var $recorded.state3546185: int;                                                                   
 var Node.next3546041: [Node]Node;                                                                  
 var $result3546279: int;                                                                           
 var Queue._state3546322: [Queue]State;                                                             
 var Queue._state3545958: [Queue]State;                                                             
 var last3546107: Node;                                                                             
 var $recorded.state3546291: int;                                                                   
 var tmp63546156: bool;                                                                             
 var $pc3545826: Phase;                                                                             
 var first3546276: Node;                                                                            
 var Node.next3545952: [Node]Node;                                                                  
 var next3546044_post: Node;                                                                        
 var tmp73546186_post: bool;                                                                        
 var Queue.tail3546134: [Queue]Node;                                                                
 var Node._state3545895: [Node]State;                                                               
 var tid3545883: Tid;                                                                               
 var Node.value3545814: [Node]int;                                                                  
 var next3545938: Node;                                                                             
 var value3546186: int;                                                                             
 var $recorded.state3546276: int;                                                                   
 var Node.next_nextValue3546149: [Node]Node;                                                        
 var tmp73546041: bool;                                                                             
 var next3545958: Node;                                                                             
 var Queue._lock3546291: [Queue]Tid;                                                                
 var next3546156: Node;                                                                             
 var last: Node;                                                                                    
 var mover3546107: Mover;                                                                           
 var moverPath3546107: MoverPath;                                                                   
 var $pc3546249: Phase;                                                                             
 var tid3545869: Tid;                                                                               
 var mover3545814: Mover;                                                                           
 var tmp123546276: bool;                                                                            
 var Node.next_nextValue3546276: [Node]Node;                                                        
 var tid3545964: Tid;                                                                               
 var Queue.head_nextThread3546149: [Queue]Tid;                                                      
 var _currentValue3546291: Node;                                                                    
 var Queue.tail_nextValue3546319: [Queue]Node;                                                      
 var Node.next_nextThread3546041: [Node]Tid;                                                        
 var tmpTid3546253: Tid;                                                                            
 var Queue.tail_nextValue3546186_post: [Queue]Node;                                                 
 var first: Node;                                                                                   
 var tid3546253: Tid;                                                                               
 var $result3546111: int;                                                                           
 var tmp63545952: bool;                                                                             
 var first3546298: Node;                                                                            
 var tmp113546253: bool;                                                                            
 var Node.value3545864: [Node]int;                                                                  
 var moverPath3546007: MoverPath;                                                                   
 var tmp63546041: bool;                                                                             
 var $result3546322_bottom: int;                                                                    
 var Node.next_nextValue3546186_post: [Node]Node;                                                   
 var ctmp35200943546111: bool;                                                                      
 var Node._state3545938: [Node]State;                                                               
 var Queue.tail_nextValue3546279: [Queue]Node;                                                      
 var Queue.tail3546253: [Queue]Node;                                                                
 var Queue._state3545869: [Queue]State;                                                             
 var Queue.head3546246: [Queue]Node;                                                                
 var this3545873_post: Queue;                                                                       
 var Node._lock3546186_post: [Node]Tid;                                                             
 var moverPath3545895: MoverPath;                                                                   
 var first3546291: Node;                                                                            
 var mover3546246: Mover;                                                                           
 var next3546111: Node;                                                                             
 var tmp93546041: int;                                                                              
 var Node.next3545826: [Node]Node;                                                                  
 var tmp113546276: bool;                                                                            
 var $recorded.state3546111: int;                                                                   
 var tid3545873_post: Tid;                                                                          
 var Node.value3546322_bottom: [Node]int;                                                           
 var Queue._lock3546002: [Queue]Tid;                                                                
 var tmp73546134: bool;                                                                             
 var Node.next_nextThread3546149: [Node]Tid;                                                        
 var $result3546186: int;                                                                           
 var tmp73546104: bool;                                                                             
 var Queue.tail3546322: [Queue]Node;                                                                
 var last3546246: Node;                                                                             
 var tmp113546298: bool;                                                                            
 var Node._lock3546249: [Node]Tid;                                                                  
 var Node.next3546325: [Node]Node;                                                                  
 var Node.value3546007: [Node]int;                                                                  
 var Queue.tail_nextThread3546044_post: [Queue]Tid;                                                 
 var tid3545864: Tid;                                                                               
 var Node._lock3546185: [Node]Tid;                                                                  
 var path3545864: int;                                                                              
 var $result3545964: int;                                                                           
 var Queue.tail_nextValue3546276: [Queue]Node;                                                      
 var $result3546134: int;                                                                           
 var Queue.head3545869: [Queue]Node;                                                                
 var Queue.head_nextThread3546279: [Queue]Tid;                                                      
 var tmp103546156: bool;                                                                            
 var path3545869: int;                                                                              
 var Node._lock3546309: [Node]Tid;                                                                  
 var first3545883: Node;                                                                            
 var Queue._lock3546185: [Queue]Tid;                                                                
 var Queue.head_nextThread3546186: [Queue]Tid;                                                      
 var $pc3546007: Phase;                                                                             
 var tid3546002: Tid;                                                                               
 var $recorded.state3545958: int;                                                                   
 var Queue.tail_nextThread3546041: [Queue]Tid;                                                      
 var tmp10: bool;                                                                                   
 var this3545938: Queue;                                                                            
 var Queue.head_nextThread3546104: [Queue]Tid;                                                      
 var $recorded.state3546249: int;                                                                   
 var ctmp35200943546104: bool;                                                                      
 var $recorded.state3546253: int;                                                                   
 var _casable3546002: bool;                                                                         
 var Queue._lock3546279: [Queue]Tid;                                                                
 var last3546319: Node;                                                                             
 var Queue.head_nextValue3545889: [Queue]Node;                                                      
 var $recorded.state3545964: int;                                                                   
 var this3546044: Queue;                                                                            
 var last3546185: Node;                                                                             
 var Queue.head_nextValue3545883: [Queue]Node;                                                      
 var Node._state3546319: [Node]State;                                                               
 var tmp12: bool;                                                                                   
 var tmp73546044: bool;                                                                             
 var mover3546291: Mover;                                                                           
 var $result3546291: int;                                                                           
 var path3546149: int;                                                                              
 var Queue.head_nextValue3546044: [Queue]Node;                                                      
 var Node.next_nextValue3546186: [Node]Node;                                                        
 var Queue.tail_nextThread3546322_bottom: [Queue]Tid;                                               
 var Node.next_nextValue3545889: [Node]Node;                                                        
 var next3546044: Node;                                                                             
 var Queue.tail_nextValue3545895: [Queue]Node;                                                      
 var tid3546276: Tid;                                                                               
 var Node.next_nextValue3545820: [Node]Node;                                                        
 var first3545820: Node;                                                                            
 var $pc3546276: Phase;                                                                             
 var _currentValue: Node;                                                                           
 var last3546319_post: Node;                                                                        
 var Node._lock3546276: [Node]Tid;                                                                  
 var tid3546137: Tid;                                                                               
 var $pc3546322_bottom: Phase;                                                                      
 var Queue.head_nextThread3546276: [Queue]Tid;                                                      
 var Queue.head_nextValue3546186: [Queue]Node;                                                      
 var moverPath3546137: MoverPath;                                                                   
 var Node.next_nextValue3545864: [Node]Node;                                                        
 var Queue.tail_nextThread3546137: [Queue]Tid;                                                      
 var path3546107: int;                                                                              
 var Queue.tail3545964: [Queue]Node;                                                                
 var Node.value3546185: [Node]int;                                                                  
 var Node.next_nextThread3546137: [Node]Tid;                                                        
 var _C_v3545938: Node;                                                                             
 var Node.next_nextThread3546002: [Node]Tid;                                                        
 var Node._state3545873: [Node]State;                                                               
 var Queue.head_nextValue3545952: [Queue]Node;                                                      
 var mover3546249: Mover;                                                                           
 var this3545883: Queue;                                                                            
 var first3546111: Node;                                                                            
 var Node.next_nextThread3546186_post: [Node]Tid;                                                   
 var value3546309: int;                                                                             
 var next3546249: Node;                                                                             
 var Node.value3546041: [Node]int;                                                                  
 var $pc3546149: Phase;                                                                             
 var Queue.head_nextValue3545938: [Queue]Node;                                                      
 var tmp63545889: bool;                                                                             
 var _R_t: Mover;                                                                                   
 var Queue.head_nextValue3545958: [Queue]Node;                                                      
 var ctmp3520129: bool;                                                                             
 var $pc3546253: Phase;                                                                             
 var this3545864: Queue;                                                                            
 var Queue.head_nextThread3545826: [Queue]Tid;                                                      
 var tid3546279: Tid;                                                                               
 var Queue._state3545942_post: [Queue]State;                                                        
 var first3546249: Node;                                                                            
 var Node.value3546246: [Node]int;                                                                  
 var moverPath3546156: MoverPath;                                                                   
 var Queue.head3546325: [Queue]Node;                                                                
 var Node._lock3546319_post: [Node]Tid;                                                             
 var tmpValue3546104: Node;                                                                         
 var tmp113546185: bool;                                                                            
 var Queue.head3546149: [Queue]Node;                                                                
 var tmp73546044_post: bool;                                                                        
 var Node.next_nextThread3545933: [Node]Tid;                                                        
 var tmp7: bool;                                                                                    
 var Queue.tail_nextValue3545814: [Queue]Node;                                                      
 var mover3546276: Mover;                                                                           
 var tid3545814: Tid;                                                                               
 var tmp73546185: bool;                                                                             
 var this3546298: Queue;                                                                            
 var value3546279: int;                                                                             
 var Queue.head_nextValue3546291: [Queue]Node;                                                      
 var $pc3546104: Phase;                                                                             
 var path3545933: int;                                                                              
 var Node.next_nextThread3546322_bottom: [Node]Tid;                                                 
 var Queue.head3545952: [Queue]Node;                                                                
 var _m3546291: Mover;                                                                              
 var Queue._state3546186: [Queue]State;                                                             
 var Queue.tail3546186_post: [Queue]Node;                                                           
 var path3546007: int;                                                                              
 var Queue._lock3545869: [Queue]Tid;                                                                
 var this3545873: Queue;                                                                            
 var _C_t3545964: Tid;                                                                              
 var Queue.tail3546309: [Queue]Node;                                                                
 var _m: Mover;                                                                                     
 var tmp63545933: bool;                                                                             
 var mover3545895: Mover;                                                                           
 var tmp63546137: bool;                                                                             
 var _C_t3545869: Tid;                                                                              
 var Queue.tail_nextThread3546186: [Queue]Tid;                                                      
 var Node.next_nextValue3545942: [Node]Node;                                                        
 var tmp63545942: bool;                                                                             
 var tmp103546149: bool;                                                                            
 var Queue.head_nextThread3545952: [Queue]Tid;                                                      
 var moverPath3546279: MoverPath;                                                                   
 var next3546007: Node;                                                                             
 var first3546246: Node;                                                                            
 var Node.next_nextValue3546253: [Node]Node;                                                        
 var Queue.head3546041: [Queue]Node;                                                                
 var $recorded.state3546156: int;                                                                   
 var $pc3545869: Phase;                                                                             
 var Node._state3546279: [Node]State;                                                               
 var Node.next3546185: [Node]Node;                                                                  
 var Queue.head_nextValue3546309: [Queue]Node;                                                      
 var Node._lock3545942: [Node]Tid;                                                                  
 var Node.next3546137: [Node]Node;                                                                  
 var $recorded.state3545873_post: int;                                                              
 var $result3546041: int;                                                                           
 var Node._state3545826: [Node]State;                                                               
 var tmp83546107: bool;                                                                             
 var Node.next3546246: [Node]Node;                                                                  
 var Queue.tail_nextThread3546276: [Queue]Tid;                                                      
 var $pc3545942: Phase;                                                                             
 var this3545942: Queue;                                                                            
 var Queue.tail3546291: [Queue]Node;                                                                
 var Node.value3546186_post: [Node]int;                                                             
 var Node.next_nextThread3545889: [Node]Tid;                                                        
 var Queue._lock3546325: [Queue]Tid;                                                                
 var Queue._lock3545952: [Queue]Tid;                                                                
 var first3546007: Node;                                                                            
 var Queue.tail3546249: [Queue]Node;                                                                
 var this3546007: Queue;                                                                            
 var Queue._lock3546007: [Queue]Tid;                                                                
 var tmp63546111: bool;                                                                             
 var _C_t3545864: Tid;                                                                              
 var Queue.tail_nextValue3545952: [Queue]Node;                                                      
 var Node.next_nextValue3546325: [Node]Node;                                                        
 var mover3545952: Mover;                                                                           
 var $recorded.state3545864: int;                                                                   
 var Node.next_nextValue3546041: [Node]Node;                                                        
 var last3546291: Node;                                                                             
 var first3545938: Node;                                                                            
 var Node.value3545938: [Node]int;                                                                  
 var next3546186_post: Node;                                                                        
 var tmpValue3546107: Node;                                                                         
 var tid3545889: Tid;                                                                               
 var $pc3546134: Phase;                                                                             
 var Node.value3546309: [Node]int;                                                                  
 var last3546156: Node;                                                                             
 var moverPath3545869: MoverPath;                                                                   
 var ctmp35200943546107: bool;                                                                      
 var Queue.head3546253: [Queue]Node;                                                                
 var this3546319_post: Queue;                                                                       
 var $pc3545933: Phase;                                                                             
 var path3545938: int;                                                                              
 var path3546276: int;                                                                              
 var mover3545869: Mover;                                                                           
 var Node._state3545964: [Node]State;                                                               
 var $result3546246: int;                                                                           
 var next3546185: Node;                                                                             
 var Node.next_nextValue3546322_bottom: [Node]Node;                                                 
 var Queue.head_nextThread3545964: [Queue]Tid;                                                      
 var Queue.head_nextThread3545895: [Queue]Tid;                                                      
 var tmp63545869: bool;                                                                             
 var tmp63545873_post: bool;                                                                        
 var ctmp35200943546134: bool;                                                                      
 var Node.value3545826: [Node]int;                                                                  
 var first3545873: Node;                                                                            
 var Queue.head3546322: [Queue]Node;                                                                
 var moverPath3545964: MoverPath;                                                                   
 var _currentValue3545869: Node;                                                                    
 var Node.next3545814: [Node]Node;                                                                  
 var Node._lock3545933: [Node]Tid;                                                                  
 var $pc3546319: Phase;                                                                             
 var tmp73546186: bool;                                                                             
 var Node._lock3546156: [Node]Tid;                                                                  
 var Node.next_nextThread3546322: [Node]Tid;                                                        
 var first3545814: Node;                                                                            
 var path3545883: int;                                                                              
 var $recorded.state3545820: int;                                                                   
 var tmp83546041: bool;                                                                             
 var _m3546107: Mover;                                                                              
 var Queue._lock3546149: [Queue]Tid;                                                                
 var Node.next_nextValue3546279: [Node]Node;                                                        
 var next3546137: Node;                                                                             
 var Node.next_nextThread3545869: [Node]Tid;                                                        
 var Queue.tail_nextValue3546044_post: [Queue]Node;                                                 
 var Queue.head_nextValue3546249: [Queue]Node;                                                      
 var this3546111: Queue;                                                                            
 var first3545942_post: Node;                                                                       
 var tmp103546107: bool;                                                                            
 var tmp63546246: bool;                                                                             
 var Node.next_nextValue3546291: [Node]Node;                                                        
 var $result3545933: int;                                                                           
 var Node.next3546111: [Node]Node;                                                                  
 var tid3546044: Tid;                                                                               
 var path3546111: int;                                                                              
 var Node.next_nextValue3545938: [Node]Node;                                                        
 var Queue.tail3546149: [Queue]Node;                                                                
 var Queue.tail_nextThread3545958: [Queue]Tid;                                                      
 var Queue.tail_nextValue3546002: [Queue]Node;                                                      
 var Queue._state3546107: [Queue]State;                                                             
 var Queue.tail_nextThread3546186_post: [Queue]Tid;                                                 
 var Node.next_nextThread3546298: [Node]Tid;                                                        
 var Node._state3545864: [Node]State;                                                               
 var Queue.head_nextValue3546111: [Queue]Node;                                                      
 var Queue.tail_nextValue3545938: [Queue]Node;                                                      
 var Node._state3546291: [Node]State;                                                               
 var $pc3546319_post: Phase;                                                                        
 var Node.next_nextThread3545883: [Node]Tid;                                                        
 var tid3546246: Tid;                                                                               
 var $pc3546279: Phase;                                                                             
 var moverPath3545820: MoverPath;                                                                   
 var Queue.head_nextValue3545826: [Queue]Node;                                                      
 var Queue._state3546291: [Queue]State;                                                             
 var $pc3545889: Phase;                                                                             
 var moverPath3546246: MoverPath;                                                                   
 var Node.next_nextValue3545895: [Node]Node;                                                        
 var Queue.head_nextValue3545869: [Queue]Node;                                                      
 var $pc3545814: Phase;                                                                             
 var tmp63546044: bool;                                                                             
 var moverPath3546291: MoverPath;                                                                   
 var ctmp35201293546253: bool;                                                                      
 var Queue._state3545942: [Queue]State;                                                             
 var $pc3546002: Phase;                                                                             
 var tmp113546186: bool;                                                                            
 var Queue.tail_nextThread3546322: [Queue]Tid;                                                      
 var Node.next_nextValue3546185: [Node]Node;                                                        
 var Queue.head3545883: [Queue]Node;                                                                
 var Node.value3546253: [Node]int;                                                                  
 var Queue._state3546041: [Queue]State;                                                             
 var value3546186_post: int;                                                                        
 var Node.next_nextThread3545942_post: [Node]Tid;                                                   
 var first3545942: Node;                                                                            
 var Node._lock3546149: [Node]Tid;                                                                  
 var Queue._state3546319: [Queue]State;                                                             
 var $result3545873_post: int;                                                                      
 var Node._state3545873_post: [Node]State;                                                          
 var Queue.tail_nextValue3545933: [Queue]Node;                                                      
 var _currentValue3546149: Node;                                                                    
 var Queue._lock3546134: [Queue]Tid;                                                                
 var _C_v3545958: Node;                                                                             
 var Queue._lock3546319: [Queue]Tid;                                                                
 var tmp63546319_post: bool;                                                                        
 var Node._lock3545964: [Node]Tid;                                                                  
 var Queue._lock3545942: [Queue]Tid;                                                                
 var last3546002: Node;                                                                             
 var Queue.tail3545895: [Queue]Node;                                                                
 var Queue.tail3545938: [Queue]Node;                                                                
 var $recorded.state3546149: int;                                                                   
 var _casable3546007: bool;                                                                         
 var $pc3546111: Phase;                                                                             
 var Queue.head3546279: [Queue]Node;                                                                
 var Queue.head_nextThread3546322: [Queue]Tid;                                                      
 var Node._state3546319_post: [Node]State;                                                          
 var tid3546325: Tid;                                                                               
 var tmp113546246: bool;                                                                            
 var moverPath3546298: MoverPath;                                                                   
 var Queue.head_nextThread3545958: [Queue]Tid;                                                      
 var Queue.head_nextValue3546044_post: [Queue]Node;                                                 
 var this3546325: Queue;                                                                            
 var Node._state3546186_post: [Node]State;                                                          
 var Queue.head_nextValue3546279: [Queue]Node;                                                      
 var Node.next3546319: [Node]Node;                                                                  
 var Node._lock3546322: [Node]Tid;                                                                  
 var Node.next_nextValue3545952: [Node]Node;                                                        
 var $recorded.state3546325: int;                                                                   
 var Queue._state3546309: [Queue]State;                                                             
 var tmp63546007: bool;                                                                             
 var Queue.head3545873_post: [Queue]Node;                                                           
 var first3546137: Node;                                                                            
 var Node._lock3546041: [Node]Tid;                                                                  
 var tmp73546309: bool;                                                                             
 var tmp6: bool;                                                                                    
 var tmpTid: Tid;                                                                                   
 var Node.next3546186: [Node]Node;                                                                  
 var Node.value3546149: [Node]int;                                                                  
 var Node.value3546104: [Node]int;                                                                  
 var Queue.head_nextValue3545895: [Queue]Node;                                                      
 var Node._lock3545873_post: [Node]Tid;                                                             
 var this3546253: Queue;                                                                            
 var $recorded.state3545869: int;                                                                   
 var Queue._lock3545814: [Queue]Tid;                                                                
 var last3546044_post: Node;                                                                        
 var Queue.tail_nextValue3546322_bottom: [Queue]Node;                                               
 var tid3546156: Tid;                                                                               
 var tmp63545964: bool;                                                                             
 var Node.value3545942: [Node]int;                                                                  
 var Queue._lock3546322: [Queue]Tid;                                                                
 var Node._lock3546246: [Node]Tid;                                                                  
 var next3545883: Node;                                                                             
 var $recorded.state3546186: int;                                                                   
 var Node._state3546107: [Node]State;                                                               
 var tmp73546137: bool;                                                                             
 var Queue.head_nextValue3545864: [Queue]Node;                                                      
 var $result3546253: int;                                                                           
 var Queue.head_nextThread3546044: [Queue]Tid;                                                      
 var Queue.tail3546279: [Queue]Node;                                                                
 var Node.next_nextThread3545873_post: [Node]Tid;                                                   
 var Queue.tail_nextThread3546134: [Queue]Tid;                                                      
 var this3545869: Queue;                                                                            
 var Node.next_nextThread3545964: [Node]Tid;                                                        
 var last3545964: Node;                                                                             
 var Node.value3546276: [Node]int;                                                                  
 var Queue.head_nextThread3545942_post: [Queue]Tid;                                                 
 var Node._state3546276: [Node]State;                                                               
 var this3546137: Queue;                                                                            
 var Queue._lock3546044_post: [Queue]Tid;                                                           
 var Node._lock3546104: [Node]Tid;                                                                  
 var tid3545938: Tid;                                                                               
 var $result3546186_post: int;                                                                      
 var tid3546298: Tid;                                                                               
 var Queue.head3546156: [Queue]Node;                                                                
 var Queue._state3545873: [Queue]State;                                                             
 var Queue._state3545895: [Queue]State;                                                             
 var $pc3546041: Phase;                                                                             
 var _C_v3545864: Node;                                                                             
 var mover3546298: Mover;                                                                           
 var tmp73546319_post: bool;                                                                        
 var Queue.tail_nextValue3546246: [Queue]Node;                                                      
 var path3545889: int;                                                                              
 var Queue.head_nextValue3546007: [Queue]Node;                                                      
 var this3546134: Queue;                                                                            
 var last3546041: Node;                                                                             
 var Queue.tail_nextValue3545964: [Queue]Node;                                                      
 var Queue.tail_nextThread3546319_post: [Queue]Tid;                                                 
 var tmp103546111: bool;                                                                            
 var tmp63546253: bool;                                                                             
 var Queue._state3546185: [Queue]State;                                                             
 var Queue.tail3545942: [Queue]Node;                                                                
 var Node.next3546276: [Node]Node;                                                                  
 var _currentValue3546276: Node;                                                                    
 var this3546041: Queue;                                                                            
 var Node.next_nextThread3546134: [Node]Tid;                                                        
 var Queue._state3546044_post: [Queue]State;                                                        
 var $pc3545958: Phase;                                                                             
 var Queue._lock3546044: [Queue]Tid;                                                                
 var Queue.tail_nextThread3545942: [Queue]Tid;                                                      
 var Node._state3545942_post: [Node]State;                                                          
 var $recorded.state3546137: int;                                                                   
 var tmp63546276: bool;                                                                             
 var first3545933: Node;                                                                            
 var Node.next3546298: [Node]Node;                                                                  
 var path3545814: int;                                                                              
 var Queue.head3546276: [Queue]Node;                                                                
 var $pc3546185: Phase;                                                                             
 var Queue.head3546044_post: [Queue]Node;                                                           
 var Queue.tail_nextValue3545869: [Queue]Node;                                                      
 var next3546309: Node;                                                                             
 var Queue.head_nextThread3545873: [Queue]Tid;                                                      
 var tmp83546044_post: bool;                                                                        
 var Queue.tail_nextThread3546319: [Queue]Tid;                                                      
 var $result3546325: int;                                                                           
 var ctmp35200943546156: bool;                                                                      
 var Queue.tail_nextValue3546186: [Queue]Node;                                                      
 var this3546279: Queue;                                                                            
 var Node.value3546156: [Node]int;                                                                  
 var $result3546319: int;                                                                           
 var Node.next_nextValue3546319_post: [Node]Node;                                                   
 var $recorded.state3545889: int;                                                                   
 var this3546322: Queue;                                                                            
 var Node.value3546044_post: [Node]int;                                                             
 var Queue.head_nextThread3545938: [Queue]Tid;                                                      
 var Queue.tail_nextValue3546044: [Queue]Node;                                                      
 var Node._lock3545958: [Node]Tid;                                                                  
 var Node.next_nextThread3546044: [Node]Tid;                                                        
 var $pc3546246: Phase;                                                                             
 var $result3546249: int;                                                                           
 var Node.next_nextThread3546156: [Node]Tid;                                                        
 var first3546134: Node;                                                                            
 var last3546276: Node;                                                                             
 var tmp123546298: bool;                                                                            
 var last3545952: Node;                                                                             
 var $recorded.state3545952: int;                                                                   
 var path3546279: int;                                                                              
 var Node.value3546111: [Node]int;                                                                  
 var Queue.head_nextValue3546185: [Queue]Node;                                                      
 var Node.next_nextThread3546111: [Node]Tid;                                                        
 var Queue.tail3546111: [Queue]Node;                                                                
 var Queue.tail3546002: [Queue]Node;                                                                
 var Queue.tail_nextThread3546111: [Queue]Tid;                                                      
 var Node._lock3546186: [Node]Tid;                                                                  
 var Node._state3546156: [Node]State;                                                               
 var Node.next3546279: [Node]Node;                                                                  
 var Queue.tail_nextThread3546044: [Queue]Tid;                                                      
 var Node._lock3545869: [Node]Tid;                                                                  
 var Queue.head_nextValue3546107: [Queue]Node;                                                      
 var this3545952: Queue;                                                                            
 var last3546309: Node;                                                                             
 var Queue.head_nextThread3545820: [Queue]Tid;                                                      
 var $pc3545820: Phase;                                                                             
 var Queue.head3546319_post: [Queue]Node;                                                           
 var Queue.head_nextThread3546253: [Queue]Tid;                                                      
 var Queue.head3545889: [Queue]Node;                                                                
 var Queue._state3545938: [Queue]State;                                                             
 var Node._state3546007: [Node]State;                                                               
 var Node._lock3546111: [Node]Tid;                                                                  
 var _C_t3546007: Tid;                                                                              
 var Node.next3546253: [Node]Node;                                                                  
 var tmp63545814: bool;                                                                             
 var Queue.tail3546322_bottom: [Queue]Node;                                                         
 var $pc3545883: Phase;                                                                             
 var _currentValue3545964: Node;                                                                    
 var mover3546111: Mover;                                                                           
 var Queue.head_nextValue3546104: [Queue]Node;                                                      
 var Queue.tail_nextValue3546253: [Queue]Node;                                                      
 var Queue.tail_nextThread3546007: [Queue]Tid;                                                      
 var Queue.tail_nextValue3546134: [Queue]Node;                                                      
 var value3546246: int;                                                                             
 var mover3545883: Mover;                                                                           
 var Queue._state3546298: [Queue]State;                                                             
 var moverPath3546276: MoverPath;                                                                   
 var $recorded.state3546322: int;                                                                   
 var moverPath3546002: MoverPath;                                                                   
 var Node.next3546309: [Node]Node;                                                                  
 var Queue._state3546253: [Queue]State;                                                             
 var mover3546137: Mover;                                                                           
 var last3546249: Node;                                                                             
 var _m3546253: Mover;                                                                              
 var mover3546156: Mover;                                                                           
 var Node._lock3545873: [Node]Tid;                                                                  
 var next3546253: Node;                                                                             
 var this3546319: Queue;                                                                            
 var Queue.tail_nextThread3546249: [Queue]Tid;                                                      
 var Queue.head_nextThread3546107: [Queue]Tid;                                                      
 var Queue._lock3546104: [Queue]Tid;                                                                
 var path3546291: int;                                                                              
 var Queue._lock3545873: [Queue]Tid;                                                                
 var Node.next_nextThread3546291: [Node]Tid;                                                        
 var Queue.tail_nextThread3546298: [Queue]Tid;                                                      
 var Queue.head_nextThread3546044_post: [Queue]Tid;                                                 
 var Node.next_nextThread3546186: [Node]Tid;                                                        
 var moverPath3545864: MoverPath;                                                                   
 var Node._lock3546007: [Node]Tid;                                                                  
 var Queue._lock3546107: [Queue]Tid;                                                                
 var Node._state3545869: [Node]State;                                                               
 var moverPath3545938: MoverPath;                                                                   
 var first3545895: Node;                                                                            
 var Queue.tail_nextThread3545869: [Queue]Tid;                                                      
 var Queue.tail_nextValue3546107: [Queue]Node;                                                      
 var Node.next3545889: [Node]Node;                                                                  
 var ctmp35201293546279: bool;                                                                      
 var tid3545820: Tid;                                                                               
 var $recorded.state3546041: int;                                                                   
 var tmp63545826: bool;                                                                             
 var tmp73546246: bool;                                                                             
 var last3546111: Node;                                                                             
 var Node.value3546186: [Node]int;                                                                  
 var tmp8: bool;                                                                                    
 var Node.next3545958: [Node]Node;                                                                  
 var mover3545933: Mover;                                                                           
 var Node._state3546253: [Node]State;                                                               
 var _casable3545933: bool;                                                                         
 var Node.value3545952: [Node]int;                                                                  
 var Queue.tail_nextThread3545864: [Queue]Tid;                                                      
 var Queue.head_nextThread3546185: [Queue]Tid;                                                      
 var Node.next_nextThread3545938: [Node]Tid;                                                        
 var tmp83546104: bool;                                                                             
 var Node.next3545873: [Node]Node;                                                                  
 var first3546156: Node;                                                                            
 var tmp63545942_post: bool;                                                                        
 var _casable3545864: bool;                                                                         
 var tmp63546149: bool;                                                                             
 var _C_t3546002: Tid;                                                                              
 var phase3546322: Phase;                                                                           
 var Node.value3546134: [Node]int;                                                                  
 var Node._lock3546044: [Node]Tid;                                                                  
 var Queue.tail3546298: [Queue]Node;                                                                
 var Node.next3546186_post: [Node]Node;                                                             
 var _currentValue3545895: Node;                                                                    
 var next3545933: Node;                                                                             
 var mover3546002: Mover;                                                                           
 var Queue.head_nextValue3545942: [Queue]Node;                                                      
 var Node.value3546319_post: [Node]int;                                                             
 var $result3546002: int;                                                                           
 var Queue.head_nextThread3545869: [Queue]Tid;                                                      
 var Node.next3545873_post: [Node]Node;                                                             
 var first3546104: Node;                                                                            
 var tmp113546309: bool;                                                                            
 var Node.next3546319_post: [Node]Node;                                                             
 var Queue.head_nextThread3546186_post: [Queue]Tid;                                                 
 var tmp63546319: bool;                                                                             
 var Queue.head3545873: [Queue]Node;                                                                
 var Queue.tail3545826: [Queue]Node;                                                                
 var Queue.head3545814: [Queue]Node;                                                                
 var Queue._lock3545873_post: [Queue]Tid;                                                           
 var Queue._state3546276: [Queue]State;                                                             
 var Queue.tail3546107: [Queue]Node;                                                                
 var Node.next_nextValue3545933: [Node]Node;                                                        
 var $result3545873: int;                                                                           
 var Node.next_nextValue3545814: [Node]Node;                                                        
 var Node.next_nextThread3546319_post: [Node]Tid;                                                   
 var $result3546276: int;                                                                           
 var $recorded.state3546319: int;                                                                   
 var Queue.tail_nextValue3545873_post: [Queue]Node;                                                 
 var Node.next_nextValue3546156: [Node]Node;                                                        
 var moverPath3545814: MoverPath;                                                                   
 var $result3545869: int;                                                                           
 var Queue._lock3545958: [Queue]Tid;                                                                
 var Node.next3546156: [Node]Node;                                                                  
 var Queue.tail3546319: [Queue]Node;                                                                
 var Node._state3545883: [Node]State;                                                               
 var Queue.head_nextValue3546253: [Queue]Node;                                                      
 var Queue.head3546104: [Queue]Node;                                                                
 var tmp63546107: bool;                                                                             
 var tid3546149: Tid;                                                                               
 var this3546322_bottom: Queue;                                                                     
 var tmp103546137: bool;                                                                            
 var Queue.tail_nextValue3545942_post: [Queue]Node;                                                 
 var Queue.head_nextThread3546309: [Queue]Tid;                                                      
 var first3546149: Node;                                                                            
 var Queue._state3545826: [Queue]State;                                                             
 var path3545826: int;                                                                              
 var Node.next_nextThread3546185: [Node]Tid;                                                        
 var Queue.head3546186: [Queue]Node;                                                                
 var tmp73546298: bool;                                                                             
 var Queue.tail_nextValue3546149: [Queue]Node;                                                      
 var Node._state3546249: [Node]State;                                                               
 var Node.value3546002: [Node]int;                                                                  
 var ctmp35201293546291: bool;                                                                      
 var Node._state3546186: [Node]State;                                                               
 var this3545814: Queue;                                                                            
 var $recorded.state3546044_post: int;                                                              
 var Queue._lock3546137: [Queue]Tid;                                                                
 var Node._lock3546322_bottom: [Node]Tid;                                                           
 var Queue._lock3546298: [Queue]Tid;                                                                
 var _R_t3545938: Mover;                                                                            
 var value3546298: int;                                                                             
 var Queue.tail_nextThread3545938: [Queue]Tid;                                                      
 var next3546134: Node;                                                                             
 var Queue.tail3545942_post: [Queue]Node;                                                           
 var Queue.head_nextValue3545873: [Queue]Node;                                                      
 var Queue._lock3545933: [Queue]Tid;                                                                
 var $result3545820: int;                                                                           
 var Queue.head3546107: [Queue]Node;                                                                
 var tmpValue3546246: Node;                                                                         
 var Queue.tail_nextValue3546319_post: [Queue]Node;                                                 
 var $pc3545964: Phase;                                                                             
 var Node._lock3545952: [Node]Tid;                                                                  
 var _C_t3545958: Tid;                                                                              
 var path3546137: int;                                                                              
 var this3546246: Queue;                                                                            
 var first3545958: Node;                                                                            
 var tmp63546104: bool;                                                                             
 var tmp73546253: bool;                                                                             
 var path3546185: int;                                                                              
 var Queue.head3545964: [Queue]Node;                                                                
 var tmp63546002: bool;                                                                             
 var mover3545889: Mover;                                                                           
 var Node._state3545820: [Node]State;                                                               
 var Queue.tail_nextThread3545873_post: [Queue]Tid;                                                 
 var Node._lock3546253: [Node]Tid;                                                                  
 var Node.value3545883: [Node]int;                                                                  
 var first3546319: Node;                                                                            
 var next3545889: Node;                                                                             
 var last3546134: Node;                                                                             
 var tid3546319: Tid;                                                                               
 var Queue.head3546002: [Queue]Node;                                                                
 var $result3545895: int;                                                                           
 var Queue.head_nextValue3545933: [Queue]Node;                                                      
 var tmp123546309: bool;                                                                            
 var ctmp35201293546276: bool;                                                                      
 var next3546279: Node;                                                                             
 var $result3546007: int;                                                                           
 var Queue.tail_nextValue3545942: [Queue]Node;                                                      
 var this3545942_post: Queue;                                                                       
 var this3546044_post: Queue;                                                                       
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state3546322 == Node._state && Node.value3546322 == Node.value && Node.next3546322 == Node.next && Node._lock3546322 == Node._lock && Node.next_nextThread3546322 == Node.next_nextThread && Node.next_nextValue3546322 == Node.next_nextValue && Queue._state3546322 == Queue._state && Queue.head3546322 == Queue.head && Queue.tail3546322 == Queue.tail && Queue._lock3546322 == Queue._lock && Queue.head_nextThread3546322 == Queue.head_nextThread && Queue.head_nextValue3546322 == Queue.head_nextValue && Queue.tail_nextThread3546322 == Queue.tail_nextThread && Queue.tail_nextValue3546322 == Queue.tail_nextValue && $result3546322 == $result && this3546322 == this && tid3546322 == tid;
 assume $recorded.state3546322 == 1;                                                                
                                                                                                    
 // 55.9: while (true)   {                                                                          
                                                                                                    
 phase3546322 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (54.5): Bad tid
  invariant isShared(Queue._state[this]);                                                                  // (54.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
  invariant  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (55.9): Object invariant may not hold.
  invariant  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (55.9): Object invariant may not hold.
  invariant (forall _this : Node :: Invariant.Y_Node.value(tid : Tid, _this, Node.value[_this] ,Node._state3546322,Node.value3546322,Node.next3546322,Node._lock3546322,Node.next_nextThread3546322,Node.next_nextValue3546322,Queue._state3546322,Queue.head3546322,Queue.tail3546322,Queue._lock3546322,Queue.head_nextThread3546322,Queue.head_nextValue3546322,Queue.tail_nextThread3546322,Queue.tail_nextValue3546322));       // (55.9): Loop does not preserve yields_as annotation for field value
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state3546322,Node.value3546322,Node.next3546322,Node._lock3546322,Node.next_nextThread3546322,Node.next_nextValue3546322,Queue._state3546322,Queue.head3546322,Queue.tail3546322,Queue._lock3546322,Queue.head_nextThread3546322,Queue.head_nextValue3546322,Queue.tail_nextThread3546322,Queue.tail_nextValue3546322));       // (55.9): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Queue :: Invariant.Y_Queue.head(tid : Tid, _this, Queue.head[_this] ,Node._state3546322,Node.value3546322,Node.next3546322,Node._lock3546322,Node.next_nextThread3546322,Node.next_nextValue3546322,Queue._state3546322,Queue.head3546322,Queue.tail3546322,Queue._lock3546322,Queue.head_nextThread3546322,Queue.head_nextValue3546322,Queue.tail_nextThread3546322,Queue.tail_nextValue3546322));       // (55.9): Loop does not preserve yields_as annotation for field head
  invariant (forall _this : Queue :: Invariant.Y_Queue.tail(tid : Tid, _this, Queue.tail[_this] ,Node._state3546322,Node.value3546322,Node.next3546322,Node._lock3546322,Node.next_nextThread3546322,Node.next_nextValue3546322,Queue._state3546322,Queue.head3546322,Queue.tail3546322,Queue._lock3546322,Queue.head_nextThread3546322,Queue.head_nextValue3546322,Queue.tail_nextThread3546322,Queue.tail_nextValue3546322));       // (55.9): Loop does not preserve yields_as annotation for field tail
  invariant phase3546322 == $pc;                                                                           // (55.9): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (55.9): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 55.15: boolean tmp6;                                                                           
                                                                                                    
                                                                                                    
  // 55.15: tmp6 = true;                                                                            
                                                                                                    
  tmp6 := true;                                                                                     
  if (!(tmp6)) {                                                                                    
                                                                                                    
   // 55.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 57.13: Node first;                                                                             
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 57.13: Tid _C_t;                                                                               
                                                                                                    
                                                                                                    
  // 57.13: _C_t := this.head_nextThread  as B;                                                     
                                                                                                    
                                                                                                    
  moverPath3545814 := ReadEval.Queue.head_nextThread(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545814 := m#moverPath(moverPath3545814);                                                    
  path3545814 := p#moverPath(moverPath3545814);                                                     
  assume Node._state3545814 == Node._state && Node.value3545814 == Node.value && Node.next3545814 == Node.next && Node._lock3545814 == Node._lock && Node.next_nextThread3545814 == Node.next_nextThread && Node.next_nextValue3545814 == Node.next_nextValue && Queue._state3545814 == Queue._state && Queue.head3545814 == Queue.head && Queue.tail3545814 == Queue.tail && Queue._lock3545814 == Queue._lock && Queue.head_nextThread3545814 == Queue.head_nextThread && Queue.head_nextValue3545814 == Queue.head_nextValue && Queue.tail_nextThread3545814 == Queue.tail_nextThread && Queue.tail_nextValue3545814 == Queue.tail_nextValue && _C_t3545814 == _C_t && first3545814 == first && tmp63545814 == tmp6 && $result3545814 == $result && this3545814 == this && tid3545814 == tid && $pc3545814 == $pc;
  assume $recorded.state3545814 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (57.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (57.13): Reduction failure
  _C_t := Queue.head_nextThread[this];                                                              
                                                                                                    
  // 57.13: Node _C_v;                                                                              
                                                                                                    
                                                                                                    
  // 57.13: _C_v := this.head_nextValue  as B;                                                      
                                                                                                    
                                                                                                    
  moverPath3545820 := ReadEval.Queue.head_nextValue(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545820 := m#moverPath(moverPath3545820);                                                    
  path3545820 := p#moverPath(moverPath3545820);                                                     
  assume Node._state3545820 == Node._state && Node.value3545820 == Node.value && Node.next3545820 == Node.next && Node._lock3545820 == Node._lock && Node.next_nextThread3545820 == Node.next_nextThread && Node.next_nextValue3545820 == Node.next_nextValue && Queue._state3545820 == Queue._state && Queue.head3545820 == Queue.head && Queue.tail3545820 == Queue.tail && Queue._lock3545820 == Queue._lock && Queue.head_nextThread3545820 == Queue.head_nextThread && Queue.head_nextValue3545820 == Queue.head_nextValue && Queue.tail_nextThread3545820 == Queue.tail_nextThread && Queue.tail_nextValue3545820 == Queue.tail_nextValue && _C_v3545820 == _C_v && _C_t3545820 == _C_t && first3545820 == first && tmp63545820 == tmp6 && $result3545820 == $result && this3545820 == this && tid3545820 == tid && $pc3545820 == $pc;
  assume $recorded.state3545820 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (57.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (57.13): Reduction failure
  _C_v := Queue.head_nextValue[this];                                                               
                                                                                                    
  // 57.13: Node _currentValue;                                                                     
                                                                                                    
                                                                                                    
  // 57.13: _currentValue := this.head  as B;                                                       
                                                                                                    
                                                                                                    
  moverPath3545826 := ReadEval.Queue.head(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545826 := m#moverPath(moverPath3545826);                                                    
  path3545826 := p#moverPath(moverPath3545826);                                                     
  assume Node._state3545826 == Node._state && Node.value3545826 == Node.value && Node.next3545826 == Node.next && Node._lock3545826 == Node._lock && Node.next_nextThread3545826 == Node.next_nextThread && Node.next_nextValue3545826 == Node.next_nextValue && Queue._state3545826 == Queue._state && Queue.head3545826 == Queue.head && Queue.tail3545826 == Queue.tail && Queue._lock3545826 == Queue._lock && Queue.head_nextThread3545826 == Queue.head_nextThread && Queue.head_nextValue3545826 == Queue.head_nextValue && Queue.tail_nextThread3545826 == Queue.tail_nextThread && Queue.tail_nextValue3545826 == Queue.tail_nextValue && _currentValue3545826 == _currentValue && _C_v3545826 == _C_v && _C_t3545826 == _C_t && first3545826 == first && tmp63545826 == tmp6 && $result3545826 == $result && this3545826 == this && tid3545826 == tid && $pc3545826 == $pc;
  assume $recorded.state3545826 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (57.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (57.13): Reduction failure
  _currentValue := Queue.head[this];                                                                
                                                                                                    
  // 57.13: Mover _R_t;                                                                             
                                                                                                    
                                                                                                    
  // 57.13: _R_t = readPermission(this.head);                                                       
                                                                                                    
  _R_t := m#moverPath(ReadEval.Queue.head(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
  // 57.13: boolean _casable;                                                                       
                                                                                                    
                                                                                                    
  // 57.13: _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
                                                                                                    
  _casable := ((((_R_t!=_E)&&false)&&(_C_t==tid))&&(_C_v==_currentValue));                          
  if (_casable) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 57.13: first := this.head  as R;                                                              
                                                                                                    
                                                                                                    
   moverPath3545864 := ReadEval.Queue.head(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
   mover3545864 := m#moverPath(moverPath3545864);                                                   
   path3545864 := p#moverPath(moverPath3545864);                                                    
   assume Node._state3545864 == Node._state && Node.value3545864 == Node.value && Node.next3545864 == Node.next && Node._lock3545864 == Node._lock && Node.next_nextThread3545864 == Node.next_nextThread && Node.next_nextValue3545864 == Node.next_nextValue && Queue._state3545864 == Queue._state && Queue.head3545864 == Queue.head && Queue.tail3545864 == Queue.tail && Queue._lock3545864 == Queue._lock && Queue.head_nextThread3545864 == Queue.head_nextThread && Queue.head_nextValue3545864 == Queue.head_nextValue && Queue.tail_nextThread3545864 == Queue.tail_nextThread && Queue.tail_nextValue3545864 == Queue.tail_nextValue && _casable3545864 == _casable && _R_t3545864 == _R_t && _currentValue3545864 == _currentValue && _C_v3545864 == _C_v && _C_t3545864 == _C_t && first3545864 == first && tmp63545864 == tmp6 && $result3545864 == $result && this3545864 == this && tid3545864 == tid && $pc3545864 == $pc;
   assume $recorded.state3545864 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Queue.null;                                                                      
   } else {                                                                                         
    assert this != Queue.null;                                                                             // (57.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, _R);                                                                      
   assert $pc != PhaseError;                                                                               // (57.13): Reduction failure
   first := Queue.head[this];                                                                       
  } else {                                                                                          
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 57.13: first := this.head;                                                                    
                                                                                                    
                                                                                                    
   moverPath3545869 := ReadEval.Queue.head(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
   mover3545869 := m#moverPath(moverPath3545869);                                                   
   path3545869 := p#moverPath(moverPath3545869);                                                    
   assume Node._state3545869 == Node._state && Node.value3545869 == Node.value && Node.next3545869 == Node.next && Node._lock3545869 == Node._lock && Node.next_nextThread3545869 == Node.next_nextThread && Node.next_nextValue3545869 == Node.next_nextValue && Queue._state3545869 == Queue._state && Queue.head3545869 == Queue.head && Queue.tail3545869 == Queue.tail && Queue._lock3545869 == Queue._lock && Queue.head_nextThread3545869 == Queue.head_nextThread && Queue.head_nextValue3545869 == Queue.head_nextValue && Queue.tail_nextThread3545869 == Queue.tail_nextThread && Queue.tail_nextValue3545869 == Queue.tail_nextValue && _casable3545869 == _casable && _R_t3545869 == _R_t && _currentValue3545869 == _currentValue && _C_v3545869 == _C_v && _C_t3545869 == _C_t && first3545869 == first && tmp63545869 == tmp6 && $result3545869 == $result && this3545869 == this && tid3545869 == tid && $pc3545869 == $pc;
   assume $recorded.state3545869 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Queue.null;                                                                      
   } else {                                                                                         
    assert this != Queue.null;                                                                             // (57.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover3545869);                                                            
   assert $pc != PhaseError;                                                                               // (57.13): Reduction failure
   first := Queue.head[this];                                                                       
  }                                                                                                 
                                                                                                    
  // 58.13: yield;                                                                                  
                                                                                                    
  assume Node._state3545873 == Node._state && Node.value3545873 == Node.value && Node.next3545873 == Node.next && Node._lock3545873 == Node._lock && Node.next_nextThread3545873 == Node.next_nextThread && Node.next_nextValue3545873 == Node.next_nextValue && Queue._state3545873 == Queue._state && Queue.head3545873 == Queue.head && Queue.tail3545873 == Queue.tail && Queue._lock3545873 == Queue._lock && Queue.head_nextThread3545873 == Queue.head_nextThread && Queue.head_nextValue3545873 == Queue.head_nextValue && Queue.tail_nextThread3545873 == Queue.tail_nextThread && Queue.tail_nextValue3545873 == Queue.tail_nextValue && first3545873 == first && tmp63545873 == tmp6 && $result3545873 == $result && this3545873 == this && tid3545873 == tid;
  assume $recorded.state3545873 == 1;                                                               
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (58.13): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (58.13): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (58.13): Object invariant may not hold.
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (58.13): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Node._state3545873_post == Node._state && Node.value3545873_post == Node.value && Node.next3545873_post == Node.next && Node._lock3545873_post == Node._lock && Node.next_nextThread3545873_post == Node.next_nextThread && Node.next_nextValue3545873_post == Node.next_nextValue && Queue._state3545873_post == Queue._state && Queue.head3545873_post == Queue.head && Queue.tail3545873_post == Queue.tail && Queue._lock3545873_post == Queue._lock && Queue.head_nextThread3545873_post == Queue.head_nextThread && Queue.head_nextValue3545873_post == Queue.head_nextValue && Queue.tail_nextThread3545873_post == Queue.tail_nextThread && Queue.tail_nextValue3545873_post == Queue.tail_nextValue && first3545873_post == first && tmp63545873_post == tmp6 && $result3545873_post == $result && this3545873_post == this && tid3545873_post == tid;
  assume $recorded.state3545873_post == 1;                                                          
                                                                                                    
  // 59.13: Node next;                                                                              
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 59.13: Tid _C_t;                                                                               
                                                                                                    
                                                                                                    
  // 59.13: _C_t := first.next_nextThread  as B;                                                    
                                                                                                    
                                                                                                    
  moverPath3545883 := ReadEval.Node.next_nextThread(tid: Tid,first: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545883 := m#moverPath(moverPath3545883);                                                    
  path3545883 := p#moverPath(moverPath3545883);                                                     
  assume Node._state3545883 == Node._state && Node.value3545883 == Node.value && Node.next3545883 == Node.next && Node._lock3545883 == Node._lock && Node.next_nextThread3545883 == Node.next_nextThread && Node.next_nextValue3545883 == Node.next_nextValue && Queue._state3545883 == Queue._state && Queue.head3545883 == Queue.head && Queue.tail3545883 == Queue.tail && Queue._lock3545883 == Queue._lock && Queue.head_nextThread3545883 == Queue.head_nextThread && Queue.head_nextValue3545883 == Queue.head_nextValue && Queue.tail_nextThread3545883 == Queue.tail_nextThread && Queue.tail_nextValue3545883 == Queue.tail_nextValue && _C_t3545883 == _C_t && next3545883 == next && first3545883 == first && tmp63545883 == tmp6 && $result3545883 == $result && this3545883 == this && tid3545883 == tid && $pc3545883 == $pc;
  assume $recorded.state3545883 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume first != Node.null;                                                                       
  } else {                                                                                          
   assert first != Node.null;                                                                              // (59.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (59.13): Reduction failure
  _C_t := Node.next_nextThread[first];                                                              
                                                                                                    
  // 59.13: Node _C_v;                                                                              
                                                                                                    
                                                                                                    
  // 59.13: _C_v := first.next_nextValue  as B;                                                     
                                                                                                    
                                                                                                    
  moverPath3545889 := ReadEval.Node.next_nextValue(tid: Tid,first: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545889 := m#moverPath(moverPath3545889);                                                    
  path3545889 := p#moverPath(moverPath3545889);                                                     
  assume Node._state3545889 == Node._state && Node.value3545889 == Node.value && Node.next3545889 == Node.next && Node._lock3545889 == Node._lock && Node.next_nextThread3545889 == Node.next_nextThread && Node.next_nextValue3545889 == Node.next_nextValue && Queue._state3545889 == Queue._state && Queue.head3545889 == Queue.head && Queue.tail3545889 == Queue.tail && Queue._lock3545889 == Queue._lock && Queue.head_nextThread3545889 == Queue.head_nextThread && Queue.head_nextValue3545889 == Queue.head_nextValue && Queue.tail_nextThread3545889 == Queue.tail_nextThread && Queue.tail_nextValue3545889 == Queue.tail_nextValue && _C_v3545889 == _C_v && _C_t3545889 == _C_t && next3545889 == next && first3545889 == first && tmp63545889 == tmp6 && $result3545889 == $result && this3545889 == this && tid3545889 == tid && $pc3545889 == $pc;
  assume $recorded.state3545889 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume first != Node.null;                                                                       
  } else {                                                                                          
   assert first != Node.null;                                                                              // (59.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (59.13): Reduction failure
  _C_v := Node.next_nextValue[first];                                                               
                                                                                                    
  // 59.13: Node _currentValue;                                                                     
                                                                                                    
                                                                                                    
  // 59.13: _currentValue := first.next  as B;                                                      
                                                                                                    
                                                                                                    
  moverPath3545895 := ReadEval.Node.next(tid: Tid,first: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545895 := m#moverPath(moverPath3545895);                                                    
  path3545895 := p#moverPath(moverPath3545895);                                                     
  assume Node._state3545895 == Node._state && Node.value3545895 == Node.value && Node.next3545895 == Node.next && Node._lock3545895 == Node._lock && Node.next_nextThread3545895 == Node.next_nextThread && Node.next_nextValue3545895 == Node.next_nextValue && Queue._state3545895 == Queue._state && Queue.head3545895 == Queue.head && Queue.tail3545895 == Queue.tail && Queue._lock3545895 == Queue._lock && Queue.head_nextThread3545895 == Queue.head_nextThread && Queue.head_nextValue3545895 == Queue.head_nextValue && Queue.tail_nextThread3545895 == Queue.tail_nextThread && Queue.tail_nextValue3545895 == Queue.tail_nextValue && _currentValue3545895 == _currentValue && _C_v3545895 == _C_v && _C_t3545895 == _C_t && next3545895 == next && first3545895 == first && tmp63545895 == tmp6 && $result3545895 == $result && this3545895 == this && tid3545895 == tid && $pc3545895 == $pc;
  assume $recorded.state3545895 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume first != Node.null;                                                                       
  } else {                                                                                          
   assert first != Node.null;                                                                              // (59.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (59.13): Reduction failure
  _currentValue := Node.next[first];                                                                
                                                                                                    
  // 59.13: Mover _R_t;                                                                             
                                                                                                    
                                                                                                    
  // 59.13: _R_t = readPermission(first.next);                                                      
                                                                                                    
  _R_t := m#moverPath(ReadEval.Node.next(tid: Tid,first: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
  // 59.13: boolean _casable;                                                                       
                                                                                                    
                                                                                                    
  // 59.13: _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
                                                                                                    
  _casable := ((((_R_t!=_E)&&false)&&(_C_t==tid))&&(_C_v==_currentValue));                          
  if (_casable) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 59.13: next := first.next  as R;                                                              
                                                                                                    
                                                                                                    
   moverPath3545933 := ReadEval.Node.next(tid: Tid,first: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
   mover3545933 := m#moverPath(moverPath3545933);                                                   
   path3545933 := p#moverPath(moverPath3545933);                                                    
   assume Node._state3545933 == Node._state && Node.value3545933 == Node.value && Node.next3545933 == Node.next && Node._lock3545933 == Node._lock && Node.next_nextThread3545933 == Node.next_nextThread && Node.next_nextValue3545933 == Node.next_nextValue && Queue._state3545933 == Queue._state && Queue.head3545933 == Queue.head && Queue.tail3545933 == Queue.tail && Queue._lock3545933 == Queue._lock && Queue.head_nextThread3545933 == Queue.head_nextThread && Queue.head_nextValue3545933 == Queue.head_nextValue && Queue.tail_nextThread3545933 == Queue.tail_nextThread && Queue.tail_nextValue3545933 == Queue.tail_nextValue && _casable3545933 == _casable && _R_t3545933 == _R_t && _currentValue3545933 == _currentValue && _C_v3545933 == _C_v && _C_t3545933 == _C_t && next3545933 == next && first3545933 == first && tmp63545933 == tmp6 && $result3545933 == $result && this3545933 == this && tid3545933 == tid && $pc3545933 == $pc;
   assume $recorded.state3545933 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume first != Node.null;                                                                      
   } else {                                                                                         
    assert first != Node.null;                                                                             // (59.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, _R);                                                                      
   assert $pc != PhaseError;                                                                               // (59.13): Reduction failure
   next := Node.next[first];                                                                        
  } else {                                                                                          
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 59.13: next := first.next;                                                                    
                                                                                                    
                                                                                                    
   moverPath3545938 := ReadEval.Node.next(tid: Tid,first: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
   mover3545938 := m#moverPath(moverPath3545938);                                                   
   path3545938 := p#moverPath(moverPath3545938);                                                    
   assume Node._state3545938 == Node._state && Node.value3545938 == Node.value && Node.next3545938 == Node.next && Node._lock3545938 == Node._lock && Node.next_nextThread3545938 == Node.next_nextThread && Node.next_nextValue3545938 == Node.next_nextValue && Queue._state3545938 == Queue._state && Queue.head3545938 == Queue.head && Queue.tail3545938 == Queue.tail && Queue._lock3545938 == Queue._lock && Queue.head_nextThread3545938 == Queue.head_nextThread && Queue.head_nextValue3545938 == Queue.head_nextValue && Queue.tail_nextThread3545938 == Queue.tail_nextThread && Queue.tail_nextValue3545938 == Queue.tail_nextValue && _casable3545938 == _casable && _R_t3545938 == _R_t && _currentValue3545938 == _currentValue && _C_v3545938 == _C_v && _C_t3545938 == _C_t && next3545938 == next && first3545938 == first && tmp63545938 == tmp6 && $result3545938 == $result && this3545938 == this && tid3545938 == tid && $pc3545938 == $pc;
   assume $recorded.state3545938 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume first != Node.null;                                                                      
   } else {                                                                                         
    assert first != Node.null;                                                                             // (59.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover3545938);                                                            
   assert $pc != PhaseError;                                                                               // (59.13): Reduction failure
   next := Node.next[first];                                                                        
  }                                                                                                 
                                                                                                    
  // 60.13: yield;                                                                                  
                                                                                                    
  assume Node._state3545942 == Node._state && Node.value3545942 == Node.value && Node.next3545942 == Node.next && Node._lock3545942 == Node._lock && Node.next_nextThread3545942 == Node.next_nextThread && Node.next_nextValue3545942 == Node.next_nextValue && Queue._state3545942 == Queue._state && Queue.head3545942 == Queue.head && Queue.tail3545942 == Queue.tail && Queue._lock3545942 == Queue._lock && Queue.head_nextThread3545942 == Queue.head_nextThread && Queue.head_nextValue3545942 == Queue.head_nextValue && Queue.tail_nextThread3545942 == Queue.tail_nextThread && Queue.tail_nextValue3545942 == Queue.tail_nextValue && next3545942 == next && first3545942 == first && tmp63545942 == tmp6 && $result3545942 == $result && this3545942 == this && tid3545942 == tid;
  assume $recorded.state3545942 == 1;                                                               
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (60.13): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (60.13): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (60.13): Object invariant may not hold.
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (60.13): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Node._state3545942_post == Node._state && Node.value3545942_post == Node.value && Node.next3545942_post == Node.next && Node._lock3545942_post == Node._lock && Node.next_nextThread3545942_post == Node.next_nextThread && Node.next_nextValue3545942_post == Node.next_nextValue && Queue._state3545942_post == Queue._state && Queue.head3545942_post == Queue.head && Queue.tail3545942_post == Queue.tail && Queue._lock3545942_post == Queue._lock && Queue.head_nextThread3545942_post == Queue.head_nextThread && Queue.head_nextValue3545942_post == Queue.head_nextValue && Queue.tail_nextThread3545942_post == Queue.tail_nextThread && Queue.tail_nextValue3545942_post == Queue.tail_nextValue && next3545942_post == next && first3545942_post == first && tmp63545942_post == tmp6 && $result3545942_post == $result && this3545942_post == this && tid3545942_post == tid;
  assume $recorded.state3545942_post == 1;                                                          
                                                                                                    
  // 61.13: Node last;                                                                              
                                                                                                    
  // NoOp: 'TraceOff'                                                                               
                                                                                                    
  // 61.13: Tid _C_t;                                                                               
                                                                                                    
                                                                                                    
  // 61.13: _C_t := this.tail_nextThread  as B;                                                     
                                                                                                    
                                                                                                    
  moverPath3545952 := ReadEval.Queue.tail_nextThread(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545952 := m#moverPath(moverPath3545952);                                                    
  path3545952 := p#moverPath(moverPath3545952);                                                     
  assume Node._state3545952 == Node._state && Node.value3545952 == Node.value && Node.next3545952 == Node.next && Node._lock3545952 == Node._lock && Node.next_nextThread3545952 == Node.next_nextThread && Node.next_nextValue3545952 == Node.next_nextValue && Queue._state3545952 == Queue._state && Queue.head3545952 == Queue.head && Queue.tail3545952 == Queue.tail && Queue._lock3545952 == Queue._lock && Queue.head_nextThread3545952 == Queue.head_nextThread && Queue.head_nextValue3545952 == Queue.head_nextValue && Queue.tail_nextThread3545952 == Queue.tail_nextThread && Queue.tail_nextValue3545952 == Queue.tail_nextValue && _C_t3545952 == _C_t && last3545952 == last && next3545952 == next && first3545952 == first && tmp63545952 == tmp6 && $result3545952 == $result && this3545952 == this && tid3545952 == tid && $pc3545952 == $pc;
  assume $recorded.state3545952 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (61.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (61.13): Reduction failure
  _C_t := Queue.tail_nextThread[this];                                                              
                                                                                                    
  // 61.13: Node _C_v;                                                                              
                                                                                                    
                                                                                                    
  // 61.13: _C_v := this.tail_nextValue  as B;                                                      
                                                                                                    
                                                                                                    
  moverPath3545958 := ReadEval.Queue.tail_nextValue(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545958 := m#moverPath(moverPath3545958);                                                    
  path3545958 := p#moverPath(moverPath3545958);                                                     
  assume Node._state3545958 == Node._state && Node.value3545958 == Node.value && Node.next3545958 == Node.next && Node._lock3545958 == Node._lock && Node.next_nextThread3545958 == Node.next_nextThread && Node.next_nextValue3545958 == Node.next_nextValue && Queue._state3545958 == Queue._state && Queue.head3545958 == Queue.head && Queue.tail3545958 == Queue.tail && Queue._lock3545958 == Queue._lock && Queue.head_nextThread3545958 == Queue.head_nextThread && Queue.head_nextValue3545958 == Queue.head_nextValue && Queue.tail_nextThread3545958 == Queue.tail_nextThread && Queue.tail_nextValue3545958 == Queue.tail_nextValue && _C_v3545958 == _C_v && _C_t3545958 == _C_t && last3545958 == last && next3545958 == next && first3545958 == first && tmp63545958 == tmp6 && $result3545958 == $result && this3545958 == this && tid3545958 == tid && $pc3545958 == $pc;
  assume $recorded.state3545958 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (61.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (61.13): Reduction failure
  _C_v := Queue.tail_nextValue[this];                                                               
                                                                                                    
  // 61.13: Node _currentValue;                                                                     
                                                                                                    
                                                                                                    
  // 61.13: _currentValue := this.tail  as B;                                                       
                                                                                                    
                                                                                                    
  moverPath3545964 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
  mover3545964 := m#moverPath(moverPath3545964);                                                    
  path3545964 := p#moverPath(moverPath3545964);                                                     
  assume Node._state3545964 == Node._state && Node.value3545964 == Node.value && Node.next3545964 == Node.next && Node._lock3545964 == Node._lock && Node.next_nextThread3545964 == Node.next_nextThread && Node.next_nextValue3545964 == Node.next_nextValue && Queue._state3545964 == Queue._state && Queue.head3545964 == Queue.head && Queue.tail3545964 == Queue.tail && Queue._lock3545964 == Queue._lock && Queue.head_nextThread3545964 == Queue.head_nextThread && Queue.head_nextValue3545964 == Queue.head_nextValue && Queue.tail_nextThread3545964 == Queue.tail_nextThread && Queue.tail_nextValue3545964 == Queue.tail_nextValue && _currentValue3545964 == _currentValue && _C_v3545964 == _C_v && _C_t3545964 == _C_t && last3545964 == last && next3545964 == next && first3545964 == first && tmp63545964 == tmp6 && $result3545964 == $result && this3545964 == this && tid3545964 == tid && $pc3545964 == $pc;
  assume $recorded.state3545964 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (61.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, _B);                                                                       
  assert $pc != PhaseError;                                                                                // (61.13): Reduction failure
  _currentValue := Queue.tail[this];                                                                
                                                                                                    
  // 61.13: Mover _R_t;                                                                             
                                                                                                    
                                                                                                    
  // 61.13: _R_t = readPermission(this.tail);                                                       
                                                                                                    
  _R_t := m#moverPath(ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
  // 61.13: boolean _casable;                                                                       
                                                                                                    
                                                                                                    
  // 61.13: _casable = _R_t != E && false && _C_t == tid && _C_v == _currentValue;                  
                                                                                                    
  _casable := ((((_R_t!=_E)&&false)&&(_C_t==tid))&&(_C_v==_currentValue));                          
  if (_casable) {                                                                                   
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 61.13: last := this.tail  as R;                                                               
                                                                                                    
                                                                                                    
   moverPath3546002 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
   mover3546002 := m#moverPath(moverPath3546002);                                                   
   path3546002 := p#moverPath(moverPath3546002);                                                    
   assume Node._state3546002 == Node._state && Node.value3546002 == Node.value && Node.next3546002 == Node.next && Node._lock3546002 == Node._lock && Node.next_nextThread3546002 == Node.next_nextThread && Node.next_nextValue3546002 == Node.next_nextValue && Queue._state3546002 == Queue._state && Queue.head3546002 == Queue.head && Queue.tail3546002 == Queue.tail && Queue._lock3546002 == Queue._lock && Queue.head_nextThread3546002 == Queue.head_nextThread && Queue.head_nextValue3546002 == Queue.head_nextValue && Queue.tail_nextThread3546002 == Queue.tail_nextThread && Queue.tail_nextValue3546002 == Queue.tail_nextValue && _casable3546002 == _casable && _R_t3546002 == _R_t && _currentValue3546002 == _currentValue && _C_v3546002 == _C_v && _C_t3546002 == _C_t && last3546002 == last && next3546002 == next && first3546002 == first && tmp63546002 == tmp6 && $result3546002 == $result && this3546002 == this && tid3546002 == tid && $pc3546002 == $pc;
   assume $recorded.state3546002 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Queue.null;                                                                      
   } else {                                                                                         
    assert this != Queue.null;                                                                             // (61.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, _R);                                                                      
   assert $pc != PhaseError;                                                                               // (61.13): Reduction failure
   last := Queue.tail[this];                                                                        
  } else {                                                                                          
   // NoOp: 'TraceOn'                                                                               
                                                                                                    
   // 61.13: last := this.tail;                                                                     
                                                                                                    
                                                                                                    
   moverPath3546007 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
   mover3546007 := m#moverPath(moverPath3546007);                                                   
   path3546007 := p#moverPath(moverPath3546007);                                                    
   assume Node._state3546007 == Node._state && Node.value3546007 == Node.value && Node.next3546007 == Node.next && Node._lock3546007 == Node._lock && Node.next_nextThread3546007 == Node.next_nextThread && Node.next_nextValue3546007 == Node.next_nextValue && Queue._state3546007 == Queue._state && Queue.head3546007 == Queue.head && Queue.tail3546007 == Queue.tail && Queue._lock3546007 == Queue._lock && Queue.head_nextThread3546007 == Queue.head_nextThread && Queue.head_nextValue3546007 == Queue.head_nextValue && Queue.tail_nextThread3546007 == Queue.tail_nextThread && Queue.tail_nextValue3546007 == Queue.tail_nextValue && _casable3546007 == _casable && _R_t3546007 == _R_t && _currentValue3546007 == _currentValue && _C_v3546007 == _C_v && _C_t3546007 == _C_t && last3546007 == last && next3546007 == next && first3546007 == first && tmp63546007 == tmp6 && $result3546007 == $result && this3546007 == this && tid3546007 == tid && $pc3546007 == $pc;
   assume $recorded.state3546007 == 1;                                                              
   if ($pc == PreCommit) {                                                                          
    assume this != Queue.null;                                                                      
   } else {                                                                                         
    assert this != Queue.null;                                                                             // (61.13): Cannot have potential null deference in left-mover part.
   }                                                                                                
                                                                                                    
   $pc := transition($pc, mover3546007);                                                            
   assert $pc != PhaseError;                                                                               // (61.13): Reduction failure
   last := Queue.tail[this];                                                                        
  }                                                                                                 
                                                                                                    
  // 62.13: boolean tmp7;                                                                           
                                                                                                    
                                                                                                    
  // 62.13: tmp7 = first == last;                                                                   
                                                                                                    
  tmp7 := (first==last);                                                                            
  if (tmp7 /* lowered (first==last) */) {                                                           
                                                                                                    
   // 63.17: boolean tmp8;                                                                          
                                                                                                    
                                                                                                    
   // 63.17: tmp8 = next == Node.null;                                                              
                                                                                                    
   tmp8 := (next==Node.null);                                                                       
   if (tmp8 /* lowered (next==Node.null) */) {                                                      
                                                                                                    
    // 64.18: int tmp9;                                                                             
                                                                                                    
                                                                                                    
    // 64.18: tmp9 = -1;                                                                            
                                                                                                    
    tmp9 := -(1);                                                                                   
                                                                                                    
    // 64.18:  return tmp9;                                                                         
                                                                                                    
    assume Node._state3546041 == Node._state && Node.value3546041 == Node.value && Node.next3546041 == Node.next && Node._lock3546041 == Node._lock && Node.next_nextThread3546041 == Node.next_nextThread && Node.next_nextValue3546041 == Node.next_nextValue && Queue._state3546041 == Queue._state && Queue.head3546041 == Queue.head && Queue.tail3546041 == Queue.tail && Queue._lock3546041 == Queue._lock && Queue.head_nextThread3546041 == Queue.head_nextThread && Queue.head_nextValue3546041 == Queue.head_nextValue && Queue.tail_nextThread3546041 == Queue.tail_nextThread && Queue.tail_nextValue3546041 == Queue.tail_nextValue && tmp93546041 == tmp9 && tmp83546041 == tmp8 && tmp73546041 == tmp7 && last3546041 == last && next3546041 == next && first3546041 == first && tmp63546041 == tmp6 && $result3546041 == $result && this3546041 == this && tid3546041 == tid;
    assume $recorded.state3546041 == 1;                                                             
    $result := tmp9;                                                                                
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (64.18): Object invariant may not hold.
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (64.18): Object invariant may not hold.
    return;                                                                                         
   } else {                                                                                         
                                                                                                    
    // 66.18: yield;                                                                                
                                                                                                    
    assume Node._state3546044 == Node._state && Node.value3546044 == Node.value && Node.next3546044 == Node.next && Node._lock3546044 == Node._lock && Node.next_nextThread3546044 == Node.next_nextThread && Node.next_nextValue3546044 == Node.next_nextValue && Queue._state3546044 == Queue._state && Queue.head3546044 == Queue.head && Queue.tail3546044 == Queue.tail && Queue._lock3546044 == Queue._lock && Queue.head_nextThread3546044 == Queue.head_nextThread && Queue.head_nextValue3546044 == Queue.head_nextValue && Queue.tail_nextThread3546044 == Queue.tail_nextThread && Queue.tail_nextValue3546044 == Queue.tail_nextValue && tmp83546044 == tmp8 && tmp73546044 == tmp7 && last3546044 == last && next3546044 == next && first3546044 == first && tmp63546044 == tmp6 && $result3546044 == $result && this3546044 == this && tid3546044 == tid;
    assume $recorded.state3546044 == 1;                                                             
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (66.18): Object invariant may not hold.
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (66.18): Object invariant may not hold.
    call Yield(tid);                                                                                
    assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (66.18): Object invariant may not hold.
    assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (66.18): Object invariant may not hold.
    $pc := PreCommit;                                                                               
    assume Node._state3546044_post == Node._state && Node.value3546044_post == Node.value && Node.next3546044_post == Node.next && Node._lock3546044_post == Node._lock && Node.next_nextThread3546044_post == Node.next_nextThread && Node.next_nextValue3546044_post == Node.next_nextValue && Queue._state3546044_post == Queue._state && Queue.head3546044_post == Queue.head && Queue.tail3546044_post == Queue.tail && Queue._lock3546044_post == Queue._lock && Queue.head_nextThread3546044_post == Queue.head_nextThread && Queue.head_nextValue3546044_post == Queue.head_nextValue && Queue.tail_nextThread3546044_post == Queue.tail_nextThread && Queue.tail_nextValue3546044_post == Queue.tail_nextValue && tmp83546044_post == tmp8 && tmp73546044_post == tmp7 && last3546044_post == last && next3546044_post == next && first3546044_post == first && tmp63546044_post == tmp6 && $result3546044_post == $result && this3546044_post == this && tid3546044_post == tid;
    assume $recorded.state3546044_post == 1;                                                        
                                                                                                    
    // 67.18: boolean tmp10;                                                                        
                                                                                                    
    // NoOp: 'TraceOff'                                                                             
                                                                                                    
    // 67.18: boolean ctmp3520094;                                                                  
                                                                                                    
                                                                                                    
    // 67.18: ctmp3520094 = *;                                                                      
                                                                                                    
    havoc ctmp3520094;                                                                              
    if (ctmp3520094) {                                                                              
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
     // 67.18: tmp10 = false;                                                                       
                                                                                                    
     tmp10 := false;                                                                                
    } else {                                                                                        
                                                                                                    
     // 67.18: ctmp3520094 = *;                                                                     
                                                                                                    
     havoc ctmp3520094;                                                                             
     if (ctmp3520094) {                                                                             
                                                                                                    
      // 67.18: Tid tmpTid;                                                                         
                                                                                                    
                                                                                                    
      // 67.18: Node tmpValue;                                                                      
                                                                                                    
                                                                                                    
      // 67.18: Mover _m;                                                                           
                                                                                                    
                                                                                                    
      // 67.18: _m = writePermission(this.tail, next);                                              
                                                                                                    
      _m := m#moverPath(WriteEval.Queue.tail(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
      // 67.18: assume this.tail == last;                                                           
                                                                                                    
      assume (Queue.tail[this]==last);                                                              
                                                                                                    
      // 67.18: assume !goesWrong(_m);                                                              
                                                                                                    
      assume !(transition($pc, _m) == PhaseError);                                                  
                                                                                                    
      // 67.18: assume this.tail_nextThread == tid;                                                 
                                                                                                    
      assume (Queue.tail_nextThread[this]==tid);                                                    
                                                                                                    
      // 67.18: assume this.tail_nextValue == last;                                                 
                                                                                                    
      assume (Queue.tail_nextValue[this]==last);                                                    
                                                                                                    
                                                                                                    
      // 67.18: this.tail_nextThread := tmpTid as B;                                                
                                                                                                    
                                                                                                    
      moverPath3546104 := WriteEval.Queue.tail_nextThread(tid: Tid,this: Queue,tmpTid: Tid,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546104 := m#moverPath(moverPath3546104);                                                
      path3546104 := p#moverPath(moverPath3546104);                                                 
      assume Node._state3546104 == Node._state && Node.value3546104 == Node.value && Node.next3546104 == Node.next && Node._lock3546104 == Node._lock && Node.next_nextThread3546104 == Node.next_nextThread && Node.next_nextValue3546104 == Node.next_nextValue && Queue._state3546104 == Queue._state && Queue.head3546104 == Queue.head && Queue.tail3546104 == Queue.tail && Queue._lock3546104 == Queue._lock && Queue.head_nextThread3546104 == Queue.head_nextThread && Queue.head_nextValue3546104 == Queue.head_nextValue && Queue.tail_nextThread3546104 == Queue.tail_nextThread && Queue.tail_nextValue3546104 == Queue.tail_nextValue && _m3546104 == _m && tmpValue3546104 == tmpValue && tmpTid3546104 == tmpTid && ctmp35200943546104 == ctmp3520094 && tmp103546104 == tmp10 && tmp83546104 == tmp8 && tmp73546104 == tmp7 && last3546104 == last && next3546104 == next && first3546104 == first && tmp63546104 == tmp6 && $result3546104 == $result && this3546104 == this && tid3546104 == tid && $pc3546104 == $pc;
      assume $recorded.state3546104 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (67.18): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (67.18): Reduction failure
      Queue.tail_nextThread[this] := tmpTid;                                                        
                                                                                                    
                                                                                                    
      // 67.18: this.tail_nextValue := tmpValue as B;                                               
                                                                                                    
                                                                                                    
      moverPath3546107 := WriteEval.Queue.tail_nextValue(tid: Tid,this: Queue,tmpValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546107 := m#moverPath(moverPath3546107);                                                
      path3546107 := p#moverPath(moverPath3546107);                                                 
      assume Node._state3546107 == Node._state && Node.value3546107 == Node.value && Node.next3546107 == Node.next && Node._lock3546107 == Node._lock && Node.next_nextThread3546107 == Node.next_nextThread && Node.next_nextValue3546107 == Node.next_nextValue && Queue._state3546107 == Queue._state && Queue.head3546107 == Queue.head && Queue.tail3546107 == Queue.tail && Queue._lock3546107 == Queue._lock && Queue.head_nextThread3546107 == Queue.head_nextThread && Queue.head_nextValue3546107 == Queue.head_nextValue && Queue.tail_nextThread3546107 == Queue.tail_nextThread && Queue.tail_nextValue3546107 == Queue.tail_nextValue && _m3546107 == _m && tmpValue3546107 == tmpValue && tmpTid3546107 == tmpTid && ctmp35200943546107 == ctmp3520094 && tmp103546107 == tmp10 && tmp83546107 == tmp8 && tmp73546107 == tmp7 && last3546107 == last && next3546107 == next && first3546107 == first && tmp63546107 == tmp6 && $result3546107 == $result && this3546107 == this && tid3546107 == tid && $pc3546107 == $pc;
      assume $recorded.state3546107 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (67.18): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (67.18): Reduction failure
      Queue.tail_nextValue[this] := tmpValue;                                                       
      // NoOp: 'TraceOn'                                                                            
                                                                                                    
                                                                                                    
      // 67.18: this.tail := next;                                                                  
                                                                                                    
                                                                                                    
      moverPath3546111 := WriteEval.Queue.tail(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546111 := m#moverPath(moverPath3546111);                                                
      path3546111 := p#moverPath(moverPath3546111);                                                 
      assume Node._state3546111 == Node._state && Node.value3546111 == Node.value && Node.next3546111 == Node.next && Node._lock3546111 == Node._lock && Node.next_nextThread3546111 == Node.next_nextThread && Node.next_nextValue3546111 == Node.next_nextValue && Queue._state3546111 == Queue._state && Queue.head3546111 == Queue.head && Queue.tail3546111 == Queue.tail && Queue._lock3546111 == Queue._lock && Queue.head_nextThread3546111 == Queue.head_nextThread && Queue.head_nextValue3546111 == Queue.head_nextValue && Queue.tail_nextThread3546111 == Queue.tail_nextThread && Queue.tail_nextValue3546111 == Queue.tail_nextValue && _m3546111 == _m && tmpValue3546111 == tmpValue && tmpTid3546111 == tmpTid && ctmp35200943546111 == ctmp3520094 && tmp103546111 == tmp10 && tmp83546111 == tmp8 && tmp73546111 == tmp7 && last3546111 == last && next3546111 == next && first3546111 == first && tmp63546111 == tmp6 && $result3546111 == $result && this3546111 == this && tid3546111 == tid && $pc3546111 == $pc;
      assume $recorded.state3546111 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (67.18): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, mover3546111);                                                         
      assert $pc != PhaseError;                                                                            // (67.18): Reduction failure
      Queue.tail[this] := next;                                                                     
      if (isLocal(Node._state[next], tid)) {                                                        
       Node._state[next] := SHARED();                                                               
       assert isSharedAssignable(Node._state[Node.next[next]]);                                            // (67.18): next became shared, but next.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 67.18: tmp10 = true;                                                                       
                                                                                                    
      tmp10 := true;                                                                                
     } else {                                                                                       
                                                                                                    
      // 67.18: assume this.tail_nextThread == tid;                                                 
                                                                                                    
      assume (Queue.tail_nextThread[this]==tid);                                                    
                                                                                                    
      // 67.18: assume this.tail_nextValue == last;                                                 
                                                                                                    
      assume (Queue.tail_nextValue[this]==last);                                                    
                                                                                                    
      // 67.18: Node _currentValue;                                                                 
                                                                                                    
                                                                                                    
      // 67.18: _currentValue := this.tail  as B;                                                   
                                                                                                    
                                                                                                    
      moverPath3546134 := ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546134 := m#moverPath(moverPath3546134);                                                
      path3546134 := p#moverPath(moverPath3546134);                                                 
      assume Node._state3546134 == Node._state && Node.value3546134 == Node.value && Node.next3546134 == Node.next && Node._lock3546134 == Node._lock && Node.next_nextThread3546134 == Node.next_nextThread && Node.next_nextValue3546134 == Node.next_nextValue && Queue._state3546134 == Queue._state && Queue.head3546134 == Queue.head && Queue.tail3546134 == Queue.tail && Queue._lock3546134 == Queue._lock && Queue.head_nextThread3546134 == Queue.head_nextThread && Queue.head_nextValue3546134 == Queue.head_nextValue && Queue.tail_nextThread3546134 == Queue.tail_nextThread && Queue.tail_nextValue3546134 == Queue.tail_nextValue && _currentValue3546134 == _currentValue && ctmp35200943546134 == ctmp3520094 && tmp103546134 == tmp10 && tmp83546134 == tmp8 && tmp73546134 == tmp7 && last3546134 == last && next3546134 == next && first3546134 == first && tmp63546134 == tmp6 && $result3546134 == $result && this3546134 == this && tid3546134 == tid && $pc3546134 == $pc;
      assume $recorded.state3546134 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (67.18): Cannot have potential null deference in left-mover part.
      }                                                                                             
                                                                                                    
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (67.18): Reduction failure
      _currentValue := Queue.tail[this];                                                            
                                                                                                    
                                                                                                    
      // 67.18: this.tail := last as B;                                                             
                                                                                                    
                                                                                                    
      moverPath3546137 := WriteEval.Queue.tail(tid: Tid,this: Queue,last: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546137 := m#moverPath(moverPath3546137);                                                
      path3546137 := p#moverPath(moverPath3546137);                                                 
      assume Node._state3546137 == Node._state && Node.value3546137 == Node.value && Node.next3546137 == Node.next && Node._lock3546137 == Node._lock && Node.next_nextThread3546137 == Node.next_nextThread && Node.next_nextValue3546137 == Node.next_nextValue && Queue._state3546137 == Queue._state && Queue.head3546137 == Queue.head && Queue.tail3546137 == Queue.tail && Queue._lock3546137 == Queue._lock && Queue.head_nextThread3546137 == Queue.head_nextThread && Queue.head_nextValue3546137 == Queue.head_nextValue && Queue.tail_nextThread3546137 == Queue.tail_nextThread && Queue.tail_nextValue3546137 == Queue.tail_nextValue && _currentValue3546137 == _currentValue && ctmp35200943546137 == ctmp3520094 && tmp103546137 == tmp10 && tmp83546137 == tmp8 && tmp73546137 == tmp7 && last3546137 == last && next3546137 == next && first3546137 == first && tmp63546137 == tmp6 && $result3546137 == $result && this3546137 == this && tid3546137 == tid && $pc3546137 == $pc;
      assume $recorded.state3546137 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (67.18): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (67.18): Reduction failure
      Queue.tail[this] := last;                                                                     
      if (isLocal(Node._state[last], tid)) {                                                        
       Node._state[last] := SHARED();                                                               
       assert isSharedAssignable(Node._state[Node.next[last]]);                                            // (67.18): last became shared, but last.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 67.18: Mover _m;                                                                           
                                                                                                    
                                                                                                    
      // 67.18: _m = writePermission(this.tail, next);                                              
                                                                                                    
      _m := m#moverPath(WriteEval.Queue.tail(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
                                                                                                    
      // 67.18: this.tail := _currentValue as B;                                                    
                                                                                                    
                                                                                                    
      moverPath3546149 := WriteEval.Queue.tail(tid: Tid,this: Queue,_currentValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546149 := m#moverPath(moverPath3546149);                                                
      path3546149 := p#moverPath(moverPath3546149);                                                 
      assume Node._state3546149 == Node._state && Node.value3546149 == Node.value && Node.next3546149 == Node.next && Node._lock3546149 == Node._lock && Node.next_nextThread3546149 == Node.next_nextThread && Node.next_nextValue3546149 == Node.next_nextValue && Queue._state3546149 == Queue._state && Queue.head3546149 == Queue.head && Queue.tail3546149 == Queue.tail && Queue._lock3546149 == Queue._lock && Queue.head_nextThread3546149 == Queue.head_nextThread && Queue.head_nextValue3546149 == Queue.head_nextValue && Queue.tail_nextThread3546149 == Queue.tail_nextThread && Queue.tail_nextValue3546149 == Queue.tail_nextValue && _m3546149 == _m && _currentValue3546149 == _currentValue && ctmp35200943546149 == ctmp3520094 && tmp103546149 == tmp10 && tmp83546149 == tmp8 && tmp73546149 == tmp7 && last3546149 == last && next3546149 == next && first3546149 == first && tmp63546149 == tmp6 && $result3546149 == $result && this3546149 == this && tid3546149 == tid && $pc3546149 == $pc;
      assume $recorded.state3546149 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (67.18): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (67.18): Reduction failure
      Queue.tail[this] := _currentValue;                                                            
      if (isLocal(Node._state[_currentValue], tid)) {                                               
       Node._state[_currentValue] := SHARED();                                                      
       assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                   // (67.18): _currentValue became shared, but _currentValue.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 67.18: assume goesWrong(_m);                                                               
                                                                                                    
      assume transition($pc, _m) == PhaseError;                                                     
      // NoOp: 'TraceOn'                                                                            
                                                                                                    
                                                                                                    
      // 67.18: this.tail := next;                                                                  
                                                                                                    
                                                                                                    
      moverPath3546156 := WriteEval.Queue.tail(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546156 := m#moverPath(moverPath3546156);                                                
      path3546156 := p#moverPath(moverPath3546156);                                                 
      assume Node._state3546156 == Node._state && Node.value3546156 == Node.value && Node.next3546156 == Node.next && Node._lock3546156 == Node._lock && Node.next_nextThread3546156 == Node.next_nextThread && Node.next_nextValue3546156 == Node.next_nextValue && Queue._state3546156 == Queue._state && Queue.head3546156 == Queue.head && Queue.tail3546156 == Queue.tail && Queue._lock3546156 == Queue._lock && Queue.head_nextThread3546156 == Queue.head_nextThread && Queue.head_nextValue3546156 == Queue.head_nextValue && Queue.tail_nextThread3546156 == Queue.tail_nextThread && Queue.tail_nextValue3546156 == Queue.tail_nextValue && _m3546156 == _m && _currentValue3546156 == _currentValue && ctmp35200943546156 == ctmp3520094 && tmp103546156 == tmp10 && tmp83546156 == tmp8 && tmp73546156 == tmp7 && last3546156 == last && next3546156 == next && first3546156 == first && tmp63546156 == tmp6 && $result3546156 == $result && this3546156 == this && tid3546156 == tid && $pc3546156 == $pc;
      assume $recorded.state3546156 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (67.18): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, mover3546156);                                                         
      assert $pc != PhaseError;                                                                            // (67.18): Reduction failure
      Queue.tail[this] := next;                                                                     
      if (isLocal(Node._state[next], tid)) {                                                        
       Node._state[next] := SHARED();                                                               
       assert isSharedAssignable(Node._state[Node.next[next]]);                                            // (67.18): next became shared, but next.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 67.18: tmp10 = false;                                                                      
                                                                                                    
      tmp10 := false;                                                                               
     }                                                                                              
    }                                                                                               
   }                                                                                                
  } else {                                                                                          
                                                                                                    
   // 70.17: boolean tmp11;                                                                         
                                                                                                    
                                                                                                    
   // 70.17: tmp11 = next != Node.null;                                                             
                                                                                                    
   tmp11 := (next!=Node.null);                                                                      
   if (tmp11 /* lowered (next!=Node.null) */) {                                                     
                                                                                                    
    // 71.21: int value;                                                                            
                                                                                                    
                                                                                                    
    // 71.21: value := next.value;                                                                  
                                                                                                    
                                                                                                    
    moverPath3546185 := ReadEval.Node.value(tid: Tid,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
    mover3546185 := m#moverPath(moverPath3546185);                                                  
    path3546185 := p#moverPath(moverPath3546185);                                                   
    assume Node._state3546185 == Node._state && Node.value3546185 == Node.value && Node.next3546185 == Node.next && Node._lock3546185 == Node._lock && Node.next_nextThread3546185 == Node.next_nextThread && Node.next_nextValue3546185 == Node.next_nextValue && Queue._state3546185 == Queue._state && Queue.head3546185 == Queue.head && Queue.tail3546185 == Queue.tail && Queue._lock3546185 == Queue._lock && Queue.head_nextThread3546185 == Queue.head_nextThread && Queue.head_nextValue3546185 == Queue.head_nextValue && Queue.tail_nextThread3546185 == Queue.tail_nextThread && Queue.tail_nextValue3546185 == Queue.tail_nextValue && value3546185 == value && tmp113546185 == tmp11 && tmp73546185 == tmp7 && last3546185 == last && next3546185 == next && first3546185 == first && tmp63546185 == tmp6 && $result3546185 == $result && this3546185 == this && tid3546185 == tid && $pc3546185 == $pc;
    assume $recorded.state3546185 == 1;                                                             
    if ($pc == PreCommit) {                                                                         
     assume next != Node.null;                                                                      
    } else {                                                                                        
     assert next != Node.null;                                                                             // (71.21): Cannot have potential null deference in left-mover part.
    }                                                                                               
                                                                                                    
    $pc := transition($pc, mover3546185);                                                           
    assert $pc != PhaseError;                                                                              // (71.21): Reduction failure
    value := Node.value[next];                                                                      
                                                                                                    
    // 72.21: yield;                                                                                
                                                                                                    
    assume Node._state3546186 == Node._state && Node.value3546186 == Node.value && Node.next3546186 == Node.next && Node._lock3546186 == Node._lock && Node.next_nextThread3546186 == Node.next_nextThread && Node.next_nextValue3546186 == Node.next_nextValue && Queue._state3546186 == Queue._state && Queue.head3546186 == Queue.head && Queue.tail3546186 == Queue.tail && Queue._lock3546186 == Queue._lock && Queue.head_nextThread3546186 == Queue.head_nextThread && Queue.head_nextValue3546186 == Queue.head_nextValue && Queue.tail_nextThread3546186 == Queue.tail_nextThread && Queue.tail_nextValue3546186 == Queue.tail_nextValue && value3546186 == value && tmp113546186 == tmp11 && tmp73546186 == tmp7 && last3546186 == last && next3546186 == next && first3546186 == first && tmp63546186 == tmp6 && $result3546186 == $result && this3546186 == this && tid3546186 == tid;
    assume $recorded.state3546186 == 1;                                                             
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (72.21): Object invariant may not hold.
    assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (72.21): Object invariant may not hold.
    call Yield(tid);                                                                                
    assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (72.21): Object invariant may not hold.
    assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (72.21): Object invariant may not hold.
    $pc := PreCommit;                                                                               
    assume Node._state3546186_post == Node._state && Node.value3546186_post == Node.value && Node.next3546186_post == Node.next && Node._lock3546186_post == Node._lock && Node.next_nextThread3546186_post == Node.next_nextThread && Node.next_nextValue3546186_post == Node.next_nextValue && Queue._state3546186_post == Queue._state && Queue.head3546186_post == Queue.head && Queue.tail3546186_post == Queue.tail && Queue._lock3546186_post == Queue._lock && Queue.head_nextThread3546186_post == Queue.head_nextThread && Queue.head_nextValue3546186_post == Queue.head_nextValue && Queue.tail_nextThread3546186_post == Queue.tail_nextThread && Queue.tail_nextValue3546186_post == Queue.tail_nextValue && value3546186_post == value && tmp113546186_post == tmp11 && tmp73546186_post == tmp7 && last3546186_post == last && next3546186_post == next && first3546186_post == first && tmp63546186_post == tmp6 && $result3546186_post == $result && this3546186_post == this && tid3546186_post == tid;
    assume $recorded.state3546186_post == 1;                                                        
                                                                                                    
    // 73.21: boolean tmp12;                                                                        
                                                                                                    
    // NoOp: 'TraceOff'                                                                             
                                                                                                    
    // 73.21: boolean ctmp3520129;                                                                  
                                                                                                    
                                                                                                    
    // 73.21: ctmp3520129 = *;                                                                      
                                                                                                    
    havoc ctmp3520129;                                                                              
    if (ctmp3520129) {                                                                              
     // NoOp: 'TraceOn'                                                                             
                                                                                                    
     // 73.21: tmp12 = false;                                                                       
                                                                                                    
     tmp12 := false;                                                                                
    } else {                                                                                        
                                                                                                    
     // 73.21: ctmp3520129 = *;                                                                     
                                                                                                    
     havoc ctmp3520129;                                                                             
     if (ctmp3520129) {                                                                             
                                                                                                    
      // 73.21: Tid tmpTid;                                                                         
                                                                                                    
                                                                                                    
      // 73.21: Node tmpValue;                                                                      
                                                                                                    
                                                                                                    
      // 73.21: Mover _m;                                                                           
                                                                                                    
                                                                                                    
      // 73.21: _m = writePermission(this.head, next);                                              
                                                                                                    
      _m := m#moverPath(WriteEval.Queue.head(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
      // 73.21: assume this.head == first;                                                          
                                                                                                    
      assume (Queue.head[this]==first);                                                             
                                                                                                    
      // 73.21: assume !goesWrong(_m);                                                              
                                                                                                    
      assume !(transition($pc, _m) == PhaseError);                                                  
                                                                                                    
      // 73.21: assume this.head_nextThread == tid;                                                 
                                                                                                    
      assume (Queue.head_nextThread[this]==tid);                                                    
                                                                                                    
      // 73.21: assume this.head_nextValue == first;                                                
                                                                                                    
      assume (Queue.head_nextValue[this]==first);                                                   
                                                                                                    
                                                                                                    
      // 73.21: this.head_nextThread := tmpTid as B;                                                
                                                                                                    
                                                                                                    
      moverPath3546246 := WriteEval.Queue.head_nextThread(tid: Tid,this: Queue,tmpTid: Tid,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546246 := m#moverPath(moverPath3546246);                                                
      path3546246 := p#moverPath(moverPath3546246);                                                 
      assume Node._state3546246 == Node._state && Node.value3546246 == Node.value && Node.next3546246 == Node.next && Node._lock3546246 == Node._lock && Node.next_nextThread3546246 == Node.next_nextThread && Node.next_nextValue3546246 == Node.next_nextValue && Queue._state3546246 == Queue._state && Queue.head3546246 == Queue.head && Queue.tail3546246 == Queue.tail && Queue._lock3546246 == Queue._lock && Queue.head_nextThread3546246 == Queue.head_nextThread && Queue.head_nextValue3546246 == Queue.head_nextValue && Queue.tail_nextThread3546246 == Queue.tail_nextThread && Queue.tail_nextValue3546246 == Queue.tail_nextValue && _m3546246 == _m && tmpValue3546246 == tmpValue && tmpTid3546246 == tmpTid && ctmp35201293546246 == ctmp3520129 && tmp123546246 == tmp12 && value3546246 == value && tmp113546246 == tmp11 && tmp73546246 == tmp7 && last3546246 == last && next3546246 == next && first3546246 == first && tmp63546246 == tmp6 && $result3546246 == $result && this3546246 == this && tid3546246 == tid && $pc3546246 == $pc;
      assume $recorded.state3546246 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (73.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (73.21): Reduction failure
      Queue.head_nextThread[this] := tmpTid;                                                        
                                                                                                    
                                                                                                    
      // 73.21: this.head_nextValue := tmpValue as B;                                               
                                                                                                    
                                                                                                    
      moverPath3546249 := WriteEval.Queue.head_nextValue(tid: Tid,this: Queue,tmpValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546249 := m#moverPath(moverPath3546249);                                                
      path3546249 := p#moverPath(moverPath3546249);                                                 
      assume Node._state3546249 == Node._state && Node.value3546249 == Node.value && Node.next3546249 == Node.next && Node._lock3546249 == Node._lock && Node.next_nextThread3546249 == Node.next_nextThread && Node.next_nextValue3546249 == Node.next_nextValue && Queue._state3546249 == Queue._state && Queue.head3546249 == Queue.head && Queue.tail3546249 == Queue.tail && Queue._lock3546249 == Queue._lock && Queue.head_nextThread3546249 == Queue.head_nextThread && Queue.head_nextValue3546249 == Queue.head_nextValue && Queue.tail_nextThread3546249 == Queue.tail_nextThread && Queue.tail_nextValue3546249 == Queue.tail_nextValue && _m3546249 == _m && tmpValue3546249 == tmpValue && tmpTid3546249 == tmpTid && ctmp35201293546249 == ctmp3520129 && tmp123546249 == tmp12 && value3546249 == value && tmp113546249 == tmp11 && tmp73546249 == tmp7 && last3546249 == last && next3546249 == next && first3546249 == first && tmp63546249 == tmp6 && $result3546249 == $result && this3546249 == this && tid3546249 == tid && $pc3546249 == $pc;
      assume $recorded.state3546249 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (73.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (73.21): Reduction failure
      Queue.head_nextValue[this] := tmpValue;                                                       
      // NoOp: 'TraceOn'                                                                            
                                                                                                    
                                                                                                    
      // 73.21: this.head := next;                                                                  
                                                                                                    
                                                                                                    
      moverPath3546253 := WriteEval.Queue.head(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546253 := m#moverPath(moverPath3546253);                                                
      path3546253 := p#moverPath(moverPath3546253);                                                 
      assume Node._state3546253 == Node._state && Node.value3546253 == Node.value && Node.next3546253 == Node.next && Node._lock3546253 == Node._lock && Node.next_nextThread3546253 == Node.next_nextThread && Node.next_nextValue3546253 == Node.next_nextValue && Queue._state3546253 == Queue._state && Queue.head3546253 == Queue.head && Queue.tail3546253 == Queue.tail && Queue._lock3546253 == Queue._lock && Queue.head_nextThread3546253 == Queue.head_nextThread && Queue.head_nextValue3546253 == Queue.head_nextValue && Queue.tail_nextThread3546253 == Queue.tail_nextThread && Queue.tail_nextValue3546253 == Queue.tail_nextValue && _m3546253 == _m && tmpValue3546253 == tmpValue && tmpTid3546253 == tmpTid && ctmp35201293546253 == ctmp3520129 && tmp123546253 == tmp12 && value3546253 == value && tmp113546253 == tmp11 && tmp73546253 == tmp7 && last3546253 == last && next3546253 == next && first3546253 == first && tmp63546253 == tmp6 && $result3546253 == $result && this3546253 == this && tid3546253 == tid && $pc3546253 == $pc;
      assume $recorded.state3546253 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (73.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, mover3546253);                                                         
      assert $pc != PhaseError;                                                                            // (73.21): Reduction failure
      Queue.head[this] := next;                                                                     
      if (isLocal(Node._state[next], tid)) {                                                        
       Node._state[next] := SHARED();                                                               
       assert isSharedAssignable(Node._state[Node.next[next]]);                                            // (73.21): next became shared, but next.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 73.21: tmp12 = true;                                                                       
                                                                                                    
      tmp12 := true;                                                                                
     } else {                                                                                       
                                                                                                    
      // 73.21: assume this.head_nextThread == tid;                                                 
                                                                                                    
      assume (Queue.head_nextThread[this]==tid);                                                    
                                                                                                    
      // 73.21: assume this.head_nextValue == first;                                                
                                                                                                    
      assume (Queue.head_nextValue[this]==first);                                                   
                                                                                                    
      // 73.21: Node _currentValue;                                                                 
                                                                                                    
                                                                                                    
      // 73.21: _currentValue := this.head  as B;                                                   
                                                                                                    
                                                                                                    
      moverPath3546276 := ReadEval.Queue.head(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546276 := m#moverPath(moverPath3546276);                                                
      path3546276 := p#moverPath(moverPath3546276);                                                 
      assume Node._state3546276 == Node._state && Node.value3546276 == Node.value && Node.next3546276 == Node.next && Node._lock3546276 == Node._lock && Node.next_nextThread3546276 == Node.next_nextThread && Node.next_nextValue3546276 == Node.next_nextValue && Queue._state3546276 == Queue._state && Queue.head3546276 == Queue.head && Queue.tail3546276 == Queue.tail && Queue._lock3546276 == Queue._lock && Queue.head_nextThread3546276 == Queue.head_nextThread && Queue.head_nextValue3546276 == Queue.head_nextValue && Queue.tail_nextThread3546276 == Queue.tail_nextThread && Queue.tail_nextValue3546276 == Queue.tail_nextValue && _currentValue3546276 == _currentValue && ctmp35201293546276 == ctmp3520129 && tmp123546276 == tmp12 && value3546276 == value && tmp113546276 == tmp11 && tmp73546276 == tmp7 && last3546276 == last && next3546276 == next && first3546276 == first && tmp63546276 == tmp6 && $result3546276 == $result && this3546276 == this && tid3546276 == tid && $pc3546276 == $pc;
      assume $recorded.state3546276 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (73.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
                                                                                                    
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (73.21): Reduction failure
      _currentValue := Queue.head[this];                                                            
                                                                                                    
                                                                                                    
      // 73.21: this.head := first as B;                                                            
                                                                                                    
                                                                                                    
      moverPath3546279 := WriteEval.Queue.head(tid: Tid,this: Queue,first: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546279 := m#moverPath(moverPath3546279);                                                
      path3546279 := p#moverPath(moverPath3546279);                                                 
      assume Node._state3546279 == Node._state && Node.value3546279 == Node.value && Node.next3546279 == Node.next && Node._lock3546279 == Node._lock && Node.next_nextThread3546279 == Node.next_nextThread && Node.next_nextValue3546279 == Node.next_nextValue && Queue._state3546279 == Queue._state && Queue.head3546279 == Queue.head && Queue.tail3546279 == Queue.tail && Queue._lock3546279 == Queue._lock && Queue.head_nextThread3546279 == Queue.head_nextThread && Queue.head_nextValue3546279 == Queue.head_nextValue && Queue.tail_nextThread3546279 == Queue.tail_nextThread && Queue.tail_nextValue3546279 == Queue.tail_nextValue && _currentValue3546279 == _currentValue && ctmp35201293546279 == ctmp3520129 && tmp123546279 == tmp12 && value3546279 == value && tmp113546279 == tmp11 && tmp73546279 == tmp7 && last3546279 == last && next3546279 == next && first3546279 == first && tmp63546279 == tmp6 && $result3546279 == $result && this3546279 == this && tid3546279 == tid && $pc3546279 == $pc;
      assume $recorded.state3546279 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (73.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (73.21): Reduction failure
      Queue.head[this] := first;                                                                    
      if (isLocal(Node._state[first], tid)) {                                                       
       Node._state[first] := SHARED();                                                              
       assert isSharedAssignable(Node._state[Node.next[first]]);                                           // (73.21): first became shared, but first.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 73.21: Mover _m;                                                                           
                                                                                                    
                                                                                                    
      // 73.21: _m = writePermission(this.head, next);                                              
                                                                                                    
      _m := m#moverPath(WriteEval.Queue.head(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));
                                                                                                    
                                                                                                    
      // 73.21: this.head := _currentValue as B;                                                    
                                                                                                    
                                                                                                    
      moverPath3546291 := WriteEval.Queue.head(tid: Tid,this: Queue,_currentValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546291 := m#moverPath(moverPath3546291);                                                
      path3546291 := p#moverPath(moverPath3546291);                                                 
      assume Node._state3546291 == Node._state && Node.value3546291 == Node.value && Node.next3546291 == Node.next && Node._lock3546291 == Node._lock && Node.next_nextThread3546291 == Node.next_nextThread && Node.next_nextValue3546291 == Node.next_nextValue && Queue._state3546291 == Queue._state && Queue.head3546291 == Queue.head && Queue.tail3546291 == Queue.tail && Queue._lock3546291 == Queue._lock && Queue.head_nextThread3546291 == Queue.head_nextThread && Queue.head_nextValue3546291 == Queue.head_nextValue && Queue.tail_nextThread3546291 == Queue.tail_nextThread && Queue.tail_nextValue3546291 == Queue.tail_nextValue && _m3546291 == _m && _currentValue3546291 == _currentValue && ctmp35201293546291 == ctmp3520129 && tmp123546291 == tmp12 && value3546291 == value && tmp113546291 == tmp11 && tmp73546291 == tmp7 && last3546291 == last && next3546291 == next && first3546291 == first && tmp63546291 == tmp6 && $result3546291 == $result && this3546291 == this && tid3546291 == tid && $pc3546291 == $pc;
      assume $recorded.state3546291 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (73.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, _B);                                                                   
      assert $pc != PhaseError;                                                                            // (73.21): Reduction failure
      Queue.head[this] := _currentValue;                                                            
      if (isLocal(Node._state[_currentValue], tid)) {                                               
       Node._state[_currentValue] := SHARED();                                                      
       assert isSharedAssignable(Node._state[Node.next[_currentValue]]);                                   // (73.21): _currentValue became shared, but _currentValue.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 73.21: assume goesWrong(_m);                                                               
                                                                                                    
      assume transition($pc, _m) == PhaseError;                                                     
      // NoOp: 'TraceOn'                                                                            
                                                                                                    
                                                                                                    
      // 73.21: this.head := next;                                                                  
                                                                                                    
                                                                                                    
      moverPath3546298 := WriteEval.Queue.head(tid: Tid,this: Queue,next: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
      mover3546298 := m#moverPath(moverPath3546298);                                                
      path3546298 := p#moverPath(moverPath3546298);                                                 
      assume Node._state3546298 == Node._state && Node.value3546298 == Node.value && Node.next3546298 == Node.next && Node._lock3546298 == Node._lock && Node.next_nextThread3546298 == Node.next_nextThread && Node.next_nextValue3546298 == Node.next_nextValue && Queue._state3546298 == Queue._state && Queue.head3546298 == Queue.head && Queue.tail3546298 == Queue.tail && Queue._lock3546298 == Queue._lock && Queue.head_nextThread3546298 == Queue.head_nextThread && Queue.head_nextValue3546298 == Queue.head_nextValue && Queue.tail_nextThread3546298 == Queue.tail_nextThread && Queue.tail_nextValue3546298 == Queue.tail_nextValue && _m3546298 == _m && _currentValue3546298 == _currentValue && ctmp35201293546298 == ctmp3520129 && tmp123546298 == tmp12 && value3546298 == value && tmp113546298 == tmp11 && tmp73546298 == tmp7 && last3546298 == last && next3546298 == next && first3546298 == first && tmp63546298 == tmp6 && $result3546298 == $result && this3546298 == this && tid3546298 == tid && $pc3546298 == $pc;
      assume $recorded.state3546298 == 1;                                                           
      if ($pc == PreCommit) {                                                                       
       assume this != Queue.null;                                                                   
      } else {                                                                                      
       assert this != Queue.null;                                                                          // (73.21): Cannot have potential null deference in left-mover part.
      }                                                                                             
      $pc := transition($pc, mover3546298);                                                         
      assert $pc != PhaseError;                                                                            // (73.21): Reduction failure
      Queue.head[this] := next;                                                                     
      if (isLocal(Node._state[next], tid)) {                                                        
       Node._state[next] := SHARED();                                                               
       assert isSharedAssignable(Node._state[Node.next[next]]);                                            // (73.21): next became shared, but next.next may not be shared.
      }                                                                                             
                                                                                                    
                                                                                                    
      // 73.21: tmp12 = false;                                                                      
                                                                                                    
      tmp12 := false;                                                                               
     }                                                                                              
    }                                                                                               
    if (tmp12) {                                                                                    
                                                                                                    
     // 74.25:  return value;                                                                       
                                                                                                    
     assume Node._state3546309 == Node._state && Node.value3546309 == Node.value && Node.next3546309 == Node.next && Node._lock3546309 == Node._lock && Node.next_nextThread3546309 == Node.next_nextThread && Node.next_nextValue3546309 == Node.next_nextValue && Queue._state3546309 == Queue._state && Queue.head3546309 == Queue.head && Queue.tail3546309 == Queue.tail && Queue._lock3546309 == Queue._lock && Queue.head_nextThread3546309 == Queue.head_nextThread && Queue.head_nextValue3546309 == Queue.head_nextValue && Queue.tail_nextThread3546309 == Queue.tail_nextThread && Queue.tail_nextValue3546309 == Queue.tail_nextValue && tmp123546309 == tmp12 && value3546309 == value && tmp113546309 == tmp11 && tmp73546309 == tmp7 && last3546309 == last && next3546309 == next && first3546309 == first && tmp63546309 == tmp6 && $result3546309 == $result && this3546309 == this && tid3546309 == tid;
     assume $recorded.state3546309 == 1;                                                            
     $result := value;                                                                              
     assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (74.25): Object invariant may not hold.
     assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (74.25): Object invariant may not hold.
     return;                                                                                        
    } else {                                                                                        
    }                                                                                               
   } else {                                                                                         
   }                                                                                                
  }                                                                                                 
                                                                                                    
  // 78.13: yield;                                                                                  
                                                                                                    
  assume Node._state3546319 == Node._state && Node.value3546319 == Node.value && Node.next3546319 == Node.next && Node._lock3546319 == Node._lock && Node.next_nextThread3546319 == Node.next_nextThread && Node.next_nextValue3546319 == Node.next_nextValue && Queue._state3546319 == Queue._state && Queue.head3546319 == Queue.head && Queue.tail3546319 == Queue.tail && Queue._lock3546319 == Queue._lock && Queue.head_nextThread3546319 == Queue.head_nextThread && Queue.head_nextValue3546319 == Queue.head_nextValue && Queue.tail_nextThread3546319 == Queue.tail_nextThread && Queue.tail_nextValue3546319 == Queue.tail_nextValue && tmp73546319 == tmp7 && last3546319 == last && next3546319 == next && first3546319 == first && tmp63546319 == tmp6 && $result3546319 == $result && this3546319 == this && tid3546319 == tid;
  assume $recorded.state3546319 == 1;                                                               
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (78.13): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (78.13): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (78.13): Object invariant may not hold.
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (78.13): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Node._state3546319_post == Node._state && Node.value3546319_post == Node.value && Node.next3546319_post == Node.next && Node._lock3546319_post == Node._lock && Node.next_nextThread3546319_post == Node.next_nextThread && Node.next_nextValue3546319_post == Node.next_nextValue && Queue._state3546319_post == Queue._state && Queue.head3546319_post == Queue.head && Queue.tail3546319_post == Queue.tail && Queue._lock3546319_post == Queue._lock && Queue.head_nextThread3546319_post == Queue.head_nextThread && Queue.head_nextValue3546319_post == Queue.head_nextValue && Queue.tail_nextThread3546319_post == Queue.tail_nextThread && Queue.tail_nextValue3546319_post == Queue.tail_nextValue && tmp73546319_post == tmp7 && last3546319_post == last && next3546319_post == next && first3546319_post == first && tmp63546319_post == tmp6 && $result3546319_post == $result && this3546319_post == this && tid3546319_post == tid;
  assume $recorded.state3546319_post == 1;                                                          
  assume Node._state3546322_bottom == Node._state && Node.value3546322_bottom == Node.value && Node.next3546322_bottom == Node.next && Node._lock3546322_bottom == Node._lock && Node.next_nextThread3546322_bottom == Node.next_nextThread && Node.next_nextValue3546322_bottom == Node.next_nextValue && Queue._state3546322_bottom == Queue._state && Queue.head3546322_bottom == Queue.head && Queue.tail3546322_bottom == Queue.tail && Queue._lock3546322_bottom == Queue._lock && Queue.head_nextThread3546322_bottom == Queue.head_nextThread && Queue.head_nextValue3546322_bottom == Queue.head_nextValue && Queue.tail_nextThread3546322_bottom == Queue.tail_nextThread && Queue.tail_nextValue3546322_bottom == Queue.tail_nextValue && $result3546322_bottom == $result && this3546322_bottom == this && tid3546322_bottom == tid;
  assume $recorded.state3546322_bottom == 1;                                                        
  assert phase3546322 == $pc;                                                                              // (55.9): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 54.26: // return -1;                                                                            
                                                                                                    
 assume Node._state3546325 == Node._state && Node.value3546325 == Node.value && Node.next3546325 == Node.next && Node._lock3546325 == Node._lock && Node.next_nextThread3546325 == Node.next_nextThread && Node.next_nextValue3546325 == Node.next_nextValue && Queue._state3546325 == Queue._state && Queue.head3546325 == Queue.head && Queue.tail3546325 == Queue.tail && Queue._lock3546325 == Queue._lock && Queue.head_nextThread3546325 == Queue.head_nextThread && Queue.head_nextValue3546325 == Queue.head_nextValue && Queue.tail_nextThread3546325 == Queue.tail_nextThread && Queue.tail_nextValue3546325 == Queue.tail_nextValue && $result3546325 == $result && this3546325 == this && tid3546325 == tid;
 assume $recorded.state3546325 == 1;                                                                
 $result := -1;                                                                                     
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (54.26): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (54.26): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Node._state: [Node]State,Node.value: [Node]int,Node.next: [Node]Node,Node._lock: [Node]Tid,Node.next_nextThread: [Node]Tid,Node.next_nextValue: [Node]Node,Queue._state: [Queue]State,Queue.head: [Queue]Node,Queue.tail: [Queue]Node,Queue._lock: [Queue]Tid,Queue.head_nextThread: [Queue]Tid,Queue.head_nextValue: [Queue]Node,Queue.tail_nextThread: [Queue]Tid,Queue.tail_nextValue: [Queue]Node) returns (bool) {
  true &&                                                                                           
  (forall _i: Node  :: _i == Node.null <==> isNull(Node._state[_i])) &&                             
  (forall _i: Queue  :: _i == Queue.null <==> isNull(Queue._state[_i])) &&                          
  (forall _i: Node ::  (isShared(Node._state[_i]) ==> isSharedAssignable(Node._state[Node.next[_i]]))) &&
  (forall _i: Node ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Node._state[_i],_t) ==> isLocalAssignable(Node._state[Node.next[_i]], _t)))) &&
  (forall _i: Queue ::  (isShared(Queue._state[_i]) ==> isSharedAssignable(Node._state[Queue.head[_i]]))) &&
  (forall _i: Queue ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Queue._state[_i],_t) ==> isLocalAssignable(Node._state[Queue.head[_i]], _t)))) &&
  (forall _i: Queue ::  (isShared(Queue._state[_i]) ==> isSharedAssignable(Node._state[Queue.tail[_i]]))) &&
  (forall _i: Queue ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Queue._state[_i],_t) ==> isLocalAssignable(Node._state[Queue.tail[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)          
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.value(u: Tid,x: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (3.5): Node.value failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)           
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.value(u: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (3.5): Node.value failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)           
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.value[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.value[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.value(u: Tid,x: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (3.5): Node.value failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.value[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.value(u: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (3.5): Node.value failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)                
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.value(u: Tid,x: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (3.5): Node.value failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.value(t: Tid, u: Tid, v: int, w: int, x: Node)                 
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Node.value[x];                                                                         
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.value[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.value(u: Tid,x: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (3.5): Node.value failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)         
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (4.5): Node.next failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (4.5): Node.next failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (4.5): Node.next failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)           
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (4.5): Node.next failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)               
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (4.5): Node.next failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)                
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Node.next[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (4.5): Node.next failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Queue.head(t: Tid, u: Tid, v: Node, w: Node, x: Queue)       
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (18.5): Queue.head failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Queue.head(t: Tid, u: Tid, v: Node, w: Node, x: Queue)        
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Queue.head(u: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (18.5): Queue.head failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Queue.head(t: Tid, u: Tid, v: Node, w: Node, x: Queue)        
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Queue.head[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Queue.head[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (18.5): Queue.head failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Queue.head(t: Tid, u: Tid, v: Node, w: Node, x: Queue)         
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Queue.head[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Queue.head(u: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (18.5): Queue.head failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Queue.head(t: Tid, u: Tid, v: Node, w: Node, x: Queue)             
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (18.5): Queue.head failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Queue.head(t: Tid, u: Tid, v: Node, w: Node, x: Queue)              
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Queue.head[x];                                                                         
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Queue.head[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (18.5): Queue.head failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, x: Queue)       
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (19.5): Queue.tail failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, x: Queue)        
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Queue.tail(u: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (19.5): Queue.tail failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, x: Queue)        
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Queue.tail[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Queue.tail[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (19.5): Queue.tail failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, x: Queue)         
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Queue.tail[x];                                                                         
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Queue.tail(u: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (19.5): Queue.tail failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, x: Queue)             
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (19.5): Queue.tail failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, x: Queue)              
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Queue.tail[x];                                                                         
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Queue.tail[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (19.5): Queue.tail failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.value (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.5): Node.value is not Write-Write Stable with respect to Node.value (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.value (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.value (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.value (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.value (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Node.value (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Node.value (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Node.value (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.value.Node.value(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Node.value (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Node.value (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.5): Node.value is not Write-Read Stable with respect to Node.value (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.value (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.5): Node.next is not Write-Write Stable with respect to Node.value (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.value (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.value.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.value;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to Node.value (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to Node.value (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.5): Node.next is not Write-Read Stable with respect to Node.value (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.value.Queue.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.value (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.value (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.value (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.value.Queue.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.value.Queue.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.value.Queue.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Queue.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.value.Queue.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Queue.head is not Write-Read Stable with respect to Node.value (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Queue.head is not Write-Read Stable with respect to Node.value (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (18.5): Queue.head is not Write-Read Stable with respect to Node.value (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.value.Queue.tail(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.value (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.value (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.value (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.value.Queue.tail(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.value.Queue.tail(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.value[x];                                                                             
 Node.value[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.value[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.value.Queue.tail(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.value(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Queue.tail (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (3.5): Node.value is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.value.Queue.tail(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.value;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.value(t: Tid,x: Node,v: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.tail is not Write-Read Stable with respect to Node.value (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.tail is not Write-Read Stable with respect to Node.value (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Queue.tail is not Write-Read Stable with respect to Node.value (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.value (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.value (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.value (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Node.value (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Node.value (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Node.value (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.5): Node.value is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Node.next.Node.value(t: Tid, u: Tid, v: Node, w1: int, w2: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: int;                                                                                     
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var w2_pre: int;                                                                                   
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w1_pre: int;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var w2_mid: int;                                                                                   
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var w1_mid: int;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var w2_post: int;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var w1_post: int;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w1: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.value[y];                                                                             
 Node.value[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.value(u: Tid,y: Node,w2: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.value[y] := tmpW;                                                                             
                                                                                                    
 Node.next[x] := v;                                                                                 
 Node.value[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.value(u: Tid,y: Node,w2: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Node.next.Node.value(t: Tid, u: Tid, v1: Node, v2: Node, w: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v1;                                                                                
 _writeByTAfterT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Node.next[x] := tmpV;                                                                              
                                                                                                    
 Node.value[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Node.next[x] := v1;                                                                                
 _writeByTAfterUAndT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Node.next (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Node.next.Node.next(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.next[y];                                                                              
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.next[y] := tmpW;                                                                              
                                                                                                    
 Node.next[x] := v;                                                                                 
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Node.next.Node.next(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v1;                                                                                
 _writeByTAfterT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Node.next[x] := tmpV;                                                                              
                                                                                                    
 Node.next[y] := w;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Node.next[x] := v1;                                                                                
 _writeByTAfterUAndT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Node.next (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Queue.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Queue.head is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Queue.head is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (18.5): Queue.head is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Node.next.Queue.head(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Queue.head[y];                                                                             
 Queue.head[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Queue.head(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Queue.head[y] := tmpW;                                                                             
                                                                                                    
 Node.next[x] := v;                                                                                 
 Queue.head[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Queue.head(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Node.next.Queue.head(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v1;                                                                                
 _writeByTAfterT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Node.next[x] := tmpV;                                                                              
                                                                                                    
 Queue.head[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Node.next[x] := v1;                                                                                
 _writeByTAfterUAndT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Queue.tail (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Node.next is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.tail is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.tail is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Queue.tail is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Node.next.Queue.tail(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Queue.tail[y];                                                                             
 Queue.tail[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Queue.tail(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Queue.tail[y] := tmpW;                                                                             
                                                                                                    
 Node.next[x] := v;                                                                                 
 Queue.tail[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Queue.tail(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Node.next.Queue.tail(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Node, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Node.next;                                                                                
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var x_pre: Node;                                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v1;                                                                                
 _writeByTAfterT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Node.next[x] := tmpV;                                                                              
                                                                                                    
 Queue.tail[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Node.next[x] := v1;                                                                                
 _writeByTAfterUAndT := WriteEval.Node.next(t: Tid,x: Node,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.value (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.value (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.value (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Queue.head is not Read-Write Stable with respect to Node.value (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Queue.head is not Read-Write Stable with respect to Node.value (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Queue.head is not Read-Write Stable with respect to Node.value (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.5): Node.value is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Queue.head.Node.value(t: Tid, u: Tid, v: Node, w1: int, w2: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: int;                                                                                     
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var w2_pre: int;                                                                                   
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w1_pre: int;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var w2_mid: int;                                                                                   
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var w1_mid: int;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var w2_post: int;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var w1_post: int;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w1: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.value[y];                                                                             
 Node.value[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.value(u: Tid,y: Node,w2: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.value[y] := tmpW;                                                                             
                                                                                                    
 Queue.head[x] := v;                                                                                
 Node.value[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.value(u: Tid,y: Node,w2: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Queue.head.Node.value(t: Tid, u: Tid, v1: Node, v2: Node, w: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v1;                                                                               
 _writeByTAfterT := WriteEval.Queue.head(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Queue.head[x] := tmpV;                                                                             
                                                                                                    
 Node.value[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Queue.head[x] := v1;                                                                               
 _writeByTAfterUAndT := WriteEval.Queue.head(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Queue.head is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Queue.head is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Queue.head is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.5): Node.next is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Queue.head.Node.next(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.next[y];                                                                              
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.next[y] := tmpW;                                                                              
                                                                                                    
 Queue.head[x] := v;                                                                                
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Queue.head.Node.next(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.head;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v1;                                                                               
 _writeByTAfterT := WriteEval.Queue.head(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Queue.head[x] := tmpV;                                                                             
                                                                                                    
 Node.next[y] := w;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Queue.head[x] := v1;                                                                               
 _writeByTAfterUAndT := WriteEval.Queue.head(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Queue.head is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Queue.head is not Read-Write Stable with respect to Queue.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Queue.head is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Queue.head is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Queue.head is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (18.5): Queue.head is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Queue.head.Queue.head(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Queue.head[y];                                                                             
 Queue.head[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Queue.head(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Queue.head[y] := tmpW;                                                                             
                                                                                                    
 Queue.head[x] := v;                                                                                
 Queue.head[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Queue.head(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Queue.head.Queue.head(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v1;                                                                               
 _writeByTAfterT := WriteEval.Queue.head(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Queue.head[x] := tmpV;                                                                             
                                                                                                    
 Queue.head[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Queue.head[x] := v1;                                                                               
 _writeByTAfterUAndT := WriteEval.Queue.head(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Queue.head.Queue.tail(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Queue.tail[y];                                                                             
 Queue.tail[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Queue.tail(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Queue.tail[y] := tmpW;                                                                             
                                                                                                    
 Queue.head[x] := v;                                                                                
 Queue.tail[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Queue.tail(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Queue.head.Queue.tail(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v1;                                                                               
 _writeByTAfterT := WriteEval.Queue.head(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Queue.head[x] := tmpV;                                                                             
                                                                                                    
 Queue.tail[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Queue.head[x] := v1;                                                                               
 _writeByTAfterUAndT := WriteEval.Queue.head(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.value (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Node.value[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.value (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.value (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.value[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.tail is not Read-Write Stable with respect to Node.value (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.tail is not Read-Write Stable with respect to Node.value (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.tail is not Read-Write Stable with respect to Node.value (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Node.value(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.value(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (3.5): Node.value is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (3.5): Node.value is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Queue.tail.Node.value(t: Tid, u: Tid, v: Node, w1: int, w2: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: int;                                                                                     
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var w2_pre: int;                                                                                   
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w1_pre: int;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var w2_mid: int;                                                                                   
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var w1_mid: int;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var w2_post: int;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var w1_post: int;                                                                                  
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w1: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.value[y];                                                                             
 Node.value[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.value(u: Tid,y: Node,w2: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.value[y] := tmpW;                                                                             
                                                                                                    
 Queue.tail[x] := v;                                                                                
 Node.value[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.value(u: Tid,y: Node,w2: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Queue.tail.Node.value(t: Tid, u: Tid, v1: Node, v2: Node, w: int, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.value;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w_post: int;                                                                                   
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.value(u: Tid,y: Node,w: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Queue.tail[x] := tmpV;                                                                             
                                                                                                    
 Node.value[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterUAndT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.tail is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.tail is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.tail is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Node.next is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.5): Node.next is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Queue.tail.Node.next(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Node.next[y];                                                                              
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Node.next[y] := tmpW;                                                                              
                                                                                                    
 Queue.tail[x] := v;                                                                                
 Node.next[y] := w1;                                                                                
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Node.next(u: Tid,y: Node,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Queue.tail.Node.next(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Queue, y: Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Node._state[y], u);                                                          
 modifies Queue.tail;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var y_pre: Node;                                                                                   
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var y_post: Node;                                                                                  
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Queue.tail[x] := tmpV;                                                                             
                                                                                                    
 Node.next[y] := w;                                                                                 
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterUAndT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Queue.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (18.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Queue.tail.Queue.head(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Queue.head[y];                                                                             
 Queue.head[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Queue.head(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Queue.head[y] := tmpW;                                                                             
                                                                                                    
 Queue.tail[x] := v;                                                                                
 Queue.head[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Queue.head(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Queue.tail.Queue.head(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Queue.tail[x] := tmpV;                                                                             
                                                                                                    
 Queue.head[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterUAndT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var w0_mid: Node;                                                                                  
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Queue.tail(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var w0_post: Node;                                                                                 
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.M.Queue.tail.Queue.tail(t: Tid, u: Tid, v: Node, w1: Node, w2: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpW: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUAfterU : MoverPath;                                                                   
 var _writeByUAfterU_Mover : Mover;                                                                 
 var _writeByUAfterU_Path : int;                                                                    
 var _writeByUAfterTAndU : MoverPath;                                                               
 var _writeByUAfterTAndU_Mover : Mover;                                                             
 var _writeByUAfterTAndU_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var w2_pre: Node;                                                                                  
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w1_pre: Node;                                                                                  
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v_pre: Node;                                                                                   
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var v_mid: Node;                                                                                   
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w2_mid: Node;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
 var w1_mid: Node;                                                                                  
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var w2_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var v_post: Node;                                                                                  
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w1_post: Node;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v_pre == v && w1_pre == w1 && w2_pre == w2 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpW := Queue.tail[y];                                                                             
 Queue.tail[y] := w1;                                                                               
                                                                                                    
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v_mid == v && w1_mid == w1 && w2_mid == w2 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUAfterU := WriteEval.Queue.tail(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterU_Mover := m#moverPath(_writeByUAfterU);                                             
 _writeByUAfterU_Path := p#moverPath(_writeByUAfterU);                                              
 Queue.tail[y] := tmpW;                                                                             
                                                                                                    
 Queue.tail[x] := v;                                                                                
 Queue.tail[y] := w1;                                                                               
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v_post == v && w1_post == w1 && w2_post == w2 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUAfterTAndU := WriteEval.Queue.tail(u: Tid,y: Queue,w2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByUAfterTAndU_Mover := m#moverPath(_writeByUAfterTAndU);                                     
 _writeByUAfterTAndU_Path := p#moverPath(_writeByUAfterTAndU);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _N) && true && true) ==> ((_writeByUAfterU_Mover == _writeByUAfterTAndU_Mover || _writeByUAfterU_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case M)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.N.Queue.tail.Queue.tail(t: Tid, u: Tid, v1: Node, v2: Node, w: Node, x: Queue, y: Queue)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV: Node;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTAfterT : MoverPath;                                                                   
 var _writeByTAfterT_Mover : Mover;                                                                 
 var _writeByTAfterT_Path : int;                                                                    
 var _writeByTAfterUAndT : MoverPath;                                                               
 var _writeByTAfterUAndT_Mover : Mover;                                                             
 var _writeByTAfterUAndT_Path : int;                                                                
 var Node._lock_pre: [Node]Tid;                                                                     
 var Queue.head_pre: [Queue]Node;                                                                   
 var Queue.tail_nextThread_pre: [Queue]Tid;                                                         
 var Queue.head_nextValue_pre: [Queue]Node;                                                         
 var Queue.head_nextThread_pre: [Queue]Tid;                                                         
 var Node.next_nextValue_pre: [Node]Node;                                                           
 var v2_pre: Node;                                                                                  
 var x_pre: Queue;                                                                                  
 var Node.next_nextThread_pre: [Node]Tid;                                                           
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Queue.tail_nextValue_pre: [Queue]Node;                                                         
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.value_pre: [Node]int;                                                                     
 var v1_pre: Node;                                                                                  
 var Queue.tail_pre: [Queue]Node;                                                                   
 var Queue._state_pre: [Queue]State;                                                                
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Queue.tail_mid: [Queue]Node;                                                                   
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Queue.head_nextThread_mid: [Queue]Tid;                                                         
 var Queue.tail_nextValue_mid: [Queue]Node;                                                         
 var Node.value_mid: [Node]int;                                                                     
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var y_mid: Queue;                                                                                  
 var v2_mid: Node;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue.tail_nextThread_mid: [Queue]Tid;                                                         
 var Queue.head_nextValue_mid: [Queue]Node;                                                         
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.head_mid: [Queue]Node;                                                                   
 var v1_mid: Node;                                                                                  
 var Node.next_nextValue_mid: [Node]Node;                                                           
 var Node.next_nextThread_mid: [Node]Tid;                                                           
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var Queue._state_mid: [Queue]State;                                                                
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var Queue.head_nextValue_post: [Queue]Node;                                                        
 var $recorded.state_post: int;                                                                     
 var v1_post: Node;                                                                                 
 var t_post: Tid;                                                                                   
 var Node.next_nextThread_post: [Node]Tid;                                                          
 var Node.value_post: [Node]int;                                                                    
 var x_post: Queue;                                                                                 
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Queue.tail_post: [Queue]Node;                                                                  
 var Node.next_nextValue_post: [Node]Node;                                                          
 var Queue.head_post: [Queue]Node;                                                                  
 var Queue.tail_nextThread_post: [Queue]Tid;                                                        
 var y_post: Queue;                                                                                 
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var Queue.tail_nextValue_post: [Queue]Node;                                                        
 var Queue._state_post: [Queue]State;                                                               
 var v2_post: Node;                                                                                 
 var Queue.head_nextThread_post: [Queue]Tid;                                                        
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && t_pre == t && u_pre == u && v1_pre == v1 && v2_pre == v2 && w_pre == w && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterT_Mover := m#moverPath(_writeByTAfterT);                                             
 _writeByTAfterT_Path := p#moverPath(_writeByTAfterT);                                              
 Queue.tail[x] := tmpV;                                                                             
                                                                                                    
 Queue.tail[y] := w;                                                                                
 assume Node._state_mid == Node._state && Node.value_mid == Node.value && Node.next_mid == Node.next && Node._lock_mid == Node._lock && Node.next_nextThread_mid == Node.next_nextThread && Node.next_nextValue_mid == Node.next_nextValue && Queue._state_mid == Queue._state && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue._lock_mid == Queue._lock && Queue.head_nextThread_mid == Queue.head_nextThread && Queue.head_nextValue_mid == Queue.head_nextValue && Queue.tail_nextThread_mid == Queue.tail_nextThread && Queue.tail_nextValue_mid == Queue.tail_nextValue && t_mid == t && u_mid == u && v1_mid == v1 && v2_mid == v2 && w_mid == w && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v1: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 Queue.tail[x] := v1;                                                                               
 _writeByTAfterUAndT := WriteEval.Queue.tail(t: Tid,x: Queue,v2: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue);
 _writeByTAfterUAndT_Mover := m#moverPath(_writeByTAfterUAndT);                                     
 _writeByTAfterUAndT_Path := p#moverPath(_writeByTAfterUAndT);                                      
                                                                                                    
 assume Node._state_post == Node._state && Node.value_post == Node.value && Node.next_post == Node.next && Node._lock_post == Node._lock && Node.next_nextThread_post == Node.next_nextThread && Node.next_nextValue_post == Node.next_nextValue && Queue._state_post == Queue._state && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue._lock_post == Queue._lock && Queue.head_nextThread_post == Queue.head_nextThread && Queue.head_nextValue_post == Queue.head_nextValue && Queue.tail_nextThread_post == Queue.tail_nextThread && Queue.tail_nextValue_post == Queue.tail_nextValue && t_post == t && u_post == u && v1_post == v1 && v2_post == v2 && w_post == w && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByU_Mover, _L)) ==> ((_writeByTAfterUAndT_Mover == _writeByTAfterT_Mover || _writeByTAfterUAndT_Mover == _E));       // (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case N)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
requires ValidTid(tid);                                                                             
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (<undefined position>): Object invariant may not hold.
modifies Node._state;                                                                               
modifies Node.value;                                                                                
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies Node.next_nextThread;                                                                      
modifies Node.next_nextValue;                                                                       
modifies Queue._state;                                                                              
modifies Queue.head;                                                                                
modifies Queue.tail;                                                                                
modifies Queue._lock;                                                                               
modifies Queue.head_nextThread;                                                                     
modifies Queue.head_nextValue;                                                                      
modifies Queue.tail_nextThread;                                                                     
modifies Queue.tail_nextValue;                                                                      
ensures StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
ensures Y(tid , old(Node._state), old(Node.value), old(Node.next), old(Node._lock), old(Node.next_nextThread), old(Node.next_nextValue), old(Queue._state), old(Queue.head), old(Queue.tail), old(Queue._lock), old(Queue.head_nextThread), old(Queue.head_nextValue), old(Queue.tail_nextThread), old(Queue.tail_nextValue) , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// Node.value:                                                                                      
                                                                                                    
function {:inline} Y_Node.value(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.value(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Node.value[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.value(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.value.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Queue.head_nextValue_yield: [Queue]Node;                                                        
var newValue_yield: int;                                                                            
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_nextThread_yield: [Queue]Tid;                                                        
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.value(u: Tid,this: Node,newValue: int,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.head_nextThread_yield == Queue.head_nextThread && Queue.head_nextValue_yield == Queue.head_nextValue && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.value(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.value.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Queue.head_nextValue_yield: [Queue]Node;                                                        
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_nextThread_yield: [Queue]Tid;                                                        
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.head_nextThread_yield == Queue.head_nextThread && Queue.head_nextValue_yield == Queue.head_nextValue && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.value(tid, this, Node.value[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.value.Transitive(tid : Tid, this: Node, newValue : int , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.head_nextThread_p: [Queue]Tid, Queue.head_nextValue_p: [Queue]Node, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (3.25): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (3.25): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Queue.head_pre: [Queue]Node;                                                                    
var Queue.tail_nextThread_pre: [Queue]Tid;                                                          
var Queue.head_nextValue_pre: [Queue]Node;                                                          
var Queue.head_nextThread_pre: [Queue]Tid;                                                          
var Node.next_nextValue_pre: [Node]Node;                                                            
var Node.next_nextThread_pre: [Node]Tid;                                                            
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var newValue_pre: int;                                                                              
var Queue.tail_nextValue_pre: [Queue]Node;                                                          
var Queue._lock_pre: [Queue]Tid;                                                                    
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Queue.tail_pre: [Queue]Node;                                                                    
var Queue._state_pre: [Queue]State;                                                                 
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
                                                                                                    
var Queue.head_nextValue_post: [Queue]Node;                                                         
var $recorded.state_post: int;                                                                      
var Node.next_nextThread_post: [Node]Tid;                                                           
var Node.value_post: [Node]int;                                                                     
var newValue_post: int;                                                                             
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Queue.tail_post: [Queue]Node;                                                                   
var Node.next_nextValue_post: [Node]Node;                                                           
var tid_post: Tid;                                                                                  
var Queue.head_post: [Queue]Node;                                                                   
var Queue.tail_nextThread_post: [Queue]Tid;                                                         
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Queue.tail_nextValue_post: [Queue]Node;                                                         
var Queue._state_post: [Queue]State;                                                                
var this_post: Node;                                                                                
var Queue.head_nextThread_post: [Queue]Tid;                                                         
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 assume Y_Node.value(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Node.next_nextThread_post == Node.next_nextThread_p && Node.next_nextValue_post == Node.next_nextValue_p && Queue._state_post == Queue._state_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue._lock_post == Queue._lock_p && Queue.head_nextThread_post == Queue.head_nextThread_p && Queue.head_nextValue_post == Queue.head_nextValue_p && Queue.tail_nextThread_post == Queue.tail_nextThread_p && Queue.tail_nextValue_post == Queue.tail_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.value(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
// Node.next:                                                                                       
                                                                                                    
function {:inline} Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.next(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Node.next[this] == newValue))
 &&(((Node.next[this]!=newValue)==>!(isShared(Node._state[newValue]))))                             
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Queue.head_nextValue_yield: [Queue]Node;                                                        
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_nextThread_yield: [Queue]Tid;                                                        
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var newValue_yield: Node;                                                                           
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.next(u: Tid,this: Node,newValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.head_nextThread_yield == Queue.head_nextThread && Queue.head_nextValue_yield == Queue.head_nextValue && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Queue.head_nextValue_yield: [Queue]Node;                                                        
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_nextThread_yield: [Queue]Tid;                                                        
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.head_nextThread_yield == Queue.head_nextThread && Queue.head_nextValue_yield == Queue.head_nextValue && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, Node.next[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Transitive(tid : Tid, this: Node, newValue : Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.head_nextThread_p: [Queue]Tid, Queue.head_nextValue_p: [Queue]Node, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (4.34): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (4.34): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Queue.head_pre: [Queue]Node;                                                                    
var Queue.tail_nextThread_pre: [Queue]Tid;                                                          
var Queue.head_nextValue_pre: [Queue]Node;                                                          
var Queue.head_nextThread_pre: [Queue]Tid;                                                          
var Node.next_nextValue_pre: [Node]Node;                                                            
var Node.next_nextThread_pre: [Node]Tid;                                                            
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var Queue.tail_nextValue_pre: [Queue]Node;                                                          
var Queue._lock_pre: [Queue]Tid;                                                                    
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Queue.tail_pre: [Queue]Node;                                                                    
var Queue._state_pre: [Queue]State;                                                                 
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
                                                                                                    
var Queue.head_nextValue_post: [Queue]Node;                                                         
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.next_nextThread_post: [Node]Tid;                                                           
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Queue.tail_post: [Queue]Node;                                                                   
var Node.next_nextValue_post: [Node]Node;                                                           
var tid_post: Tid;                                                                                  
var Queue.head_post: [Queue]Node;                                                                   
var Queue.tail_nextThread_post: [Queue]Tid;                                                         
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Queue.tail_nextValue_post: [Queue]Node;                                                         
var Queue._state_post: [Queue]State;                                                                
var this_post: Node;                                                                                
var Queue.head_nextThread_post: [Queue]Tid;                                                         
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 assume Y_Node.next(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Node.next_nextThread_post == Node.next_nextThread_p && Node.next_nextValue_post == Node.next_nextValue_p && Queue._state_post == Queue._state_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue._lock_post == Queue._lock_p && Queue.head_nextThread_post == Queue.head_nextThread_p && Queue.head_nextValue_post == Queue.head_nextValue_p && Queue.tail_nextThread_post == Queue.tail_nextThread_p && Queue.tail_nextValue_post == Queue.tail_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.next(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
// Node._lock:                                                                                      
                                                                                                    
function {:inline} Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Node._lock[this] == newValue))
 &&(((Node._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var newValue_yield: Tid;                                                                            
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Queue.head_nextValue_yield: [Queue]Node;                                                        
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_nextThread_yield: [Queue]Tid;                                                        
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node._lock(u: Tid,this: Node,newValue: Tid,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)));
 assume leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _N);
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.head_nextThread_yield == Queue.head_nextThread && Queue.head_nextValue_yield == Queue.head_nextValue && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Queue.head_nextValue_yield: [Queue]Node;                                                        
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_nextThread_yield: [Queue]Tid;                                                        
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.head_nextThread_yield == Queue.head_nextThread && Queue.head_nextValue_yield == Queue.head_nextValue && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, Node._lock[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Transitive(tid : Tid, this: Node, newValue : Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.head_nextThread_p: [Queue]Tid, Queue.head_nextValue_p: [Queue]Node, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (2.1): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (2.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Queue.head_pre: [Queue]Node;                                                                    
var Queue.tail_nextThread_pre: [Queue]Tid;                                                          
var Queue.head_nextValue_pre: [Queue]Node;                                                          
var Queue.head_nextThread_pre: [Queue]Tid;                                                          
var Node.next_nextValue_pre: [Node]Node;                                                            
var Node.next_nextThread_pre: [Node]Tid;                                                            
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var Queue.tail_nextValue_pre: [Queue]Node;                                                          
var Queue._lock_pre: [Queue]Tid;                                                                    
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Queue.tail_pre: [Queue]Node;                                                                    
var Queue._state_pre: [Queue]State;                                                                 
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var newValue_pre: Tid;                                                                              
                                                                                                    
var Queue.head_nextValue_post: [Queue]Node;                                                         
var $recorded.state_post: int;                                                                      
var Node.next_nextThread_post: [Node]Tid;                                                           
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Queue.tail_post: [Queue]Node;                                                                   
var Node.next_nextValue_post: [Node]Node;                                                           
var tid_post: Tid;                                                                                  
var Queue.head_post: [Queue]Node;                                                                   
var Queue.tail_nextThread_post: [Queue]Tid;                                                         
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Queue.tail_nextValue_post: [Queue]Node;                                                         
var Queue._state_post: [Queue]State;                                                                
var this_post: Node;                                                                                
var newValue_post: Tid;                                                                             
var Queue.head_nextThread_post: [Queue]Tid;                                                         
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 assume Y_Node._lock(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Node.next_nextThread_post == Node.next_nextThread_p && Node.next_nextValue_post == Node.next_nextValue_p && Queue._state_post == Queue._state_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue._lock_post == Queue._lock_p && Queue.head_nextThread_post == Queue.head_nextThread_p && Queue.head_nextValue_post == Queue.head_nextValue_p && Queue.tail_nextThread_post == Queue.tail_nextThread_p && Queue.tail_nextValue_post == Queue.tail_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
// Node.next_nextThread:                                                                            
                                                                                                    
function {:inline} Y_Node.next_nextThread(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.next_nextThread(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Node.next_nextThread[this] == newValue))
 &&(((Node.next_nextThread[this]==tid)==>(newValue==tid)))                                          
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.next_nextThread(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// Node.next_nextValue:                                                                             
                                                                                                    
function {:inline} Y_Node.next_nextValue(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.next_nextValue(tid: Tid,this: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Node.next_nextValue[this] == newValue))
 &&(((Node.next_nextThread[this]==tid)==>(newValue==Node.next_nextValue[this])))                    
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.next_nextValue(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// Queue.head:                                                                                      
                                                                                                    
function {:inline} Y_Queue.head(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.head(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Queue.head[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Queue.head(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue.head.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Queue.head_nextValue_yield: [Queue]Node;                                                        
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_nextThread_yield: [Queue]Tid;                                                        
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var newValue_yield: Node;                                                                           
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue.head(u: Tid,this: Queue,newValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.head_nextThread_yield == Queue.head_nextThread && Queue.head_nextValue_yield == Queue.head_nextValue && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.head(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Queue.head.Reflexive(tid : Tid, this: Queue , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Queue.head_nextValue_yield: [Queue]Node;                                                        
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_nextThread_yield: [Queue]Tid;                                                        
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.head_nextThread_yield == Queue.head_nextThread && Queue.head_nextValue_yield == Queue.head_nextValue && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.head(tid, this, Queue.head[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Queue.head.Transitive(tid : Tid, this: Queue, newValue : Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.head_nextThread_p: [Queue]Tid, Queue.head_nextValue_p: [Queue]Node, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (18.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (18.33): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Queue.head_pre: [Queue]Node;                                                                    
var Queue.tail_nextThread_pre: [Queue]Tid;                                                          
var Queue.head_nextValue_pre: [Queue]Node;                                                          
var Queue.head_nextThread_pre: [Queue]Tid;                                                          
var Node.next_nextValue_pre: [Node]Node;                                                            
var Node.next_nextThread_pre: [Node]Tid;                                                            
var $recorded.state_pre: int;                                                                       
var Queue.tail_nextValue_pre: [Queue]Node;                                                          
var Queue._lock_pre: [Queue]Tid;                                                                    
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Queue.tail_pre: [Queue]Node;                                                                    
var Queue._state_pre: [Queue]State;                                                                 
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var this_pre: Queue;                                                                                
                                                                                                    
var Queue.head_nextValue_post: [Queue]Node;                                                         
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.next_nextThread_post: [Node]Tid;                                                           
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Queue.tail_post: [Queue]Node;                                                                   
var Node.next_nextValue_post: [Node]Node;                                                           
var tid_post: Tid;                                                                                  
var this_post: Queue;                                                                               
var Queue.head_post: [Queue]Node;                                                                   
var Queue.tail_nextThread_post: [Queue]Tid;                                                         
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Queue.tail_nextValue_post: [Queue]Node;                                                         
var Queue._state_post: [Queue]State;                                                                
var Queue.head_nextThread_post: [Queue]Tid;                                                         
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 assume Y_Queue.head(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Node.next_nextThread_post == Node.next_nextThread_p && Node.next_nextValue_post == Node.next_nextValue_p && Queue._state_post == Queue._state_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue._lock_post == Queue._lock_p && Queue.head_nextThread_post == Queue.head_nextThread_p && Queue.head_nextValue_post == Queue.head_nextValue_p && Queue.tail_nextThread_post == Queue.tail_nextThread_p && Queue.tail_nextValue_post == Queue.tail_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue.head(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
// Queue.tail:                                                                                      
                                                                                                    
function {:inline} Y_Queue.tail(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.tail(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Queue.tail[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Queue.tail(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue.tail.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Queue.head_nextValue_yield: [Queue]Node;                                                        
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_nextThread_yield: [Queue]Tid;                                                        
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var newValue_yield: Node;                                                                           
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue.tail(u: Tid,this: Queue,newValue: Node,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)));
                                                                                                    
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.head_nextThread_yield == Queue.head_nextThread && Queue.head_nextValue_yield == Queue.head_nextValue && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.tail(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Queue.tail.Reflexive(tid : Tid, this: Queue , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Queue.head_nextValue_yield: [Queue]Node;                                                        
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_nextThread_yield: [Queue]Tid;                                                        
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.head_nextThread_yield == Queue.head_nextThread && Queue.head_nextValue_yield == Queue.head_nextValue && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.tail(tid, this, Queue.tail[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Queue.tail.Transitive(tid : Tid, this: Queue, newValue : Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.head_nextThread_p: [Queue]Tid, Queue.head_nextValue_p: [Queue]Node, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (19.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (19.33): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Queue.head_pre: [Queue]Node;                                                                    
var Queue.tail_nextThread_pre: [Queue]Tid;                                                          
var Queue.head_nextValue_pre: [Queue]Node;                                                          
var Queue.head_nextThread_pre: [Queue]Tid;                                                          
var Node.next_nextValue_pre: [Node]Node;                                                            
var Node.next_nextThread_pre: [Node]Tid;                                                            
var $recorded.state_pre: int;                                                                       
var Queue.tail_nextValue_pre: [Queue]Node;                                                          
var Queue._lock_pre: [Queue]Tid;                                                                    
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Queue.tail_pre: [Queue]Node;                                                                    
var Queue._state_pre: [Queue]State;                                                                 
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var this_pre: Queue;                                                                                
                                                                                                    
var Queue.head_nextValue_post: [Queue]Node;                                                         
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.next_nextThread_post: [Node]Tid;                                                           
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Queue.tail_post: [Queue]Node;                                                                   
var Node.next_nextValue_post: [Node]Node;                                                           
var tid_post: Tid;                                                                                  
var this_post: Queue;                                                                               
var Queue.head_post: [Queue]Node;                                                                   
var Queue.tail_nextThread_post: [Queue]Tid;                                                         
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Queue.tail_nextValue_post: [Queue]Node;                                                         
var Queue._state_post: [Queue]State;                                                                
var Queue.head_nextThread_post: [Queue]Tid;                                                         
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 assume Y_Queue.tail(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Node.next_nextThread_post == Node.next_nextThread_p && Node.next_nextValue_post == Node.next_nextValue_p && Queue._state_post == Queue._state_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue._lock_post == Queue._lock_p && Queue.head_nextThread_post == Queue.head_nextThread_p && Queue.head_nextValue_post == Queue.head_nextValue_p && Queue.tail_nextThread_post == Queue.tail_nextThread_p && Queue.tail_nextValue_post == Queue.tail_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue.tail(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
// Queue._lock:                                                                                     
                                                                                                    
function {:inline} Y_Queue._lock(tid : Tid, this: Queue, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue._lock(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Queue._lock[this] == newValue))
 &&(((Queue._lock[this]==tid)==(newValue==tid)))                                                    
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Queue._lock(tid : Tid, this: Queue, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue._lock.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var Node.value_yield: [Node]int;                                                                    
var newValue_yield: Tid;                                                                            
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Queue.head_nextValue_yield: [Queue]Node;                                                        
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_nextThread_yield: [Queue]Tid;                                                        
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue._lock(u: Tid,this: Queue,newValue: Tid,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)));
 assume leq(m#moverPath(ReadEval.Queue._lock(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _N);
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.head_nextThread_yield == Queue.head_nextThread && Queue.head_nextValue_yield == Queue.head_nextValue && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue._lock(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Queue._lock.Reflexive(tid : Tid, this: Queue , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue.tail_yield: [Queue]Node;                                                                  
var Node.next_yield: [Node]Node;                                                                    
var Node.value_yield: [Node]int;                                                                    
var Queue._state_yield: [Queue]State;                                                               
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.next_nextThread_yield: [Node]Tid;                                                          
var $pc_yield: Phase;                                                                               
var Queue.head_nextValue_yield: [Queue]Node;                                                        
var Node._lock_yield: [Node]Tid;                                                                    
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_nextThread_yield: [Queue]Tid;                                                        
var Queue.tail_nextValue_yield: [Queue]Node;                                                        
var Node.next_nextValue_yield: [Node]Node;                                                          
var Queue.tail_nextThread_yield: [Queue]Tid;                                                        
var Queue.head_yield: [Queue]Node;                                                                  
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Node._state_yield == Node._state && Node.value_yield == Node.value && Node.next_yield == Node.next && Node._lock_yield == Node._lock && Node.next_nextThread_yield == Node.next_nextThread && Node.next_nextValue_yield == Node.next_nextValue && Queue._state_yield == Queue._state && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue._lock_yield == Queue._lock && Queue.head_nextThread_yield == Queue.head_nextThread && Queue.head_nextValue_yield == Queue.head_nextValue && Queue.tail_nextThread_yield == Queue.tail_nextThread && Queue.tail_nextValue_yield == Queue.tail_nextValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue._lock(tid, this, Queue._lock[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
                                                                                                    
procedure Y_Queue._lock.Transitive(tid : Tid, this: Queue, newValue : Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.head_nextThread_p: [Queue]Tid, Queue.head_nextValue_p: [Queue]Node, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node)
 requires StateInvariant(Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
 requires StateInvariant(Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537828(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (16.1): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3537836(tid: Tid,_this : Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue));       // (16.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Queue.head_pre: [Queue]Node;                                                                    
var Queue.tail_nextThread_pre: [Queue]Tid;                                                          
var Queue.head_nextValue_pre: [Queue]Node;                                                          
var Queue.head_nextThread_pre: [Queue]Tid;                                                          
var Node.next_nextValue_pre: [Node]Node;                                                            
var Node.next_nextThread_pre: [Node]Tid;                                                            
var $recorded.state_pre: int;                                                                       
var Queue.tail_nextValue_pre: [Queue]Node;                                                          
var Queue._lock_pre: [Queue]Tid;                                                                    
var Node._state_pre: [Node]State;                                                                   
var Node.value_pre: [Node]int;                                                                      
var tid_pre: Tid;                                                                                   
var Queue.tail_pre: [Queue]Node;                                                                    
var Queue._state_pre: [Queue]State;                                                                 
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var newValue_pre: Tid;                                                                              
var this_pre: Queue;                                                                                
                                                                                                    
var Queue.head_nextValue_post: [Queue]Node;                                                         
var $recorded.state_post: int;                                                                      
var Node.next_nextThread_post: [Node]Tid;                                                           
var Node.value_post: [Node]int;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var Queue.tail_post: [Queue]Node;                                                                   
var Node.next_nextValue_post: [Node]Node;                                                           
var tid_post: Tid;                                                                                  
var this_post: Queue;                                                                               
var Queue.head_post: [Queue]Node;                                                                   
var Queue.tail_nextThread_post: [Queue]Tid;                                                         
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var Queue.tail_nextValue_post: [Queue]Node;                                                         
var Queue._state_post: [Queue]State;                                                                
var newValue_post: Tid;                                                                             
var Queue.head_nextThread_post: [Queue]Tid;                                                         
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Node._state_pre == Node._state && Node.value_pre == Node.value && Node.next_pre == Node.next && Node._lock_pre == Node._lock && Node.next_nextThread_pre == Node.next_nextThread && Node.next_nextValue_pre == Node.next_nextValue && Queue._state_pre == Queue._state && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue._lock_pre == Queue._lock && Queue.head_nextThread_pre == Queue.head_nextThread && Queue.head_nextValue_pre == Queue.head_nextValue && Queue.tail_nextThread_pre == Queue.tail_nextThread && Queue.tail_nextValue_pre == Queue.tail_nextValue && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
 assume Y_Queue._lock(tid, this, newValue , Node._state_p, Node.value_p, Node.next_p, Node._lock_p, Node.next_nextThread_p, Node.next_nextValue_p, Queue._state_p, Queue.head_p, Queue.tail_p, Queue._lock_p, Queue.head_nextThread_p, Queue.head_nextValue_p, Queue.tail_nextThread_p, Queue.tail_nextValue_p);
assume Node._state_post == Node._state_p && Node.value_post == Node.value_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && Node.next_nextThread_post == Node.next_nextThread_p && Node.next_nextValue_post == Node.next_nextValue_p && Queue._state_post == Queue._state_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue._lock_post == Queue._lock_p && Queue.head_nextThread_post == Queue.head_nextThread_p && Queue.head_nextValue_post == Queue.head_nextValue_p && Queue.tail_nextThread_post == Queue.tail_nextThread_p && Queue.tail_nextValue_post == Queue.tail_nextValue_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue._lock(tid, this, newValue , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue);
}                                                                                                   
// Queue.head_nextThread:                                                                           
                                                                                                    
function {:inline} Y_Queue.head_nextThread(tid : Tid, this: Queue, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.head_nextThread(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Queue.head_nextThread[this] == newValue))
 &&(((Queue.head_nextThread[this]==tid)==>(newValue==tid)))                                         
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Queue.head_nextThread(tid : Tid, this: Queue, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// Queue.head_nextValue:                                                                            
                                                                                                    
function {:inline} Y_Queue.head_nextValue(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.head_nextValue(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Queue.head_nextValue[this] == newValue))
 &&(((Queue.head_nextThread[this]==tid)==>(newValue==Queue.head_nextValue[this])))                  
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Queue.head_nextValue(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// Queue.tail_nextThread:                                                                           
                                                                                                    
function {:inline} Y_Queue.tail_nextThread(tid : Tid, this: Queue, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.tail_nextThread(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Queue.tail_nextThread[this] == newValue))
 &&(((Queue.tail_nextThread[this]==tid)==>(newValue==tid)))                                         
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Queue.tail_nextThread(tid : Tid, this: Queue, newValue: Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
// Queue.tail_nextValue:                                                                            
                                                                                                    
function {:inline} Y_Queue.tail_nextValue(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.tail_nextValue(tid: Tid,this: Queue,Node._state,Node.value,Node.next,Node._lock,Node.next_nextThread,Node.next_nextValue,Queue._state,Queue.head,Queue.tail,Queue._lock,Queue.head_nextThread,Queue.head_nextValue,Queue.tail_nextThread,Queue.tail_nextValue)), _R)) ==> (Queue.tail_nextValue[this] == newValue))
 &&(((Queue.tail_nextThread[this]==tid)==>(newValue==Queue.tail_nextValue[this])))                  
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Queue.tail_nextValue(tid : Tid, this: Queue, newValue: Node , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Node._state: [Node]State, Node.value: [Node]int, Node.next: [Node]Node, Node._lock: [Node]Tid, Node.next_nextThread: [Node]Tid, Node.next_nextValue: [Node]Node, Queue._state: [Queue]State, Queue.head: [Queue]Node, Queue.tail: [Queue]Node, Queue._lock: [Queue]Tid, Queue.head_nextThread: [Queue]Tid, Queue.head_nextValue: [Queue]Node, Queue.tail_nextThread: [Queue]Tid, Queue.tail_nextValue: [Queue]Node , Node._state_p: [Node]State, Node.value_p: [Node]int, Node.next_p: [Node]Node, Node._lock_p: [Node]Tid, Node.next_nextThread_p: [Node]Tid, Node.next_nextValue_p: [Node]Node, Queue._state_p: [Queue]State, Queue.head_p: [Queue]Node, Queue.tail_p: [Queue]Node, Queue._lock_p: [Queue]Tid, Queue.head_nextThread_p: [Queue]Tid, Queue.head_nextValue_p: [Queue]Node, Queue.tail_nextThread_p: [Queue]Tid, Queue.tail_nextValue_p: [Queue]Node): bool
{                                                                                                   
 (forall this: Node :: Y_Node.value(tid : Tid, this, Node.value_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Node :: Y_Node.next(tid : Tid, this, Node.next_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Node :: Y_Node._lock(tid : Tid, this, Node._lock_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Node :: Y_Node.next_nextThread(tid : Tid, this, Node.next_nextThread_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Node :: Y_Node.next_nextValue(tid : Tid, this, Node.next_nextValue_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Queue :: Y_Queue.head(tid : Tid, this, Queue.head_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Queue :: Y_Queue.tail(tid : Tid, this, Queue.tail_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Queue :: Y_Queue._lock(tid : Tid, this, Queue._lock_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Queue :: Y_Queue.head_nextThread(tid : Tid, this, Queue.head_nextThread_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Queue :: Y_Queue.head_nextValue(tid : Tid, this, Queue.head_nextValue_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Queue :: Y_Queue.tail_nextThread(tid : Tid, this, Queue.tail_nextThread_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall this: Queue :: Y_Queue.tail_nextValue(tid : Tid, this, Queue.tail_nextValue_p[this] , Node._state, Node.value, Node.next, Node._lock, Node.next_nextThread, Node.next_nextValue, Queue._state, Queue.head, Queue.tail, Queue._lock, Queue.head_nextThread, Queue.head_nextValue, Queue.tail_nextThread, Queue.tail_nextValue))
 && (forall _i : Node :: isShared(Node._state[_i]) ==> isShared(Node._state_p[_i]))                 
 && (forall _i : Node :: isLocal(Node._state[_i], tid) <==> isLocal(Node._state_p[_i], tid))        
 && (forall _i : Queue :: isShared(Queue._state[_i]) ==> isShared(Queue._state_p[_i]))              
 && (forall _i : Queue :: isLocal(Queue._state[_i], tid) <==> isLocal(Queue._state_p[_i], tid))     
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 2497.1-4990.2: (Method:31.5)
// 2515.1-2515.24: (31.5): Bad tid
// 2516.1-2516.39: (31.5): this is not global
// 2519.1-2519.379: (31.5): Object invariant may not hold.
// 2520.1-2520.379: (31.5): Object invariant may not hold.
// 2523.1-2523.378: (31.5): Object invariant may not hold.
// 2524.1-2524.378: (31.5): Object invariant may not hold.
// 3830.2-3832.2: (class anchor.sink.VarDeclStmt:32.9)
// 3833.2-3841.36: (class anchor.sink.Alloc:32.9)
// 3844.2-3846.2: (class anchor.sink.VarDeclStmt:32.9)
// 3847.2-3849.2: (class anchor.sink.VarDeclStmt:32.9)
// 3850.2-3852.2: (class anchor.sink.VarDeclStmt:32.9)
// 3853.2-3856.21: (class anchor.sink.Assign:32.9)
// 3857.2-3860.24: (class anchor.sink.Assign:32.9)
// 3861.2-3864.16: (class anchor.sink.Assign:32.9)
// 3865.2-3868.35: (class anchor.sink.Assume:10.5)
// 3869.2-3872.42: (class anchor.sink.Assume:10.5)
// 3874.2-3890.36: (class anchor.sink.Write:11.7)
// 3886.1-3886.32: (11.7): Cannot have potential null deference in left-mover part.
// 3889.1-3889.27: (11.7): Reduction failure
// 3892.2-3895.47: (class anchor.sink.Assume:12.7)
// 3898.2-3919.2: (class anchor.sink.Write:12.7)
// 3910.1-3910.32: (12.7): Cannot have potential null deference in left-mover part.
// 3913.1-3913.27: (12.7): Reduction failure
// 3917.1-3917.63: (12.7): next$230 became shared, but next$230.next may not be shared.
// 3920.2-3923.23: (class anchor.sink.Break:10.32)
// 3927.2-3931.14: (class anchor.sink.While:33.9)
// 3933.1-3933.27: (31.5): Bad tid
// 3934.1-3934.42: (31.5): this is not global
// 3937.1-3937.382: (33.9): Object invariant may not hold.
// 3938.1-3938.382: (33.9): Object invariant may not hold.
// 3938.382-3939.42: (33.9): invariant isLocal(n, tid) may not hold
// 3939.42-3940.39: (33.9): invariant n.next == Node.null may not hold
// 3941.1-3941.415: (33.9): Loop does not preserve yields_as annotation for field value
// 3942.1-3942.413: (33.9): Loop does not preserve yields_as annotation for field next
// 3943.1-3943.416: (33.9): Loop does not preserve yields_as annotation for field head
// 3944.1-3944.416: (33.9): Loop does not preserve yields_as annotation for field tail
// 3945.1-3945.33: (33.9): Phase must be invariant at loop head
// 3946.1-3946.30: (33.9): Potentially infinite loop cannot be in post-commit phase.
// 3948.3-3950.3: (class anchor.sink.VarDeclStmt:33.15)
// 3951.3-3954.16: (class anchor.sink.Assign:33.15)
// 3956.4-3959.10: (class anchor.sink.Break:33.9)
// 3962.3-3964.3: (class anchor.sink.VarDeclStmt:37.13)
// 3966.3-3968.3: (class anchor.sink.VarDeclStmt:37.13)
// 3969.3-3986.39: (class anchor.sink.Read:37.13)
// 3981.1-3981.30: (37.13): Cannot have potential null deference in left-mover part.
// 3985.1-3985.28: (37.13): Reduction failure
// 3987.3-3989.3: (class anchor.sink.VarDeclStmt:37.13)
// 3990.3-4007.38: (class anchor.sink.Read:37.13)
// 4002.1-4002.30: (37.13): Cannot have potential null deference in left-mover part.
// 4006.1-4006.28: (37.13): Reduction failure
// 4008.3-4010.3: (class anchor.sink.VarDeclStmt:37.13)
// 4011.3-4028.37: (class anchor.sink.Read:37.13)
// 4023.1-4023.30: (37.13): Cannot have potential null deference in left-mover part.
// 4027.1-4027.28: (37.13): Reduction failure
// 4029.3-4031.3: (class anchor.sink.VarDeclStmt:37.13)
// 4032.3-4035.284: (class anchor.sink.Assign:37.13)
// 4036.3-4038.3: (class anchor.sink.VarDeclStmt:37.13)
// 4039.3-4042.75: (class anchor.sink.Assign:37.13)
// 4045.4-4062.29: (class anchor.sink.Read:37.13)
// 4057.1-4057.31: (37.13): Cannot have potential null deference in left-mover part.
// 4061.1-4061.29: (37.13): Reduction failure
// 4065.4-4082.29: (class anchor.sink.Read:37.13)
// 4077.1-4077.31: (37.13): Cannot have potential null deference in left-mover part.
// 4081.1-4081.29: (37.13): Reduction failure
// 4084.3-4096.43: (class anchor.sink.Yield:38.13)
// 4089.1-4089.379: (38.13): Object invariant may not hold.
// 4090.1-4090.379: (38.13): Object invariant may not hold.
// 4092.1-4092.379: (38.13): Object invariant may not hold.
// 4093.1-4093.379: (38.13): Object invariant may not hold.
// 4097.3-4099.3: (class anchor.sink.VarDeclStmt:39.13)
// 4101.3-4103.3: (class anchor.sink.VarDeclStmt:39.13)
// 4104.3-4121.38: (class anchor.sink.Read:39.13)
// 4116.1-4116.29: (39.13): Cannot have potential null deference in left-mover part.
// 4120.1-4120.28: (39.13): Reduction failure
// 4122.3-4124.3: (class anchor.sink.VarDeclStmt:39.13)
// 4125.3-4142.37: (class anchor.sink.Read:39.13)
// 4137.1-4137.29: (39.13): Cannot have potential null deference in left-mover part.
// 4141.1-4141.28: (39.13): Reduction failure
// 4143.3-4145.3: (class anchor.sink.VarDeclStmt:39.13)
// 4146.3-4163.36: (class anchor.sink.Read:39.13)
// 4158.1-4158.29: (39.13): Cannot have potential null deference in left-mover part.
// 4162.1-4162.28: (39.13): Reduction failure
// 4164.3-4166.3: (class anchor.sink.VarDeclStmt:39.13)
// 4167.3-4170.282: (class anchor.sink.Assign:39.13)
// 4171.3-4173.3: (class anchor.sink.VarDeclStmt:39.13)
// 4174.3-4177.75: (class anchor.sink.Assign:39.13)
// 4180.4-4197.28: (class anchor.sink.Read:39.13)
// 4192.1-4192.30: (39.13): Cannot have potential null deference in left-mover part.
// 4196.1-4196.29: (39.13): Reduction failure
// 4200.4-4217.28: (class anchor.sink.Read:39.13)
// 4212.1-4212.30: (39.13): Cannot have potential null deference in left-mover part.
// 4216.1-4216.29: (39.13): Reduction failure
// 4219.3-4221.3: (class anchor.sink.VarDeclStmt:40.13)
// 4222.3-4225.29: (class anchor.sink.Assign:40.13)
// 4227.4-4239.44: (class anchor.sink.Yield:41.17)
// 4232.1-4232.380: (41.17): Object invariant may not hold.
// 4233.1-4233.380: (41.17): Object invariant may not hold.
// 4235.1-4235.380: (41.17): Object invariant may not hold.
// 4236.1-4236.380: (41.17): Object invariant may not hold.
// 4240.4-4242.4: (class anchor.sink.VarDeclStmt:42.17)
// 4244.4-4246.4: (class anchor.sink.VarDeclStmt:42.17)
// 4247.4-4250.22: (class anchor.sink.Assign:42.17)
// 4253.5-4256.19: (class anchor.sink.Assign:42.17)
// 4258.5-4261.23: (class anchor.sink.Assign:42.17)
// 4263.6-4265.6: (class anchor.sink.VarDeclStmt:42.17)
// 4266.6-4268.6: (class anchor.sink.VarDeclStmt:42.17)
// 4269.6-4271.6: (class anchor.sink.VarDeclStmt:42.17)
// 4272.6-4275.292: (class anchor.sink.Assign:42.17)
// 4276.6-4279.37: (class anchor.sink.Assume:42.17)
// 4280.6-4283.50: (class anchor.sink.Assume:42.17)
// 4284.6-4287.47: (class anchor.sink.Assume:42.17)
// 4288.6-4291.47: (class anchor.sink.Assume:42.17)
// 4293.6-4309.43: (class anchor.sink.Write:42.17)
// 4305.1-4305.32: (42.17): Cannot have potential null deference in left-mover part.
// 4308.1-4308.31: (42.17): Reduction failure
// 4311.6-4327.44: (class anchor.sink.Write:42.17)
// 4323.1-4323.32: (42.17): Cannot have potential null deference in left-mover part.
// 4326.1-4326.31: (42.17): Reduction failure
// 4330.6-4351.6: (class anchor.sink.Write:42.17)
// 4342.1-4342.32: (42.17): Cannot have potential null deference in left-mover part.
// 4345.1-4345.31: (42.17): Reduction failure
// 4349.1-4349.60: (42.17): n became shared, but n.next may not be shared.
// 4352.6-4355.19: (class anchor.sink.Assign:42.17)
// 4357.6-4360.47: (class anchor.sink.Assume:42.17)
// 4361.6-4364.47: (class anchor.sink.Assume:42.17)
// 4365.6-4367.6: (class anchor.sink.VarDeclStmt:42.17)
// 4368.6-4385.39: (class anchor.sink.Read:42.17)
// 4380.1-4380.32: (42.17): Cannot have potential null deference in left-mover part.
// 4384.1-4384.31: (42.17): Reduction failure
// 4387.6-4408.6: (class anchor.sink.Write:42.17)
// 4399.1-4399.32: (42.17): Cannot have potential null deference in left-mover part.
// 4402.1-4402.31: (42.17): Reduction failure
// 4406.1-4406.63: (42.17): next became shared, but next.next may not be shared.
// 4409.6-4411.6: (class anchor.sink.VarDeclStmt:42.17)
// 4412.6-4415.292: (class anchor.sink.Assign:42.17)
// 4417.6-4438.6: (class anchor.sink.Write:42.17)
// 4429.1-4429.32: (42.17): Cannot have potential null deference in left-mover part.
// 4432.1-4432.31: (42.17): Reduction failure
// 4436.1-4436.72: (42.17): _currentValue became shared, but _currentValue.next may not be shared.
// 4439.6-4442.47: (class anchor.sink.Assume:42.17)
// 4445.6-4466.6: (class anchor.sink.Write:42.17)
// 4457.1-4457.32: (42.17): Cannot have potential null deference in left-mover part.
// 4460.1-4460.31: (42.17): Reduction failure
// 4464.1-4464.60: (42.17): n became shared, but n.next may not be shared.
// 4467.6-4470.20: (class anchor.sink.Assign:42.17)
// 4474.5-4486.45: (class anchor.sink.Yield:43.21)
// 4479.1-4479.381: (43.21): Object invariant may not hold.
// 4480.1-4480.381: (43.21): Object invariant may not hold.
// 4482.1-4482.381: (43.21): Object invariant may not hold.
// 4483.1-4483.381: (43.21): Object invariant may not hold.
// 4487.5-4489.5: (class anchor.sink.VarDeclStmt:44.21)
// 4491.5-4493.5: (class anchor.sink.VarDeclStmt:44.21)
// 4494.5-4497.23: (class anchor.sink.Assign:44.21)
// 4500.6-4503.20: (class anchor.sink.Assign:44.21)
// 4505.6-4508.24: (class anchor.sink.Assign:44.21)
// 4510.7-4512.7: (class anchor.sink.VarDeclStmt:44.21)
// 4513.7-4515.7: (class anchor.sink.VarDeclStmt:44.21)
// 4516.7-4518.7: (class anchor.sink.VarDeclStmt:44.21)
// 4519.7-4522.295: (class anchor.sink.Assign:44.21)
// 4523.7-4526.39: (class anchor.sink.Assume:44.21)
// 4527.7-4530.51: (class anchor.sink.Assume:44.21)
// 4531.7-4534.49: (class anchor.sink.Assume:44.21)
// 4535.7-4538.49: (class anchor.sink.Assume:44.21)
// 4540.7-4556.45: (class anchor.sink.Write:44.21)
// 4552.1-4552.34: (44.21): Cannot have potential null deference in left-mover part.
// 4555.1-4555.32: (44.21): Reduction failure
// 4558.7-4574.46: (class anchor.sink.Write:44.21)
// 4570.1-4570.34: (44.21): Cannot have potential null deference in left-mover part.
// 4573.1-4573.32: (44.21): Reduction failure
// 4577.7-4598.7: (class anchor.sink.Write:44.21)
// 4589.1-4589.34: (44.21): Cannot have potential null deference in left-mover part.
// 4592.1-4592.32: (44.21): Reduction failure
// 4596.1-4596.61: (44.21): n became shared, but n.next may not be shared.
// 4599.7-4602.20: (class anchor.sink.Assign:44.21)
// 4604.7-4607.49: (class anchor.sink.Assume:44.21)
// 4608.7-4611.49: (class anchor.sink.Assume:44.21)
// 4612.7-4614.7: (class anchor.sink.VarDeclStmt:44.21)
// 4615.7-4632.41: (class anchor.sink.Read:44.21)
// 4627.1-4627.34: (44.21): Cannot have potential null deference in left-mover part.
// 4631.1-4631.32: (44.21): Reduction failure
// 4634.7-4655.7: (class anchor.sink.Write:44.21)
// 4646.1-4646.34: (44.21): Cannot have potential null deference in left-mover part.
// 4649.1-4649.32: (44.21): Reduction failure
// 4653.1-4653.64: (44.21): last became shared, but last.next may not be shared.
// 4656.7-4658.7: (class anchor.sink.VarDeclStmt:44.21)
// 4659.7-4662.295: (class anchor.sink.Assign:44.21)
// 4664.7-4685.7: (class anchor.sink.Write:44.21)
// 4676.1-4676.34: (44.21): Cannot have potential null deference in left-mover part.
// 4679.1-4679.32: (44.21): Reduction failure
// 4683.1-4683.73: (44.21): _currentValue became shared, but _currentValue.next may not be shared.
// 4686.7-4689.48: (class anchor.sink.Assume:44.21)
// 4692.7-4713.7: (class anchor.sink.Write:44.21)
// 4704.1-4704.34: (44.21): Cannot have potential null deference in left-mover part.
// 4707.1-4707.32: (44.21): Reduction failure
// 4711.1-4711.61: (44.21): n became shared, but n.next may not be shared.
// 4714.7-4717.21: (class anchor.sink.Assign:44.21)
// 4720.5-4727.12: (class anchor.sink.Return:45.21)
// 4725.1-4725.381: (45.21): Object invariant may not hold.
// 4726.1-4726.381: (45.21): Object invariant may not hold.
// 4731.4-4733.4: (class anchor.sink.VarDeclStmt:48.18)
// 4735.4-4737.4: (class anchor.sink.VarDeclStmt:48.18)
// 4738.4-4741.22: (class anchor.sink.Assign:48.18)
// 4744.5-4747.19: (class anchor.sink.Assign:48.18)
// 4749.5-4752.23: (class anchor.sink.Assign:48.18)
// 4754.6-4756.6: (class anchor.sink.VarDeclStmt:48.18)
// 4757.6-4759.6: (class anchor.sink.VarDeclStmt:48.18)
// 4760.6-4762.6: (class anchor.sink.VarDeclStmt:48.18)
// 4763.6-4766.297: (class anchor.sink.Assign:48.18)
// 4767.6-4770.38: (class anchor.sink.Assume:48.18)
// 4771.6-4774.50: (class anchor.sink.Assume:48.18)
// 4775.6-4778.48: (class anchor.sink.Assume:48.18)
// 4779.6-4782.48: (class anchor.sink.Assume:48.18)
// 4784.6-4800.44: (class anchor.sink.Write:48.18)
// 4796.1-4796.33: (48.18): Cannot have potential null deference in left-mover part.
// 4799.1-4799.31: (48.18): Reduction failure
// 4802.6-4818.45: (class anchor.sink.Write:48.18)
// 4814.1-4814.33: (48.18): Cannot have potential null deference in left-mover part.
// 4817.1-4817.31: (48.18): Reduction failure
// 4821.6-4842.6: (class anchor.sink.Write:48.18)
// 4833.1-4833.33: (48.18): Cannot have potential null deference in left-mover part.
// 4836.1-4836.31: (48.18): Reduction failure
// 4840.1-4840.63: (48.18): next became shared, but next.next may not be shared.
// 4843.6-4846.19: (class anchor.sink.Assign:48.18)
// 4848.6-4851.48: (class anchor.sink.Assume:48.18)
// 4852.6-4855.48: (class anchor.sink.Assume:48.18)
// 4856.6-4858.6: (class anchor.sink.VarDeclStmt:48.18)
// 4859.6-4876.40: (class anchor.sink.Read:48.18)
// 4871.1-4871.33: (48.18): Cannot have potential null deference in left-mover part.
// 4875.1-4875.31: (48.18): Reduction failure
// 4878.6-4899.6: (class anchor.sink.Write:48.18)
// 4890.1-4890.33: (48.18): Cannot have potential null deference in left-mover part.
// 4893.1-4893.31: (48.18): Reduction failure
// 4897.1-4897.63: (48.18): last became shared, but last.next may not be shared.
// 4900.6-4902.6: (class anchor.sink.VarDeclStmt:48.18)
// 4903.6-4906.297: (class anchor.sink.Assign:48.18)
// 4908.6-4929.6: (class anchor.sink.Write:48.18)
// 4920.1-4920.33: (48.18): Cannot have potential null deference in left-mover part.
// 4923.1-4923.31: (48.18): Reduction failure
// 4927.1-4927.72: (48.18): _currentValue became shared, but _currentValue.next may not be shared.
// 4930.6-4933.47: (class anchor.sink.Assume:48.18)
// 4936.6-4957.6: (class anchor.sink.Write:48.18)
// 4948.1-4948.33: (48.18): Cannot have potential null deference in left-mover part.
// 4951.1-4951.31: (48.18): Reduction failure
// 4955.1-4955.63: (48.18): next became shared, but next.next may not be shared.
// 4958.6-4961.20: (class anchor.sink.Assign:48.18)
// 4965.3-4977.43: (class anchor.sink.Yield:50.13)
// 4970.1-4970.379: (50.13): Object invariant may not hold.
// 4971.1-4971.379: (50.13): Object invariant may not hold.
// 4973.1-4973.379: (50.13): Object invariant may not hold.
// 4974.1-4974.379: (50.13): Object invariant may not hold.
// 4980.1-4980.30: (33.9): Phase must be invariant at loop head
// 4982.2-4989.9: (class anchor.sink.Return:31.36)
// 4987.1-4987.378: (31.36): Object invariant may not hold.
// 4988.1-4988.378: (31.36): Object invariant may not hold.
// 4991.1-7327.2: (Method:54.5)
// 5010.1-5010.24: (54.5): Bad tid
// 5011.1-5011.39: (54.5): this is not global
// 5014.1-5014.379: (54.5): Object invariant may not hold.
// 5015.1-5015.379: (54.5): Object invariant may not hold.
// 5018.1-5018.378: (54.5): Object invariant may not hold.
// 5019.1-5019.378: (54.5): Object invariant may not hold.
// 6305.2-6309.14: (class anchor.sink.While:55.9)
// 6311.1-6311.27: (54.5): Bad tid
// 6312.1-6312.42: (54.5): this is not global
// 6315.1-6315.382: (55.9): Object invariant may not hold.
// 6316.1-6316.382: (55.9): Object invariant may not hold.
// 6317.1-6317.415: (55.9): Loop does not preserve yields_as annotation for field value
// 6318.1-6318.413: (55.9): Loop does not preserve yields_as annotation for field next
// 6319.1-6319.416: (55.9): Loop does not preserve yields_as annotation for field head
// 6320.1-6320.416: (55.9): Loop does not preserve yields_as annotation for field tail
// 6321.1-6321.33: (55.9): Phase must be invariant at loop head
// 6322.1-6322.30: (55.9): Potentially infinite loop cannot be in post-commit phase.
// 6324.3-6326.3: (class anchor.sink.VarDeclStmt:55.15)
// 6327.3-6330.16: (class anchor.sink.Assign:55.15)
// 6332.4-6335.10: (class anchor.sink.Break:55.9)
// 6338.3-6340.3: (class anchor.sink.VarDeclStmt:57.13)
// 6342.3-6344.3: (class anchor.sink.VarDeclStmt:57.13)
// 6345.3-6362.39: (class anchor.sink.Read:57.13)
// 6357.1-6357.30: (57.13): Cannot have potential null deference in left-mover part.
// 6361.1-6361.28: (57.13): Reduction failure
// 6363.3-6365.3: (class anchor.sink.VarDeclStmt:57.13)
// 6366.3-6383.38: (class anchor.sink.Read:57.13)
// 6378.1-6378.30: (57.13): Cannot have potential null deference in left-mover part.
// 6382.1-6382.28: (57.13): Reduction failure
// 6384.3-6386.3: (class anchor.sink.VarDeclStmt:57.13)
// 6387.3-6404.37: (class anchor.sink.Read:57.13)
// 6399.1-6399.30: (57.13): Cannot have potential null deference in left-mover part.
// 6403.1-6403.28: (57.13): Reduction failure
// 6405.3-6407.3: (class anchor.sink.VarDeclStmt:57.13)
// 6408.3-6411.284: (class anchor.sink.Assign:57.13)
// 6412.3-6414.3: (class anchor.sink.VarDeclStmt:57.13)
// 6415.3-6418.75: (class anchor.sink.Assign:57.13)
// 6421.4-6438.30: (class anchor.sink.Read:57.13)
// 6433.1-6433.31: (57.13): Cannot have potential null deference in left-mover part.
// 6437.1-6437.29: (57.13): Reduction failure
// 6441.4-6458.30: (class anchor.sink.Read:57.13)
// 6453.1-6453.31: (57.13): Cannot have potential null deference in left-mover part.
// 6457.1-6457.29: (57.13): Reduction failure
// 6460.3-6472.43: (class anchor.sink.Yield:58.13)
// 6465.1-6465.379: (58.13): Object invariant may not hold.
// 6466.1-6466.379: (58.13): Object invariant may not hold.
// 6468.1-6468.379: (58.13): Object invariant may not hold.
// 6469.1-6469.379: (58.13): Object invariant may not hold.
// 6473.3-6475.3: (class anchor.sink.VarDeclStmt:59.13)
// 6477.3-6479.3: (class anchor.sink.VarDeclStmt:59.13)
// 6480.3-6497.39: (class anchor.sink.Read:59.13)
// 6492.1-6492.30: (59.13): Cannot have potential null deference in left-mover part.
// 6496.1-6496.28: (59.13): Reduction failure
// 6498.3-6500.3: (class anchor.sink.VarDeclStmt:59.13)
// 6501.3-6518.38: (class anchor.sink.Read:59.13)
// 6513.1-6513.30: (59.13): Cannot have potential null deference in left-mover part.
// 6517.1-6517.28: (59.13): Reduction failure
// 6519.3-6521.3: (class anchor.sink.VarDeclStmt:59.13)
// 6522.3-6539.37: (class anchor.sink.Read:59.13)
// 6534.1-6534.30: (59.13): Cannot have potential null deference in left-mover part.
// 6538.1-6538.28: (59.13): Reduction failure
// 6540.3-6542.3: (class anchor.sink.VarDeclStmt:59.13)
// 6543.3-6546.283: (class anchor.sink.Assign:59.13)
// 6547.3-6549.3: (class anchor.sink.VarDeclStmt:59.13)
// 6550.3-6553.75: (class anchor.sink.Assign:59.13)
// 6556.4-6573.29: (class anchor.sink.Read:59.13)
// 6568.1-6568.31: (59.13): Cannot have potential null deference in left-mover part.
// 6572.1-6572.29: (59.13): Reduction failure
// 6576.4-6593.29: (class anchor.sink.Read:59.13)
// 6588.1-6588.31: (59.13): Cannot have potential null deference in left-mover part.
// 6592.1-6592.29: (59.13): Reduction failure
// 6595.3-6607.43: (class anchor.sink.Yield:60.13)
// 6600.1-6600.379: (60.13): Object invariant may not hold.
// 6601.1-6601.379: (60.13): Object invariant may not hold.
// 6603.1-6603.379: (60.13): Object invariant may not hold.
// 6604.1-6604.379: (60.13): Object invariant may not hold.
// 6608.3-6610.3: (class anchor.sink.VarDeclStmt:61.13)
// 6612.3-6614.3: (class anchor.sink.VarDeclStmt:61.13)
// 6615.3-6632.39: (class anchor.sink.Read:61.13)
// 6627.1-6627.30: (61.13): Cannot have potential null deference in left-mover part.
// 6631.1-6631.28: (61.13): Reduction failure
// 6633.3-6635.3: (class anchor.sink.VarDeclStmt:61.13)
// 6636.3-6653.38: (class anchor.sink.Read:61.13)
// 6648.1-6648.30: (61.13): Cannot have potential null deference in left-mover part.
// 6652.1-6652.28: (61.13): Reduction failure
// 6654.3-6656.3: (class anchor.sink.VarDeclStmt:61.13)
// 6657.3-6674.37: (class anchor.sink.Read:61.13)
// 6669.1-6669.30: (61.13): Cannot have potential null deference in left-mover part.
// 6673.1-6673.28: (61.13): Reduction failure
// 6675.3-6677.3: (class anchor.sink.VarDeclStmt:61.13)
// 6678.3-6681.284: (class anchor.sink.Assign:61.13)
// 6682.3-6684.3: (class anchor.sink.VarDeclStmt:61.13)
// 6685.3-6688.75: (class anchor.sink.Assign:61.13)
// 6691.4-6708.29: (class anchor.sink.Read:61.13)
// 6703.1-6703.31: (61.13): Cannot have potential null deference in left-mover part.
// 6707.1-6707.29: (61.13): Reduction failure
// 6711.4-6728.29: (class anchor.sink.Read:61.13)
// 6723.1-6723.31: (61.13): Cannot have potential null deference in left-mover part.
// 6727.1-6727.29: (61.13): Reduction failure
// 6730.3-6732.3: (class anchor.sink.VarDeclStmt:62.13)
// 6733.3-6736.25: (class anchor.sink.Assign:62.13)
// 6738.4-6740.4: (class anchor.sink.VarDeclStmt:63.17)
// 6741.4-6744.30: (class anchor.sink.Assign:63.17)
// 6746.5-6748.5: (class anchor.sink.VarDeclStmt:64.18)
// 6749.5-6752.18: (class anchor.sink.Assign:64.18)
// 6753.5-6761.12: (class anchor.sink.Return:64.18)
// 6759.1-6759.381: (64.18): Object invariant may not hold.
// 6760.1-6760.381: (64.18): Object invariant may not hold.
// 6763.5-6775.45: (class anchor.sink.Yield:66.18)
// 6768.1-6768.381: (66.18): Object invariant may not hold.
// 6769.1-6769.381: (66.18): Object invariant may not hold.
// 6771.1-6771.381: (66.18): Object invariant may not hold.
// 6772.1-6772.381: (66.18): Object invariant may not hold.
// 6776.5-6778.5: (class anchor.sink.VarDeclStmt:67.18)
// 6780.5-6782.5: (class anchor.sink.VarDeclStmt:67.18)
// 6783.5-6786.23: (class anchor.sink.Assign:67.18)
// 6789.6-6792.21: (class anchor.sink.Assign:67.18)
// 6794.6-6797.24: (class anchor.sink.Assign:67.18)
// 6799.7-6801.7: (class anchor.sink.VarDeclStmt:67.18)
// 6802.7-6804.7: (class anchor.sink.VarDeclStmt:67.18)
// 6805.7-6807.7: (class anchor.sink.VarDeclStmt:67.18)
// 6808.7-6811.298: (class anchor.sink.Assign:67.18)
// 6812.7-6815.39: (class anchor.sink.Assume:67.18)
// 6816.7-6819.51: (class anchor.sink.Assume:67.18)
// 6820.7-6823.49: (class anchor.sink.Assume:67.18)
// 6824.7-6827.49: (class anchor.sink.Assume:67.18)
// 6829.7-6845.45: (class anchor.sink.Write:67.18)
// 6841.1-6841.34: (67.18): Cannot have potential null deference in left-mover part.
// 6844.1-6844.32: (67.18): Reduction failure
// 6847.7-6863.46: (class anchor.sink.Write:67.18)
// 6859.1-6859.34: (67.18): Cannot have potential null deference in left-mover part.
// 6862.1-6862.32: (67.18): Reduction failure
// 6866.7-6887.7: (class anchor.sink.Write:67.18)
// 6878.1-6878.34: (67.18): Cannot have potential null deference in left-mover part.
// 6881.1-6881.32: (67.18): Reduction failure
// 6885.1-6885.64: (67.18): next became shared, but next.next may not be shared.
// 6888.7-6891.21: (class anchor.sink.Assign:67.18)
// 6893.7-6896.49: (class anchor.sink.Assume:67.18)
// 6897.7-6900.49: (class anchor.sink.Assume:67.18)
// 6901.7-6903.7: (class anchor.sink.VarDeclStmt:67.18)
// 6904.7-6921.41: (class anchor.sink.Read:67.18)
// 6916.1-6916.34: (67.18): Cannot have potential null deference in left-mover part.
// 6920.1-6920.32: (67.18): Reduction failure
// 6923.7-6944.7: (class anchor.sink.Write:67.18)
// 6935.1-6935.34: (67.18): Cannot have potential null deference in left-mover part.
// 6938.1-6938.32: (67.18): Reduction failure
// 6942.1-6942.64: (67.18): last became shared, but last.next may not be shared.
// 6945.7-6947.7: (class anchor.sink.VarDeclStmt:67.18)
// 6948.7-6951.298: (class anchor.sink.Assign:67.18)
// 6953.7-6974.7: (class anchor.sink.Write:67.18)
// 6965.1-6965.34: (67.18): Cannot have potential null deference in left-mover part.
// 6968.1-6968.32: (67.18): Reduction failure
// 6972.1-6972.73: (67.18): _currentValue became shared, but _currentValue.next may not be shared.
// 6975.7-6978.48: (class anchor.sink.Assume:67.18)
// 6981.7-7002.7: (class anchor.sink.Write:67.18)
// 6993.1-6993.34: (67.18): Cannot have potential null deference in left-mover part.
// 6996.1-6996.32: (67.18): Reduction failure
// 7000.1-7000.64: (67.18): next became shared, but next.next may not be shared.
// 7003.7-7006.22: (class anchor.sink.Assign:67.18)
// 7011.4-7013.4: (class anchor.sink.VarDeclStmt:70.17)
// 7014.4-7017.31: (class anchor.sink.Assign:70.17)
// 7019.5-7021.5: (class anchor.sink.VarDeclStmt:71.21)
// 7022.5-7039.31: (class anchor.sink.Read:71.21)
// 7034.1-7034.31: (71.21): Cannot have potential null deference in left-mover part.
// 7038.1-7038.30: (71.21): Reduction failure
// 7040.5-7052.45: (class anchor.sink.Yield:72.21)
// 7045.1-7045.381: (72.21): Object invariant may not hold.
// 7046.1-7046.381: (72.21): Object invariant may not hold.
// 7048.1-7048.381: (72.21): Object invariant may not hold.
// 7049.1-7049.381: (72.21): Object invariant may not hold.
// 7053.5-7055.5: (class anchor.sink.VarDeclStmt:73.21)
// 7057.5-7059.5: (class anchor.sink.VarDeclStmt:73.21)
// 7060.5-7063.23: (class anchor.sink.Assign:73.21)
// 7066.6-7069.21: (class anchor.sink.Assign:73.21)
// 7071.6-7074.24: (class anchor.sink.Assign:73.21)
// 7076.7-7078.7: (class anchor.sink.VarDeclStmt:73.21)
// 7079.7-7081.7: (class anchor.sink.VarDeclStmt:73.21)
// 7082.7-7084.7: (class anchor.sink.VarDeclStmt:73.21)
// 7085.7-7088.298: (class anchor.sink.Assign:73.21)
// 7089.7-7092.40: (class anchor.sink.Assume:73.21)
// 7093.7-7096.51: (class anchor.sink.Assume:73.21)
// 7097.7-7100.49: (class anchor.sink.Assume:73.21)
// 7101.7-7104.50: (class anchor.sink.Assume:73.21)
// 7106.7-7122.45: (class anchor.sink.Write:73.21)
// 7118.1-7118.34: (73.21): Cannot have potential null deference in left-mover part.
// 7121.1-7121.32: (73.21): Reduction failure
// 7124.7-7140.46: (class anchor.sink.Write:73.21)
// 7136.1-7136.34: (73.21): Cannot have potential null deference in left-mover part.
// 7139.1-7139.32: (73.21): Reduction failure
// 7143.7-7164.7: (class anchor.sink.Write:73.21)
// 7155.1-7155.34: (73.21): Cannot have potential null deference in left-mover part.
// 7158.1-7158.32: (73.21): Reduction failure
// 7162.1-7162.64: (73.21): next became shared, but next.next may not be shared.
// 7165.7-7168.21: (class anchor.sink.Assign:73.21)
// 7170.7-7173.49: (class anchor.sink.Assume:73.21)
// 7174.7-7177.50: (class anchor.sink.Assume:73.21)
// 7178.7-7180.7: (class anchor.sink.VarDeclStmt:73.21)
// 7181.7-7198.41: (class anchor.sink.Read:73.21)
// 7193.1-7193.34: (73.21): Cannot have potential null deference in left-mover part.
// 7197.1-7197.32: (73.21): Reduction failure
// 7200.7-7221.7: (class anchor.sink.Write:73.21)
// 7212.1-7212.34: (73.21): Cannot have potential null deference in left-mover part.
// 7215.1-7215.32: (73.21): Reduction failure
// 7219.1-7219.65: (73.21): first became shared, but first.next may not be shared.
// 7222.7-7224.7: (class anchor.sink.VarDeclStmt:73.21)
// 7225.7-7228.298: (class anchor.sink.Assign:73.21)
// 7230.7-7251.7: (class anchor.sink.Write:73.21)
// 7242.1-7242.34: (73.21): Cannot have potential null deference in left-mover part.
// 7245.1-7245.32: (73.21): Reduction failure
// 7249.1-7249.73: (73.21): _currentValue became shared, but _currentValue.next may not be shared.
// 7252.7-7255.48: (class anchor.sink.Assume:73.21)
// 7258.7-7279.7: (class anchor.sink.Write:73.21)
// 7270.1-7270.34: (73.21): Cannot have potential null deference in left-mover part.
// 7273.1-7273.32: (73.21): Reduction failure
// 7277.1-7277.64: (73.21): next became shared, but next.next may not be shared.
// 7280.7-7283.22: (class anchor.sink.Assign:73.21)
// 7287.6-7295.13: (class anchor.sink.Return:74.25)
// 7293.1-7293.382: (74.25): Object invariant may not hold.
// 7294.1-7294.382: (74.25): Object invariant may not hold.
// 7301.3-7313.43: (class anchor.sink.Yield:78.13)
// 7306.1-7306.379: (78.13): Object invariant may not hold.
// 7307.1-7307.379: (78.13): Object invariant may not hold.
// 7309.1-7309.379: (78.13): Object invariant may not hold.
// 7310.1-7310.379: (78.13): Object invariant may not hold.
// 7316.1-7316.30: (55.9): Phase must be invariant at loop head
// 7318.2-7326.9: (class anchor.sink.Return:54.26)
// 7324.1-7324.378: (54.26): Object invariant may not hold.
// 7325.1-7325.378: (54.26): Object invariant may not hold.
// 7430.1-7430.34: (3.5): Node.value failed Write-Write Right-Mover Check
// 7509.1-7509.30: (3.5): Node.value failed Write-Read Right-Mover Check
// 7592.1-7592.34: (3.5): Node.value failed Write-Write Left-Mover Check
// 7672.1-7672.30: (3.5): Node.value failed Write-Read Left-Mover Check
// 7749.1-7749.34: (3.5): Node.value failed Read-Write Right-Mover Check
// 7829.1-7829.34: (3.5): Node.value failed Read-Write Left-Mover Check
// 7908.1-7908.34: (4.5): Node.next failed Write-Write Right-Mover Check
// 7987.1-7987.30: (4.5): Node.next failed Write-Read Right-Mover Check
// 8070.1-8070.34: (4.5): Node.next failed Write-Write Left-Mover Check
// 8150.1-8150.30: (4.5): Node.next failed Write-Read Left-Mover Check
// 8227.1-8227.34: (4.5): Node.next failed Read-Write Right-Mover Check
// 8307.1-8307.34: (4.5): Node.next failed Read-Write Left-Mover Check
// 8386.1-8386.34: (18.5): Queue.head failed Write-Write Right-Mover Check
// 8465.1-8465.30: (18.5): Queue.head failed Write-Read Right-Mover Check
// 8548.1-8548.34: (18.5): Queue.head failed Write-Write Left-Mover Check
// 8628.1-8628.30: (18.5): Queue.head failed Write-Read Left-Mover Check
// 8705.1-8705.34: (18.5): Queue.head failed Read-Write Right-Mover Check
// 8785.1-8785.34: (18.5): Queue.head failed Read-Write Left-Mover Check
// 8864.1-8864.34: (19.5): Queue.tail failed Write-Write Right-Mover Check
// 8943.1-8943.30: (19.5): Queue.tail failed Write-Read Right-Mover Check
// 9026.1-9026.34: (19.5): Queue.tail failed Write-Write Left-Mover Check
// 9106.1-9106.30: (19.5): Queue.tail failed Write-Read Left-Mover Check
// 9183.1-9183.34: (19.5): Queue.tail failed Read-Write Right-Mover Check
// 9263.1-9263.34: (19.5): Queue.tail failed Read-Write Left-Mover Check
// 9354.1-9354.140: (3.5): Node.value is not Write-Write Stable with respect to Node.value (case A.1)
// 9355.1-9355.101: (3.5): Node.value is not Write-Write Stable with respect to Node.value (case A.2)
// 9356.1-9356.158: (3.5): Node.value is not Write-Write Stable with respect to Node.value (case A.3)
// 9482.1-9482.140: (3.5): Node.value is not Write-Write Stable with respect to Node.value (case C)
// 9613.1-9613.144: (3.5): Node.value is not Write-Write Stable with respect to Node.value (case D)
// 9614.1-9614.144: (3.5): Node.value is not Write-Write Stable with respect to Node.value (case R)
// 9705.1-9705.136: (3.5): Node.value is not Read-Write Stable with respect to Node.value (case F)
// 9706.1-9706.136: (3.5): Node.value is not Read-Write Stable with respect to Node.value (case H)
// 9707.1-9707.146: (3.5): Node.value is not Read-Write Stable with respect to Node.value (case I)
// 9797.1-9797.136: (3.5): Node.value is not Write-Read Stable with respect to Node.value (case J)
// 9798.1-9798.136: (3.5): Node.value is not Write-Read Stable with respect to Node.value (case K)
// 9799.1-9799.99: (3.5): Node.value is not Write-Read Stable with respect to Node.value (case L)
// 9891.1-9891.140: (4.5): Node.next is not Write-Write Stable with respect to Node.value (case A.1)
// 9892.1-9892.101: (4.5): Node.next is not Write-Write Stable with respect to Node.value (case A.2)
// 9893.1-9893.158: (4.5): Node.next is not Write-Write Stable with respect to Node.value (case A.3)
// 10019.1-10019.140: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case C)
// 10150.1-10150.144: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case D)
// 10151.1-10151.144: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case R)
// 10242.1-10242.136: (3.5): Node.value is not Read-Write Stable with respect to Node.next (case F)
// 10243.1-10243.136: (3.5): Node.value is not Read-Write Stable with respect to Node.next (case H)
// 10244.1-10244.146: (3.5): Node.value is not Read-Write Stable with respect to Node.next (case I)
// 10334.1-10334.136: (4.5): Node.next is not Write-Read Stable with respect to Node.value (case J)
// 10335.1-10335.136: (4.5): Node.next is not Write-Read Stable with respect to Node.value (case K)
// 10336.1-10336.99: (4.5): Node.next is not Write-Read Stable with respect to Node.value (case L)
// 10428.1-10428.140: (18.5): Queue.head is not Write-Write Stable with respect to Node.value (case A.1)
// 10429.1-10429.101: (18.5): Queue.head is not Write-Write Stable with respect to Node.value (case A.2)
// 10430.1-10430.156: (18.5): Queue.head is not Write-Write Stable with respect to Node.value (case A.3)
// 10556.1-10556.140: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case C)
// 10687.1-10687.144: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case D)
// 10688.1-10688.144: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case R)
// 10779.1-10779.136: (3.5): Node.value is not Read-Write Stable with respect to Queue.head (case F)
// 10780.1-10780.136: (3.5): Node.value is not Read-Write Stable with respect to Queue.head (case H)
// 10781.1-10781.144: (3.5): Node.value is not Read-Write Stable with respect to Queue.head (case I)
// 10871.1-10871.136: (18.5): Queue.head is not Write-Read Stable with respect to Node.value (case J)
// 10872.1-10872.136: (18.5): Queue.head is not Write-Read Stable with respect to Node.value (case K)
// 10873.1-10873.99: (18.5): Queue.head is not Write-Read Stable with respect to Node.value (case L)
// 10965.1-10965.140: (19.5): Queue.tail is not Write-Write Stable with respect to Node.value (case A.1)
// 10966.1-10966.101: (19.5): Queue.tail is not Write-Write Stable with respect to Node.value (case A.2)
// 10967.1-10967.156: (19.5): Queue.tail is not Write-Write Stable with respect to Node.value (case A.3)
// 11093.1-11093.140: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case C)
// 11224.1-11224.144: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case D)
// 11225.1-11225.144: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case R)
// 11316.1-11316.136: (3.5): Node.value is not Read-Write Stable with respect to Queue.tail (case F)
// 11317.1-11317.136: (3.5): Node.value is not Read-Write Stable with respect to Queue.tail (case H)
// 11318.1-11318.144: (3.5): Node.value is not Read-Write Stable with respect to Queue.tail (case I)
// 11408.1-11408.136: (19.5): Queue.tail is not Write-Read Stable with respect to Node.value (case J)
// 11409.1-11409.136: (19.5): Queue.tail is not Write-Read Stable with respect to Node.value (case K)
// 11410.1-11410.99: (19.5): Queue.tail is not Write-Read Stable with respect to Node.value (case L)
// 11502.1-11502.140: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case A.1)
// 11503.1-11503.101: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case A.2)
// 11504.1-11504.158: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case A.3)
// 11630.1-11630.140: (4.5): Node.next is not Write-Write Stable with respect to Node.value (case C)
// 11761.1-11761.144: (4.5): Node.next is not Write-Write Stable with respect to Node.value (case D)
// 11762.1-11762.144: (4.5): Node.next is not Write-Write Stable with respect to Node.value (case R)
// 11853.1-11853.136: (4.5): Node.next is not Read-Write Stable with respect to Node.value (case F)
// 11854.1-11854.136: (4.5): Node.next is not Read-Write Stable with respect to Node.value (case H)
// 11855.1-11855.146: (4.5): Node.next is not Read-Write Stable with respect to Node.value (case I)
// 11945.1-11945.136: (3.5): Node.value is not Write-Read Stable with respect to Node.next (case J)
// 11946.1-11946.136: (3.5): Node.value is not Write-Read Stable with respect to Node.next (case K)
// 11947.1-11947.99: (3.5): Node.value is not Write-Read Stable with respect to Node.next (case L)
// 12083.1-12083.142: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case M)
// 12217.1-12217.130: (3.5): Node.value is not Write-Write Stable with respect to Node.next (case N)
// 12310.1-12310.140: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
// 12311.1-12311.101: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
// 12312.1-12312.158: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
// 12438.1-12438.140: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
// 12569.1-12569.144: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
// 12570.1-12570.144: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
// 12661.1-12661.136: (4.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
// 12662.1-12662.136: (4.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
// 12663.1-12663.146: (4.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
// 12753.1-12753.136: (4.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
// 12754.1-12754.136: (4.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
// 12755.1-12755.99: (4.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
// 12891.1-12891.142: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case M)
// 13025.1-13025.130: (4.5): Node.next is not Write-Write Stable with respect to Node.next (case N)
// 13118.1-13118.140: (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case A.1)
// 13119.1-13119.101: (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case A.2)
// 13120.1-13120.156: (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case A.3)
// 13246.1-13246.140: (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case C)
// 13377.1-13377.144: (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case D)
// 13378.1-13378.144: (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case R)
// 13469.1-13469.136: (4.5): Node.next is not Read-Write Stable with respect to Queue.head (case F)
// 13470.1-13470.136: (4.5): Node.next is not Read-Write Stable with respect to Queue.head (case H)
// 13471.1-13471.144: (4.5): Node.next is not Read-Write Stable with respect to Queue.head (case I)
// 13561.1-13561.136: (18.5): Queue.head is not Write-Read Stable with respect to Node.next (case J)
// 13562.1-13562.136: (18.5): Queue.head is not Write-Read Stable with respect to Node.next (case K)
// 13563.1-13563.99: (18.5): Queue.head is not Write-Read Stable with respect to Node.next (case L)
// 13699.1-13699.142: (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case M)
// 13833.1-13833.130: (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case N)
// 13926.1-13926.140: (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case A.1)
// 13927.1-13927.101: (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case A.2)
// 13928.1-13928.156: (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case A.3)
// 14054.1-14054.140: (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case C)
// 14185.1-14185.144: (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case D)
// 14186.1-14186.144: (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case R)
// 14277.1-14277.136: (4.5): Node.next is not Read-Write Stable with respect to Queue.tail (case F)
// 14278.1-14278.136: (4.5): Node.next is not Read-Write Stable with respect to Queue.tail (case H)
// 14279.1-14279.144: (4.5): Node.next is not Read-Write Stable with respect to Queue.tail (case I)
// 14369.1-14369.136: (19.5): Queue.tail is not Write-Read Stable with respect to Node.next (case J)
// 14370.1-14370.136: (19.5): Queue.tail is not Write-Read Stable with respect to Node.next (case K)
// 14371.1-14371.99: (19.5): Queue.tail is not Write-Read Stable with respect to Node.next (case L)
// 14507.1-14507.142: (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case M)
// 14641.1-14641.130: (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case N)
// 14734.1-14734.140: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case A.1)
// 14735.1-14735.101: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case A.2)
// 14736.1-14736.156: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case A.3)
// 14862.1-14862.140: (18.5): Queue.head is not Write-Write Stable with respect to Node.value (case C)
// 14993.1-14993.144: (18.5): Queue.head is not Write-Write Stable with respect to Node.value (case D)
// 14994.1-14994.144: (18.5): Queue.head is not Write-Write Stable with respect to Node.value (case R)
// 15085.1-15085.136: (18.5): Queue.head is not Read-Write Stable with respect to Node.value (case F)
// 15086.1-15086.136: (18.5): Queue.head is not Read-Write Stable with respect to Node.value (case H)
// 15087.1-15087.144: (18.5): Queue.head is not Read-Write Stable with respect to Node.value (case I)
// 15177.1-15177.136: (3.5): Node.value is not Write-Read Stable with respect to Queue.head (case J)
// 15178.1-15178.136: (3.5): Node.value is not Write-Read Stable with respect to Queue.head (case K)
// 15179.1-15179.99: (3.5): Node.value is not Write-Read Stable with respect to Queue.head (case L)
// 15315.1-15315.142: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case M)
// 15449.1-15449.130: (3.5): Node.value is not Write-Write Stable with respect to Queue.head (case N)
// 15542.1-15542.140: (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case A.1)
// 15543.1-15543.101: (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case A.2)
// 15544.1-15544.156: (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case A.3)
// 15670.1-15670.140: (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case C)
// 15801.1-15801.144: (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case D)
// 15802.1-15802.144: (18.5): Queue.head is not Write-Write Stable with respect to Node.next (case R)
// 15893.1-15893.136: (18.5): Queue.head is not Read-Write Stable with respect to Node.next (case F)
// 15894.1-15894.136: (18.5): Queue.head is not Read-Write Stable with respect to Node.next (case H)
// 15895.1-15895.144: (18.5): Queue.head is not Read-Write Stable with respect to Node.next (case I)
// 15985.1-15985.136: (4.5): Node.next is not Write-Read Stable with respect to Queue.head (case J)
// 15986.1-15986.136: (4.5): Node.next is not Write-Read Stable with respect to Queue.head (case K)
// 15987.1-15987.99: (4.5): Node.next is not Write-Read Stable with respect to Queue.head (case L)
// 16123.1-16123.142: (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case M)
// 16257.1-16257.130: (4.5): Node.next is not Write-Write Stable with respect to Queue.head (case N)
// 16350.1-16350.140: (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.1)
// 16351.1-16351.101: (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.2)
// 16352.1-16352.158: (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.3)
// 16478.1-16478.140: (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case C)
// 16609.1-16609.144: (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case D)
// 16610.1-16610.144: (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case R)
// 16701.1-16701.136: (18.5): Queue.head is not Read-Write Stable with respect to Queue.head (case F)
// 16702.1-16702.136: (18.5): Queue.head is not Read-Write Stable with respect to Queue.head (case H)
// 16703.1-16703.146: (18.5): Queue.head is not Read-Write Stable with respect to Queue.head (case I)
// 16793.1-16793.136: (18.5): Queue.head is not Write-Read Stable with respect to Queue.head (case J)
// 16794.1-16794.136: (18.5): Queue.head is not Write-Read Stable with respect to Queue.head (case K)
// 16795.1-16795.99: (18.5): Queue.head is not Write-Read Stable with respect to Queue.head (case L)
// 16931.1-16931.142: (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case M)
// 17065.1-17065.130: (18.5): Queue.head is not Write-Write Stable with respect to Queue.head (case N)
// 17158.1-17158.140: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.1)
// 17159.1-17159.101: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.2)
// 17160.1-17160.158: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.3)
// 17286.1-17286.140: (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case C)
// 17417.1-17417.144: (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case D)
// 17418.1-17418.144: (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case R)
// 17509.1-17509.136: (18.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case F)
// 17510.1-17510.136: (18.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case H)
// 17511.1-17511.146: (18.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case I)
// 17601.1-17601.136: (19.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case J)
// 17602.1-17602.136: (19.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case K)
// 17603.1-17603.99: (19.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case L)
// 17739.1-17739.142: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case M)
// 17873.1-17873.130: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case N)
// 17966.1-17966.140: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case A.1)
// 17967.1-17967.101: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case A.2)
// 17968.1-17968.156: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case A.3)
// 18094.1-18094.140: (19.5): Queue.tail is not Write-Write Stable with respect to Node.value (case C)
// 18225.1-18225.144: (19.5): Queue.tail is not Write-Write Stable with respect to Node.value (case D)
// 18226.1-18226.144: (19.5): Queue.tail is not Write-Write Stable with respect to Node.value (case R)
// 18317.1-18317.136: (19.5): Queue.tail is not Read-Write Stable with respect to Node.value (case F)
// 18318.1-18318.136: (19.5): Queue.tail is not Read-Write Stable with respect to Node.value (case H)
// 18319.1-18319.144: (19.5): Queue.tail is not Read-Write Stable with respect to Node.value (case I)
// 18409.1-18409.136: (3.5): Node.value is not Write-Read Stable with respect to Queue.tail (case J)
// 18410.1-18410.136: (3.5): Node.value is not Write-Read Stable with respect to Queue.tail (case K)
// 18411.1-18411.99: (3.5): Node.value is not Write-Read Stable with respect to Queue.tail (case L)
// 18547.1-18547.142: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case M)
// 18681.1-18681.130: (3.5): Node.value is not Write-Write Stable with respect to Queue.tail (case N)
// 18774.1-18774.140: (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case A.1)
// 18775.1-18775.101: (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case A.2)
// 18776.1-18776.156: (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case A.3)
// 18902.1-18902.140: (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case C)
// 19033.1-19033.144: (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case D)
// 19034.1-19034.144: (19.5): Queue.tail is not Write-Write Stable with respect to Node.next (case R)
// 19125.1-19125.136: (19.5): Queue.tail is not Read-Write Stable with respect to Node.next (case F)
// 19126.1-19126.136: (19.5): Queue.tail is not Read-Write Stable with respect to Node.next (case H)
// 19127.1-19127.144: (19.5): Queue.tail is not Read-Write Stable with respect to Node.next (case I)
// 19217.1-19217.136: (4.5): Node.next is not Write-Read Stable with respect to Queue.tail (case J)
// 19218.1-19218.136: (4.5): Node.next is not Write-Read Stable with respect to Queue.tail (case K)
// 19219.1-19219.99: (4.5): Node.next is not Write-Read Stable with respect to Queue.tail (case L)
// 19355.1-19355.142: (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case M)
// 19489.1-19489.130: (4.5): Node.next is not Write-Write Stable with respect to Queue.tail (case N)
// 19582.1-19582.140: (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.1)
// 19583.1-19583.101: (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.2)
// 19584.1-19584.158: (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.3)
// 19710.1-19710.140: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case C)
// 19841.1-19841.144: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case D)
// 19842.1-19842.144: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case R)
// 19933.1-19933.136: (19.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case F)
// 19934.1-19934.136: (19.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case H)
// 19935.1-19935.146: (19.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case I)
// 20025.1-20025.136: (18.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case J)
// 20026.1-20026.136: (18.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case K)
// 20027.1-20027.99: (18.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case L)
// 20163.1-20163.142: (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case M)
// 20297.1-20297.130: (18.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case N)
// 20390.1-20390.140: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.1)
// 20391.1-20391.101: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.2)
// 20392.1-20392.158: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.3)
// 20518.1-20518.140: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case C)
// 20649.1-20649.144: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case D)
// 20650.1-20650.144: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case R)
// 20741.1-20741.136: (19.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case F)
// 20742.1-20742.136: (19.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case H)
// 20743.1-20743.146: (19.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case I)
// 20833.1-20833.136: (19.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case J)
// 20834.1-20834.136: (19.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case K)
// 20835.1-20835.99: (19.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case L)
// 20971.1-20971.142: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case M)
// 21105.1-21105.130: (19.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case N)
// 21113.1-21113.379: (<undefined position>): Object invariant may not hold.
// 21114.1-21114.379: (<undefined position>): Object invariant may not hold.
// 21131.1-21131.378: (<undefined position>): Object invariant may not hold.
// 21132.1-21132.378: (<undefined position>): Object invariant may not hold.
// 21152.1-21182.2: (3.5): yields_as clause for Node.value is not valid
// 21187.1-21212.2: (3.5): yields_as clause for Node.value is not reflexive
// 21218.1-21218.379: (3.25): Object invariant may not hold.
// 21219.1-21219.379: (3.25): Object invariant may not hold.
// 21220.1-21270.2: (3.5): yields_as clause for Node.value is not transitive
// 21290.1-21320.2: (7.42): yields_as clause for Node.next is not valid
// 21325.1-21350.2: (7.42): yields_as clause for Node.next is not reflexive
// 21356.1-21356.379: (4.34): Object invariant may not hold.
// 21357.1-21357.379: (4.34): Object invariant may not hold.
// 21358.1-21408.2: (7.42): yields_as clause for Node.next is not transitive
// 21428.1-21458.2: (7.32): yields_as clause for Node._lock is not valid
// 21463.1-21488.2: (7.32): yields_as clause for Node._lock is not reflexive
// 21494.1-21494.379: (2.1): Object invariant may not hold.
// 21495.1-21495.379: (2.1): Object invariant may not hold.
// 21496.1-21546.2: (7.32): yields_as clause for Node._lock is not transitive
// 21593.1-21623.2: (18.5): yields_as clause for Queue.head is not valid
// 21628.1-21653.2: (18.5): yields_as clause for Queue.head is not reflexive
// 21659.1-21659.379: (18.33): Object invariant may not hold.
// 21660.1-21660.379: (18.33): Object invariant may not hold.
// 21661.1-21711.2: (18.5): yields_as clause for Queue.head is not transitive
// 21730.1-21760.2: (19.5): yields_as clause for Queue.tail is not valid
// 21765.1-21790.2: (19.5): yields_as clause for Queue.tail is not reflexive
// 21796.1-21796.379: (19.33): Object invariant may not hold.
// 21797.1-21797.379: (19.33): Object invariant may not hold.
// 21798.1-21848.2: (19.5): yields_as clause for Queue.tail is not transitive
// 21868.1-21898.2: (7.32): yields_as clause for Queue._lock is not valid
// 21903.1-21928.2: (7.32): yields_as clause for Queue._lock is not reflexive
// 21934.1-21934.379: (16.1): Object invariant may not hold.
// 21935.1-21935.379: (16.1): Object invariant may not hold.
// 21936.1-21986.2: (7.32): yields_as clause for Queue._lock is not transitive
