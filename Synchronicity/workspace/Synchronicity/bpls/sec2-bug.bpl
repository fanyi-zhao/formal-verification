                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/sec2-bug.anchor:                        
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Lock {                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        // return;                                                                                  
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Buffer {                                                                                  
       Lock popLock isRead ? B : E                                                                  
                                                                                                    
       Lock pushLock isRead ? B : E                                                                 
                                                                                                    
      volatile boolean full isRead                                                                  
       ? holds(this.popLock, tid)                                                                   
         ? this.full ? R : N                                                                        
         : holds(this.pushLock, tid)                                                                
           ? this.full ? N : R                                                                      
           : E                                                                                      
       : holds(this, tid) && holds(this.popLock, tid)                                               
         ? this.full && !newValue ? N : E                                                           
         : holds(this, tid) && holds(this.pushLock, tid)                                            
           ? !this.full && newValue ? N : E                                                         
           : E                                                                                      
                                                                                                    
      volatile int data isRead                                                                      
       ? holds(this.popLock, tid) && this.full ? B : E                                              
       : holds(this.pushLock, tid) && holds(this, tid) && !this.full ? B : E                        
                                                                                                    
      invariant  this.popLock != this.pushLock;                                                     
      invariant  this.popLock != Lock.null;                                                         
      invariant  this.pushLock != Lock.null;                                                        
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.popLock == Lock.null;                                                           
        assume this.pushLock == Lock.null;                                                          
        assume this.full == false;                                                                  
        assume this.data == 0;                                                                      
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires !holds(this.popLock, tid);                                                           
      requires !holds(this.pushLock, tid);                                                          
                                                                                                    
      public void push(int x) {                                                                     
        Lock tmp1;                                                                                  
        tmp1 := this.pushLock;                                                                      
        synchronized (tmp1) {                                                                       
          while (true)                                                                              
            invariant holds(this.pushLock, tid);                                                    
            invariant !holds(this.popLock, tid);                                                    
            {                                                                                       
            boolean tmp2;                                                                           
            tmp2 = true;                                                                            
            if (!tmp2) break; else {                                                                
                                                                                                    
            }                                                                                       
            {                                                                                       
              boolean tmp3;                                                                         
              boolean tmp4;                                                                         
              tmp4 := this.full;                                                                    
              tmp3 = !tmp4;                                                                         
              if (tmp3 /* == !this.full */) {                                                       
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              yield;                                                                                
            }                                                                                       
          }                                                                                         
          synchronized (this) {                                                                     
            this.data := x;                                                                         
            boolean tmp5;                                                                           
            tmp5 = true;                                                                            
            this.full := tmp5;                                                                      
          }                                                                                         
        }                                                                                           
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
      requires !holds(this.popLock, tid);                                                           
      requires !holds(this.pushLock, tid);                                                          
                                                                                                    
      public int pop() {                                                                            
        Lock tmp6;                                                                                  
        tmp6 := this.popLock;                                                                       
        synchronized (tmp6) {                                                                       
          while (true)                                                                              
            invariant holds(this.popLock, tid);                                                     
            invariant !holds(this.pushLock, tid);                                                   
            {                                                                                       
            boolean tmp7;                                                                           
            tmp7 = true;                                                                            
            if (!tmp7) break; else {                                                                
                                                                                                    
            }                                                                                       
            {                                                                                       
              boolean tmp8;                                                                         
              tmp8 := this.full;                                                                    
              if (tmp8 /* == this.full */) {                                                        
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              yield;                                                                                
            }                                                                                       
          }                                                                                         
          synchronized (this) {                                                                     
            int result;                                                                             
            result := this.data;                                                                    
            boolean tmp9;                                                                           
            tmp9 = false;                                                                           
            this.full := tmp9;                                                                      
             return result;                                                                         
          }                                                                                         
        }                                                                                           
        // return -1;                                                                               
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Lock {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Buffer {                                                                                  
       Lock popLock isRead ? B : E                                                                  
                                                                                                    
       Lock pushLock isRead ? B : E                                                                 
                                                                                                    
      volatile boolean full isRead                                                                  
       ? holds(this.popLock, tid)                                                                   
         ? this.full ? R : N                                                                        
         : holds(this.pushLock, tid)                                                                
           ? this.full ? N : R                                                                      
           : E                                                                                      
       : holds(this, tid) && holds(this.popLock, tid)                                               
         ? this.full && !newValue ? N : E                                                           
         : holds(this, tid) && holds(this.pushLock, tid)                                            
           ? !this.full && newValue ? N : E                                                         
           : E                                                                                      
                                                                                                    
      volatile int data isRead                                                                      
       ? holds(this.popLock, tid) && this.full ? B : E                                              
       : holds(this.pushLock, tid) && holds(this, tid) && !this.full ? B : E                        
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.popLock != this.pushLock;                                                     
      invariant  this.popLock != Lock.null;                                                         
      invariant  this.pushLock != Lock.null;                                                        
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.popLock == Lock.null;                                                           
        assume this.pushLock == Lock.null;                                                          
        assume this.full == false;                                                                  
        assume this.data == 0;                                                                      
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires !holds(this.popLock, tid);                                                           
      requires !holds(this.pushLock, tid);                                                          
                                                                                                    
      public void push(int x) {                                                                     
        Lock tmp1;                                                                                  
        tmp1 := this.pushLock;                                                                      
        {                                                                                           
          acquire(tmp1);                                                                            
          {                                                                                         
            while (true)                                                                            
              invariant holds(this.pushLock, tid);                                                  
              invariant !holds(this.popLock, tid);                                                  
              invariant holds(tmp1, tid);                                                           
              {                                                                                     
              boolean tmp2;                                                                         
              tmp2 = true;                                                                          
              if (!tmp2) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                boolean tmp3;                                                                       
                boolean tmp4;                                                                       
                tmp4 := this.full;                                                                  
                tmp3 = !tmp4;                                                                       
                if (tmp3 /* == !this.full */) {                                                     
                  {                                                                                 
                    break;                                                                          
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            {                                                                                       
              acquire(this);                                                                        
              {                                                                                     
                this.data := x;                                                                     
                boolean tmp5;                                                                       
                tmp5 = true;                                                                        
                this.full := tmp5;                                                                  
              }                                                                                     
              release(this);                                                                        
            }                                                                                       
          }                                                                                         
          release(tmp1);                                                                            
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires !holds(this.popLock, tid);                                                           
      requires !holds(this.pushLock, tid);                                                          
                                                                                                    
      public int pop() {                                                                            
        Lock tmp6;                                                                                  
        tmp6 := this.popLock;                                                                       
        {                                                                                           
          acquire(tmp6);                                                                            
          {                                                                                         
            while (true)                                                                            
              invariant holds(this.popLock, tid);                                                   
              invariant !holds(this.pushLock, tid);                                                 
              invariant holds(tmp6, tid);                                                           
              {                                                                                     
              boolean tmp7;                                                                         
              tmp7 = true;                                                                          
              if (!tmp7) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                boolean tmp8;                                                                       
                tmp8 := this.full;                                                                  
                if (tmp8 /* == this.full */) {                                                      
                  {                                                                                 
                    break;                                                                          
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            {                                                                                       
              acquire(this);                                                                        
              {                                                                                     
                int result;                                                                         
                result := this.data;                                                                
                boolean tmp9;                                                                       
                tmp9 = false;                                                                       
                this.full := tmp9;                                                                  
                {                                                                                   
                  release(this);                                                                    
                  release(tmp6);                                                                    
                   return result;                                                                   
                }                                                                                   
              }                                                                                     
              release(this);                                                                        
            }                                                                                       
          }                                                                                         
          release(tmp6);                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Lock {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Buffer {                                                                                  
       Lock popLock isRead ? B : E                                                                  
                                                                                                    
       Lock pushLock isRead ? B : E                                                                 
                                                                                                    
      volatile boolean full isRead                                                                  
       ? holds(this.popLock, tid)                                                                   
         ? this.full ? R : N                                                                        
         : holds(this.pushLock, tid)                                                                
           ? this.full ? N : R                                                                      
           : E                                                                                      
       : holds(this, tid) && holds(this.popLock, tid)                                               
         ? this.full && !newValue ? N : E                                                           
         : holds(this, tid) && holds(this.pushLock, tid)                                            
           ? !this.full && newValue ? N : E                                                         
           : E                                                                                      
                                                                                                    
      volatile int data isRead                                                                      
       ? holds(this.popLock, tid) && this.full ? B : E                                              
       : holds(this.pushLock, tid) && holds(this, tid) && !this.full ? B : E                        
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.popLock != this.pushLock;                                                     
      invariant  this.popLock != Lock.null;                                                         
      invariant  this.pushLock != Lock.null;                                                        
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.popLock == Lock.null;                                                           
        assume this.pushLock == Lock.null;                                                          
        assume this.full == false;                                                                  
        assume this.data == 0;                                                                      
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires !holds(this.popLock, tid);                                                           
      requires !holds(this.pushLock, tid);                                                          
                                                                                                    
      public void push(int x) {                                                                     
        Lock tmp1;                                                                                  
        tmp1 := this.pushLock;                                                                      
        {                                                                                           
          acquire(tmp1);                                                                            
          {                                                                                         
            while (true)                                                                            
              invariant holds(this.pushLock, tid);                                                  
              invariant !holds(this.popLock, tid);                                                  
              invariant holds(tmp1, tid);                                                           
              {                                                                                     
              boolean tmp2;                                                                         
              tmp2 = true;                                                                          
              if (!tmp2) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                boolean tmp3;                                                                       
                boolean tmp4;                                                                       
                tmp4 := this.full;                                                                  
                tmp3 = !tmp4;                                                                       
                if (tmp3 /* == !this.full */) {                                                     
                  {                                                                                 
                    break;                                                                          
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            {                                                                                       
              acquire(this);                                                                        
              {                                                                                     
                this.data := x;                                                                     
                boolean tmp5;                                                                       
                tmp5 = true;                                                                        
                this.full := tmp5;                                                                  
              }                                                                                     
              release(this);                                                                        
            }                                                                                       
          }                                                                                         
          release(tmp1);                                                                            
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires !holds(this.popLock, tid);                                                           
      requires !holds(this.pushLock, tid);                                                          
                                                                                                    
      public int pop() {                                                                            
        Lock tmp6;                                                                                  
        tmp6 := this.popLock;                                                                       
        {                                                                                           
          acquire(tmp6);                                                                            
          {                                                                                         
            while (true)                                                                            
              invariant holds(this.popLock, tid);                                                   
              invariant !holds(this.pushLock, tid);                                                 
              invariant holds(tmp6, tid);                                                           
              {                                                                                     
              boolean tmp7;                                                                         
              tmp7 = true;                                                                          
              if (!tmp7) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                boolean tmp8;                                                                       
                tmp8 := this.full;                                                                  
                if (tmp8 /* == this.full */) {                                                      
                  {                                                                                 
                    break;                                                                          
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            {                                                                                       
              acquire(this);                                                                        
              {                                                                                     
                int result;                                                                         
                result := this.data;                                                                
                boolean tmp9;                                                                       
                tmp9 = false;                                                                       
                this.full := tmp9;                                                                  
                {                                                                                   
                  release(this);                                                                    
                  release(tmp6);                                                                    
                   return result;                                                                   
                }                                                                                   
              }                                                                                     
              release(this);                                                                        
            }                                                                                       
          }                                                                                         
          release(tmp6);                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Lock {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Buffer {                                                                                  
       Lock popLock isRead ? B : E                                                                  
                                                                                                    
       Lock pushLock isRead ? B : E                                                                 
                                                                                                    
      volatile boolean full isRead                                                                  
       ? holds(this.popLock, tid)                                                                   
         ? this.full ? R : N                                                                        
         : holds(this.pushLock, tid)                                                                
           ? this.full ? N : R                                                                      
           : E                                                                                      
       : holds(this, tid) && holds(this.popLock, tid)                                               
         ? this.full && !newValue ? N : E                                                           
         : holds(this, tid) && holds(this.pushLock, tid)                                            
           ? !this.full && newValue ? N : E                                                         
           : E                                                                                      
                                                                                                    
      volatile int data isRead                                                                      
       ? holds(this.popLock, tid) && this.full ? B : E                                              
       : holds(this.pushLock, tid) && holds(this, tid) && !this.full ? B : E                        
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.popLock != this.pushLock;                                                     
      invariant  this.popLock != Lock.null;                                                         
      invariant  this.pushLock != Lock.null;                                                        
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.popLock == Lock.null;                                                           
        assume this.pushLock == Lock.null;                                                          
        assume this.full == false;                                                                  
        assume this.data == 0;                                                                      
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires !holds(this.popLock, tid);                                                           
      requires !holds(this.pushLock, tid);                                                          
                                                                                                    
      public void push(int x) {                                                                     
        Lock tmp1;                                                                                  
        tmp1 := this.pushLock;                                                                      
        {                                                                                           
          acquire(tmp1);                                                                            
          {                                                                                         
            while (true)                                                                            
              invariant holds(this.pushLock, tid);                                                  
              invariant !holds(this.popLock, tid);                                                  
              invariant holds(tmp1, tid);                                                           
              {                                                                                     
              boolean tmp2;                                                                         
              tmp2 = true;                                                                          
              if (!tmp2) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                boolean tmp3;                                                                       
                boolean tmp4;                                                                       
                tmp4 := this.full;                                                                  
                tmp3 = !tmp4;                                                                       
                if (tmp3 /* == !this.full */) {                                                     
                  {                                                                                 
                    break;                                                                          
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            {                                                                                       
              acquire(this);                                                                        
              {                                                                                     
                this.data := x;                                                                     
                boolean tmp5;                                                                       
                tmp5 = true;                                                                        
                this.full := tmp5;                                                                  
              }                                                                                     
              release(this);                                                                        
            }                                                                                       
          }                                                                                         
          release(tmp1);                                                                            
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires !holds(this.popLock, tid);                                                           
      requires !holds(this.pushLock, tid);                                                          
                                                                                                    
      public int pop() {                                                                            
        Lock tmp6;                                                                                  
        tmp6 := this.popLock;                                                                       
        {                                                                                           
          acquire(tmp6);                                                                            
          {                                                                                         
            while (true)                                                                            
              invariant holds(this.popLock, tid);                                                   
              invariant !holds(this.pushLock, tid);                                                 
              invariant holds(tmp6, tid);                                                           
              {                                                                                     
              boolean tmp7;                                                                         
              tmp7 = true;                                                                          
              if (!tmp7) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                boolean tmp8;                                                                       
                tmp8 := this.full;                                                                  
                if (tmp8 /* == this.full */) {                                                      
                  {                                                                                 
                    break;                                                                          
                  }                                                                                 
                } else {                                                                            
                                                                                                    
                }                                                                                   
                yield;                                                                              
              }                                                                                     
            }                                                                                       
            {                                                                                       
              acquire(this);                                                                        
              {                                                                                     
                int result;                                                                         
                result := this.data;                                                                
                boolean tmp9;                                                                       
                tmp9 = false;                                                                       
                this.full := tmp9;                                                                  
                {                                                                                   
                  release(this);                                                                    
                  release(tmp6);                                                                    
                   return result;                                                                   
                }                                                                                   
              }                                                                                     
              release(this);                                                                        
            }                                                                                       
          }                                                                                         
          release(tmp6);                                                                            
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Lock ***/                                                                           
                                                                                                    
type Lock;                                                                                          
const unique Lock.null: Lock;                                                                       
var Lock._state: [Lock]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Lock._lock: [Lock]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Lock._lock(tid: Tid,this : Lock,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Lock._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Lock._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Lock._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Lock._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Lock._lock(tid: Tid,this : Lock,newValue: Tid,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Lock._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Lock._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Lock._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Lock._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Buffer ***/                                                                         
                                                                                                    
type Buffer;                                                                                        
const unique Buffer.null: Buffer;                                                                   
var Buffer._state: [Buffer]State;                                                                   
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer.popLock: [Buffer]Lock;                                                                   
                                                                                                    
function {:inline} ReadEval.Buffer.popLock(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Lock.null;                                                                        
 if (isRead) then                                                                                   
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer.popLock(tid: Tid,this : Buffer,newValue: Lock,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isRead) then                                                                                   
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer.pushLock: [Buffer]Lock;                                                                  
                                                                                                    
function {:inline} ReadEval.Buffer.pushLock(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Lock.null;                                                                        
 if (isRead) then                                                                                   
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer.pushLock(tid: Tid,this : Buffer,newValue: Lock,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isRead) then                                                                                   
  moverPath(_B, 1)                                                                                  
 else                                                                                               
  moverPath(_E, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer.full: [Buffer]bool;                                                                      
                                                                                                    
function {:inline} ReadEval.Buffer.full(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := false;                                                                            
 if (isRead) then                                                                                   
  if ((isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid)) then
   if (Buffer.full[this]) then                                                                      
    moverPath(_R, 7)                                                                                
   else                                                                                             
    moverPath(_N, 3)                                                                                
  else                                                                                              
   if ((isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid)) then
    if (Buffer.full[this]) then                                                                     
     moverPath(_N, 13)                                                                              
    else                                                                                            
     moverPath(_R, 5)                                                                               
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)&&(isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid))) then
   if ((Buffer.full[this]&&!(newValue))) then                                                       
    moverPath(_N, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)&&(isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid))) then
    if ((!(Buffer.full[this])&&newValue)) then                                                      
     moverPath(_N, 12)                                                                              
    else                                                                                            
     moverPath(_E, 4)                                                                               
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer.full(tid: Tid,this : Buffer,newValue: bool,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isRead) then                                                                                   
  if ((isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid)) then
   if (Buffer.full[this]) then                                                                      
    moverPath(_R, 7)                                                                                
   else                                                                                             
    moverPath(_N, 3)                                                                                
  else                                                                                              
   if ((isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid)) then
    if (Buffer.full[this]) then                                                                     
     moverPath(_N, 13)                                                                              
    else                                                                                            
     moverPath(_R, 5)                                                                               
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)&&(isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid))) then
   if ((Buffer.full[this]&&!(newValue))) then                                                       
    moverPath(_N, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid)&&(isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid))) then
    if ((!(Buffer.full[this])&&newValue)) then                                                      
     moverPath(_N, 12)                                                                              
    else                                                                                            
     moverPath(_E, 4)                                                                               
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer.data: [Buffer]int;                                                                       
                                                                                                    
function {:inline} ReadEval.Buffer.data(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isRead) then                                                                                   
  if (((isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid)&&Buffer.full[this])) then
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((((isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid)&&(isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid))&&!(Buffer.full[this]))) then
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer.data(tid: Tid,this : Buffer,newValue: int,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isRead) then                                                                                   
  if (((isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid)&&Buffer.full[this])) then
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((((isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid)&&(isAccessible(Buffer._state[this], tid) && Buffer._lock[this] == tid))&&!(Buffer.full[this]))) then
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Buffer._lock: [Buffer]Tid;                                                                      
                                                                                                    
function {:inline} ReadEval.Buffer._lock(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Buffer._lock[this]==tid)) then                                                              
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Buffer._lock[this]==Tid.null)&&(newValue==tid))) then                                      
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Buffer._lock[this]==tid)&&(newValue==Tid.null))) then                                     
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Buffer._lock(tid: Tid,this : Buffer,newValue: Tid,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Buffer._state[this], tid)) then                                                        
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Buffer._lock[this]==tid)) then                                                              
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Buffer._lock[this]==Tid.null)&&(newValue==tid))) then                                      
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Buffer._lock[this]==tid)&&(newValue==Tid.null))) then                                     
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.Buffer.3689920(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (bool) {
 (Buffer.popLock[this]!=Buffer.pushLock[this])                                                      
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Buffer.3689928(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (bool) {
 (Buffer.popLock[this]!=Lock.null)                                                                  
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Buffer.3689936(tid: Tid,this : Buffer,Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (bool) {
 (Buffer.pushLock[this]!=Lock.null)                                                                 
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Buffer.push(tid:Tid, this : Buffer, x : int)                                             
modifies Lock._state;                                                                               
modifies Lock._lock;                                                                                
modifies Buffer._state;                                                                             
modifies Buffer.popLock;                                                                            
modifies Buffer.pushLock;                                                                           
modifies Buffer.full;                                                                               
modifies Buffer.data;                                                                               
modifies Buffer._lock;                                                                              
                                                                                                    
requires ValidTid(tid);                                                                                    // (23.3): Bad tid
requires isShared(Buffer._state[this]);                                                                    // (23.3): this is not global
                                                                                                    
requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
requires !((isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid));
                                                                                                    
requires !((isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid));
                                                                                                    
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (23.3): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (23.3): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (23.3): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
ensures  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (23.3): Object invariant may not hold.
ensures  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (23.3): Object invariant may not hold.
ensures  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (23.3): Object invariant may not hold.
{                                                                                                   
 var tid3695885: Tid;                                                                               
 var phase3695921: Phase;                                                                           
 var $pc3695918: Phase;                                                                             
 var Buffer.popLock3695907: [Buffer]Lock;                                                           
 var Buffer.pushLock3695936: [Buffer]Lock;                                                          
 var Buffer._state3695921_bottom: [Buffer]State;                                                    
 var mover3695907: Mover;                                                                           
 var tid3695945: Tid;                                                                               
 var $recorded.state3695945: int;                                                                   
 var x3695918: int;                                                                                 
 var Buffer.full3695918: [Buffer]bool;                                                              
 var Buffer._lock3695918: [Buffer]Tid;                                                              
 var Lock._lock3695921: [Lock]Tid;                                                                  
 var tmp5: bool;                                                                                    
 var Buffer._lock3695926: [Buffer]Tid;                                                              
 var tid3695936: Tid;                                                                               
 var Buffer.full3695885: [Buffer]bool;                                                              
 var Buffer._state3695907: [Buffer]State;                                                           
 var $pc3695918_post: Phase;                                                                        
 var Lock._lock3695907: [Lock]Tid;                                                                  
 var Buffer.pushLock3695907: [Buffer]Lock;                                                          
 var path3695907: int;                                                                              
 var Buffer.data3695921_bottom: [Buffer]int;                                                        
 var Lock._lock3695926: [Lock]Tid;                                                                  
 var Lock._state3695885: [Lock]State;                                                               
 var tid3695926: Tid;                                                                               
 var Lock._state3695926: [Lock]State;                                                               
 var mover3695926: Mover;                                                                           
 var Lock._lock3695918_post: [Lock]Tid;                                                             
 var Buffer._state3695885: [Buffer]State;                                                           
 var $recorded.state3695918: int;                                                                   
 var $recorded.state3695926: int;                                                                   
 var Buffer.data3695921: [Buffer]int;                                                               
 var x3695907: int;                                                                                 
 var Buffer.full3695936: [Buffer]bool;                                                              
 var Buffer.data3695926: [Buffer]int;                                                               
 var tmp2: bool;                                                                                    
 var tmp13695918_post: Lock;                                                                        
 var tid3695921: Tid;                                                                               
 var Lock._state3695936: [Lock]State;                                                               
 var Buffer.pushLock3695945: [Buffer]Lock;                                                          
 var $recorded.state3695921_bottom: int;                                                            
 var mover3695885: Mover;                                                                           
 var $recorded.state3695907: int;                                                                   
 var moverPath3695885: MoverPath;                                                                   
 var Buffer.pushLock3695921: [Buffer]Lock;                                                          
 var Lock._state3695918_post: [Lock]State;                                                          
 var $pc3695945: Phase;                                                                             
 var Buffer.full3695921: [Buffer]bool;                                                              
 var $pc3695936: Phase;                                                                             
 var this3695936: Buffer;                                                                           
 var Buffer.pushLock3695921_bottom: [Buffer]Lock;                                                   
 var tmp53695936: bool;                                                                             
 var x3695921_bottom: int;                                                                          
 var moverPath3695907: MoverPath;                                                                   
 var tmp33695907: bool;                                                                             
 var Buffer.full3695918_post: [Buffer]bool;                                                         
 var $recorded.state3695918_post: int;                                                              
 var Buffer.data3695918: [Buffer]int;                                                               
 var Buffer.full3695945: [Buffer]bool;                                                              
 var tmp1: Lock;                                                                                    
 var this3695907: Buffer;                                                                           
 var Lock._state3695945: [Lock]State;                                                               
 var Lock._state3695921_bottom: [Lock]State;                                                        
 var tmp33695918: bool;                                                                             
 var x3695945: int;                                                                                 
 var this3695926: Buffer;                                                                           
 var x3695918_post: int;                                                                            
 var Lock._lock3695945: [Lock]Tid;                                                                  
 var Buffer._lock3695945: [Buffer]Tid;                                                              
 var Buffer._state3695918: [Buffer]State;                                                           
 var tmp13695921_bottom: Lock;                                                                      
 var $recorded.state3695885: int;                                                                   
 var Buffer._lock3695921_bottom: [Buffer]Tid;                                                       
 var Buffer.pushLock3695926: [Buffer]Lock;                                                          
 var x3695885: int;                                                                                 
 var Lock._lock3695936: [Lock]Tid;                                                                  
 var tmp13695926: Lock;                                                                             
 var moverPath3695926: MoverPath;                                                                   
 var $pc3695921: Phase;                                                                             
 var Buffer._state3695926: [Buffer]State;                                                           
 var path3695926: int;                                                                              
 var tmp43695907: bool;                                                                             
 var tmp13695945: Lock;                                                                             
 var tmp23695918: bool;                                                                             
 var $recorded.state3695936: int;                                                                   
 var tid3695907: Tid;                                                                               
 var Buffer.popLock3695918: [Buffer]Lock;                                                           
 var Buffer.data3695918_post: [Buffer]int;                                                          
 var Lock._lock3695918: [Lock]Tid;                                                                  
 var Buffer._state3695936: [Buffer]State;                                                           
 var Buffer.pushLock3695885: [Buffer]Lock;                                                          
 var tmp23695918_post: bool;                                                                        
 var path3695936: int;                                                                              
 var this3695885: Buffer;                                                                           
 var x3695921: int;                                                                                 
 var Buffer.data3695907: [Buffer]int;                                                               
 var tmp13695936: Lock;                                                                             
 var mover3695936: Mover;                                                                           
 var $pc3695926: Phase;                                                                             
 var Buffer._lock3695907: [Buffer]Tid;                                                              
 var tmp13695885: Lock;                                                                             
 var $pc3695921_bottom: Phase;                                                                      
 var $pc3695885: Phase;                                                                             
 var Buffer.data3695945: [Buffer]int;                                                               
 var tid3695921_bottom: Tid;                                                                        
 var Buffer.pushLock3695918_post: [Buffer]Lock;                                                     
 var tid3695918: Tid;                                                                               
 var Buffer._lock3695936: [Buffer]Tid;                                                              
 var Buffer.popLock3695921: [Buffer]Lock;                                                           
 var Buffer.popLock3695918_post: [Buffer]Lock;                                                      
 var this3695918: Buffer;                                                                           
 var tmp3: bool;                                                                                    
 var Buffer.popLock3695926: [Buffer]Lock;                                                           
 var Buffer.pushLock3695918: [Buffer]Lock;                                                          
 var tmp13695907: Lock;                                                                             
 var Buffer.full3695921_bottom: [Buffer]bool;                                                       
 var tmp4: bool;                                                                                    
 var Lock._lock3695885: [Lock]Tid;                                                                  
 var Buffer.data3695885: [Buffer]int;                                                               
 var Buffer._lock3695918_post: [Buffer]Tid;                                                         
 var Buffer.data3695936: [Buffer]int;                                                               
 var Lock._state3695921: [Lock]State;                                                               
 var this3695921_bottom: Buffer;                                                                    
 var Buffer.popLock3695921_bottom: [Buffer]Lock;                                                    
 var tmp13695918: Lock;                                                                             
 var Lock._lock3695921_bottom: [Lock]Tid;                                                           
 var Buffer._state3695918_post: [Buffer]State;                                                      
 var Buffer.popLock3695936: [Buffer]Lock;                                                           
 var Buffer.popLock3695885: [Buffer]Lock;                                                           
 var Lock._state3695907: [Lock]State;                                                               
 var this3695921: Buffer;                                                                           
 var $pc3695907: Phase;                                                                             
 var tmp13695921: Lock;                                                                             
 var Buffer.full3695926: [Buffer]bool;                                                              
 var Lock._state3695918: [Lock]State;                                                               
 var tid3695918_post: Tid;                                                                          
 var Buffer.popLock3695945: [Buffer]Lock;                                                           
 var Buffer.full3695907: [Buffer]bool;                                                              
 var Buffer._state3695945: [Buffer]State;                                                           
 var moverPath3695936: MoverPath;                                                                   
 var this3695945: Buffer;                                                                           
 var tmp43695918: bool;                                                                             
 var x3695936: int;                                                                                 
 var tmp43695918_post: bool;                                                                        
 var tmp23695907: bool;                                                                             
 var path3695885: int;                                                                              
 var Buffer._state3695921: [Buffer]State;                                                           
 var Buffer._lock3695921: [Buffer]Tid;                                                              
 var x3695926: int;                                                                                 
 var $recorded.state3695921: int;                                                                   
 var this3695918_post: Buffer;                                                                      
 var Buffer._lock3695885: [Buffer]Tid;                                                              
 var tmp33695918_post: bool;                                                                        
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true && leq(m#moverPath(ReadEval.Buffer.popLock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)),_R);       // (23.12): Can only have right-mover memory accesses in requires clause
 assert true && leq(m#moverPath(ReadEval.Buffer.pushLock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)),_R);       // (24.12): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 26.5: Lock tmp1;                                                                                
                                                                                                    
                                                                                                    
 // 26.5: tmp1 := this.pushLock;                                                                    
                                                                                                    
                                                                                                    
 moverPath3695885 := ReadEval.Buffer.pushLock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 mover3695885 := m#moverPath(moverPath3695885);                                                     
 path3695885 := p#moverPath(moverPath3695885);                                                      
 assume Lock._state3695885 == Lock._state && Lock._lock3695885 == Lock._lock && Buffer._state3695885 == Buffer._state && Buffer.popLock3695885 == Buffer.popLock && Buffer.pushLock3695885 == Buffer.pushLock && Buffer.full3695885 == Buffer.full && Buffer.data3695885 == Buffer.data && Buffer._lock3695885 == Buffer._lock && tmp13695885 == tmp1 && x3695885 == x && this3695885 == this && tid3695885 == tid && $pc3695885 == $pc;
 assume $recorded.state3695885 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (26.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover3695885);                                                              
 assert $pc != PhaseError;                                                                                 // (26.5): Reduction failure
 tmp1 := Buffer.pushLock[this];                                                                     
 if ($pc == PreCommit) {                                                                            
  assume tmp1 != Lock.null;                                                                         
 } else {                                                                                           
  assert tmp1 != Lock.null;                                                                                // (26.18): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume Lock._lock[tmp1] == Tid.null;                                                               
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (26.18): Reduction failure
 Lock._lock[tmp1] := tid;                                                                           
 assume Lock._state3695921 == Lock._state && Lock._lock3695921 == Lock._lock && Buffer._state3695921 == Buffer._state && Buffer.popLock3695921 == Buffer.popLock && Buffer.pushLock3695921 == Buffer.pushLock && Buffer.full3695921 == Buffer.full && Buffer.data3695921 == Buffer.data && Buffer._lock3695921 == Buffer._lock && tmp13695921 == tmp1 && x3695921 == x && this3695921 == this && tid3695921 == tid;
 assume $recorded.state3695921 == 1;                                                                
                                                                                                    
 // 27.9: while (true)                                                                              
                                                                                                    
 phase3695921 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (23.3): Bad tid
  invariant isShared(Buffer._state[this]);                                                                 // (23.3): this is not global
                                                                                                    
  invariant StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
  invariant  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (27.9): Object invariant may not hold.
  invariant  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (27.9): Object invariant may not hold.
  invariant  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (27.9): Object invariant may not hold.
  invariant (isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid);
  invariant !((isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid));
  invariant (isAccessible(Lock._state[tmp1], tid) && Lock._lock[tmp1] == tid);                      
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.popLock(tid : Tid, _this, Buffer.popLock[_this] ,Lock._state3695921,Lock._lock3695921,Buffer._state3695921,Buffer.popLock3695921,Buffer.pushLock3695921,Buffer.full3695921,Buffer.data3695921,Buffer._lock3695921));       // (27.9): Loop does not preserve yields_as annotation for field popLock
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.pushLock(tid : Tid, _this, Buffer.pushLock[_this] ,Lock._state3695921,Lock._lock3695921,Buffer._state3695921,Buffer.popLock3695921,Buffer.pushLock3695921,Buffer.full3695921,Buffer.data3695921,Buffer._lock3695921));       // (27.9): Loop does not preserve yields_as annotation for field pushLock
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.full(tid : Tid, _this, Buffer.full[_this] ,Lock._state3695921,Lock._lock3695921,Buffer._state3695921,Buffer.popLock3695921,Buffer.pushLock3695921,Buffer.full3695921,Buffer.data3695921,Buffer._lock3695921));       // (27.9): Loop does not preserve yields_as annotation for field full
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.data(tid : Tid, _this, Buffer.data[_this] ,Lock._state3695921,Lock._lock3695921,Buffer._state3695921,Buffer.popLock3695921,Buffer.pushLock3695921,Buffer.full3695921,Buffer.data3695921,Buffer._lock3695921));       // (27.9): Loop does not preserve yields_as annotation for field data
  invariant phase3695921 == $pc;                                                                           // (27.9): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (27.9): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 27.16: boolean tmp2;                                                                           
                                                                                                    
                                                                                                    
  // 27.16: tmp2 = true;                                                                            
                                                                                                    
  tmp2 := true;                                                                                     
  if (!(tmp2)) {                                                                                    
                                                                                                    
   // 27.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 31.11: boolean tmp3;                                                                           
                                                                                                    
                                                                                                    
  // 31.11: boolean tmp4;                                                                           
                                                                                                    
                                                                                                    
  // 31.11: tmp4 := this.full;                                                                      
                                                                                                    
                                                                                                    
  moverPath3695907 := ReadEval.Buffer.full(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
  mover3695907 := m#moverPath(moverPath3695907);                                                    
  path3695907 := p#moverPath(moverPath3695907);                                                     
  assume Lock._state3695907 == Lock._state && Lock._lock3695907 == Lock._lock && Buffer._state3695907 == Buffer._state && Buffer.popLock3695907 == Buffer.popLock && Buffer.pushLock3695907 == Buffer.pushLock && Buffer.full3695907 == Buffer.full && Buffer.data3695907 == Buffer.data && Buffer._lock3695907 == Buffer._lock && tmp43695907 == tmp4 && tmp33695907 == tmp3 && tmp23695907 == tmp2 && tmp13695907 == tmp1 && x3695907 == x && this3695907 == this && tid3695907 == tid && $pc3695907 == $pc;
  assume $recorded.state3695907 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Buffer.null;                                                                      
  } else {                                                                                          
   assert this != Buffer.null;                                                                             // (31.11): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover3695907);                                                             
  assert $pc != PhaseError;                                                                                // (31.11): Reduction failure
  tmp4 := Buffer.full[this];                                                                        
                                                                                                    
  // 31.11: tmp3 = !tmp4;                                                                           
                                                                                                    
  tmp3 := !(tmp4);                                                                                  
  if (tmp3 /* lowered !(Buffer.full[this]) */) {                                                    
                                                                                                    
   // 31.29: break;                                                                                 
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 32.11: yield;                                                                                  
                                                                                                    
  assume Lock._state3695918 == Lock._state && Lock._lock3695918 == Lock._lock && Buffer._state3695918 == Buffer._state && Buffer.popLock3695918 == Buffer.popLock && Buffer.pushLock3695918 == Buffer.pushLock && Buffer.full3695918 == Buffer.full && Buffer.data3695918 == Buffer.data && Buffer._lock3695918 == Buffer._lock && tmp43695918 == tmp4 && tmp33695918 == tmp3 && tmp23695918 == tmp2 && tmp13695918 == tmp1 && x3695918 == x && this3695918 == this && tid3695918 == tid;
  assume $recorded.state3695918 == 1;                                                               
  assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (32.11): Object invariant may not hold.
  assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (32.11): Object invariant may not hold.
  assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (32.11): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (32.11): Object invariant may not hold.
  assume  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (32.11): Object invariant may not hold.
  assume  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (32.11): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Lock._state3695918_post == Lock._state && Lock._lock3695918_post == Lock._lock && Buffer._state3695918_post == Buffer._state && Buffer.popLock3695918_post == Buffer.popLock && Buffer.pushLock3695918_post == Buffer.pushLock && Buffer.full3695918_post == Buffer.full && Buffer.data3695918_post == Buffer.data && Buffer._lock3695918_post == Buffer._lock && tmp43695918_post == tmp4 && tmp33695918_post == tmp3 && tmp23695918_post == tmp2 && tmp13695918_post == tmp1 && x3695918_post == x && this3695918_post == this && tid3695918_post == tid;
  assume $recorded.state3695918_post == 1;                                                          
  assume Lock._state3695921_bottom == Lock._state && Lock._lock3695921_bottom == Lock._lock && Buffer._state3695921_bottom == Buffer._state && Buffer.popLock3695921_bottom == Buffer.popLock && Buffer.pushLock3695921_bottom == Buffer.pushLock && Buffer.full3695921_bottom == Buffer.full && Buffer.data3695921_bottom == Buffer.data && Buffer._lock3695921_bottom == Buffer._lock && tmp13695921_bottom == tmp1 && x3695921_bottom == x && this3695921_bottom == this && tid3695921_bottom == tid;
  assume $recorded.state3695921_bottom == 1;                                                        
  assert phase3695921 == $pc;                                                                              // (27.9): Phase must be invariant at loop head
 }                                                                                                  
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (34.22): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume Buffer._lock[this] == Tid.null;                                                             
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (34.22): Reduction failure
 Buffer._lock[this] := tid;                                                                         
                                                                                                    
                                                                                                    
 // 35.13: this.data := x;                                                                          
                                                                                                    
                                                                                                    
 moverPath3695926 := WriteEval.Buffer.data(tid: Tid,this: Buffer,x: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 mover3695926 := m#moverPath(moverPath3695926);                                                     
 path3695926 := p#moverPath(moverPath3695926);                                                      
 assume Lock._state3695926 == Lock._state && Lock._lock3695926 == Lock._lock && Buffer._state3695926 == Buffer._state && Buffer.popLock3695926 == Buffer.popLock && Buffer.pushLock3695926 == Buffer.pushLock && Buffer.full3695926 == Buffer.full && Buffer.data3695926 == Buffer.data && Buffer._lock3695926 == Buffer._lock && tmp13695926 == tmp1 && x3695926 == x && this3695926 == this && tid3695926 == tid && $pc3695926 == $pc;
 assume $recorded.state3695926 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (35.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3695926);                                                              
 assert $pc != PhaseError;                                                                                 // (35.13): Reduction failure
 Buffer.data[this] := x;                                                                            
                                                                                                    
 // 36.13: boolean tmp5;                                                                            
                                                                                                    
                                                                                                    
 // 36.13: tmp5 = true;                                                                             
                                                                                                    
 tmp5 := true;                                                                                      
                                                                                                    
                                                                                                    
 // 36.13: this.full := tmp5;                                                                       
                                                                                                    
                                                                                                    
 moverPath3695936 := WriteEval.Buffer.full(tid: Tid,this: Buffer,tmp5: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 mover3695936 := m#moverPath(moverPath3695936);                                                     
 path3695936 := p#moverPath(moverPath3695936);                                                      
 assume Lock._state3695936 == Lock._state && Lock._lock3695936 == Lock._lock && Buffer._state3695936 == Buffer._state && Buffer.popLock3695936 == Buffer.popLock && Buffer.pushLock3695936 == Buffer.pushLock && Buffer.full3695936 == Buffer.full && Buffer.data3695936 == Buffer.data && Buffer._lock3695936 == Buffer._lock && tmp53695936 == tmp5 && tmp13695936 == tmp1 && x3695936 == x && this3695936 == this && tid3695936 == tid && $pc3695936 == $pc;
 assume $recorded.state3695936 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (36.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3695936);                                                              
 assert $pc != PhaseError;                                                                                 // (36.13): Reduction failure
 Buffer.full[this] := tmp5;                                                                         
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (37.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Buffer._lock[this] == tid;                                                                         // (37.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (37.9): Reduction failure
 Buffer._lock[this] := Tid.null;                                                                    
 if ($pc == PreCommit) {                                                                            
  assume tmp1 != Lock.null;                                                                         
 } else {                                                                                           
  assert tmp1 != Lock.null;                                                                                // (38.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Lock._lock[tmp1] == tid;                                                                           // (38.5): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (38.5): Reduction failure
 Lock._lock[tmp1] := Tid.null;                                                                      
                                                                                                    
 // 25.27: // return;                                                                               
                                                                                                    
 assume Lock._state3695945 == Lock._state && Lock._lock3695945 == Lock._lock && Buffer._state3695945 == Buffer._state && Buffer.popLock3695945 == Buffer.popLock && Buffer.pushLock3695945 == Buffer.pushLock && Buffer.full3695945 == Buffer.full && Buffer.data3695945 == Buffer.data && Buffer._lock3695945 == Buffer._lock && tmp13695945 == tmp1 && x3695945 == x && this3695945 == this && tid3695945 == tid;
 assume $recorded.state3695945 == 1;                                                                
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (25.27): Object invariant may not hold.
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (25.27): Object invariant may not hold.
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (25.27): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  Buffer.pop(tid:Tid, this : Buffer)                                                       
returns ($result : int)                                                                             
modifies Lock._state;                                                                               
modifies Lock._lock;                                                                                
modifies Buffer._state;                                                                             
modifies Buffer.popLock;                                                                            
modifies Buffer.pushLock;                                                                           
modifies Buffer.full;                                                                               
modifies Buffer.data;                                                                               
modifies Buffer._lock;                                                                              
                                                                                                    
requires ValidTid(tid);                                                                                    // (41.3): Bad tid
requires isShared(Buffer._state[this]);                                                                    // (41.3): this is not global
                                                                                                    
requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
requires !((isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid));
                                                                                                    
requires !((isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid));
                                                                                                    
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (41.3): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (41.3): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (41.3): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
ensures  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (41.3): Object invariant may not hold.
ensures  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (41.3): Object invariant may not hold.
ensures  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (41.3): Object invariant may not hold.
{                                                                                                   
 var tmp73695979_post: bool;                                                                        
 var mover3696000: Mover;                                                                           
 var Buffer.pushLock3695979_post: [Buffer]Lock;                                                     
 var moverPath3695990: MoverPath;                                                                   
 var result: int;                                                                                   
 var $recorded.state3695954: int;                                                                   
 var tmp63695973: Lock;                                                                             
 var Lock._lock3696006: [Lock]Tid;                                                                  
 var $result3695973: int;                                                                           
 var this3696006: Buffer;                                                                           
 var Buffer.full3695979_post: [Buffer]bool;                                                         
 var this3695979_post: Buffer;                                                                      
 var Buffer.popLock3696000: [Buffer]Lock;                                                           
 var Lock._lock3695954: [Lock]Tid;                                                                  
 var $result3696006: int;                                                                           
 var Buffer.popLock3695954: [Buffer]Lock;                                                           
 var Lock._state3696018: [Lock]State;                                                               
 var path3696000: int;                                                                              
 var $pc3695982_bottom: Phase;                                                                      
 var Buffer.full3696006: [Buffer]bool;                                                              
 var Lock._lock3695982: [Lock]Tid;                                                                  
 var Buffer._state3695982: [Buffer]State;                                                           
 var tmp93696006: bool;                                                                             
 var tmp73695979: bool;                                                                             
 var $pc3695954: Phase;                                                                             
 var Buffer._state3696000: [Buffer]State;                                                           
 var tmp63695979_post: Lock;                                                                        
 var path3695954: int;                                                                              
 var Buffer.full3695990: [Buffer]bool;                                                              
 var Buffer._state3695973: [Buffer]State;                                                           
 var Buffer._state3695982_bottom: [Buffer]State;                                                    
 var Buffer._state3696006: [Buffer]State;                                                           
 var Buffer._lock3695979: [Buffer]Tid;                                                              
 var $recorded.state3696000: int;                                                                   
 var Lock._state3695954: [Lock]State;                                                               
 var Lock._state3695990: [Lock]State;                                                               
 var this3696018: Buffer;                                                                           
 var tid3695973: Tid;                                                                               
 var $result3695982_bottom: int;                                                                    
 var Buffer.popLock3696006: [Buffer]Lock;                                                           
 var moverPath3695973: MoverPath;                                                                   
 var result3695990: int;                                                                            
 var Buffer.popLock3695979_post: [Buffer]Lock;                                                      
 var $recorded.state3695982: int;                                                                   
 var $result3695979: int;                                                                           
 var Lock._state3696000: [Lock]State;                                                               
 var $recorded.state3696006: int;                                                                   
 var tid3696018: Tid;                                                                               
 var Buffer.data3695979_post: [Buffer]int;                                                          
 var Buffer._lock3695973: [Buffer]Tid;                                                              
 var $pc3696000: Phase;                                                                             
 var Buffer.pushLock3695990: [Buffer]Lock;                                                          
 var mover3695954: Mover;                                                                           
 var tmp83695979: bool;                                                                             
 var $pc3695979_post: Phase;                                                                        
 var Buffer.pushLock3696000: [Buffer]Lock;                                                          
 var Buffer.data3695982: [Buffer]int;                                                               
 var Buffer._lock3695990: [Buffer]Tid;                                                              
 var Lock._lock3695979_post: [Lock]Tid;                                                             
 var tmp83695979_post: bool;                                                                        
 var Buffer.popLock3695982_bottom: [Buffer]Lock;                                                    
 var Buffer.full3695982: [Buffer]bool;                                                              
 var Lock._lock3696018: [Lock]Tid;                                                                  
 var this3695990: Buffer;                                                                           
 var $recorded.state3695979: int;                                                                   
 var Buffer.data3696000: [Buffer]int;                                                               
 var $recorded.state3695979_post: int;                                                              
 var Buffer.full3695979: [Buffer]bool;                                                              
 var Buffer._lock3695982_bottom: [Buffer]Tid;                                                       
 var $pc3695982: Phase;                                                                             
 var Buffer._lock3696000: [Buffer]Tid;                                                              
 var $pc3695973: Phase;                                                                             
 var tmp63695982_bottom: Lock;                                                                      
 var $recorded.state3696018: int;                                                                   
 var tmp63696018: Lock;                                                                             
 var tmp63695954: Lock;                                                                             
 var $recorded.state3695973: int;                                                                   
 var $recorded.state3695990: int;                                                                   
 var Buffer.popLock3695982: [Buffer]Lock;                                                           
 var Buffer._lock3695954: [Buffer]Tid;                                                              
 var Lock._lock3696000: [Lock]Tid;                                                                  
 var tmp83695973: bool;                                                                             
 var phase3695982: Phase;                                                                           
 var $result3695954: int;                                                                           
 var Buffer.full3696018: [Buffer]bool;                                                              
 var Buffer.pushLock3695982_bottom: [Buffer]Lock;                                                   
 var Lock._lock3695973: [Lock]Tid;                                                                  
 var this3695954: Buffer;                                                                           
 var tmp63696006: Lock;                                                                             
 var moverPath3695954: MoverPath;                                                                   
 var Buffer._state3696018: [Buffer]State;                                                           
 var Buffer.pushLock3696018: [Buffer]Lock;                                                          
 var Lock._lock3695979: [Lock]Tid;                                                                  
 var tmp63695979: Lock;                                                                             
 var Buffer.popLock3695990: [Buffer]Lock;                                                           
 var this3695973: Buffer;                                                                           
 var $result3696018: int;                                                                           
 var tmp63695982: Lock;                                                                             
 var this3696000: Buffer;                                                                           
 var result3696000: int;                                                                            
 var Lock._lock3695990: [Lock]Tid;                                                                  
 var Lock._state3696006: [Lock]State;                                                               
 var tid3696000: Tid;                                                                               
 var $pc3696006: Phase;                                                                             
 var tmp9: bool;                                                                                    
 var tid3695979_post: Tid;                                                                          
 var Buffer.data3695982_bottom: [Buffer]int;                                                        
 var Buffer.data3696006: [Buffer]int;                                                               
 var Buffer._lock3696006: [Buffer]Tid;                                                              
 var tmp63696000: Lock;                                                                             
 var Buffer.popLock3696018: [Buffer]Lock;                                                           
 var tmp7: bool;                                                                                    
 var Buffer.pushLock3695979: [Buffer]Lock;                                                          
 var Buffer.full3695973: [Buffer]bool;                                                              
 var Buffer._state3695954: [Buffer]State;                                                           
 var $result3696000: int;                                                                           
 var $pc3695979: Phase;                                                                             
 var Lock._state3695979_post: [Lock]State;                                                          
 var Lock._state3695982: [Lock]State;                                                               
 var this3695982_bottom: Buffer;                                                                    
 var this3695982: Buffer;                                                                           
 var tid3695979: Tid;                                                                               
 var Buffer.data3695979: [Buffer]int;                                                               
 var Lock._lock3695982_bottom: [Lock]Tid;                                                           
 var Buffer.full3695954: [Buffer]bool;                                                              
 var Buffer._lock3696018: [Buffer]Tid;                                                              
 var tmp73695973: bool;                                                                             
 var Lock._state3695973: [Lock]State;                                                               
 var Buffer.popLock3695973: [Buffer]Lock;                                                           
 var mover3695973: Mover;                                                                           
 var tmp63695990: Lock;                                                                             
 var path3695973: int;                                                                              
 var Buffer._lock3695982: [Buffer]Tid;                                                              
 var tid3696006: Tid;                                                                               
 var Lock._state3695982_bottom: [Lock]State;                                                        
 var Buffer.pushLock3695973: [Buffer]Lock;                                                          
 var Buffer._state3695979_post: [Buffer]State;                                                      
 var $result3695990: int;                                                                           
 var Buffer.full3696000: [Buffer]bool;                                                              
 var Lock._state3695979: [Lock]State;                                                               
 var Buffer.pushLock3695982: [Buffer]Lock;                                                          
 var tid3695982: Tid;                                                                               
 var Buffer.popLock3695979: [Buffer]Lock;                                                           
 var $result3695982: int;                                                                           
 var Buffer._lock3695979_post: [Buffer]Tid;                                                         
 var $pc3695990: Phase;                                                                             
 var this3695979: Buffer;                                                                           
 var Buffer.pushLock3695954: [Buffer]Lock;                                                          
 var tid3695990: Tid;                                                                               
 var tmp93696000: bool;                                                                             
 var $result3695979_post: int;                                                                      
 var $pc3696018: Phase;                                                                             
 var mover3695990: Mover;                                                                           
 var tid3695982_bottom: Tid;                                                                        
 var Buffer._state3695990: [Buffer]State;                                                           
 var tmp6: Lock;                                                                                    
 var tid3695954: Tid;                                                                               
 var $recorded.state3695982_bottom: int;                                                            
 var Buffer._state3695979: [Buffer]State;                                                           
 var tmp8: bool;                                                                                    
 var result3696006: int;                                                                            
 var Buffer.data3695990: [Buffer]int;                                                               
 var Buffer.data3696018: [Buffer]int;                                                               
 var moverPath3696000: MoverPath;                                                                   
 var Buffer.data3695973: [Buffer]int;                                                               
 var Buffer.pushLock3696006: [Buffer]Lock;                                                          
 var Buffer.data3695954: [Buffer]int;                                                               
 var path3695990: int;                                                                              
 var Buffer.full3695982_bottom: [Buffer]bool;                                                       
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true && leq(m#moverPath(ReadEval.Buffer.popLock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)),_R);       // (41.12): Can only have right-mover memory accesses in requires clause
 assert true && leq(m#moverPath(ReadEval.Buffer.pushLock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)),_R);       // (42.12): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 44.5: Lock tmp6;                                                                                
                                                                                                    
                                                                                                    
 // 44.5: tmp6 := this.popLock;                                                                     
                                                                                                    
                                                                                                    
 moverPath3695954 := ReadEval.Buffer.popLock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 mover3695954 := m#moverPath(moverPath3695954);                                                     
 path3695954 := p#moverPath(moverPath3695954);                                                      
 assume Lock._state3695954 == Lock._state && Lock._lock3695954 == Lock._lock && Buffer._state3695954 == Buffer._state && Buffer.popLock3695954 == Buffer.popLock && Buffer.pushLock3695954 == Buffer.pushLock && Buffer.full3695954 == Buffer.full && Buffer.data3695954 == Buffer.data && Buffer._lock3695954 == Buffer._lock && tmp63695954 == tmp6 && $result3695954 == $result && this3695954 == this && tid3695954 == tid && $pc3695954 == $pc;
 assume $recorded.state3695954 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (44.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover3695954);                                                              
 assert $pc != PhaseError;                                                                                 // (44.5): Reduction failure
 tmp6 := Buffer.popLock[this];                                                                      
 if ($pc == PreCommit) {                                                                            
  assume tmp6 != Lock.null;                                                                         
 } else {                                                                                           
  assert tmp6 != Lock.null;                                                                                // (44.18): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume Lock._lock[tmp6] == Tid.null;                                                               
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (44.18): Reduction failure
 Lock._lock[tmp6] := tid;                                                                           
 assume Lock._state3695982 == Lock._state && Lock._lock3695982 == Lock._lock && Buffer._state3695982 == Buffer._state && Buffer.popLock3695982 == Buffer.popLock && Buffer.pushLock3695982 == Buffer.pushLock && Buffer.full3695982 == Buffer.full && Buffer.data3695982 == Buffer.data && Buffer._lock3695982 == Buffer._lock && tmp63695982 == tmp6 && $result3695982 == $result && this3695982 == this && tid3695982 == tid;
 assume $recorded.state3695982 == 1;                                                                
                                                                                                    
 // 45.9: while (true)                                                                              
                                                                                                    
 phase3695982 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (41.3): Bad tid
  invariant isShared(Buffer._state[this]);                                                                 // (41.3): this is not global
                                                                                                    
  invariant StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
  invariant  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (45.9): Object invariant may not hold.
  invariant  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (45.9): Object invariant may not hold.
  invariant  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (45.9): Object invariant may not hold.
  invariant (isAccessible(Lock._state[Buffer.popLock[this]], tid) && Lock._lock[Buffer.popLock[this]] == tid);
  invariant !((isAccessible(Lock._state[Buffer.pushLock[this]], tid) && Lock._lock[Buffer.pushLock[this]] == tid));
  invariant (isAccessible(Lock._state[tmp6], tid) && Lock._lock[tmp6] == tid);                      
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.popLock(tid : Tid, _this, Buffer.popLock[_this] ,Lock._state3695982,Lock._lock3695982,Buffer._state3695982,Buffer.popLock3695982,Buffer.pushLock3695982,Buffer.full3695982,Buffer.data3695982,Buffer._lock3695982));       // (45.9): Loop does not preserve yields_as annotation for field popLock
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.pushLock(tid : Tid, _this, Buffer.pushLock[_this] ,Lock._state3695982,Lock._lock3695982,Buffer._state3695982,Buffer.popLock3695982,Buffer.pushLock3695982,Buffer.full3695982,Buffer.data3695982,Buffer._lock3695982));       // (45.9): Loop does not preserve yields_as annotation for field pushLock
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.full(tid : Tid, _this, Buffer.full[_this] ,Lock._state3695982,Lock._lock3695982,Buffer._state3695982,Buffer.popLock3695982,Buffer.pushLock3695982,Buffer.full3695982,Buffer.data3695982,Buffer._lock3695982));       // (45.9): Loop does not preserve yields_as annotation for field full
  invariant (forall _this : Buffer :: Invariant.Y_Buffer.data(tid : Tid, _this, Buffer.data[_this] ,Lock._state3695982,Lock._lock3695982,Buffer._state3695982,Buffer.popLock3695982,Buffer.pushLock3695982,Buffer.full3695982,Buffer.data3695982,Buffer._lock3695982));       // (45.9): Loop does not preserve yields_as annotation for field data
  invariant phase3695982 == $pc;                                                                           // (45.9): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (45.9): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 45.16: boolean tmp7;                                                                           
                                                                                                    
                                                                                                    
  // 45.16: tmp7 = true;                                                                            
                                                                                                    
  tmp7 := true;                                                                                     
  if (!(tmp7)) {                                                                                    
                                                                                                    
   // 45.9: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 49.11: boolean tmp8;                                                                           
                                                                                                    
                                                                                                    
  // 49.11: tmp8 := this.full;                                                                      
                                                                                                    
                                                                                                    
  moverPath3695973 := ReadEval.Buffer.full(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
  mover3695973 := m#moverPath(moverPath3695973);                                                    
  path3695973 := p#moverPath(moverPath3695973);                                                     
  assume Lock._state3695973 == Lock._state && Lock._lock3695973 == Lock._lock && Buffer._state3695973 == Buffer._state && Buffer.popLock3695973 == Buffer.popLock && Buffer.pushLock3695973 == Buffer.pushLock && Buffer.full3695973 == Buffer.full && Buffer.data3695973 == Buffer.data && Buffer._lock3695973 == Buffer._lock && tmp83695973 == tmp8 && tmp73695973 == tmp7 && tmp63695973 == tmp6 && $result3695973 == $result && this3695973 == this && tid3695973 == tid && $pc3695973 == $pc;
  assume $recorded.state3695973 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this != Buffer.null;                                                                      
  } else {                                                                                          
   assert this != Buffer.null;                                                                             // (49.11): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover3695973);                                                             
  assert $pc != PhaseError;                                                                                // (49.11): Reduction failure
  tmp8 := Buffer.full[this];                                                                        
  if (tmp8 /* lowered Buffer.full[this] */) {                                                       
                                                                                                    
   // 49.28: break;                                                                                 
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 50.11: yield;                                                                                  
                                                                                                    
  assume Lock._state3695979 == Lock._state && Lock._lock3695979 == Lock._lock && Buffer._state3695979 == Buffer._state && Buffer.popLock3695979 == Buffer.popLock && Buffer.pushLock3695979 == Buffer.pushLock && Buffer.full3695979 == Buffer.full && Buffer.data3695979 == Buffer.data && Buffer._lock3695979 == Buffer._lock && tmp83695979 == tmp8 && tmp73695979 == tmp7 && tmp63695979 == tmp6 && $result3695979 == $result && this3695979 == this && tid3695979 == tid;
  assume $recorded.state3695979 == 1;                                                               
  assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (50.11): Object invariant may not hold.
  assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (50.11): Object invariant may not hold.
  assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (50.11): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (50.11): Object invariant may not hold.
  assume  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (50.11): Object invariant may not hold.
  assume  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (50.11): Object invariant may not hold.
  $pc := PreCommit;                                                                                 
  assume Lock._state3695979_post == Lock._state && Lock._lock3695979_post == Lock._lock && Buffer._state3695979_post == Buffer._state && Buffer.popLock3695979_post == Buffer.popLock && Buffer.pushLock3695979_post == Buffer.pushLock && Buffer.full3695979_post == Buffer.full && Buffer.data3695979_post == Buffer.data && Buffer._lock3695979_post == Buffer._lock && tmp83695979_post == tmp8 && tmp73695979_post == tmp7 && tmp63695979_post == tmp6 && $result3695979_post == $result && this3695979_post == this && tid3695979_post == tid;
  assume $recorded.state3695979_post == 1;                                                          
  assume Lock._state3695982_bottom == Lock._state && Lock._lock3695982_bottom == Lock._lock && Buffer._state3695982_bottom == Buffer._state && Buffer.popLock3695982_bottom == Buffer.popLock && Buffer.pushLock3695982_bottom == Buffer.pushLock && Buffer.full3695982_bottom == Buffer.full && Buffer.data3695982_bottom == Buffer.data && Buffer._lock3695982_bottom == Buffer._lock && tmp63695982_bottom == tmp6 && $result3695982_bottom == $result && this3695982_bottom == this && tid3695982_bottom == tid;
  assume $recorded.state3695982_bottom == 1;                                                        
  assert phase3695982 == $pc;                                                                              // (45.9): Phase must be invariant at loop head
 }                                                                                                  
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (52.22): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume Buffer._lock[this] == Tid.null;                                                             
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (52.22): Reduction failure
 Buffer._lock[this] := tid;                                                                         
                                                                                                    
 // 53.13: int result;                                                                              
                                                                                                    
                                                                                                    
 // 53.13: result := this.data;                                                                     
                                                                                                    
                                                                                                    
 moverPath3695990 := ReadEval.Buffer.data(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 mover3695990 := m#moverPath(moverPath3695990);                                                     
 path3695990 := p#moverPath(moverPath3695990);                                                      
 assume Lock._state3695990 == Lock._state && Lock._lock3695990 == Lock._lock && Buffer._state3695990 == Buffer._state && Buffer.popLock3695990 == Buffer.popLock && Buffer.pushLock3695990 == Buffer.pushLock && Buffer.full3695990 == Buffer.full && Buffer.data3695990 == Buffer.data && Buffer._lock3695990 == Buffer._lock && result3695990 == result && tmp63695990 == tmp6 && $result3695990 == $result && this3695990 == this && tid3695990 == tid && $pc3695990 == $pc;
 assume $recorded.state3695990 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (53.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover3695990);                                                              
 assert $pc != PhaseError;                                                                                 // (53.13): Reduction failure
 result := Buffer.data[this];                                                                       
                                                                                                    
 // 54.13: boolean tmp9;                                                                            
                                                                                                    
                                                                                                    
 // 54.13: tmp9 = false;                                                                            
                                                                                                    
 tmp9 := false;                                                                                     
                                                                                                    
                                                                                                    
 // 54.13: this.full := tmp9;                                                                       
                                                                                                    
                                                                                                    
 moverPath3696000 := WriteEval.Buffer.full(tid: Tid,this: Buffer,tmp9: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 mover3696000 := m#moverPath(moverPath3696000);                                                     
 path3696000 := p#moverPath(moverPath3696000);                                                      
 assume Lock._state3696000 == Lock._state && Lock._lock3696000 == Lock._lock && Buffer._state3696000 == Buffer._state && Buffer.popLock3696000 == Buffer.popLock && Buffer.pushLock3696000 == Buffer.pushLock && Buffer.full3696000 == Buffer.full && Buffer.data3696000 == Buffer.data && Buffer._lock3696000 == Buffer._lock && tmp93696000 == tmp9 && result3696000 == result && tmp63696000 == tmp6 && $result3696000 == $result && this3696000 == this && tid3696000 == tid && $pc3696000 == $pc;
 assume $recorded.state3696000 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (54.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover3696000);                                                              
 assert $pc != PhaseError;                                                                                 // (54.13): Reduction failure
 Buffer.full[this] := tmp9;                                                                         
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (56.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Buffer._lock[this] == tid;                                                                         // (56.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (56.9): Reduction failure
 Buffer._lock[this] := Tid.null;                                                                    
 if ($pc == PreCommit) {                                                                            
  assume tmp6 != Lock.null;                                                                         
 } else {                                                                                           
  assert tmp6 != Lock.null;                                                                                // (57.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Lock._lock[tmp6] == tid;                                                                           // (57.5): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (57.5): Reduction failure
 Lock._lock[tmp6] := Tid.null;                                                                      
                                                                                                    
 // 55.13:  return result;                                                                          
                                                                                                    
 assume Lock._state3696006 == Lock._state && Lock._lock3696006 == Lock._lock && Buffer._state3696006 == Buffer._state && Buffer.popLock3696006 == Buffer.popLock && Buffer.pushLock3696006 == Buffer.pushLock && Buffer.full3696006 == Buffer.full && Buffer.data3696006 == Buffer.data && Buffer._lock3696006 == Buffer._lock && tmp93696006 == tmp9 && result3696006 == result && tmp63696006 == tmp6 && $result3696006 == $result && this3696006 == this && tid3696006 == tid;
 assume $recorded.state3696006 == 1;                                                                
 $result := result;                                                                                 
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (55.13): Object invariant may not hold.
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (55.13): Object invariant may not hold.
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (55.13): Object invariant may not hold.
 return;                                                                                            
 if ($pc == PreCommit) {                                                                            
  assume this != Buffer.null;                                                                       
 } else {                                                                                           
  assert this != Buffer.null;                                                                              // (56.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Buffer._lock[this] == tid;                                                                         // (56.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (56.9): Reduction failure
 Buffer._lock[this] := Tid.null;                                                                    
 if ($pc == PreCommit) {                                                                            
  assume tmp6 != Lock.null;                                                                         
 } else {                                                                                           
  assert tmp6 != Lock.null;                                                                                // (57.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert Lock._lock[tmp6] == tid;                                                                           // (57.5): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (57.5): Reduction failure
 Lock._lock[tmp6] := Tid.null;                                                                      
                                                                                                    
 // 43.20: // return -1;                                                                            
                                                                                                    
 assume Lock._state3696018 == Lock._state && Lock._lock3696018 == Lock._lock && Buffer._state3696018 == Buffer._state && Buffer.popLock3696018 == Buffer.popLock && Buffer.pushLock3696018 == Buffer.pushLock && Buffer.full3696018 == Buffer.full && Buffer.data3696018 == Buffer.data && Buffer._lock3696018 == Buffer._lock && tmp63696018 == tmp6 && $result3696018 == $result && this3696018 == this && tid3696018 == tid;
 assume $recorded.state3696018 == 1;                                                                
 $result := -1;                                                                                     
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (43.20): Object invariant may not hold.
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (43.20): Object invariant may not hold.
 assert  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (43.20): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Lock._state: [Lock]State,Lock._lock: [Lock]Tid,Buffer._state: [Buffer]State,Buffer.popLock: [Buffer]Lock,Buffer.pushLock: [Buffer]Lock,Buffer.full: [Buffer]bool,Buffer.data: [Buffer]int,Buffer._lock: [Buffer]Tid) returns (bool) {
  true &&                                                                                           
  (forall _i: Lock  :: _i == Lock.null <==> isNull(Lock._state[_i])) &&                             
  (forall _i: Buffer  :: _i == Buffer.null <==> isNull(Buffer._state[_i])) &&                       
  (forall _i: Buffer ::  (isShared(Buffer._state[_i]) ==> isSharedAssignable(Lock._state[Buffer.popLock[_i]]))) &&
  (forall _i: Buffer ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Buffer._state[_i],_t) ==> isLocalAssignable(Lock._state[Buffer.popLock[_i]], _t)))) &&
  (forall _i: Buffer ::  (isShared(Buffer._state[_i]) ==> isSharedAssignable(Lock._state[Buffer.pushLock[_i]]))) &&
  (forall _i: Buffer ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Buffer._state[_i],_t) ==> isLocalAssignable(Lock._state[Buffer.pushLock[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)  
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.popLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.3): Buffer.popLock failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)   
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Buffer.popLock(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (5.3): Buffer.popLock failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)   
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Lock;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.popLock[x];                                                                     
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Buffer.popLock[x] := havocValue;                                                                   
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.popLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.3): Buffer.popLock failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)    
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Lock;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.popLock[x];                                                                     
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Buffer.popLock(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (5.3): Buffer.popLock failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)        
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Buffer.popLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.3): Buffer.popLock failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)         
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Lock;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Buffer.popLock[x];                                                                     
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Buffer.popLock[x] := havocValue;                                                                   
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Buffer.popLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.3): Buffer.popLock failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer) 
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.3): Buffer.pushLock failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)  
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Buffer.pushLock(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (6.3): Buffer.pushLock failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)  
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Lock;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.pushLock[x];                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Buffer.pushLock[x] := havocValue;                                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.3): Buffer.pushLock failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)   
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Lock;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.pushLock[x];                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Buffer.pushLock(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (6.3): Buffer.pushLock failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)       
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.3): Buffer.pushLock failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, x: Buffer)        
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Lock;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Buffer.pushLock[x];                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Buffer.pushLock[x] := havocValue;                                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,x: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.3): Buffer.pushLock failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, x: Buffer)     
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.full(u: Tid,x: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (8.2): Buffer.full failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, x: Buffer)      
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Buffer.full(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (8.2): Buffer.full failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, x: Buffer)      
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.full[x];                                                                        
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Buffer.full[x] := havocValue;                                                                      
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.full(u: Tid,x: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (8.2): Buffer.full failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, x: Buffer)       
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : bool;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.full[x];                                                                        
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Buffer.full(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (8.2): Buffer.full failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, x: Buffer)           
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Buffer.full(u: Tid,x: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (8.2): Buffer.full failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, x: Buffer)            
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Buffer.full[x];                                                                        
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Buffer.full[x] := havocValue;                                                                      
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Buffer.full(u: Tid,x: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (8.2): Buffer.full failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Buffer.data(t: Tid, u: Tid, v: int, w: int, x: Buffer)       
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.data(u: Tid,x: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (15.3): Buffer.data failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Buffer.data(t: Tid, u: Tid, v: int, w: int, x: Buffer)        
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Buffer.data(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (15.3): Buffer.data failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Buffer.data(t: Tid, u: Tid, v: int, w: int, x: Buffer)        
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.data[x];                                                                        
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Buffer.data[x] := havocValue;                                                                      
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Buffer.data(u: Tid,x: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (15.3): Buffer.data failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Buffer.data(t: Tid, u: Tid, v: int, w: int, x: Buffer)         
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Buffer.data[x];                                                                        
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Buffer.data(u: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (15.3): Buffer.data failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Buffer.data(t: Tid, u: Tid, v: int, w: int, x: Buffer)             
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Buffer.data(u: Tid,x: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (15.3): Buffer.data failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Buffer.data(t: Tid, u: Tid, v: int, w: int, x: Buffer)              
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[x], u);                                                        
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Buffer.data[x];                                                                        
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Buffer.data[x] := havocValue;                                                                      
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Buffer.data(u: Tid,x: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (15.3): Buffer.data failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.popLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.popLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.popLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.popLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[y] := w;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.popLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.popLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.popLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.popLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.popLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.popLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.popLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.popLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.popLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.popLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.popLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[y] := w;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.pushLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.pushLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.pushLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.popLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.popLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.popLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.popLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.popLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.popLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.popLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.popLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.full (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.full (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.full (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.popLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.popLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.popLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.popLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.popLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.popLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.popLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.popLock[x];                                                                         
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.popLock[x] := tmpV;                                                                         
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.popLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.popLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.data (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.data (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.data (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.popLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.popLock;                                                                           
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.popLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[x] := v;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.popLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.popLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.popLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.pushLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.pushLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.pushLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.pushLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[y] := w;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.popLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.popLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.popLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.pushLock.Buffer.popLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.pushLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.pushLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.pushLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.pushLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.pushLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.pushLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.pushLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[y] := w;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.pushLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.pushLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.pushLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.pushLock.Buffer.pushLock(t: Tid, u: Tid, v: Lock, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.pushLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.pushLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.pushLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.pushLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.pushLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.pushLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.pushLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.full (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.full (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.full (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.pushLock.Buffer.full(t: Tid, u: Tid, v: Lock, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.pushLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.pushLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.pushLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.pushLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.pushLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.pushLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Lock;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var v_mid: Lock;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.pushLock[x];                                                                        
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.pushLock[x] := tmpV;                                                                        
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.pushLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.pushLock(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.data (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.data (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.data (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.pushLock.Buffer.data(t: Tid, u: Tid, v: Lock, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.pushLock;                                                                          
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var v_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var v_post: Lock;                                                                                  
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.pushLock(t: Tid,x: Buffer,v: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[x] := v;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.pushLock (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.pushLock (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.pushLock (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.full.Buffer.popLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.full.Buffer.popLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.full.Buffer.popLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.full.Buffer.popLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[y] := w;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.popLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.popLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.popLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.full.Buffer.popLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.full (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.full (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.full (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.full.Buffer.pushLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.full.Buffer.pushLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.full.Buffer.pushLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.full.Buffer.pushLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[y] := w;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.pushLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.pushLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.pushLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.full.Buffer.pushLock(t: Tid, u: Tid, v: bool, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.full (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.full (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.full (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.full.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.full (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.full (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.full (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.full.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.full (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.full.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.full (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.full (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.full.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.full (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.full (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.full (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.full.Buffer.full(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.full (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.full (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.full (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.full.Buffer.data(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.full.Buffer.data(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.data (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.full.Buffer.data(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var v_mid: bool;                                                                                   
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.full[x];                                                                            
 Buffer.full[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.full[x] := tmpV;                                                                            
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.data (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.data (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.full.Buffer.data(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.full(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.data (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.data (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.data (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.full.Buffer.data(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.full;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Buffer.full_post: [Buffer]bool;                                                                
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.full(t: Tid,x: Buffer,v: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.full (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.full (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.full (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.data.Buffer.popLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.data.Buffer.popLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.data.Buffer.popLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.popLock[y] := w;                                                                            
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.data.Buffer.popLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.popLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.popLock[y] := w;                                                                            
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.popLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.popLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.popLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.data.Buffer.popLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.popLock;                                                                           
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.popLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.data (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.data (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.data (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.data.Buffer.pushLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.data.Buffer.pushLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.data.Buffer.pushLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var t_mid: Tid;                                                                                    
 var w0_mid: Lock;                                                                                  
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w_mid: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.pushLock[y] := w;                                                                           
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.data.Buffer.pushLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.pushLock(u: Tid,y: Buffer,w: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.pushLock[y] := w;                                                                           
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.pushLock (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.pushLock (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.pushLock (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.data.Buffer.pushLock(t: Tid, u: Tid, v: int, w: Lock, w0: Lock, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.pushLock;                                                                          
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var w0_pre: Lock;                                                                                  
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
 var w_pre: Lock;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var w_post: Lock;                                                                                  
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var w0_post: Lock;                                                                                 
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.pushLock(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.data (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.data (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.data (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.data.Buffer.full(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.data (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.data (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.data (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.data.Buffer.full(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.data.Buffer.full(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var w0_mid: bool;                                                                                  
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var w_mid: bool;                                                                                   
 var $pc_mid: Phase;                                                                                
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.full[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.data.Buffer.full(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.full(u: Tid,y: Buffer,w: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.full[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.full (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.full (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.full (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.data.Buffer.full(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.full;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var w_pre: bool;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var Buffer._state_pre: [Buffer]State;                                                              
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var w0_pre: bool;                                                                                  
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var w_post: bool;                                                                                  
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.full(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.data (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.data (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.data (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Buffer.data.Buffer.data(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Buffer.data.Buffer.data(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
                                                                                                    
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Buffer.data.Buffer.data(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Buffer.full_mid: [Buffer]bool;                                                                 
 var Buffer.data_mid: [Buffer]int;                                                                  
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Buffer.popLock_mid: [Buffer]Lock;                                                              
 var Lock._state_mid: [Lock]State;                                                                  
 var w_mid: int;                                                                                    
 var Lock._lock_mid: [Lock]Tid;                                                                     
 var Buffer._lock_mid: [Buffer]Tid;                                                                 
 var x_mid: Buffer;                                                                                 
 var Buffer._state_mid: [Buffer]State;                                                              
 var y_mid: Buffer;                                                                                 
 var Buffer.pushLock_mid: [Buffer]Lock;                                                             
 var v_mid: int;                                                                                    
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Buffer.data[x];                                                                            
 Buffer.data[x] := v;                                                                               
 assume Lock._state_mid == Lock._state && Lock._lock_mid == Lock._lock && Buffer._state_mid == Buffer._state && Buffer.popLock_mid == Buffer.popLock && Buffer.pushLock_mid == Buffer.pushLock && Buffer.full_mid == Buffer.full && Buffer.data_mid == Buffer.data && Buffer._lock_mid == Buffer._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Buffer.data[x] := tmpV;                                                                            
 Buffer.data[y] := w;                                                                               
 _writeByTPost := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Buffer.data.Buffer.data(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Buffer.data(u: Tid,y: Buffer,w: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[y] := w;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Buffer.data(t: Tid,x: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.data (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.data (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.data (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Buffer.data.Buffer.data(t: Tid, u: Tid, v: int, w: int, w0: int, x: Buffer, y: Buffer)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Buffer._state[x], t);                                                        
 requires isAccessible(Buffer._state[y], u);                                                        
 modifies Buffer.data;                                                                              
 modifies Buffer.data;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Buffer.pushLock_pre: [Buffer]Lock;                                                             
 var v_pre: int;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var Buffer.data_pre: [Buffer]int;                                                                  
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Buffer._state_pre: [Buffer]State;                                                              
 var w_pre: int;                                                                                    
 var Lock._lock_pre: [Lock]Tid;                                                                     
 var y_pre: Buffer;                                                                                 
 var Buffer.full_pre: [Buffer]bool;                                                                 
 var Buffer.popLock_pre: [Buffer]Lock;                                                              
 var Buffer._lock_pre: [Buffer]Tid;                                                                 
 var $pc_pre: Phase;                                                                                
 var x_pre: Buffer;                                                                                 
 var Lock._state_pre: [Lock]State;                                                                  
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Buffer._lock_post: [Buffer]Tid;                                                                
 var Lock._lock_post: [Lock]Tid;                                                                    
 var Lock._state_post: [Lock]State;                                                                 
 var Buffer.popLock_post: [Buffer]Lock;                                                             
 var $recorded.state_post: int;                                                                     
 var Buffer._state_post: [Buffer]State;                                                             
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Buffer.data_post: [Buffer]int;                                                                 
 var x_post: Buffer;                                                                                
 var $pc_post: Phase;                                                                               
 var y_post: Buffer;                                                                                
 var w_post: int;                                                                                   
 var Buffer.full_post: [Buffer]bool;                                                                
 var v_post: int;                                                                                   
 var Buffer.pushLock_post: [Buffer]Lock;                                                            
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Buffer.data(t: Tid,x: Buffer,v: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Buffer.data[x] := v;                                                                               
 assume Lock._state_post == Lock._state && Lock._lock_post == Lock._lock && Buffer._state_post == Buffer._state && Buffer.popLock_post == Buffer.popLock && Buffer.pushLock_post == Buffer.pushLock && Buffer.full_post == Buffer.full && Buffer.data_post == Buffer.data && Buffer._lock_post == Buffer._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Buffer.data(u: Tid,y: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.data (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.data (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.data (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
requires ValidTid(tid);                                                                             
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (<undefined position>): Object invariant may not hold.
modifies Lock._state;                                                                               
modifies Lock._lock;                                                                                
modifies Buffer._state;                                                                             
modifies Buffer.popLock;                                                                            
modifies Buffer.pushLock;                                                                           
modifies Buffer.full;                                                                               
modifies Buffer.data;                                                                               
modifies Buffer._lock;                                                                              
ensures StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
ensures Y(tid , old(Lock._state), old(Lock._lock), old(Buffer._state), old(Buffer.popLock), old(Buffer.pushLock), old(Buffer.full), old(Buffer.data), old(Buffer._lock) , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
ensures  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// Lock._lock:                                                                                      
                                                                                                    
function {:inline} Y_Lock._lock(tid : Tid, this: Lock, newValue: Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 ((isAccessible(Lock._state[this], tid) && leq(m#moverPath(ReadEval.Lock._lock(tid: Tid,this: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _R)) ==> (Lock._lock[this] == newValue))
 &&(((Lock._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Lock._lock(tid : Tid, this: Lock, newValue: Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Lock._lock.Subsumes.W(tid : Tid, u : Tid, this: Lock, newValue: Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var newValue_yield: Tid;                                                                            
var tid_yield: Tid;                                                                                 
var this_yield: Lock;                                                                               
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var u_yield: Tid;                                                                                   
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Lock._state[this], tid);                                                       
 assume isAccessible(Lock._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Lock._lock(u: Tid,this: Lock,newValue: Tid,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)));
 assume leq(m#moverPath(ReadEval.Lock._lock(tid: Tid,this: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _N);
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Lock._lock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Lock._lock.Reflexive(tid : Tid, this: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var this_yield: Lock;                                                                               
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Lock._state[this], tid);                                                       
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Lock._lock(tid, this, Lock._lock[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Lock._lock.Transitive(tid : Tid, this: Lock, newValue : Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires StateInvariant(Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (2.1): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (2.1): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (2.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Buffer.pushLock_pre: [Buffer]Lock;                                                              
var this_pre: Lock;                                                                                 
var $recorded.state_pre: int;                                                                       
var Buffer.data_pre: [Buffer]int;                                                                   
var Buffer._state_pre: [Buffer]State;                                                               
var Lock._lock_pre: [Lock]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var Buffer.full_pre: [Buffer]bool;                                                                  
var Buffer.popLock_pre: [Buffer]Lock;                                                               
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Lock._state_pre: [Lock]State;                                                                   
var newValue_pre: Tid;                                                                              
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var Lock._lock_post: [Lock]Tid;                                                                     
var Lock._state_post: [Lock]State;                                                                  
var Buffer.popLock_post: [Buffer]Lock;                                                              
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Buffer.data_post: [Buffer]int;                                                                  
var $pc_post: Phase;                                                                                
var tid_post: Tid;                                                                                  
var this_post: Lock;                                                                                
var Buffer.full_post: [Buffer]bool;                                                                 
var newValue_post: Tid;                                                                             
var Buffer.pushLock_post: [Buffer]Lock;                                                             
                                                                                                    
assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Lock._state[this], tid);                                                       
 assume Y(tid , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 assume Y_Lock._lock(tid, this, newValue , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
assume Lock._state_post == Lock._state_p && Lock._lock_post == Lock._lock_p && Buffer._state_post == Buffer._state_p && Buffer.popLock_post == Buffer.popLock_p && Buffer.pushLock_post == Buffer.pushLock_p && Buffer.full_post == Buffer.full_p && Buffer.data_post == Buffer.data_p && Buffer._lock_post == Buffer._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Lock._lock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
// Buffer.popLock:                                                                                  
                                                                                                    
function {:inline} Y_Buffer.popLock(tid : Tid, this: Buffer, newValue: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer.popLock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _R)) ==> (Buffer.popLock[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer.popLock(tid : Tid, this: Buffer, newValue: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer.popLock.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var u_yield: Tid;                                                                                   
var Lock._state_yield: [Lock]State;                                                                 
var newValue_yield: Lock;                                                                           
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer.popLock(u: Tid,this: Buffer,newValue: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)));
                                                                                                    
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.popLock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.popLock.Reflexive(tid : Tid, this: Buffer , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.popLock(tid, this, Buffer.popLock[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.popLock.Transitive(tid : Tid, this: Buffer, newValue : Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires StateInvariant(Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (5.31): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (5.31): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (5.31): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Buffer.pushLock_pre: [Buffer]Lock;                                                              
var $recorded.state_pre: int;                                                                       
var Buffer.data_pre: [Buffer]int;                                                                   
var Buffer._state_pre: [Buffer]State;                                                               
var Lock._lock_pre: [Lock]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Buffer.full_pre: [Buffer]bool;                                                                  
var Buffer.popLock_pre: [Buffer]Lock;                                                               
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var newValue_pre: Lock;                                                                             
var Lock._state_pre: [Lock]State;                                                                   
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var Lock._lock_post: [Lock]Tid;                                                                     
var Lock._state_post: [Lock]State;                                                                  
var Buffer.popLock_post: [Buffer]Lock;                                                              
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Buffer.data_post: [Buffer]int;                                                                  
var this_post: Buffer;                                                                              
var $pc_post: Phase;                                                                                
var tid_post: Tid;                                                                                  
var Buffer.full_post: [Buffer]bool;                                                                 
var newValue_post: Lock;                                                                            
var Buffer.pushLock_post: [Buffer]Lock;                                                             
                                                                                                    
assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 assume Y_Buffer.popLock(tid, this, newValue , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
assume Lock._state_post == Lock._state_p && Lock._lock_post == Lock._lock_p && Buffer._state_post == Buffer._state_p && Buffer.popLock_post == Buffer.popLock_p && Buffer.pushLock_post == Buffer.pushLock_p && Buffer.full_post == Buffer.full_p && Buffer.data_post == Buffer.data_p && Buffer._lock_post == Buffer._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer.popLock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
// Buffer.pushLock:                                                                                 
                                                                                                    
function {:inline} Y_Buffer.pushLock(tid : Tid, this: Buffer, newValue: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer.pushLock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _R)) ==> (Buffer.pushLock[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer.pushLock(tid : Tid, this: Buffer, newValue: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer.pushLock.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var u_yield: Tid;                                                                                   
var Lock._state_yield: [Lock]State;                                                                 
var newValue_yield: Lock;                                                                           
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer.pushLock(u: Tid,this: Buffer,newValue: Lock,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)));
                                                                                                    
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.pushLock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.pushLock.Reflexive(tid : Tid, this: Buffer , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.pushLock(tid, this, Buffer.pushLock[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.pushLock.Transitive(tid : Tid, this: Buffer, newValue : Lock , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires StateInvariant(Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (6.31): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (6.31): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (6.31): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Buffer.pushLock_pre: [Buffer]Lock;                                                              
var $recorded.state_pre: int;                                                                       
var Buffer.data_pre: [Buffer]int;                                                                   
var Buffer._state_pre: [Buffer]State;                                                               
var Lock._lock_pre: [Lock]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Buffer.full_pre: [Buffer]bool;                                                                  
var Buffer.popLock_pre: [Buffer]Lock;                                                               
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var newValue_pre: Lock;                                                                             
var Lock._state_pre: [Lock]State;                                                                   
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var Lock._lock_post: [Lock]Tid;                                                                     
var Lock._state_post: [Lock]State;                                                                  
var Buffer.popLock_post: [Buffer]Lock;                                                              
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Buffer.data_post: [Buffer]int;                                                                  
var this_post: Buffer;                                                                              
var $pc_post: Phase;                                                                                
var tid_post: Tid;                                                                                  
var Buffer.full_post: [Buffer]bool;                                                                 
var newValue_post: Lock;                                                                            
var Buffer.pushLock_post: [Buffer]Lock;                                                             
                                                                                                    
assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 assume Y_Buffer.pushLock(tid, this, newValue , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
assume Lock._state_post == Lock._state_p && Lock._lock_post == Lock._lock_p && Buffer._state_post == Buffer._state_p && Buffer.popLock_post == Buffer.popLock_p && Buffer.pushLock_post == Buffer.pushLock_p && Buffer.full_post == Buffer.full_p && Buffer.data_post == Buffer.data_p && Buffer._lock_post == Buffer._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer.pushLock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
// Buffer.full:                                                                                     
                                                                                                    
function {:inline} Y_Buffer.full(tid : Tid, this: Buffer, newValue: bool , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer.full(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _R)) ==> (Buffer.full[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer.full(tid : Tid, this: Buffer, newValue: bool , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer.full.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: bool , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var newValue_yield: bool;                                                                           
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var u_yield: Tid;                                                                                   
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer.full(u: Tid,this: Buffer,newValue: bool,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)));
                                                                                                    
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.full(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.full.Reflexive(tid : Tid, this: Buffer , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.full(tid, this, Buffer.full[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.full.Transitive(tid : Tid, this: Buffer, newValue : bool , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires StateInvariant(Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (8.43): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (8.43): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (8.43): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Buffer.pushLock_pre: [Buffer]Lock;                                                              
var newValue_pre: bool;                                                                             
var $recorded.state_pre: int;                                                                       
var Buffer.data_pre: [Buffer]int;                                                                   
var Buffer._state_pre: [Buffer]State;                                                               
var Lock._lock_pre: [Lock]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Buffer.full_pre: [Buffer]bool;                                                                  
var Buffer.popLock_pre: [Buffer]Lock;                                                               
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Lock._state_pre: [Lock]State;                                                                   
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var Lock._lock_post: [Lock]Tid;                                                                     
var Lock._state_post: [Lock]State;                                                                  
var Buffer.popLock_post: [Buffer]Lock;                                                              
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Buffer.data_post: [Buffer]int;                                                                  
var this_post: Buffer;                                                                              
var $pc_post: Phase;                                                                                
var tid_post: Tid;                                                                                  
var Buffer.full_post: [Buffer]bool;                                                                 
var newValue_post: bool;                                                                            
var Buffer.pushLock_post: [Buffer]Lock;                                                             
                                                                                                    
assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 assume Y_Buffer.full(tid, this, newValue , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
assume Lock._state_post == Lock._state_p && Lock._lock_post == Lock._lock_p && Buffer._state_post == Buffer._state_p && Buffer.popLock_post == Buffer.popLock_p && Buffer.pushLock_post == Buffer.pushLock_p && Buffer.full_post == Buffer.full_p && Buffer.data_post == Buffer.data_p && Buffer._lock_post == Buffer._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer.full(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
// Buffer.data:                                                                                     
                                                                                                    
function {:inline} Y_Buffer.data(tid : Tid, this: Buffer, newValue: int , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer.data(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _R)) ==> (Buffer.data[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer.data(tid : Tid, this: Buffer, newValue: int , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer.data.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: int , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var newValue_yield: int;                                                                            
var Buffer.data_yield: [Buffer]int;                                                                 
var u_yield: Tid;                                                                                   
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer.data(u: Tid,this: Buffer,newValue: int,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)));
                                                                                                    
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.data(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.data.Reflexive(tid : Tid, this: Buffer , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer.data(tid, this, Buffer.data[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer.data.Transitive(tid : Tid, this: Buffer, newValue : int , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires StateInvariant(Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (15.40): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (15.40): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (15.40): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Buffer.pushLock_pre: [Buffer]Lock;                                                              
var $recorded.state_pre: int;                                                                       
var Buffer.data_pre: [Buffer]int;                                                                   
var Buffer._state_pre: [Buffer]State;                                                               
var newValue_pre: int;                                                                              
var Lock._lock_pre: [Lock]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Buffer.full_pre: [Buffer]bool;                                                                  
var Buffer.popLock_pre: [Buffer]Lock;                                                               
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Lock._state_pre: [Lock]State;                                                                   
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var Lock._lock_post: [Lock]Tid;                                                                     
var Lock._state_post: [Lock]State;                                                                  
var Buffer.popLock_post: [Buffer]Lock;                                                              
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Buffer.data_post: [Buffer]int;                                                                  
var this_post: Buffer;                                                                              
var newValue_post: int;                                                                             
var $pc_post: Phase;                                                                                
var tid_post: Tid;                                                                                  
var Buffer.full_post: [Buffer]bool;                                                                 
var Buffer.pushLock_post: [Buffer]Lock;                                                             
                                                                                                    
assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 assume Y_Buffer.data(tid, this, newValue , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
assume Lock._state_post == Lock._state_p && Lock._lock_post == Lock._lock_p && Buffer._state_post == Buffer._state_p && Buffer.popLock_post == Buffer.popLock_p && Buffer.pushLock_post == Buffer.pushLock_p && Buffer.full_post == Buffer.full_p && Buffer.data_post == Buffer.data_p && Buffer._lock_post == Buffer._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer.data(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
// Buffer._lock:                                                                                    
                                                                                                    
function {:inline} Y_Buffer._lock(tid : Tid, this: Buffer, newValue: Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 ((isAccessible(Buffer._state[this], tid) && leq(m#moverPath(ReadEval.Buffer._lock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _R)) ==> (Buffer._lock[this] == newValue))
 &&(((Buffer._lock[this]==tid)==(newValue==tid)))                                                   
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Buffer._lock(tid : Tid, this: Buffer, newValue: Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Buffer._lock.Subsumes.W(tid : Tid, u : Tid, this: Buffer, newValue: Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var newValue_yield: Tid;                                                                            
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var u_yield: Tid;                                                                                   
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume isAccessible(Buffer._state[this], u);                                                       
 assume !isError(m#moverPath(WriteEval.Buffer._lock(u: Tid,this: Buffer,newValue: Tid,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)));
 assume leq(m#moverPath(ReadEval.Buffer._lock(tid: Tid,this: Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock)), _N);
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer._lock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer._lock.Reflexive(tid : Tid, this: Buffer , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Lock._lock_yield: [Lock]Tid;                                                                    
var tid_yield: Tid;                                                                                 
var Buffer._lock_yield: [Buffer]Tid;                                                                
var Buffer.popLock_yield: [Buffer]Lock;                                                             
var $pc_yield: Phase;                                                                               
var Buffer.data_yield: [Buffer]int;                                                                 
var Lock._state_yield: [Lock]State;                                                                 
var Buffer._state_yield: [Buffer]State;                                                             
var Buffer.pushLock_yield: [Buffer]Lock;                                                            
var this_yield: Buffer;                                                                             
var $recorded.state_yield: int;                                                                     
var Buffer.full_yield: [Buffer]bool;                                                                
                                                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
assume Lock._state_yield == Lock._state && Lock._lock_yield == Lock._lock && Buffer._state_yield == Buffer._state && Buffer.popLock_yield == Buffer.popLock && Buffer.pushLock_yield == Buffer.pushLock && Buffer.full_yield == Buffer.full && Buffer.data_yield == Buffer.data && Buffer._lock_yield == Buffer._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Buffer._lock(tid, this, Buffer._lock[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
procedure Y_Buffer._lock.Transitive(tid : Tid, this: Buffer, newValue : Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid)
 requires StateInvariant(Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
 requires StateInvariant(Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689920(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689928(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : Buffer ::  { Buffer._state[_this] } isAccessible(Buffer._state[_this], tid) && true ==> Invariant.Buffer.3689936(tid: Tid,_this : Buffer,Lock._state,Lock._lock,Buffer._state,Buffer.popLock,Buffer.pushLock,Buffer.full,Buffer.data,Buffer._lock));       // (4.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Buffer.pushLock_pre: [Buffer]Lock;                                                              
var $recorded.state_pre: int;                                                                       
var Buffer.data_pre: [Buffer]int;                                                                   
var Buffer._state_pre: [Buffer]State;                                                               
var Lock._lock_pre: [Lock]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var this_pre: Buffer;                                                                               
var Buffer.full_pre: [Buffer]bool;                                                                  
var Buffer.popLock_pre: [Buffer]Lock;                                                               
var Buffer._lock_pre: [Buffer]Tid;                                                                  
var $pc_pre: Phase;                                                                                 
var Lock._state_pre: [Lock]State;                                                                   
var newValue_pre: Tid;                                                                              
                                                                                                    
var Buffer._lock_post: [Buffer]Tid;                                                                 
var Lock._lock_post: [Lock]Tid;                                                                     
var Lock._state_post: [Lock]State;                                                                  
var Buffer.popLock_post: [Buffer]Lock;                                                              
var $recorded.state_post: int;                                                                      
var Buffer._state_post: [Buffer]State;                                                              
var Buffer.data_post: [Buffer]int;                                                                  
var this_post: Buffer;                                                                              
var $pc_post: Phase;                                                                                
var tid_post: Tid;                                                                                  
var Buffer.full_post: [Buffer]bool;                                                                 
var newValue_post: Tid;                                                                             
var Buffer.pushLock_post: [Buffer]Lock;                                                             
                                                                                                    
assume Lock._state_pre == Lock._state && Lock._lock_pre == Lock._lock && Buffer._state_pre == Buffer._state && Buffer.popLock_pre == Buffer.popLock && Buffer.pushLock_pre == Buffer.pushLock && Buffer.full_pre == Buffer.full && Buffer.data_pre == Buffer.data && Buffer._lock_pre == Buffer._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Buffer._state[this], tid);                                                     
 assume Y(tid , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
 assume Y_Buffer._lock(tid, this, newValue , Lock._state_p, Lock._lock_p, Buffer._state_p, Buffer.popLock_p, Buffer.pushLock_p, Buffer.full_p, Buffer.data_p, Buffer._lock_p);
assume Lock._state_post == Lock._state_p && Lock._lock_post == Lock._lock_p && Buffer._state_post == Buffer._state_p && Buffer.popLock_post == Buffer.popLock_p && Buffer.pushLock_post == Buffer.pushLock_p && Buffer.full_post == Buffer.full_p && Buffer.data_post == Buffer.data_p && Buffer._lock_post == Buffer._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Buffer._lock(tid, this, newValue , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock);
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Lock._state: [Lock]State, Lock._lock: [Lock]Tid, Buffer._state: [Buffer]State, Buffer.popLock: [Buffer]Lock, Buffer.pushLock: [Buffer]Lock, Buffer.full: [Buffer]bool, Buffer.data: [Buffer]int, Buffer._lock: [Buffer]Tid , Lock._state_p: [Lock]State, Lock._lock_p: [Lock]Tid, Buffer._state_p: [Buffer]State, Buffer.popLock_p: [Buffer]Lock, Buffer.pushLock_p: [Buffer]Lock, Buffer.full_p: [Buffer]bool, Buffer.data_p: [Buffer]int, Buffer._lock_p: [Buffer]Tid): bool
{                                                                                                   
 (forall this: Lock :: Y_Lock._lock(tid : Tid, this, Lock._lock_p[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock))
 && (forall this: Buffer :: Y_Buffer.popLock(tid : Tid, this, Buffer.popLock_p[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock))
 && (forall this: Buffer :: Y_Buffer.pushLock(tid : Tid, this, Buffer.pushLock_p[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock))
 && (forall this: Buffer :: Y_Buffer.full(tid : Tid, this, Buffer.full_p[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock))
 && (forall this: Buffer :: Y_Buffer.data(tid : Tid, this, Buffer.data_p[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock))
 && (forall this: Buffer :: Y_Buffer._lock(tid : Tid, this, Buffer._lock_p[this] , Lock._state, Lock._lock, Buffer._state, Buffer.popLock, Buffer.pushLock, Buffer.full, Buffer.data, Buffer._lock))
 && (forall _i : Lock :: isShared(Lock._state[_i]) ==> isShared(Lock._state_p[_i]))                 
 && (forall _i : Lock :: isLocal(Lock._state[_i], tid) <==> isLocal(Lock._state_p[_i], tid))        
 && (forall _i : Buffer :: isShared(Buffer._state[_i]) ==> isShared(Buffer._state_p[_i]))           
 && (forall _i : Buffer :: isLocal(Buffer._state[_i], tid) <==> isLocal(Buffer._state_p[_i], tid))  
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 1195.1-1587.2: (Method:23.3)
// 1207.1-1207.24: (23.3): Bad tid
// 1208.1-1208.40: (23.3): this is not global
// 1215.1-1215.271: (23.3): Object invariant may not hold.
// 1216.1-1216.271: (23.3): Object invariant may not hold.
// 1217.1-1217.271: (23.3): Object invariant may not hold.
// 1220.1-1220.270: (23.3): Object invariant may not hold.
// 1221.1-1221.270: (23.3): Object invariant may not hold.
// 1222.1-1222.270: (23.3): Object invariant may not hold.
// 1382.1-1382.190: (23.12): Can only have right-mover memory accesses in requires clause
// 1383.1-1383.191: (24.12): Can only have right-mover memory accesses in requires clause
// 1385.2-1387.2: (class anchor.sink.VarDeclStmt:26.5)
// 1388.2-1405.32: (class anchor.sink.Read:26.5)
// 1400.1-1400.30: (26.5): Cannot have potential null deference in left-mover part.
// 1404.1-1404.27: (26.5): Reduction failure
// 1409.1-1409.28: (26.18): Cannot have potential null deference in left-mover part.
// 1413.1-1413.27: (26.18): Reduction failure
// 1417.2-1421.14: (class anchor.sink.While:27.9)
// 1423.1-1423.27: (23.3): Bad tid
// 1424.1-1424.43: (23.3): this is not global
// 1427.1-1427.274: (27.9): Object invariant may not hold.
// 1428.1-1428.274: (27.9): Object invariant may not hold.
// 1429.1-1429.274: (27.9): Object invariant may not hold.
// 1429.274-1430.113: (27.9): invariant holds(this.pushLock, tid) may not hold
// 1430.113-1431.114: (27.9): invariant !holds(this.popLock, tid) may not hold
// 1431.114-1432.79: (27.9): invariant holds(tmp1, tid) may not hold
// 1433.1-1433.270: (27.9): Loop does not preserve yields_as annotation for field popLock
// 1434.1-1434.272: (27.9): Loop does not preserve yields_as annotation for field pushLock
// 1435.1-1435.264: (27.9): Loop does not preserve yields_as annotation for field full
// 1436.1-1436.264: (27.9): Loop does not preserve yields_as annotation for field data
// 1437.1-1437.33: (27.9): Phase must be invariant at loop head
// 1438.1-1438.30: (27.9): Potentially infinite loop cannot be in post-commit phase.
// 1440.3-1442.3: (class anchor.sink.VarDeclStmt:27.16)
// 1443.3-1446.16: (class anchor.sink.Assign:27.16)
// 1448.4-1451.10: (class anchor.sink.Break:27.9)
// 1454.3-1456.3: (class anchor.sink.VarDeclStmt:31.11)
// 1457.3-1459.3: (class anchor.sink.VarDeclStmt:31.11)
// 1460.3-1477.29: (class anchor.sink.Read:31.11)
// 1472.1-1472.31: (31.11): Cannot have potential null deference in left-mover part.
// 1476.1-1476.28: (31.11): Reduction failure
// 1478.3-1481.19: (class anchor.sink.Assign:31.11)
// 1483.4-1486.10: (class anchor.sink.Break:31.29)
// 1489.3-1503.43: (class anchor.sink.Yield:32.11)
// 1494.1-1494.271: (32.11): Object invariant may not hold.
// 1495.1-1495.271: (32.11): Object invariant may not hold.
// 1496.1-1496.271: (32.11): Object invariant may not hold.
// 1498.1-1498.271: (32.11): Object invariant may not hold.
// 1499.1-1499.271: (32.11): Object invariant may not hold.
// 1500.1-1500.271: (32.11): Object invariant may not hold.
// 1506.1-1506.30: (27.9): Phase must be invariant at loop head
// 1511.1-1511.30: (34.22): Cannot have potential null deference in left-mover part.
// 1515.1-1515.27: (34.22): Reduction failure
// 1518.2-1534.25: (class anchor.sink.Write:35.13)
// 1530.1-1530.30: (35.13): Cannot have potential null deference in left-mover part.
// 1533.1-1533.27: (35.13): Reduction failure
// 1535.2-1537.2: (class anchor.sink.VarDeclStmt:36.13)
// 1538.2-1541.15: (class anchor.sink.Assign:36.13)
// 1543.2-1559.28: (class anchor.sink.Write:36.13)
// 1555.1-1555.30: (36.13): Cannot have potential null deference in left-mover part.
// 1558.1-1558.27: (36.13): Reduction failure
// 1563.1-1563.30: (37.9): Cannot have potential null deference in left-mover part.
// 1565.1-1565.35: (37.9): lock not held
// 1567.1-1567.27: (37.9): Reduction failure
// 1572.1-1572.28: (38.5): Cannot have potential null deference in left-mover part.
// 1574.1-1574.33: (38.5): lock not held
// 1576.1-1576.27: (38.5): Reduction failure
// 1578.2-1586.9: (class anchor.sink.Return:25.27)
// 1583.1-1583.270: (25.27): Object invariant may not hold.
// 1584.1-1584.270: (25.27): Object invariant may not hold.
// 1585.1-1585.270: (25.27): Object invariant may not hold.
// 1588.1-2021.2: (Method:41.3)
// 1601.1-1601.24: (41.3): Bad tid
// 1602.1-1602.40: (41.3): this is not global
// 1609.1-1609.271: (41.3): Object invariant may not hold.
// 1610.1-1610.271: (41.3): Object invariant may not hold.
// 1611.1-1611.271: (41.3): Object invariant may not hold.
// 1614.1-1614.270: (41.3): Object invariant may not hold.
// 1615.1-1615.270: (41.3): Object invariant may not hold.
// 1616.1-1616.270: (41.3): Object invariant may not hold.
// 1791.1-1791.190: (41.12): Can only have right-mover memory accesses in requires clause
// 1792.1-1792.191: (42.12): Can only have right-mover memory accesses in requires clause
// 1794.2-1796.2: (class anchor.sink.VarDeclStmt:44.5)
// 1797.2-1814.31: (class anchor.sink.Read:44.5)
// 1809.1-1809.30: (44.5): Cannot have potential null deference in left-mover part.
// 1813.1-1813.27: (44.5): Reduction failure
// 1818.1-1818.28: (44.18): Cannot have potential null deference in left-mover part.
// 1822.1-1822.27: (44.18): Reduction failure
// 1826.2-1830.14: (class anchor.sink.While:45.9)
// 1832.1-1832.27: (41.3): Bad tid
// 1833.1-1833.43: (41.3): this is not global
// 1836.1-1836.274: (45.9): Object invariant may not hold.
// 1837.1-1837.274: (45.9): Object invariant may not hold.
// 1838.1-1838.274: (45.9): Object invariant may not hold.
// 1838.274-1839.111: (45.9): invariant holds(this.popLock, tid) may not hold
// 1839.111-1840.116: (45.9): invariant !holds(this.pushLock, tid) may not hold
// 1840.116-1841.79: (45.9): invariant holds(tmp6, tid) may not hold
// 1842.1-1842.270: (45.9): Loop does not preserve yields_as annotation for field popLock
// 1843.1-1843.272: (45.9): Loop does not preserve yields_as annotation for field pushLock
// 1844.1-1844.264: (45.9): Loop does not preserve yields_as annotation for field full
// 1845.1-1845.264: (45.9): Loop does not preserve yields_as annotation for field data
// 1846.1-1846.33: (45.9): Phase must be invariant at loop head
// 1847.1-1847.30: (45.9): Potentially infinite loop cannot be in post-commit phase.
// 1849.3-1851.3: (class anchor.sink.VarDeclStmt:45.16)
// 1852.3-1855.16: (class anchor.sink.Assign:45.16)
// 1857.4-1860.10: (class anchor.sink.Break:45.9)
// 1863.3-1865.3: (class anchor.sink.VarDeclStmt:49.11)
// 1866.3-1883.29: (class anchor.sink.Read:49.11)
// 1878.1-1878.31: (49.11): Cannot have potential null deference in left-mover part.
// 1882.1-1882.28: (49.11): Reduction failure
// 1885.4-1888.10: (class anchor.sink.Break:49.28)
// 1891.3-1905.43: (class anchor.sink.Yield:50.11)
// 1896.1-1896.271: (50.11): Object invariant may not hold.
// 1897.1-1897.271: (50.11): Object invariant may not hold.
// 1898.1-1898.271: (50.11): Object invariant may not hold.
// 1900.1-1900.271: (50.11): Object invariant may not hold.
// 1901.1-1901.271: (50.11): Object invariant may not hold.
// 1902.1-1902.271: (50.11): Object invariant may not hold.
// 1908.1-1908.30: (45.9): Phase must be invariant at loop head
// 1913.1-1913.30: (52.22): Cannot have potential null deference in left-mover part.
// 1917.1-1917.27: (52.22): Reduction failure
// 1919.2-1921.2: (class anchor.sink.VarDeclStmt:53.13)
// 1922.2-1939.30: (class anchor.sink.Read:53.13)
// 1934.1-1934.30: (53.13): Cannot have potential null deference in left-mover part.
// 1938.1-1938.27: (53.13): Reduction failure
// 1940.2-1942.2: (class anchor.sink.VarDeclStmt:54.13)
// 1943.2-1946.16: (class anchor.sink.Assign:54.13)
// 1948.2-1964.28: (class anchor.sink.Write:54.13)
// 1960.1-1960.30: (54.13): Cannot have potential null deference in left-mover part.
// 1963.1-1963.27: (54.13): Reduction failure
// 1968.1-1968.30: (56.9): Cannot have potential null deference in left-mover part.
// 1970.1-1970.35: (56.9): lock not held
// 1972.1-1972.27: (56.9): Reduction failure
// 1977.1-1977.28: (57.5): Cannot have potential null deference in left-mover part.
// 1979.1-1979.33: (57.5): lock not held
// 1981.1-1981.27: (57.5): Reduction failure
// 1983.2-1992.9: (class anchor.sink.Return:55.13)
// 1989.1-1989.270: (55.13): Object invariant may not hold.
// 1990.1-1990.270: (55.13): Object invariant may not hold.
// 1991.1-1991.270: (55.13): Object invariant may not hold.
// 1996.1-1996.30: (56.9): Cannot have potential null deference in left-mover part.
// 1998.1-1998.35: (56.9): lock not held
// 2000.1-2000.27: (56.9): Reduction failure
// 2005.1-2005.28: (57.5): Cannot have potential null deference in left-mover part.
// 2007.1-2007.33: (57.5): lock not held
// 2009.1-2009.27: (57.5): Reduction failure
// 2011.2-2020.9: (class anchor.sink.Return:43.20)
// 2017.1-2017.270: (43.20): Object invariant may not hold.
// 2018.1-2018.270: (43.20): Object invariant may not hold.
// 2019.1-2019.270: (43.20): Object invariant may not hold.
// 2110.1-2110.34: (5.3): Buffer.popLock failed Write-Write Right-Mover Check
// 2177.1-2177.30: (5.3): Buffer.popLock failed Write-Read Right-Mover Check
// 2248.1-2248.34: (5.3): Buffer.popLock failed Write-Write Left-Mover Check
// 2316.1-2316.30: (5.3): Buffer.popLock failed Write-Read Left-Mover Check
// 2381.1-2381.34: (5.3): Buffer.popLock failed Read-Write Right-Mover Check
// 2449.1-2449.34: (5.3): Buffer.popLock failed Read-Write Left-Mover Check
// 2516.1-2516.34: (6.3): Buffer.pushLock failed Write-Write Right-Mover Check
// 2583.1-2583.30: (6.3): Buffer.pushLock failed Write-Read Right-Mover Check
// 2654.1-2654.34: (6.3): Buffer.pushLock failed Write-Write Left-Mover Check
// 2722.1-2722.30: (6.3): Buffer.pushLock failed Write-Read Left-Mover Check
// 2787.1-2787.34: (6.3): Buffer.pushLock failed Read-Write Right-Mover Check
// 2855.1-2855.34: (6.3): Buffer.pushLock failed Read-Write Left-Mover Check
// 2922.1-2922.34: (8.2): Buffer.full failed Write-Write Right-Mover Check
// 2989.1-2989.30: (8.2): Buffer.full failed Write-Read Right-Mover Check
// 3060.1-3060.34: (8.2): Buffer.full failed Write-Write Left-Mover Check
// 3128.1-3128.30: (8.2): Buffer.full failed Write-Read Left-Mover Check
// 3193.1-3193.34: (8.2): Buffer.full failed Read-Write Right-Mover Check
// 3261.1-3261.34: (8.2): Buffer.full failed Read-Write Left-Mover Check
// 3328.1-3328.34: (15.3): Buffer.data failed Write-Write Right-Mover Check
// 3395.1-3395.30: (15.3): Buffer.data failed Write-Read Right-Mover Check
// 3466.1-3466.34: (15.3): Buffer.data failed Write-Write Left-Mover Check
// 3534.1-3534.30: (15.3): Buffer.data failed Write-Read Left-Mover Check
// 3599.1-3599.34: (15.3): Buffer.data failed Read-Write Right-Mover Check
// 3667.1-3667.34: (15.3): Buffer.data failed Read-Write Left-Mover Check
// 3746.1-3746.140: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case A.1)
// 3747.1-3747.101: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case A.2)
// 3748.1-3748.158: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case A.3)
// 3856.1-3856.140: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case C)
// 3969.1-3969.144: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case D)
// 3970.1-3970.144: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.popLock (case R)
// 4049.1-4049.136: (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.popLock (case F)
// 4050.1-4050.136: (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.popLock (case H)
// 4051.1-4051.146: (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.popLock (case I)
// 4129.1-4129.136: (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.popLock (case J)
// 4130.1-4130.136: (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.popLock (case K)
// 4131.1-4131.99: (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.popLock (case L)
// 4211.1-4211.140: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case A.1)
// 4212.1-4212.101: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case A.2)
// 4213.1-4213.158: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case A.3)
// 4321.1-4321.140: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case C)
// 4434.1-4434.144: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case D)
// 4435.1-4435.144: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case R)
// 4514.1-4514.136: (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.pushLock (case F)
// 4515.1-4515.136: (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.pushLock (case H)
// 4516.1-4516.146: (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.pushLock (case I)
// 4594.1-4594.136: (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.popLock (case J)
// 4595.1-4595.136: (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.popLock (case K)
// 4596.1-4596.99: (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.popLock (case L)
// 4676.1-4676.140: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case A.1)
// 4677.1-4677.101: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case A.2)
// 4678.1-4678.158: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case A.3)
// 4786.1-4786.140: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case C)
// 4899.1-4899.144: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case D)
// 4900.1-4900.144: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case R)
// 4979.1-4979.136: (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.full (case F)
// 4980.1-4980.136: (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.full (case H)
// 4981.1-4981.146: (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.full (case I)
// 5059.1-5059.136: (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.popLock (case J)
// 5060.1-5060.136: (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.popLock (case K)
// 5061.1-5061.99: (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.popLock (case L)
// 5141.1-5141.140: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case A.1)
// 5142.1-5142.101: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case A.2)
// 5143.1-5143.158: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case A.3)
// 5251.1-5251.140: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case C)
// 5364.1-5364.144: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case D)
// 5365.1-5365.144: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case R)
// 5444.1-5444.136: (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.data (case F)
// 5445.1-5445.136: (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.data (case H)
// 5446.1-5446.146: (5.3): Buffer.popLock is not Read-Write Stable with respect to Buffer.data (case I)
// 5524.1-5524.136: (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.popLock (case J)
// 5525.1-5525.136: (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.popLock (case K)
// 5526.1-5526.99: (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.popLock (case L)
// 5606.1-5606.140: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
// 5607.1-5607.101: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
// 5608.1-5608.158: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
// 5716.1-5716.140: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case C)
// 5829.1-5829.144: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case D)
// 5830.1-5830.144: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.popLock (case R)
// 5909.1-5909.136: (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.popLock (case F)
// 5910.1-5910.136: (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.popLock (case H)
// 5911.1-5911.146: (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.popLock (case I)
// 5989.1-5989.136: (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.pushLock (case J)
// 5990.1-5990.136: (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.pushLock (case K)
// 5991.1-5991.99: (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.pushLock (case L)
// 6071.1-6071.140: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
// 6072.1-6072.101: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
// 6073.1-6073.158: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
// 6181.1-6181.140: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case C)
// 6294.1-6294.144: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case D)
// 6295.1-6295.144: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.pushLock (case R)
// 6374.1-6374.136: (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.pushLock (case F)
// 6375.1-6375.136: (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.pushLock (case H)
// 6376.1-6376.146: (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.pushLock (case I)
// 6454.1-6454.136: (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.pushLock (case J)
// 6455.1-6455.136: (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.pushLock (case K)
// 6456.1-6456.99: (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.pushLock (case L)
// 6536.1-6536.140: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
// 6537.1-6537.101: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
// 6538.1-6538.158: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
// 6646.1-6646.140: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case C)
// 6759.1-6759.144: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case D)
// 6760.1-6760.144: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case R)
// 6839.1-6839.136: (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.full (case F)
// 6840.1-6840.136: (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.full (case H)
// 6841.1-6841.146: (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.full (case I)
// 6919.1-6919.136: (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.pushLock (case J)
// 6920.1-6920.136: (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.pushLock (case K)
// 6921.1-6921.99: (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.pushLock (case L)
// 7001.1-7001.140: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case A.1)
// 7002.1-7002.101: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case A.2)
// 7003.1-7003.158: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case A.3)
// 7111.1-7111.140: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case C)
// 7224.1-7224.144: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case D)
// 7225.1-7225.144: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case R)
// 7304.1-7304.136: (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.data (case F)
// 7305.1-7305.136: (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.data (case H)
// 7306.1-7306.146: (6.3): Buffer.pushLock is not Read-Write Stable with respect to Buffer.data (case I)
// 7384.1-7384.136: (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.pushLock (case J)
// 7385.1-7385.136: (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.pushLock (case K)
// 7386.1-7386.99: (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.pushLock (case L)
// 7466.1-7466.140: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case A.1)
// 7467.1-7467.101: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case A.2)
// 7468.1-7468.158: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.full (case A.3)
// 7576.1-7576.140: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case C)
// 7689.1-7689.144: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case D)
// 7690.1-7690.144: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.popLock (case R)
// 7769.1-7769.136: (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.popLock (case F)
// 7770.1-7770.136: (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.popLock (case H)
// 7771.1-7771.146: (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.popLock (case I)
// 7849.1-7849.136: (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.full (case J)
// 7850.1-7850.136: (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.full (case K)
// 7851.1-7851.99: (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.full (case L)
// 7931.1-7931.140: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case A.1)
// 7932.1-7932.101: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case A.2)
// 7933.1-7933.158: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.full (case A.3)
// 8041.1-8041.140: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case C)
// 8154.1-8154.144: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case D)
// 8155.1-8155.144: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.pushLock (case R)
// 8234.1-8234.136: (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.pushLock (case F)
// 8235.1-8235.136: (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.pushLock (case H)
// 8236.1-8236.146: (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.pushLock (case I)
// 8314.1-8314.136: (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.full (case J)
// 8315.1-8315.136: (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.full (case K)
// 8316.1-8316.99: (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.full (case L)
// 8396.1-8396.140: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.full (case A.1)
// 8397.1-8397.101: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.full (case A.2)
// 8398.1-8398.158: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.full (case A.3)
// 8506.1-8506.140: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.full (case C)
// 8619.1-8619.144: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.full (case D)
// 8620.1-8620.144: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.full (case R)
// 8699.1-8699.136: (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.full (case F)
// 8700.1-8700.136: (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.full (case H)
// 8701.1-8701.146: (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.full (case I)
// 8779.1-8779.136: (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.full (case J)
// 8780.1-8780.136: (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.full (case K)
// 8781.1-8781.99: (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.full (case L)
// 8861.1-8861.140: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case A.1)
// 8862.1-8862.101: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case A.2)
// 8863.1-8863.158: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case A.3)
// 8971.1-8971.140: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.data (case C)
// 9084.1-9084.144: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.data (case D)
// 9085.1-9085.144: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.data (case R)
// 9164.1-9164.136: (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.data (case F)
// 9165.1-9165.136: (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.data (case H)
// 9166.1-9166.146: (8.2): Buffer.full is not Read-Write Stable with respect to Buffer.data (case I)
// 9244.1-9244.136: (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.full (case J)
// 9245.1-9245.136: (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.full (case K)
// 9246.1-9246.99: (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.full (case L)
// 9326.1-9326.140: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case A.1)
// 9327.1-9327.101: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case A.2)
// 9328.1-9328.158: (5.3): Buffer.popLock is not Write-Write Stable with respect to Buffer.data (case A.3)
// 9436.1-9436.140: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case C)
// 9549.1-9549.144: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case D)
// 9550.1-9550.144: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.popLock (case R)
// 9629.1-9629.136: (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.popLock (case F)
// 9630.1-9630.136: (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.popLock (case H)
// 9631.1-9631.146: (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.popLock (case I)
// 9709.1-9709.136: (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.data (case J)
// 9710.1-9710.136: (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.data (case K)
// 9711.1-9711.99: (5.3): Buffer.popLock is not Write-Read Stable with respect to Buffer.data (case L)
// 9791.1-9791.140: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case A.1)
// 9792.1-9792.101: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case A.2)
// 9793.1-9793.158: (6.3): Buffer.pushLock is not Write-Write Stable with respect to Buffer.data (case A.3)
// 9901.1-9901.140: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case C)
// 10014.1-10014.144: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case D)
// 10015.1-10015.144: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.pushLock (case R)
// 10094.1-10094.136: (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.pushLock (case F)
// 10095.1-10095.136: (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.pushLock (case H)
// 10096.1-10096.146: (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.pushLock (case I)
// 10174.1-10174.136: (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.data (case J)
// 10175.1-10175.136: (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.data (case K)
// 10176.1-10176.99: (6.3): Buffer.pushLock is not Write-Read Stable with respect to Buffer.data (case L)
// 10256.1-10256.140: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.data (case A.1)
// 10257.1-10257.101: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.data (case A.2)
// 10258.1-10258.158: (8.2): Buffer.full is not Write-Write Stable with respect to Buffer.data (case A.3)
// 10366.1-10366.140: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case C)
// 10479.1-10479.144: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case D)
// 10480.1-10480.144: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.full (case R)
// 10559.1-10559.136: (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.full (case F)
// 10560.1-10560.136: (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.full (case H)
// 10561.1-10561.146: (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.full (case I)
// 10639.1-10639.136: (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.data (case J)
// 10640.1-10640.136: (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.data (case K)
// 10641.1-10641.99: (8.2): Buffer.full is not Write-Read Stable with respect to Buffer.data (case L)
// 10721.1-10721.140: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case A.1)
// 10722.1-10722.101: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case A.2)
// 10723.1-10723.158: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case A.3)
// 10831.1-10831.140: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case C)
// 10944.1-10944.144: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case D)
// 10945.1-10945.144: (15.3): Buffer.data is not Write-Write Stable with respect to Buffer.data (case R)
// 11024.1-11024.136: (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.data (case F)
// 11025.1-11025.136: (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.data (case H)
// 11026.1-11026.146: (15.3): Buffer.data is not Read-Write Stable with respect to Buffer.data (case I)
// 11104.1-11104.136: (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.data (case J)
// 11105.1-11105.136: (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.data (case K)
// 11106.1-11106.99: (15.3): Buffer.data is not Write-Read Stable with respect to Buffer.data (case L)
// 11113.1-11113.271: (<undefined position>): Object invariant may not hold.
// 11114.1-11114.271: (<undefined position>): Object invariant may not hold.
// 11115.1-11115.271: (<undefined position>): Object invariant may not hold.
// 11126.1-11126.270: (<undefined position>): Object invariant may not hold.
// 11127.1-11127.270: (<undefined position>): Object invariant may not hold.
// 11128.1-11128.270: (<undefined position>): Object invariant may not hold.
// 11149.1-11173.2: (7.32): yields_as clause for Lock._lock is not valid
// 11178.1-11197.2: (7.32): yields_as clause for Lock._lock is not reflexive
// 11203.1-11203.271: (2.1): Object invariant may not hold.
// 11204.1-11204.271: (2.1): Object invariant may not hold.
// 11205.1-11205.271: (2.1): Object invariant may not hold.
// 11206.1-11244.2: (7.32): yields_as clause for Lock._lock is not transitive
// 11263.1-11287.2: (5.3): yields_as clause for Buffer.popLock is not valid
// 11292.1-11311.2: (5.3): yields_as clause for Buffer.popLock is not reflexive
// 11317.1-11317.271: (5.31): Object invariant may not hold.
// 11318.1-11318.271: (5.31): Object invariant may not hold.
// 11319.1-11319.271: (5.31): Object invariant may not hold.
// 11320.1-11358.2: (5.3): yields_as clause for Buffer.popLock is not transitive
// 11377.1-11401.2: (6.3): yields_as clause for Buffer.pushLock is not valid
// 11406.1-11425.2: (6.3): yields_as clause for Buffer.pushLock is not reflexive
// 11431.1-11431.271: (6.31): Object invariant may not hold.
// 11432.1-11432.271: (6.31): Object invariant may not hold.
// 11433.1-11433.271: (6.31): Object invariant may not hold.
// 11434.1-11472.2: (6.3): yields_as clause for Buffer.pushLock is not transitive
// 11491.1-11515.2: (8.2): yields_as clause for Buffer.full is not valid
// 11520.1-11539.2: (8.2): yields_as clause for Buffer.full is not reflexive
// 11545.1-11545.271: (8.43): Object invariant may not hold.
// 11546.1-11546.271: (8.43): Object invariant may not hold.
// 11547.1-11547.271: (8.43): Object invariant may not hold.
// 11548.1-11586.2: (8.2): yields_as clause for Buffer.full is not transitive
// 11605.1-11629.2: (15.3): yields_as clause for Buffer.data is not valid
// 11634.1-11653.2: (15.3): yields_as clause for Buffer.data is not reflexive
// 11659.1-11659.271: (15.40): Object invariant may not hold.
// 11660.1-11660.271: (15.40): Object invariant may not hold.
// 11661.1-11661.271: (15.40): Object invariant may not hold.
// 11662.1-11700.2: (15.3): yields_as clause for Buffer.data is not transitive
// 11720.1-11744.2: (7.32): yields_as clause for Buffer._lock is not valid
// 11749.1-11768.2: (7.32): yields_as clause for Buffer._lock is not reflexive
// 11774.1-11774.271: (4.1): Object invariant may not hold.
// 11775.1-11775.271: (4.1): Object invariant may not hold.
// 11776.1-11776.271: (4.1): Object invariant may not hold.
// 11777.1-11815.2: (7.32): yields_as clause for Buffer._lock is not transitive
